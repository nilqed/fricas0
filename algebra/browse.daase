
(3155512 . 3864807076)       
(|OneDimensionalArrayAggregate&| A S) 
((|constructor|
  (NIL
   "One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically,{} these aggregates are finite linear aggregates with the \\spadtype{shallowlyMutable} property,{} that is,{} any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and therefore cannot efficiently grow or shrink on demand as can list structures (see however \\spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over,{} and access to,{} elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result."))) 
NIL 
(|OneDimensionalArrayAggregate| S) 
((|constructor|
  (NIL
   "One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically,{} these aggregates are finite linear aggregates with the \\spadtype{shallowlyMutable} property,{} that is,{} any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and therefore cannot efficiently grow or shrink on demand as can list structures (see however \\spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over,{} and access to,{} elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result."))) 
NIL 
(|AbelianGroup&| S) 
((|constructor|
  (NIL
   "The class of abelian groups,{} \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline"))
 (*
  (($ (|Integer|) $)
   "\\spad{n*x} is the product of \\spad{x} by the integer \\spad{n}."))
 (-
  (($ $ $)
   "\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}.")
  (($ $) "\\spad{-x} is the additive inverse of \\spad{x}."))) 
NIL 
(|AbelianGroup|) 
((|constructor|
  (NIL
   "The class of abelian groups,{} \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline"))
 (*
  (($ (|Integer|) $)
   "\\spad{n*x} is the product of \\spad{x} by the integer \\spad{n}."))
 (-
  (($ $ $)
   "\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}.")
  (($ $) "\\spad{-x} is the additive inverse of \\spad{x}."))) 
NIL 
(|AbelianMonoid&| S) 
((|constructor|
  (NIL
   "The class of multiplicative monoids,{} \\spadignore{i.e.} semigroups with an additive identity element. \\blankline"))
 (|opposite?|
  (((|Boolean|) $ $)
   "\\spad{opposite?(x,{}y)} holds if the sum of \\spad{x} and \\spad{y} is \\spad{0}."))
 (*
  (($ (|NonNegativeInteger|) $)
   "\\spad{n * x} is left-multiplication by a non negative integer"))
 (|zero?|
  (((|Boolean|) $) "\\spad{zero?(x)} tests if \\spad{x} is equal to 0."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 ((|Zero|) (($) "0 is the additive identity element."))) 
NIL 
(|AbelianMonoid|) 
((|constructor|
  (NIL
   "The class of multiplicative monoids,{} \\spadignore{i.e.} semigroups with an additive identity element. \\blankline"))
 (|opposite?|
  (((|Boolean|) $ $)
   "\\spad{opposite?(x,{}y)} holds if the sum of \\spad{x} and \\spad{y} is \\spad{0}."))
 (*
  (($ (|NonNegativeInteger|) $)
   "\\spad{n * x} is left-multiplication by a non negative integer"))
 (|zero?|
  (((|Boolean|) $) "\\spad{zero?(x)} tests if \\spad{x} is equal to 0."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 ((|Zero|) (($) "0 is the additive identity element."))) 
NIL 
(|AbelianSemiGroup&| S) 
((|constructor|
  (NIL
   "the class of all additive (commutative) semigroups,{} \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline"))
 (*
  (($ (|PositiveInteger|) $)
   "\\spad{n*x} computes the left-multiplication of \\spad{x} by the positive integer \\spad{n}. This is equivalent to adding \\spad{x} to itself \\spad{n} times."))
 (+ (($ $ $) "\\spad{x+y} computes the sum of \\spad{x} and \\spad{y}."))) 
NIL 
(|AbelianSemiGroup|) 
((|constructor|
  (NIL
   "the class of all additive (commutative) semigroups,{} \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline"))
 (*
  (($ (|PositiveInteger|) $)
   "\\spad{n*x} computes the left-multiplication of \\spad{x} by the positive integer \\spad{n}. This is equivalent to adding \\spad{x} to itself \\spad{n} times."))
 (+ (($ $ $) "\\spad{x+y} computes the sum of \\spad{x} and \\spad{y}."))) 
NIL 
(|AlgebraicallyClosedField&| S) 
((|constructor| (NIL "Model for algebraically closed fields."))
 (|zerosOf|
  (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{zerosOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities containing new symbols which display as \\spad{'\\%z0},{} \\spad{'\\%z1},{} ...; The new symbols are bound in the interpreter to respective values.")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Otherwise they are implicit algebraic quantities containing new symbols. The new symbols are bound in the interpreter to the respective values.")
  (((|List| $) (|Polynomial| $))
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Otherwise they are implicit algebraic quantities containing new symbols. The new symbols are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|zeroOf|
  (($ (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{zeroOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}; if possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity which displays as \\spad{'y}.")
  (($ (|SparseUnivariatePolynomial| $))
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}; if possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity.")
  (($ (|Polynomial| $))
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. If possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootsOf|
  (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{rootsOf(p,{} z)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; The returned roots contain new symbols \\spad{'\\%z0},{} \\spad{'\\%z1} ...; Note: the new symbols are bound in the interpreter to the respective values.")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{rootsOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values.")
  (((|List| $) (|Polynomial| $))
   "\\spad{rootsOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootOf|
  (($ (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{rootOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.")
  (($ (|SparseUnivariatePolynomial| $))
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}.")
  (($ (|Polynomial| $))
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y}."))) 
NIL 
(|AlgebraicallyClosedField|) 
((|constructor| (NIL "Model for algebraically closed fields."))
 (|zerosOf|
  (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{zerosOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities containing new symbols which display as \\spad{'\\%z0},{} \\spad{'\\%z1},{} ...; The new symbols are bound in the interpreter to respective values.")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Otherwise they are implicit algebraic quantities containing new symbols. The new symbols are bound in the interpreter to the respective values.")
  (((|List| $) (|Polynomial| $))
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Otherwise they are implicit algebraic quantities containing new symbols. The new symbols are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|zeroOf|
  (($ (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{zeroOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}; if possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity which displays as \\spad{'y}.")
  (($ (|SparseUnivariatePolynomial| $))
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}; if possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity.")
  (($ (|Polynomial| $))
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. If possible,{} \\spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootsOf|
  (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{rootsOf(p,{} z)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; The returned roots contain new symbols \\spad{'\\%z0},{} \\spad{'\\%z1} ...; Note: the new symbols are bound in the interpreter to the respective values.")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{rootsOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values.")
  (((|List| $) (|Polynomial| $))
   "\\spad{rootsOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootOf|
  (($ (|SparseUnivariatePolynomial| $) (|Symbol|))
   "\\spad{rootOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.")
  (($ (|SparseUnivariatePolynomial| $))
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}.")
  (($ (|Polynomial| $))
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y}."))) 
NIL 
(|AlgebraicallyClosedFunctionSpace&| S R) 
((|constructor| (NIL "Model for algebraically closed function spaces."))
 (|zerosOf|
  (((|List| $) $ (|Symbol|))
   "\\spad{zerosOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities containing new symbols which display as \\spad{'\\%z0},{} \\spad{'\\%z1},{} ...; The new symbols are bound in the interpreter to the respective values.")
  (((|List| $) $)
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable."))
 (|zeroOf|
  (($ $ (|Symbol|))
   "\\spad{zeroOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,{} and otherwise as an implicit algebraic quantity which displays as \\spad{'y}.")
  (($ $)
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,{} and otherwise as an implicit algebraic quantity. Error: if \\spad{p} has more than one variable."))
 (|rootsOf|
  (((|List| $) $ (|Symbol|))
   "\\spad{rootsOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; The returned roots contain new symbols \\spad{'\\%z0},{} \\spad{'\\%z1} ...; Note: the new symbols are bound in the interpreter to the respective values.")
  (((|List| $) $)
   "\\spad{rootsOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootOf|
  (($ $ (|Symbol|))
   "\\spad{rootOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.")
  (($ $)
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y}."))) 
((|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))) 
(|AlgebraicallyClosedFunctionSpace| R) 
((|constructor| (NIL "Model for algebraically closed function spaces."))
 (|zerosOf|
  (((|List| $) $ (|Symbol|))
   "\\spad{zerosOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities containing new symbols which display as \\spad{'\\%z0},{} \\spad{'\\%z1},{} ...; The new symbols are bound in the interpreter to the respective values.")
  (((|List| $) $)
   "\\spad{zerosOf(p)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}. The \\spad{yi}\\spad{'s} are expressed in radicals if possible. Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable."))
 (|zeroOf|
  (($ $ (|Symbol|))
   "\\spad{zeroOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,{} and otherwise as an implicit algebraic quantity which displays as \\spad{'y}.")
  (($ $)
   "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,{} and otherwise as an implicit algebraic quantity. Error: if \\spad{p} has more than one variable."))
 (|rootsOf|
  (((|List| $) $ (|Symbol|))
   "\\spad{rootsOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; The returned roots contain new symbols \\spad{'\\%z0},{} \\spad{'\\%z1} ...; Note: the new symbols are bound in the interpreter to the respective values.")
  (((|List| $) $)
   "\\spad{rootsOf(p,{} y)} returns \\spad{[y1,{} ...,{} yn]} such that \\spad{p(\\spad{yi}) = 0}; Note: the returned values \\spad{y1},{} ...,{} \\spad{yn} contain new symbols which are bound in the interpreter to the respective values. Error: if \\spad{p} has more than one variable \\spad{y}."))
 (|rootOf|
  (($ $ (|Symbol|))
   "\\spad{rootOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.")
  (($ $)
   "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y}."))) 
NIL 
(|PlaneAlgebraicCurvePlot|) 
((|constructor|
  (NIL
   "\\indented{1}{Plot a NON-SINGULAR plane algebraic curve \\spad{p}(\\spad{x},{} \\spad{y}) = 0.} Author: Clifton \\spad{J}. Williamson Date Created: Fall 1988 Keywords: algebraic curve,{} non-singular,{} plot Examples: References:"))
 (|refine| (($ $ (|DoubleFloat|)) "\\spad{refine(p,{} x)} \\undocumented{}"))
 (|makeSketch|
  (($ (|Polynomial| (|Integer|)) (|Symbol|) (|Symbol|)
    (|Segment| (|Fraction| (|Integer|))) (|Segment| (|Fraction| (|Integer|))))
   "\\spad{makeSketch(p,{} x,{} y,{} a..b,{} c..d)} creates an ACPLOT of the curve \\spad{p = 0} in the region {\\em a <= x <= b,{} c <= y <= d}. More specifically,{} 'makeSketch' plots a non-singular algebraic curve \\spad{p = 0} in an rectangular region {\\em xMin <= x <= xMax},{} {\\em yMin <= y <= yMax}. The user inputs \\spad{makeSketch(p,{} x,{} y,{} xMin..xMax,{} yMin..yMax)}. Here \\spad{p} is a polynomial in the variables \\spad{x} and \\spad{y} with integer coefficients (\\spad{p} belongs to the domain \\spad{Polynomial Integer}). The case where \\spad{p} is a polynomial in only one of the variables is allowed. The variables \\spad{x} and \\spad{y} are input to specify the the coordinate axes. The horizontal axis is the \\spad{x}-axis and the vertical axis is the \\spad{y}-axis. The rational numbers xMin,{} ...,{} yMax specify the boundaries of the region in which the curve is to be plotted."))) 
NIL 
(|AlgebraicFunction| R F) 
((|constructor|
  (NIL "This package provides algebraic functions over an integral domain."))
 (|iroot|
  ((|#2| |#1| (|Integer|))
   "\\spad{iroot(p,{} n)} should be a non-exported function."))
 (|definingPolynomial|
  ((|#2| |#2|)
   "\\spad{definingPolynomial(f)} returns the defining polynomial of \\spad{f} as an element of \\spad{F}. Error: if \\spad{f} is not a kernel."))
 (|minPoly|
  (((|SparseUnivariatePolynomial| |#2|) (|Kernel| |#2|))
   "\\spad{minPoly(k)} returns the defining polynomial of \\spad{k}."))
 (^
  ((|#2| |#2| (|Fraction| (|Integer|)))
   "\\spad{x ^ q} is \\spad{x} raised to the rational power \\spad{q}."))
 (|droot|
  (((|OutputForm|) (|List| |#2|))
   "\\spad{droot(l)} should be a non-exported function."))
 (|inrootof|
  ((|#2| (|SparseUnivariatePolynomial| |#2|) |#2|)
   "\\spad{inrootof(p,{} x)} should be a non-exported function."))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} is \\spad{true} if \\spad{op} is an algebraic operator,{} that is,{} an \\spad{n}th root or implicit algebraic operator."))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F}. Error: if \\spad{op} is not an algebraic operator,{} that is,{} an \\spad{n}th root or implicit algebraic operator."))
 (|rootSum|
  ((|#2| |#2| (|SparseUnivariatePolynomial| |#2|) (|Symbol|))
   "\\spad{rootSum(expr,{} p,{} s)}"))
 (|rootOf|
  ((|#2| (|SparseUnivariatePolynomial| |#2|) (|Symbol|))
   "\\spad{rootOf(p,{} y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}."))) 
((|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))) 
(|Aggregate&| S) 
((|constructor|
  (NIL
   "The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogeneous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as \"the set of \\spad{x} satisfying relation {\\em r(x)}\". An attribute \\spadtype{finiteAggregate} is used to assert that a domain has a finite number of elements."))
 (|#|
  (((|NonNegativeInteger|) $)
   "\\spad{\\#(u)} returns the number of elements in \\spad{u}."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 (|size?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{size?(u,{} n)} tests if \\spad{u} has exactly \\spad{n} elements."))
 (|more?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{more?(u,{} n)} tests if \\spad{u} has more than \\spad{n} elements."))
 (|less?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{less?(u,{} n)} tests if \\spad{u} has less than \\spad{n} elements."))
 (|empty?|
  (((|Boolean|) $) "\\spad{empty?(u)} tests if \\spad{u} has 0 elements."))
 (|empty|
  (($)
   "\\spad{empty()}\\$\\spad{D} creates an aggregate of type \\spad{D} with 0 elements. Note: The {\\em \\$D} can be dropped if understood by context,{} \\spadignore{e.g.} \\spad{u: D := empty()}."))
 (|copy|
  (($ $)
   "\\spad{copy(u)} returns a top-level (non-recursive) copy of \\spad{u}. Note: for collections,{} \\spad{copy(u) = [x for x in u]}."))
 (|eq?|
  (((|Boolean|) $ $)
   "\\spad{eq?(u,{} v)} tests if \\spad{u} and \\spad{v} are same objects."))) 
((|HasCategory| |#1| '(|finiteAggregate|))) 
(|Aggregate|) 
((|constructor|
  (NIL
   "The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogeneous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as \"the set of \\spad{x} satisfying relation {\\em r(x)}\". An attribute \\spadtype{finiteAggregate} is used to assert that a domain has a finite number of elements."))
 (|#|
  (((|NonNegativeInteger|) $)
   "\\spad{\\#(u)} returns the number of elements in \\spad{u}."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 (|size?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{size?(u,{} n)} tests if \\spad{u} has exactly \\spad{n} elements."))
 (|more?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{more?(u,{} n)} tests if \\spad{u} has more than \\spad{n} elements."))
 (|less?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{less?(u,{} n)} tests if \\spad{u} has less than \\spad{n} elements."))
 (|empty?|
  (((|Boolean|) $) "\\spad{empty?(u)} tests if \\spad{u} has 0 elements."))
 (|empty|
  (($)
   "\\spad{empty()}\\$\\spad{D} creates an aggregate of type \\spad{D} with 0 elements. Note: The {\\em \\$D} can be dropped if understood by context,{} \\spadignore{e.g.} \\spad{u: D := empty()}."))
 (|copy|
  (($ $)
   "\\spad{copy(u)} returns a top-level (non-recursive) copy of \\spad{u}. Note: for collections,{} \\spad{copy(u) = [x for x in u]}."))
 (|eq?|
  (((|Boolean|) $ $)
   "\\spad{eq?(u,{} v)} tests if \\spad{u} and \\spad{v} are same objects."))) 
NIL 
(|ArcHyperbolicFunctionCategory|) 
((|constructor|
  (NIL "Category for the inverse hyperbolic trigonometric functions."))
 (|atanh|
  (($ $) "\\spad{atanh(x)} returns the hyperbolic arc-tangent of \\spad{x}."))
 (|asinh|
  (($ $) "\\spad{asinh(x)} returns the hyperbolic arc-sine of \\spad{x}."))
 (|asech|
  (($ $) "\\spad{asech(x)} returns the hyperbolic arc-secant of \\spad{x}."))
 (|acsch|
  (($ $) "\\spad{acsch(x)} returns the hyperbolic arc-cosecant of \\spad{x}."))
 (|acoth|
  (($ $)
   "\\spad{acoth(x)} returns the hyperbolic arc-cotangent of \\spad{x}."))
 (|acosh|
  (($ $) "\\spad{acosh(x)} returns the hyperbolic arc-cosine of \\spad{x}."))) 
NIL 
(|AssociationListAggregate&| S |Key| |Entry|) 
((|constructor|
  (NIL
   "An association list is a list of key entry pairs which may be viewed as a table. It is a poor mans version of a table: searching for a key is a linear operation."))
 (|assoc|
  (((|Union| (|Record| (|:| |key| |#2|) (|:| |entry| |#3|)) "failed") |#2| $)
   "\\spad{assoc(k,{} u)} returns the element \\spad{x} in association list \\spad{u} stored with key \\spad{k},{} or \"failed\" if \\spad{u} has no key \\spad{k}."))) 
NIL 
(|AssociationListAggregate| |Key| |Entry|) 
((|constructor|
  (NIL
   "An association list is a list of key entry pairs which may be viewed as a table. It is a poor mans version of a table: searching for a key is a linear operation."))
 (|assoc|
  (((|Union| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) "failed") |#1| $)
   "\\spad{assoc(k,{} u)} returns the element \\spad{x} in association list \\spad{u} stored with key \\spad{k},{} or \"failed\" if \\spad{u} has no key \\spad{k}."))) 
NIL 
(|Algebra&| S R) 
((|constructor|
  (NIL
   "The category of associative algebras (modules which are themselves rings). \\blankline"))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(r)} maps the ring element \\spad{r} to a member of the algebra."))) 
NIL 
(|Algebra| R) 
((|constructor|
  (NIL
   "The category of associative algebras (modules which are themselves rings). \\blankline"))
 (|coerce|
  (($ |#1|)
   "\\spad{coerce(r)} maps the ring element \\spad{r} to a member of the algebra."))) 
NIL 
(|AlgFactor| UP) 
((|constructor|
  (NIL
   "Factorization of univariate polynomials with coefficients in \\spadtype{AlgebraicNumber}."))
 (|doublyTransitive?|
  (((|Boolean|) |#1|)
   "\\spad{doublyTransitive?(p)} is \\spad{true} if \\spad{p} is irreducible over over the field \\spad{K} generated by its coefficients,{} and if \\spad{p(X) / (X - a)} is irreducible over \\spad{K(a)} where \\spad{p(a) = 0}."))
 (|split|
  (((|Factored| |#1|) |#1|)
   "\\spad{split(p)} returns a prime factorisation of \\spad{p} over its splitting field."))
 (|factor|
  (((|Factored| |#1|) |#1|)
   "\\spad{factor(p)} returns a prime factorisation of \\spad{p} over the field generated by its coefficients.")
  (((|Factored| |#1|) |#1| (|List| (|AlgebraicNumber|)))
   "\\spad{factor(p,{} [a1,{} ...,{} an])} returns a prime factorisation of \\spad{p} over the field generated by its coefficients and \\spad{a1},{} ...,{} an."))) 
NIL 
(|AlgebraicFunctionField| F UP UPUP |modulus|) 
((|constructor|
  (NIL "Function field defined by \\spad{f}(\\spad{x},{} \\spad{y}) = 0."))
 (|knownInfBasis|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{knownInfBasis(n)} \\undocumented{}"))) 
((|HasCategory| (|Fraction| |#2|) '(|CharacteristicZero|))
 (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|))
 (|HasCategory| (|Fraction| |#2|) '(|Field|))
 (OR (|HasCategory| (|Fraction| |#2|) '(|Field|))
     (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))
 (|HasCategory| (|Fraction| |#2|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Fraction| |#2|) '(|Finite|))
 (OR
  (AND (|HasCategory| (|Fraction| |#2|) '(|DifferentialRing|))
       (|HasCategory| (|Fraction| |#2|) '(|Field|)))
  (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))
 (|HasCategory| (|Fraction| |#2|)
                (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| (|Fraction| |#2|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Fraction| |#2|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (AND
  (|HasCategory| (|Fraction| |#2|)
                 (LIST '|PartialDifferentialRing| '(|Symbol|)))
  (|HasCategory| (|Fraction| |#2|) '(|Field|)))
 (OR
  (AND
   (|HasCategory| (|Fraction| |#2|)
                  (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|Fraction| |#2|) '(|Field|)))
  (AND
   (|HasCategory| (|Fraction| |#2|)
                  (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|))))
 (OR
  (|HasCategory| (|Fraction| |#2|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| (|Fraction| |#2|) '(|Field|)))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Finite|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))) 
(|AlgebraicManipulations| R F) 
((|constructor|
  (NIL
   "AlgebraicManipulations provides functions to simplify and expand expressions involving algebraic operators."))
 (|rootKerSimp|
  ((|#2| (|BasicOperator|) |#2| (|NonNegativeInteger|))
   "\\spad{rootKerSimp(op,{} f,{} n)} should be local but conditional."))
 (|rootSimp|
  ((|#2| |#2|)
   "\\spad{rootSimp(f)} transforms every radical of the form \\spad{(a * b^(q*n+r))^(1/n)} appearing in \\spad{f} into \\spad{b^q * (a * b^r)^(1/n)}. This transformation is not in general valid for all complex numbers \\spad{b}."))
 (|rootProduct|
  ((|#2| |#2|)
   "\\spad{rootProduct(f)} combines every product of the form \\spad{(a^(1/n))^m * (a^(1/s))^t} into a single power of a root of \\spad{a},{} and transforms every radical power of the form \\spad{(a^(1/n))^m} into a simpler form."))
 (|rootPower|
  ((|#2| |#2|)
   "\\spad{rootPower(f)} transforms every radical power of the form \\spad{(a^(1/n))^m} into a simpler form if \\spad{m} and \\spad{n} have a common factor."))
 (|rootFactor|
  ((|#2| |#2|)
   "\\spad{rootFactor(f)} transforms every radical of the form \\spad{(a1*...*am)^(1/n)} appearing in \\spad{f} into \\spad{a^(1/n)*...*am^(1/n)}. This transformation is not in general valid for all complex numbers \\spad{a} and \\spad{b}."))
 (|ratPoly|
  (((|SparseUnivariatePolynomial| |#2|) |#2|)
   "\\spad{ratPoly(f)} returns a polynomial \\spad{p} such that \\spad{p} has no algebraic coefficients,{} and \\spad{p(f) = 0}."))
 (|ratDenom|
  ((|#2| |#2| (|List| (|Kernel| |#2|)))
   "\\spad{ratDenom(f,{} [a1,{} ...,{} an])} removes the \\spad{ai}\\spad{'s} which are algebraic from the denominators in \\spad{f}.")
  ((|#2| |#2| (|List| |#2|))
   "\\spad{ratDenom(f,{} [a1,{} ...,{} an])} removes the \\spad{ai}\\spad{'s} which are algebraic kernels from the denominators in \\spad{f}.")
  ((|#2| |#2| |#2|)
   "\\spad{ratDenom(f,{} a)} removes \\spad{a} from the denominators in \\spad{f} if \\spad{a} is an algebraic kernel.")
  ((|#2| |#2|)
   "\\spad{ratDenom(f)} rationalizes the denominators appearing in \\spad{f} by moving all the algebraic quantities into the numerators."))
 (|rootSplit|
  ((|#2| |#2|)
   "\\spad{rootSplit(f)} transforms every radical of the form \\spad{(a/b)^(1/n)} appearing in \\spad{f} into \\spad{a^(1/n) / b^(1/n)}. This transformation is not in general valid for all complex numbers \\spad{a} and \\spad{b}."))
 (|coerce|
  (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $)))
   "\\spad{coerce(x)} \\undocumented"))
 (|denom|
  (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $)
   "\\spad{denom(x)} \\undocumented"))
 (|numer|
  (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $)
   "\\spad{numer(x)} \\undocumented"))) 
((AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|GcdDomain|))
      (|HasCategory| |#2| (LIST '|FunctionSpace| (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|GcdDomain|))
      (|HasCategory| |#1| '(|UniqueFactorizationDomain|))
      (|HasCategory| |#2| (LIST '|FunctionSpace| (|devaluate| |#1|))))) 
(|AlgebraicMultFact| OV E P) 
((|constructor|
  (NIL
   "This package factors multivariate polynomials over the domain of \\spadtype{AlgebraicNumber} by allowing the user to specify a list of algebraic numbers generating the particular extension to factor over."))
 (|factor|
  (((|Factored| (|SparseUnivariatePolynomial| |#3|))
    (|SparseUnivariatePolynomial| |#3|) (|List| (|AlgebraicNumber|)))
   "\\spad{factor(p,{} lan)} factors the polynomial \\spad{p} over the extension generated by the algebraic numbers given by the list lan. \\spad{p} is presented as a univariate polynomial with multivariate coefficients.")
  (((|Factored| |#3|) |#3| (|List| (|AlgebraicNumber|)))
   "\\spad{factor(p,{} lan)} factors the polynomial \\spad{p} over the extension generated by the algebraic numbers given by the list lan."))) 
NIL 
(|AlgebraPackage| R A) 
((|constructor|
  (NIL
   "AlgebraPackage assembles a variety of useful functions for general algebras."))
 (|basis|
  (((|Vector| |#2|) (|Vector| |#2|))
   "\\spad{basis(va)} selects a basis from the elements of \\spad{va}."))
 (|radicalOfLeftTraceForm|
  (((|List| |#2|))
   "\\spad{radicalOfLeftTraceForm()} returns basis for null space of \\spad{leftTraceMatrix()},{} if the algebra is associative,{} alternative or a Jordan algebra,{} then this space equals the radical (maximal nil ideal) of the algebra."))
 (|basisOfCentroid|
  (((|List| (|Matrix| |#1|)))
   "\\spad{basisOfCentroid()} returns a basis of the centroid,{} \\spadignore{i.e.} the endomorphism ring of \\spad{A} considered as \\spad{(A,{} A)}-bimodule."))
 (|basisOfRightNucloid|
  (((|List| (|Matrix| |#1|)))
   "\\spad{basisOfRightNucloid()} returns a basis of the space of endomorphisms of \\spad{A} as left module. Note: right nucloid coincides with right nucleus if \\spad{A} has a unit."))
 (|basisOfLeftNucloid|
  (((|List| (|Matrix| |#1|)))
   "\\spad{basisOfLeftNucloid()} returns a basis of the space of endomorphisms of \\spad{A} as right module. Note: left nucloid coincides with left nucleus if \\spad{A} has a unit."))
 (|basisOfCenter|
  (((|List| |#2|))
   "\\spad{basisOfCenter()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{commutator(x,{} a) = 0} and \\spad{associator(x,{} a,{} b) = associator(a,{} x,{} b) = associator(a,{} b,{} x) = 0} for all \\spad{a},{} \\spad{b} in \\spad{A}."))
 (|basisOfNucleus|
  (((|List| |#2|))
   "\\spad{basisOfNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{associator(x,{} a,{} b) = associator(a,{} x,{} b) = associator(a,{} b,{} x) = 0} for all \\spad{a},{} \\spad{b} in \\spad{A}."))
 (|basisOfMiddleNucleus|
  (((|List| |#2|))
   "\\spad{basisOfMiddleNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(a,{} x,{} b)} for all \\spad{a},{} \\spad{b} in \\spad{A}."))
 (|basisOfRightNucleus|
  (((|List| |#2|))
   "\\spad{basisOfRightNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(a,{} b,{} x)} for all \\spad{a},{} \\spad{b} in \\spad{A}."))
 (|basisOfLeftNucleus|
  (((|List| |#2|))
   "\\spad{basisOfLeftNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(x,{} a,{} b)} for all \\spad{a},{} \\spad{b} in \\spad{A}."))
 (|basisOfRightAnnihilator|
  (((|List| |#2|) |#2|)
   "\\spad{basisOfRightAnnihilator(a)} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = a*x}."))
 (|basisOfLeftAnnihilator|
  (((|List| |#2|) |#2|)
   "\\spad{basisOfLeftAnnihilator(a)} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = x*a}."))
 (|basisOfCommutingElements|
  (((|List| |#2|))
   "\\spad{basisOfCommutingElements()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = commutator(x,{} a)} for all \\spad{a} in \\spad{A}."))
 (|biRank|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{biRank(x)} determines the number of linearly independent elements in \\spad{x},{} \\spad{x*bi},{} \\spad{bi*x},{} \\spad{bi*x*bj},{} \\spad{i,{} j=1,{} ...,{} n},{} where \\spad{b=[b1,{} ...,{} bn]} is a basis. Note: if \\spad{A} has a unit,{} then \\spadfunFrom{doubleRank}{AlgebraPackage},{} \\spadfunFrom{weakBiRank}{AlgebraPackage} and \\spadfunFrom{biRank}{AlgebraPackage} coincide."))
 (|weakBiRank|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{weakBiRank(x)} determines the number of linearly independent elements in the \\spad{bi*x*bj},{} \\spad{i,{} j=1,{} ...,{} n},{} where \\spad{b=[b1,{} ...,{} bn]} is a basis."))
 (|doubleRank|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{doubleRank(x)} determines the number of linearly independent elements in \\spad{b1*x},{} ...,{} \\spad{x*bn},{} where \\spad{b=[b1,{} ...,{} bn]} is a basis."))
 (|rightRank|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{rightRank(x)} determines the number of linearly independent elements in \\spad{b1*x},{} ...,{} \\spad{bn*x},{} where \\spad{b=[b1,{} ...,{} bn]} is a basis."))
 (|leftRank|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{leftRank(x)} determines the number of linearly independent elements in \\spad{x*b1},{} ...,{} \\spad{x*bn},{} where \\spad{b=[b1,{} ...,{} bn]} is a basis."))) 
((|HasCategory| |#1| '(|EuclideanDomain|))) 
(|AlgebraGivenByStructuralConstants| R |n| |ls| |gamma|) 
((|constructor|
  (NIL
   "AlgebraGivenByStructuralConstants implements finite rank algebras over a commutative ring,{} given by the structural constants \\spad{gamma} with respect to a fixed basis \\spad{[a1,{} ..,{} an]},{} where \\spad{gamma} is an \\spad{n}-vector of \\spad{n} by \\spad{n} matrices \\spad{[(gammaijk) for k in 1..rank()]} defined by \\spad{\\spad{ai} * aj = gammaij1 * a1 + ... + gammaijn * an}. The symbols for the fixed basis have to be given as a list of symbols."))
 (|coerce|
  (($ (|Vector| |#1|))
   "\\spad{coerce(v)} converts a vector to a member of the algebra by forming a linear combination with the basis element. Note: the vector is assumed to have length equal to the dimension of the algebra."))) 
((|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Finite|))
 (|HasCategory| |#1| '(|Field|))) 
(|AssociationList| |Key| |Entry|) 
((|constructor|
  (NIL
   "\\spadtype{AssociationList} implements association lists. These may be viewed as lists of pairs where the first part is a key and the second is the stored value. For example,{} the key might be a string with a persons employee identification number and the value might be a record with personnel data."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#2| '(|BasicType|))
 (|HasCategory| |#2| '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|Comparable|))
 (OR
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|Comparable|))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|OrderedSet|)))
 (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|Comparable|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|OrderedSet|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|Comparable|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|OrderedSet|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|Comparable|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|OrderedSet|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|OrderedSet|))))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (AND (|HasCategory| $ '(|finiteAggregate|))
          (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                         '(|Comparable|)))
     (AND (|HasCategory| $ '(|finiteAggregate|))
          (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                         '(|OrderedSet|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| $ '(|finiteAggregate|))
          (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                         '(|Comparable|)))
     (AND (|HasCategory| $ '(|finiteAggregate|))
          (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                         '(|OrderedSet|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|OrderedSet|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))) 
(|AbelianMonoidRing&| S R E) 
((|constructor|
  (NIL
   "Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} but in general do not commute with the coefficients (which themselves may or may not be commutative). See \\spadtype{FiniteAbelianMonoidRing} for the case of finite support. A useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on."))
 (/ (($ $ |#2|) "\\spad{p/c} divides \\spad{p} by the coefficient \\spad{c}."))
 (|coefficient|
  ((|#2| $ |#3|)
   "\\spad{coefficient(p,{} e)} extracts the coefficient of the monomial with exponent \\spad{e} from polynomial \\spad{p},{} or returns zero if exponent is not present."))
 (|degree|
  ((|#3| $)
   "\\spad{degree(p)} returns the maximum of the exponents of the terms of \\spad{p}."))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|VariablesCommuteWithCoefficients|))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|SemiRing|))) 
(|AbelianMonoidRing| R E) 
((|constructor|
  (NIL
   "Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} but in general do not commute with the coefficients (which themselves may or may not be commutative). See \\spadtype{FiniteAbelianMonoidRing} for the case of finite support. A useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on."))
 (/ (($ $ |#1|) "\\spad{p/c} divides \\spad{p} by the coefficient \\spad{c}."))
 (|coefficient|
  ((|#1| $ |#2|)
   "\\spad{coefficient(p,{} e)} extracts the coefficient of the monomial with exponent \\spad{e} from polynomial \\spad{p},{} or returns zero if exponent is not present."))
 (|degree|
  ((|#2| $)
   "\\spad{degree(p)} returns the maximum of the exponents of the terms of \\spad{p}."))) 
NIL 
(|AlgebraicNumber|) 
((|constructor| (NIL "Algebraic closure of the rational numbers."))
 (|norm|
  (($ $ (|List| (|Kernel| $)))
   "\\spad{norm(f,{} l)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernels \\spad{l}")
  (($ $ (|Kernel| $))
   "\\spad{norm(f,{} k)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernel \\spad{k}")
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|List| (|Kernel| $)))
   "\\spad{norm(p,{} l)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernels \\spad{l}")
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|Kernel| $))
   "\\spad{norm(p,{} k)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernel \\spad{k}"))
 (|trueEqual|
  (((|Boolean|) $ $)
   "\\spad{trueEqual(x,{} y)} tries to determine if the two numbers are equal"))
 (|reduce|
  (($ $)
   "\\spad{reduce(f)} simplifies all the unreduced algebraic numbers present in \\spad{f} by applying their defining relations."))
 (|denom|
  (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)
   "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z}."))
 (|numer|
  (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $)
   "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z}."))
 (|coerce|
  (($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)))
   "\\spad{coerce(p)} returns \\spad{p} viewed as an algebraic number."))) 
((|HasCategory| $ '(|Ring|))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| $ '(|CharacteristicNonZero|))) 
(|AnonymousFunction|) 
((|constructor| (NIL "This domain implements anonymous functions"))) 
NIL 
(|AntiSymm| R |lVar|) 
((|constructor| (NIL "The domain of antisymmetric polynomials."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} p)} changes each coefficient of \\spad{p} by the application of \\spad{f}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(p)} returns the homogeneous degree of \\spad{p}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(p)} tests if \\spad{p} is a 0-form,{} \\spadignore{i.e.} if degree(\\spad{p}) = 0."))
 (|homogeneous?|
  (((|Boolean|) $)
   "\\spad{homogeneous?(p)} tests if all of the terms of \\spad{p} have the same degree."))
 (|exp|
  (($ (|List| (|Integer|)))
   "\\spad{exp([i1,{} ...in])} returns \\spad{u_1\\^{i_1} ... u_n\\^{i_n}}"))
 (|generator|
  (($ (|NonNegativeInteger|))
   "\\spad{generator(n)} returns the \\spad{n}th multiplicative generator,{} a basis term."))
 (|coefficient|
  ((|#1| $ $)
   "\\spad{coefficient(p,{} u)} returns the coefficient of the term in \\spad{p} containing the basis term \\spad{u} if such a term exists,{} and 0 otherwise. Error: if the second argument \\spad{u} is not a basis element."))
 (|reductum|
  (($ $)
   "\\spad{reductum(p)},{} where \\spad{p} is an antisymmetric polynomial,{} returns \\spad{p} minus the leading term of \\spad{p} if \\spad{p} has at least two terms,{} and 0 otherwise."))
 (|leadingBasisTerm|
  (($ $)
   "\\spad{leadingBasisTerm(p)} returns the leading basis term of antisymmetric polynomial \\spad{p}."))
 (|leadingCoefficient|
  ((|#1| $)
   "\\spad{leadingCoefficient(p)} returns the leading coefficient of antisymmetric polynomial \\spad{p}."))) 
NIL 
(|Any|) 
((|constructor|
  (NIL
   "\\spadtype{Any} implements a type that packages up objects and their types in objects of \\spadtype{Any}. Roughly speaking that means that if \\spad{s : S} then when converted to \\spadtype{Any},{} the new object will include both the original object and its type. This is a way of converting arbitrary objects into a single type without losing any of the original information. Any object can be converted to one of \\spadtype{Any}."))
 (|showTypeInOutput|
  (((|String|) (|Boolean|))
   "\\spad{showTypeInOutput(bool)} affects the way objects of \\spadtype{Any} are displayed. If \\spad{bool} is \\spad{true} then the type of the original object that was converted to \\spadtype{Any} will be printed. If \\spad{bool} is \\spad{false},{} it will not be printed."))
 (|obj|
  (((|None|) $)
   "\\spad{obj(a)} essentially returns the original object that was converted to \\spadtype{Any} except that the type is forced to be \\spadtype{None}."))
 (|dom|
  (((|SExpression|) $)
   "\\spad{dom(a)} returns a \\spadgloss{LISP} form of the type of the original object that was converted to \\spadtype{Any}."))
 (|objectOf|
  (((|OutputForm|) $)
   "\\spad{objectOf(a)} returns a printable form of the original object that was converted to \\spadtype{Any}."))
 (|domainOf|
  (((|OutputForm|) $)
   "\\spad{domainOf(a)} returns a printable form of the type of the original object that was converted to \\spadtype{Any}."))
 (|any|
  (($ (|SExpression|) (|None|))
   "\\spad{any(type,{} object)} is a technical function for creating an object of \\spadtype{Any}. Argument \\spad{type} is a \\spadgloss{LISP} form for the \\spad{type} of \\spad{object}."))) 
NIL 
(|AnyFunctions1| S) 
((|constructor|
  (NIL
   "\\spadtype{AnyFunctions1} implements several utility functions for working with \\spadtype{Any}. These functions are used to go back and forth between objects of \\spadtype{Any} and objects of other types."))
 (|retract|
  ((|#1| (|Any|))
   "\\spad{retract(a)} tries to convert \\spad{a} into an object of type \\spad{S}. If possible,{} it returns the object. Error: if no such retraction is possible."))
 (|retractable?|
  (((|Boolean|) (|Any|))
   "\\spad{retractable?(a)} tests if \\spad{a} can be converted into an object of type \\spad{S}."))
 (|retractIfCan|
  (((|Union| |#1| "failed") (|Any|))
   "\\spad{retractIfCan(a)} tries change \\spad{a} into an object of type \\spad{S}. If it can,{} then such an object is returned. Otherwise,{} \"failed\" is returned."))
 (|coerce|
  (((|Any|) |#1|)
   "\\spad{coerce(s)} creates an object of \\spadtype{Any} from the object \\spad{s} of type \\spad{S}."))) 
NIL 
(|ApplyUnivariateSkewPolynomial| R M P) 
((|constructor|
  (NIL
   "\\spad{ApplyUnivariateSkewPolynomial} (internal) allows univariate skew polynomials to be applied to appropriate modules."))
 (|apply|
  ((|#2| |#3| (|Mapping| |#2| |#2|) |#2|)
   "\\spad{apply(p,{} f,{} m)} returns \\spad{p(m)} where the action is given by \\spad{x m = f(m)}. \\spad{f} must be an \\spad{R}-pseudo linear map on \\spad{M}."))) 
NIL 
(|ApplyRules| |Base| R F) 
((|constructor|
  (NIL
   "This package apply rewrite rules to expressions,{} calling the pattern matcher."))
 (|applyRules|
  ((|#3| (|List| (|RewriteRule| |#1| |#2| |#3|)) |#3| (|PositiveInteger|))
   "\\spad{applyRules([r1,{} ...,{} rn],{} expr,{} n)} applies the rules \\spad{r1},{} ...,{} \\spad{rn} to \\spad{f} a most \\spad{n} times.")
  ((|#3| (|List| (|RewriteRule| |#1| |#2| |#3|)) |#3|)
   "\\spad{applyRules([r1,{} ...,{} rn],{} expr)} applies the rules \\spad{r1},{} ...,{} \\spad{rn} to \\spad{f} an unlimited number of times,{} \\spadignore{i.e.} until none of \\spad{r1},{} ...,{} \\spad{rn} is applicable to the expression."))) 
NIL 
(|AbelianProductCategory| A) 
((|constructor|
  (NIL
   "This category represents products with coordinatewise additive operations."))) 
NIL 
(|TwoDimensionalArrayCategory&| S R |Row| |Col|) 
((|constructor|
  (NIL
   "\\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the 'first' row may be obtained by calling the function 'minRowIndex'. The index of the 'first' column may be obtained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa."))
 (|map!|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map!(f,{} a)} assign \\spad{a(i,{} j)} to \\spad{f(a(i,{} j))} for all \\spad{i,{} j}"))
 (|map|
  (($ (|Mapping| |#2| |#2| |#2|) $ $ |#2|)
   "\\spad{map(f,{} a,{} b,{} r)} returns \\spad{c},{} where \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} when both \\spad{a(i,{} j)} and \\spad{b(i,{} j)} exist; else \\spad{c(i,{} j) = f(r,{} b(i,{} j))} when \\spad{a(i,{} j)} does not exist; else \\spad{c(i,{} j) = f(a(i,{} j),{} r)} when \\spad{b(i,{} j)} does not exist; otherwise \\spad{c(i,{} j) = f(r,{} r)}.")
  (($ (|Mapping| |#2| |#2| |#2|) $ $)
   "\\spad{map(f,{} a,{} b)} returns \\spad{c},{} where \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \\spad{i,{} j}")
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map(f,{} a)} returns \\spad{b},{} where \\spad{b(i,{} j) = f(a(i,{} j))} for all \\spad{i,{} j}"))
 (|blockSplit|
  (((|List| (|List| $)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{blockSplit(a,{} [n1,{}...,{}\\spad{ni}],{} [m1,{}...,{}\\spad{mi}])} splits a into multiple subarraus row and column wise,{} such that element at position \\spad{k},{} \\spad{l} has \\spad{nk} rows and \\spad{ml} columns. Error: if number of rows of a is different than \\spad{n1} + ... + \\spad{ni} or number of columns of a is different than \\spad{m1} + ... + \\spad{mj}")
  (((|List| (|List| $)) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{blockSplit(a,{} n,{} m)} splits a into \\spad{n*m} subarrays of equal size row and column wise,{} dividing a into blocks. Error: if number of rows of a is not divisible by \\spad{n} or number of columns of a is not divisible by \\spad{m}."))
 (|horizSplit|
  (((|List| $) $ (|List| (|NonNegativeInteger|)))
   "\\spad{horizSplit(a,{} [n1,{} n2,{} ...,{} \\spad{ni}])} splits a into arrays having \\spad{n1},{} ...,{} \\spad{ni} columns. Error: if number of columns of a is different than \\spad{n1} + ... + \\spad{ni}.")
  (((|List| $) $ (|PositiveInteger|))
   "\\spad{horizSplit(a,{} n)} splits a into \\spad{n} arrays of equal size column wise. Error: if number of columns of a is not divisible by \\spad{n}."))
 (|vertSplit|
  (((|List| $) $ (|List| (|NonNegativeInteger|)))
   "\\spad{vertSplit(a,{} [n1,{} ...,{} \\spad{ni}])} splits a into arrays having \\spad{n1},{} ...,{} \\spad{ni} rows. Error: if number of rows of a is different than \\spad{n1+} ... + \\spad{ni}.")
  (((|List| $) $ (|PositiveInteger|))
   "\\spad{vertSplit(a,{} n)} splits a into \\spad{n} arrays of equal size row wise. Error: if number of rows of a is not divisible by \\spad{n}."))
 (|blockConcat|
  (($ (|List| (|List| $)))
   "\\spad{blockConcat(ll)} concatenates arrays row and column wise,{} building a array from blocks. The order is row major as in \\spad{matrix}."))
 (|vertConcat|
  (($ (|List| $))
   "\\spad{vertConcat(l)} vertically concatenates all members of \\spad{l} Error: if the arrays do not have the same number of columns.")
  (($ $ $)
   "\\spad{vertConcat(x,{} y)} vertically concatenates two arrays with an equal number of columns. The entries of \\spad{y} appear below of the entries of \\spad{x}. Error: if the arrays do not have the same number of columns."))
 (|horizConcat|
  (($ (|List| $))
   "\\spad{horizConcat(l)} horizontally concatenates all members of \\spad{l} Error: if the arrays do not have the same number of rows.")
  (($ $ $)
   "\\spad{horizConcat(x,{} y)} horizontally concatenates two arrays with an equal number of rows. The entries of \\spad{y} appear to the right of the entries of \\spad{x}. Error: if the arrays do not have the same number of rows."))
 (|squareTop|
  (($ $)
   "\\spad{squareTop(m)} returns an \\spad{n}-by-\\spad{n} array consisting of the first \\spad{n} rows of the \\spad{m}-by-\\spad{n} array \\spad{m}. Error: if \\spad{m < n}."))
 (|transpose|
  (($ $) "\\spad{transpose(m)} returns the transpose of the array \\spad{m}."))
 (|swapColumns!|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{swapColumns!(m,{} i,{} j)} interchanges the \\spad{i}th and \\spad{j}th columns of \\spad{m}. This destructively alters the array."))
 (|swapRows!|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{swapRows!(m,{} i,{} j)} interchanges the \\spad{i}th and \\spad{j}th rows of \\spad{m}. This destructively alters the array."))
 (|setsubMatrix!|
  (($ $ (|Integer|) (|Integer|) $)
   "\\spad{setsubMatrix(x,{} i1,{} j1,{} y)} destructively alters the array \\spad{x}. Here \\spad{x(i,{} j)} is set to \\spad{y(i-i1+1,{} j-j1+1)} for \\spad{i = i1,{} ...,{} i1-1+nrows y} and \\spad{j = j1,{} ...,{} j1-1+ncols y}."))
 (|setColumn!|
  (($ $ (|Integer|) |#4|)
   "\\spad{setColumn!(m,{} j,{} v)} sets to \\spad{j}th column of \\spad{m} to \\spad{v}"))
 (|setRow!|
  (($ $ (|Integer|) |#3|)
   "\\spad{setRow!(m,{} i,{} v)} sets to \\spad{i}th row of \\spad{m} to \\spad{v}"))
 (|qsetelt!|
  ((|#2| $ (|Integer|) (|Integer|) |#2|)
   "\\spad{qsetelt!(m,{} i,{} j,{} r)} sets the element in the \\spad{i}th row and \\spad{j}th column of \\spad{m} to \\spad{r} NO error check to determine if indices are in proper ranges"))
 (|colSlice|
  (((|Segment| (|Integer|)) $)
   "\\spad{colSlice(m)} returns a segment \\spad{s} such that for \\spad{m} the access \\spad{m}(\\spad{i},{} \\spad{s}) gives the \\spad{i}-th row."))
 (|rowSlice|
  (((|Segment| (|Integer|)) $)
   "\\spad{rowSlice(m)} returns a segment \\spad{s} such that for \\spad{m} the access \\spad{m}(\\spad{s},{} \\spad{j}) gives the \\spad{j}-th column."))
 (|setelt!|
  (($ $ (|List| (|Segment| (|Integer|))) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} ls1,{} ls1)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} ls1,{} s2)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} s1,{} ls2)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} s1,{} l2)} is equivalent to \\spad{setelt!(x,{} expand(s1),{} l2)} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} l1,{} s2)} is equivalent to \\spad{setelt!(x,{} l1,{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} s1,{} s2)} is equivalent to \\spad{setelt!(x,{} expand(s1),{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} rowList,{} colList,{} y)} destructively alters the array \\spad{x}. If \\spad{y} is \\spad{m}-by-\\spad{n},{} \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]} and \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then \\spad{x(i<k>,{} j<l>)} is set to \\spad{y(k,{} l)} for \\spad{k = 1,{} ...,{} m} and \\spad{l = 1,{} ...,{} n}.")
  (($ $ (|List| (|Integer|)) (|Integer|) $)
   "\\spad{setelt!(x,{} rowList,{} col)} assigns to an \\spad{m}-by-1 selection of the array,{} where \\spad{m = \\# rowList}.")
  (($ $ (|Integer|) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} row,{} colList)} assigns to an 1-by-\\spad{n} selection of the array,{} where \\spad{n = \\# colList}.")
  ((|#2| $ (|Integer|) (|Integer|) |#2|)
   "\\spad{setelt!(m,{} i,{} j,{} r)} sets the element in the \\spad{i}th row and \\spad{j}th column of \\spad{m} to \\spad{r} error check to determine if indices are in proper ranges")
  (($ $ (|List| (|Segment| (|Integer|))) (|Integer|) $)
   "\\spad{setelt!(x,{} ls1,{} col)} is equivalent to \\spad{setelt!(x,{} l1,{} col)} where \\spad{l1} is obtained appending expansions of elements of \\spad{ls1},{} but should be more convenient and more efficient.")
  (($ $ (|Integer|) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} row,{} ls2)} is equivalent to \\spad{setelt!(x,{} row,{} l2)} where \\spad{l2} is obtained appending expansions of elements of \\spad{ls2},{} but should be more convenient and more efficient."))
 (|subMatrix|
  (($ $ (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{subMatrix(x,{} i1,{} i2,{} j1,{} j2)} extracts the submatrix \\spad{[x(i,{} j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2} and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}."))
 (|listOfLists|
  (((|List| (|List| |#2|)) $)
   "\\spad{listOfLists(m)} returns the rows of the array \\spad{m} as a list of lists."))
 (|parts|
  (((|List| |#2|) $)
   "\\spad{parts(m)} returns a list of the elements of \\spad{m} in row major order"))
 (|column|
  ((|#4| $ (|Integer|))
   "\\spad{column(m,{} j)} returns the \\spad{j}th column of \\spad{m} error check to determine if index is in proper ranges"))
 (|row|
  ((|#3| $ (|Integer|))
   "\\spad{row(m,{} i)} returns the \\spad{i}th row of \\spad{m} error check to determine if index is in proper ranges"))
 (|qelt|
  ((|#2| $ (|Integer|) (|Integer|))
   "\\spad{qelt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m} NO error check to determine if indices are in proper ranges"))
 (|elt|
  (($ $ (|List| (|Segment| (|Integer|))) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} ls1,{} ls2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} ls1,{} s2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} s1,{} ls2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Integer|))
   "\\spad{elt(x,{} ls1,{} col)} is equivalent to \\spad{elt(x,{} l1,{} col)} where \\spad{l1} is obtained appending expansions of elements of \\spad{ls1},{} but should be more convenient and more efficient.")
  (($ $ (|Integer|) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} row,{} ls2)} is equivalent to \\spad{elt(x,{} row,{} l2)} where \\spad{l2} is obtained appending expansions of elements of \\spad{ls2},{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Integer|)))
   "\\spad{elt(x,{} s,{} colList)} is equivalent to \\spad{elt(x,{} expand(s),{} colList)} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} rowList,{} s)} is equivalent to \\spad{elt(x,{} rowList,{} expand(s))} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} s1,{} s2)} is equivalent to \\spad{elt(x,{} expand(s1),{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{elt(x,{} rowList,{} colList)} returns an \\spad{m}-by-\\spad{n} array consisting of elements of \\spad{x},{} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}. If \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]} and \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} rowList,{} colList)} is \\spad{x(i<k>,{} j<l>)}.")
  (($ $ (|List| (|Integer|)) (|Integer|))
   "\\spad{elt(x,{} rowList,{} col)} returns an \\spad{m}-by-1 array consisting of elements of \\spad{x},{} where \\spad{m = \\# rowList}. If \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} rowList,{} col)} is \\spad{x(i<k>,{} col)}.")
  (($ $ (|Integer|) (|List| (|Integer|)))
   "\\spad{elt(x,{} row,{} colList)} returns an 1-by-\\spad{n} array consisting of elements of \\spad{x},{} where \\spad{n = \\# colList}. If \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} row,{} colList)} is \\spad{x(row,{} j<l>)}.")
  ((|#2| $ (|Integer|) (|Integer|) |#2|)
   "\\spad{elt(m,{} i,{} j,{} r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m},{} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,{} and returns \\spad{r} otherwise")
  ((|#2| $ (|Integer|) (|Integer|))
   "\\spad{elt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m} error check to determine if indices are in proper ranges"))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(m)} returns the number of columns in the array \\spad{m}"))
 (|nrows|
  (((|NonNegativeInteger|) $)
   "\\spad{nrows(m)} returns the number of rows in the array \\spad{m}"))
 (|maxColIndex|
  (((|Integer|) $)
   "\\spad{maxColIndex(m)} returns the index of the 'last' column of the array \\spad{m}"))
 (|minColIndex|
  (((|Integer|) $)
   "\\spad{minColIndex(m)} returns the index of the 'first' column of the array \\spad{m}"))
 (|maxRowIndex|
  (((|Integer|) $)
   "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the array \\spad{m}"))
 (|minRowIndex|
  (((|Integer|) $)
   "\\spad{minRowIndex(m)} returns the index of the 'first' row of the array \\spad{m}"))
 (|fill!|
  (($ $ |#2|)
   "\\spad{fill!(m,{} r)} fills \\spad{m} with \\spad{r}\\spad{'s}"))
 (|qnew|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qnew(m,{} n)} is is an \\spad{m}-by-\\spad{n} uninitilized array"))
 (|new|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{new(m,{} n,{} r)} is an \\spad{m}-by-\\spad{n} array all of whose entries are \\spad{r}"))) 
((|HasCategory| |#2| '(|Comparable|))) 
(|TwoDimensionalArrayCategory| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the 'first' row may be obtained by calling the function 'minRowIndex'. The index of the 'first' column may be obtained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa."))
 (|map!|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map!(f,{} a)} assign \\spad{a(i,{} j)} to \\spad{f(a(i,{} j))} for all \\spad{i,{} j}"))
 (|map|
  (($ (|Mapping| |#1| |#1| |#1|) $ $ |#1|)
   "\\spad{map(f,{} a,{} b,{} r)} returns \\spad{c},{} where \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} when both \\spad{a(i,{} j)} and \\spad{b(i,{} j)} exist; else \\spad{c(i,{} j) = f(r,{} b(i,{} j))} when \\spad{a(i,{} j)} does not exist; else \\spad{c(i,{} j) = f(a(i,{} j),{} r)} when \\spad{b(i,{} j)} does not exist; otherwise \\spad{c(i,{} j) = f(r,{} r)}.")
  (($ (|Mapping| |#1| |#1| |#1|) $ $)
   "\\spad{map(f,{} a,{} b)} returns \\spad{c},{} where \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \\spad{i,{} j}")
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} a)} returns \\spad{b},{} where \\spad{b(i,{} j) = f(a(i,{} j))} for all \\spad{i,{} j}"))
 (|blockSplit|
  (((|List| (|List| $)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{blockSplit(a,{} [n1,{}...,{}\\spad{ni}],{} [m1,{}...,{}\\spad{mi}])} splits a into multiple subarraus row and column wise,{} such that element at position \\spad{k},{} \\spad{l} has \\spad{nk} rows and \\spad{ml} columns. Error: if number of rows of a is different than \\spad{n1} + ... + \\spad{ni} or number of columns of a is different than \\spad{m1} + ... + \\spad{mj}")
  (((|List| (|List| $)) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{blockSplit(a,{} n,{} m)} splits a into \\spad{n*m} subarrays of equal size row and column wise,{} dividing a into blocks. Error: if number of rows of a is not divisible by \\spad{n} or number of columns of a is not divisible by \\spad{m}."))
 (|horizSplit|
  (((|List| $) $ (|List| (|NonNegativeInteger|)))
   "\\spad{horizSplit(a,{} [n1,{} n2,{} ...,{} \\spad{ni}])} splits a into arrays having \\spad{n1},{} ...,{} \\spad{ni} columns. Error: if number of columns of a is different than \\spad{n1} + ... + \\spad{ni}.")
  (((|List| $) $ (|PositiveInteger|))
   "\\spad{horizSplit(a,{} n)} splits a into \\spad{n} arrays of equal size column wise. Error: if number of columns of a is not divisible by \\spad{n}."))
 (|vertSplit|
  (((|List| $) $ (|List| (|NonNegativeInteger|)))
   "\\spad{vertSplit(a,{} [n1,{} ...,{} \\spad{ni}])} splits a into arrays having \\spad{n1},{} ...,{} \\spad{ni} rows. Error: if number of rows of a is different than \\spad{n1+} ... + \\spad{ni}.")
  (((|List| $) $ (|PositiveInteger|))
   "\\spad{vertSplit(a,{} n)} splits a into \\spad{n} arrays of equal size row wise. Error: if number of rows of a is not divisible by \\spad{n}."))
 (|blockConcat|
  (($ (|List| (|List| $)))
   "\\spad{blockConcat(ll)} concatenates arrays row and column wise,{} building a array from blocks. The order is row major as in \\spad{matrix}."))
 (|vertConcat|
  (($ (|List| $))
   "\\spad{vertConcat(l)} vertically concatenates all members of \\spad{l} Error: if the arrays do not have the same number of columns.")
  (($ $ $)
   "\\spad{vertConcat(x,{} y)} vertically concatenates two arrays with an equal number of columns. The entries of \\spad{y} appear below of the entries of \\spad{x}. Error: if the arrays do not have the same number of columns."))
 (|horizConcat|
  (($ (|List| $))
   "\\spad{horizConcat(l)} horizontally concatenates all members of \\spad{l} Error: if the arrays do not have the same number of rows.")
  (($ $ $)
   "\\spad{horizConcat(x,{} y)} horizontally concatenates two arrays with an equal number of rows. The entries of \\spad{y} appear to the right of the entries of \\spad{x}. Error: if the arrays do not have the same number of rows."))
 (|squareTop|
  (($ $)
   "\\spad{squareTop(m)} returns an \\spad{n}-by-\\spad{n} array consisting of the first \\spad{n} rows of the \\spad{m}-by-\\spad{n} array \\spad{m}. Error: if \\spad{m < n}."))
 (|transpose|
  (($ $) "\\spad{transpose(m)} returns the transpose of the array \\spad{m}."))
 (|swapColumns!|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{swapColumns!(m,{} i,{} j)} interchanges the \\spad{i}th and \\spad{j}th columns of \\spad{m}. This destructively alters the array."))
 (|swapRows!|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{swapRows!(m,{} i,{} j)} interchanges the \\spad{i}th and \\spad{j}th rows of \\spad{m}. This destructively alters the array."))
 (|setsubMatrix!|
  (($ $ (|Integer|) (|Integer|) $)
   "\\spad{setsubMatrix(x,{} i1,{} j1,{} y)} destructively alters the array \\spad{x}. Here \\spad{x(i,{} j)} is set to \\spad{y(i-i1+1,{} j-j1+1)} for \\spad{i = i1,{} ...,{} i1-1+nrows y} and \\spad{j = j1,{} ...,{} j1-1+ncols y}."))
 (|setColumn!|
  (($ $ (|Integer|) |#3|)
   "\\spad{setColumn!(m,{} j,{} v)} sets to \\spad{j}th column of \\spad{m} to \\spad{v}"))
 (|setRow!|
  (($ $ (|Integer|) |#2|)
   "\\spad{setRow!(m,{} i,{} v)} sets to \\spad{i}th row of \\spad{m} to \\spad{v}"))
 (|qsetelt!|
  ((|#1| $ (|Integer|) (|Integer|) |#1|)
   "\\spad{qsetelt!(m,{} i,{} j,{} r)} sets the element in the \\spad{i}th row and \\spad{j}th column of \\spad{m} to \\spad{r} NO error check to determine if indices are in proper ranges"))
 (|colSlice|
  (((|Segment| (|Integer|)) $)
   "\\spad{colSlice(m)} returns a segment \\spad{s} such that for \\spad{m} the access \\spad{m}(\\spad{i},{} \\spad{s}) gives the \\spad{i}-th row."))
 (|rowSlice|
  (((|Segment| (|Integer|)) $)
   "\\spad{rowSlice(m)} returns a segment \\spad{s} such that for \\spad{m} the access \\spad{m}(\\spad{s},{} \\spad{j}) gives the \\spad{j}-th column."))
 (|setelt!|
  (($ $ (|List| (|Segment| (|Integer|))) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} ls1,{} ls1)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} ls1,{} s2)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} s1,{} ls2)} is equivalent to \\spad{setelt!(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} s1,{} l2)} is equivalent to \\spad{setelt!(x,{} expand(s1),{} l2)} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} l1,{} s2)} is equivalent to \\spad{setelt!(x,{} l1,{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|Segment| (|Integer|)) $)
   "\\spad{setelt!(x,{} s1,{} s2)} is equivalent to \\spad{setelt!(x,{} expand(s1),{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} rowList,{} colList,{} y)} destructively alters the array \\spad{x}. If \\spad{y} is \\spad{m}-by-\\spad{n},{} \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]} and \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then \\spad{x(i<k>,{} j<l>)} is set to \\spad{y(k,{} l)} for \\spad{k = 1,{} ...,{} m} and \\spad{l = 1,{} ...,{} n}.")
  (($ $ (|List| (|Integer|)) (|Integer|) $)
   "\\spad{setelt!(x,{} rowList,{} col)} assigns to an \\spad{m}-by-1 selection of the array,{} where \\spad{m = \\# rowList}.")
  (($ $ (|Integer|) (|List| (|Integer|)) $)
   "\\spad{setelt!(x,{} row,{} colList)} assigns to an 1-by-\\spad{n} selection of the array,{} where \\spad{n = \\# colList}.")
  ((|#1| $ (|Integer|) (|Integer|) |#1|)
   "\\spad{setelt!(m,{} i,{} j,{} r)} sets the element in the \\spad{i}th row and \\spad{j}th column of \\spad{m} to \\spad{r} error check to determine if indices are in proper ranges")
  (($ $ (|List| (|Segment| (|Integer|))) (|Integer|) $)
   "\\spad{setelt!(x,{} ls1,{} col)} is equivalent to \\spad{setelt!(x,{} l1,{} col)} where \\spad{l1} is obtained appending expansions of elements of \\spad{ls1},{} but should be more convenient and more efficient.")
  (($ $ (|Integer|) (|List| (|Segment| (|Integer|))) $)
   "\\spad{setelt!(x,{} row,{} ls2)} is equivalent to \\spad{setelt!(x,{} row,{} l2)} where \\spad{l2} is obtained appending expansions of elements of \\spad{ls2},{} but should be more convenient and more efficient."))
 (|subMatrix|
  (($ $ (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{subMatrix(x,{} i1,{} i2,{} j1,{} j2)} extracts the submatrix \\spad{[x(i,{} j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2} and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}."))
 (|listOfLists|
  (((|List| (|List| |#1|)) $)
   "\\spad{listOfLists(m)} returns the rows of the array \\spad{m} as a list of lists."))
 (|parts|
  (((|List| |#1|) $)
   "\\spad{parts(m)} returns a list of the elements of \\spad{m} in row major order"))
 (|column|
  ((|#3| $ (|Integer|))
   "\\spad{column(m,{} j)} returns the \\spad{j}th column of \\spad{m} error check to determine if index is in proper ranges"))
 (|row|
  ((|#2| $ (|Integer|))
   "\\spad{row(m,{} i)} returns the \\spad{i}th row of \\spad{m} error check to determine if index is in proper ranges"))
 (|qelt|
  ((|#1| $ (|Integer|) (|Integer|))
   "\\spad{qelt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m} NO error check to determine if indices are in proper ranges"))
 (|elt|
  (($ $ (|List| (|Segment| (|Integer|))) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} ls1,{} ls2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} ls1,{} s2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} s1,{} ls2)} is equivalent to \\spad{elt(x,{} l1,{} l2)} where \\spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.")
  (($ $ (|List| (|Segment| (|Integer|))) (|Integer|))
   "\\spad{elt(x,{} ls1,{} col)} is equivalent to \\spad{elt(x,{} l1,{} col)} where \\spad{l1} is obtained appending expansions of elements of \\spad{ls1},{} but should be more convenient and more efficient.")
  (($ $ (|Integer|) (|List| (|Segment| (|Integer|))))
   "\\spad{elt(x,{} row,{} ls2)} is equivalent to \\spad{elt(x,{} row,{} l2)} where \\spad{l2} is obtained appending expansions of elements of \\spad{ls2},{} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|List| (|Integer|)))
   "\\spad{elt(x,{} s,{} colList)} is equivalent to \\spad{elt(x,{} expand(s),{} colList)} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} rowList,{} s)} is equivalent to \\spad{elt(x,{} rowList,{} expand(s))} but should be more convenient and more efficient.")
  (($ $ (|Segment| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{elt(x,{} s1,{} s2)} is equivalent to \\spad{elt(x,{} expand(s1),{} expand(s2))} but should be more convenient and more efficient.")
  (($ $ (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{elt(x,{} rowList,{} colList)} returns an \\spad{m}-by-\\spad{n} array consisting of elements of \\spad{x},{} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}. If \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]} and \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} rowList,{} colList)} is \\spad{x(i<k>,{} j<l>)}.")
  (($ $ (|List| (|Integer|)) (|Integer|))
   "\\spad{elt(x,{} rowList,{} col)} returns an \\spad{m}-by-1 array consisting of elements of \\spad{x},{} where \\spad{m = \\# rowList}. If \\spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} rowList,{} col)} is \\spad{x(i<k>,{} col)}.")
  (($ $ (|Integer|) (|List| (|Integer|)))
   "\\spad{elt(x,{} row,{} colList)} returns an 1-by-\\spad{n} array consisting of elements of \\spad{x},{} where \\spad{n = \\# colList}. If \\spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \\spad{(k,{} l)}th entry of \\spad{elt(x,{} row,{} colList)} is \\spad{x(row,{} j<l>)}.")
  ((|#1| $ (|Integer|) (|Integer|) |#1|)
   "\\spad{elt(m,{} i,{} j,{} r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m},{} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,{} and returns \\spad{r} otherwise")
  ((|#1| $ (|Integer|) (|Integer|))
   "\\spad{elt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the array \\spad{m} error check to determine if indices are in proper ranges"))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(m)} returns the number of columns in the array \\spad{m}"))
 (|nrows|
  (((|NonNegativeInteger|) $)
   "\\spad{nrows(m)} returns the number of rows in the array \\spad{m}"))
 (|maxColIndex|
  (((|Integer|) $)
   "\\spad{maxColIndex(m)} returns the index of the 'last' column of the array \\spad{m}"))
 (|minColIndex|
  (((|Integer|) $)
   "\\spad{minColIndex(m)} returns the index of the 'first' column of the array \\spad{m}"))
 (|maxRowIndex|
  (((|Integer|) $)
   "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the array \\spad{m}"))
 (|minRowIndex|
  (((|Integer|) $)
   "\\spad{minRowIndex(m)} returns the index of the 'first' row of the array \\spad{m}"))
 (|fill!|
  (($ $ |#1|)
   "\\spad{fill!(m,{} r)} fills \\spad{m} with \\spad{r}\\spad{'s}"))
 (|qnew|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qnew(m,{} n)} is is an \\spad{m}-by-\\spad{n} uninitilized array"))
 (|new|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{new(m,{} n,{} r)} is an \\spad{m}-by-\\spad{n} array all of whose entries are \\spad{r}"))) 
NIL 
(|OneDimensionalArray| S) 
((|constructor| (NIL "This is the domain of 1-based one dimensional arrays"))
 (|oneDimensionalArray|
  (($ (|NonNegativeInteger|) |#1|)
   "\\spad{oneDimensionalArray(n,{} s)} creates an array from \\spad{n} copies of element \\spad{s}")
  (($ (|List| |#1|))
   "\\spad{oneDimensionalArray(l)} creates an array from a list of elements \\spad{l}"))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|OneDimensionalArrayFunctions2| A B) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides tools for operating on one-dimensional arrays} with unary and binary functions involving different underlying types"))
 (|map|
  (((|OneDimensionalArray| |#2|) (|Mapping| |#2| |#1|)
    (|OneDimensionalArray| |#1|))
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of one-dimensional array \\spad{a} resulting in a new one-dimensional array over a possibly different underlying domain."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#1| |#2|) (|OneDimensionalArray| |#1|) |#2|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the one-dimensional array \\spad{a} and an accumulant initialized to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as the identity element for the function \\spad{f}."))
 (|scan|
  (((|OneDimensionalArray| |#2|) (|Mapping| |#2| |#1| |#2|)
    (|OneDimensionalArray| |#1|) |#2|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-arrays \\spad{x} of one-dimensional array \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad{[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))) 
NIL 
(|TwoDimensionalArray| R) 
((|constructor|
  (NIL
   "\\indented{1}{A TwoDimensionalArray is a two dimensional array with} 1-based indexing for both rows and columns."))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|TwoDimensionalArrayFunctions| A RA CA MA B RB CB MB) 
((|map|
  ((|#8| (|Mapping| |#5| |#1|) |#4|)
   "\\spad{map(f,{} m)} applies the function \\spad{f} to every element of the array \\spad{m} producing a new array containing the values."))) 
NIL 
(|AssociatedEquations| R L) 
((|constructor|
  (NIL
   "\\spadtype{AssociatedEquations} provides functions to compute the associated equations needed for factoring operators"))
 (|associatedEquations|
  (((|Record| (|:| |minor| (|List| (|PositiveInteger|))) (|:| |eq| |#2|)
              (|:| |minors| (|List| (|List| (|PositiveInteger|))))
              (|:| |ops| (|List| |#2|)))
    |#2| (|PositiveInteger|))
   "\\spad{associatedEquations(op,{} m)} returns \\spad{[w,{} eq,{} lw,{} lop]} such that \\spad{eq(w) = 0} where \\spad{w} is the given minor,{} and \\spad{lw_i = lop_i(w)} for all the other minors."))
 (|uncouplingMatrices|
  (((|Vector| (|Matrix| |#1|)) (|Matrix| |#1|))
   "\\spad{uncouplingMatrices(M)} returns \\spad{[A_1,{} ...,{} A_n]} such that if \\spad{y = [y_1,{} ...,{} y_n]} is a solution of \\spad{y' = M y},{} then \\spad{[\\$y_j',{} y_j'',{} ...,{} y_j^{(n)}\\$] = \\$A_j y\\$} for all \\spad{j}\\spad{'s}."))
 (|associatedSystem|
  (((|Record| (|:| |mat| (|Matrix| |#1|))
              (|:| |vec| (|Vector| (|List| (|PositiveInteger|)))))
    |#2| (|PositiveInteger|))
   "\\spad{associatedSystem(op,{} m)} returns \\spad{[M,{} w]} such that the \\spad{m}-th associated equation system to \\spad{L} is \\spad{w' = M w}."))) 
((|HasCategory| |#1| '(|Field|))) 
(|ArrayStack| S) 
((|constructor| (NIL "A stack represented as a flexible array."))
 (|arrayStack|
  (($ (|List| |#1|))
   "\\spad{arrayStack([x,{} y,{} ...,{} z])} creates an array stack with first (top) element \\spad{x},{} second element \\spad{y},{} ...,{} and last element \\spad{z}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|additiveValuation|) 
((|constructor|
  (NIL
   "The class of all euclidean domains such that \\spad{euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}."))) 
NIL 
(|Approximate|) 
((|constructor| (NIL "An approximation to the real numbers."))) 
NIL 
(|arbitraryExponent|) 
((|constructor| (NIL "Approximate numbers with arbitrarily large exponents"))) 
NIL 
(|arbitraryPrecision|) 
((|constructor|
  (NIL
   "Approximate numbers for which the user can set the precision for subsequent calculations."))) 
NIL 
(|canonicalsClosed|) 
((|constructor|
  (NIL
   "The class of all integral domains such that \\spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}."))) 
NIL 
(|Canonical|) 
((|constructor|
  (NIL
   "The class of all domains which have canonical representation,{} that is if mathematically equal elements have the same data structures."))) 
NIL 
(|CommutativeStar|) 
((|constructor|
  (NIL
   "The class of all commutative semigroups in multiplicative notation. In other words domains \\spad{D} with \\spad{\"*\": (D,{} D) -> D} which is commutative. Typically applied to rings."))) 
NIL 
(|canonicalUnitNormal|) 
((|constructor|
  (NIL
   "The class of all integral domains such that we can choose a canonical representative for each class of associate elements,{} that is \\spad{associates?(a,{} b)} returns \\spad{true} if and only if \\spad{unitCanonical(a) = unitCanonical(b)}."))) 
NIL 
(|finiteAggregate|) 
((|constructor|
  (NIL "The class of all aggregates with a finite number of elements."))) 
NIL 
(|lazyRepresentation|) 
((|constructor|
  (NIL "The class of all domains which have have lazy representation."))) 
NIL 
(|multiplicativeValuation|) 
((|constructor|
  (NIL
   "The class of all euclidean domains such that \\spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}."))) 
NIL 
(|noZeroDivisors|) 
((|constructor|
  (NIL
   "The class of all semirings such that \\spad{x * y \\~~= 0} implies both \\spad{x} and \\spad{y} are non-zero"))) 
NIL 
(|ArcTrigonometricFunctionCategory&| S) 
((|constructor| (NIL "Category for the inverse trigonometric functions."))
 (|atan|
  (($ $)
   "\\spad{atan(x)} returns the arc-tangent of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for atan lies along the positive imaginary axis above \\%\\spad{i} (exclusive),{} continuous with the left half plane,{} the other along the negative imaginary axis below -\\%\\spad{i} (exclusive) continuous with the right half plane. The domain does not contain \\%\\spad{i} and -\\%\\spad{i}."))
 (|asin|
  (($ $)
   "\\spad{asin(x)} returns the arc-sine of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for asin lies along the negative real axis to the left of \\spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane."))
 (|asec| (($ $) "\\spad{asec(x)} returns the arc-secant of \\spad{x}."))
 (|acsc| (($ $) "\\spad{acsc(x)} returns the arc-cosecant of \\spad{x}."))
 (|acot| (($ $) "\\spad{acot(x)} returns the arc-cotangent of \\spad{x}."))
 (|acos|
  (($ $)
   "\\spad{acos(x)} returns the arc-cosine of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for acos lies along the negative real axis to the left of \\spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane."))) 
NIL 
(|ArcTrigonometricFunctionCategory|) 
((|constructor| (NIL "Category for the inverse trigonometric functions."))
 (|atan|
  (($ $)
   "\\spad{atan(x)} returns the arc-tangent of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for atan lies along the positive imaginary axis above \\%\\spad{i} (exclusive),{} continuous with the left half plane,{} the other along the negative imaginary axis below -\\%\\spad{i} (exclusive) continuous with the right half plane. The domain does not contain \\%\\spad{i} and -\\%\\spad{i}."))
 (|asin|
  (($ $)
   "\\spad{asin(x)} returns the arc-sine of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for asin lies along the negative real axis to the left of \\spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane."))
 (|asec| (($ $) "\\spad{asec(x)} returns the arc-secant of \\spad{x}."))
 (|acsc| (($ $) "\\spad{acsc(x)} returns the arc-cosecant of \\spad{x}."))
 (|acot| (($ $) "\\spad{acot(x)} returns the arc-cotangent of \\spad{x}."))
 (|acos|
  (($ $)
   "\\spad{acos(x)} returns the arc-cosine of \\spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for acos lies along the negative real axis to the left of \\spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane."))) 
NIL 
(|shallowlyMutable|) 
((|constructor|
  (NIL
   "The class of all domains which have have immediate components that are updateable (mutable)."))) 
NIL 
(|TwoSidedRecip|) 
((|constructor|
  (NIL
   "The class of all magmas where \\spad{leftRecip} and \\spad{rightRecip} are the same as \\spad{recip}."))) 
NIL 
(|unitsKnown|) 
((|constructor|
  (NIL
   "The class of all monoids (multiplicative semigroups with a 1) such that the operation \\spadfun{recip} can only return \"failed\" if its argument is not a unit."))) 
NIL 
(|VariablesCommuteWithCoefficients|) 
((|constructor|
  (NIL
   "The class of all polynomial domains such that variables commute with coefficients."))) 
NIL 
(|Automorphism| R) 
((|constructor|
  (NIL
   "Automorphism \\spad{R} is the multiplicative group of automorphisms of \\spad{R}."))
 (|morphism|
  (($ (|Mapping| |#1| |#1| (|Integer|)))
   "\\spad{morphism(f)} returns the morphism given by \\spad{f^n(x) = f(x,{} n)}.")
  (($ (|Mapping| |#1| |#1|) (|Mapping| |#1| |#1|))
   "\\spad{morphism(f,{} g)} returns the invertible morphism given by \\spad{f},{} where \\spad{g} is the inverse of \\spad{f}..")
  (($ (|Mapping| |#1| |#1|))
   "\\spad{morphism(f)} returns the non-invertible morphism given by \\spad{f}."))) 
NIL 
(|BalancedFactorisation| R UP) 
((|constructor|
  (NIL "This package provides balanced factorisations of polynomials."))
 (|balancedFactorisation|
  (((|Factored| |#2|) |#2| (|List| |#2|))
   "\\spad{balancedFactorisation(a,{} [b1,{} ...,{} bn])} returns a factorisation \\spad{a = p1^e1 ... pm^em} such that each \\spad{pi} is balanced with respect to \\spad{[b1,{} ...,{} bm]}.")
  (((|Factored| |#2|) |#2| |#2|)
   "\\spad{balancedFactorisation(a,{} b)} returns a factorisation \\spad{a = p1^e1 ... pm^em} such that each \\spad{\\spad{pi}} is balanced with respect to \\spad{b}."))) 
NIL 
(|BasicType&| S) 
((|constructor|
  (NIL
   "\\spadtype{BasicType} is the basic category for describing a collection of elements with \\spadop{=} (equality)."))
 (~=
  (((|Boolean|) $ $)
   "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
 (=
  (((|Boolean|) $ $)
   "\\spad{x = y} tests if \\spad{x} and \\spad{y} are equal."))) 
NIL 
(|BasicType|) 
((|constructor|
  (NIL
   "\\spadtype{BasicType} is the basic category for describing a collection of elements with \\spadop{=} (equality)."))
 (~=
  (((|Boolean|) $ $)
   "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal."))
 (=
  (((|Boolean|) $ $)
   "\\spad{x = y} tests if \\spad{x} and \\spad{y} are equal."))) 
NIL 
(|BalancedBinaryTree| S) 
((|constructor|
  (NIL
   "\\spadtype{BalancedBinaryTree(S)} is the domain of balanced binary trees (bbtree). A balanced binary tree of \\spad{2^k} leaves,{} for some \\spad{k > 0},{} is symmetric,{} that is,{} the left and right subtree of each interior node have identical shape. In general,{} the left and right subtree of a given node can differ by at most one leaf node."))
 (|mapDown!|
  (($ $ |#1| (|Mapping| (|List| |#1|) |#1| |#1| |#1|))
   "\\spad{mapDown!(t,{}p,{}f)} returns \\spad{t} after traversing \\spad{t} in \"preorder\" (node then left then right) fashion replacing the successive interior nodes as follows. Let \\spad{l} and \\spad{r} denote the left and right subtrees of \\spad{t}. The root value \\spad{x} of \\spad{t} is replaced by \\spad{p}. Then \\spad{f}(value \\spad{l},{} value \\spad{r},{} \\spad{p}),{} where \\spad{l} and \\spad{r} denote the left and right subtrees of \\spad{t},{} is evaluated producing two values \\spad{pl} and \\spad{pr}. Then \\spad{mapDown!(l,{} pl,{} f)} and \\spad{mapDown!(l,{} pr,{} f)} are evaluated.")
  (($ $ |#1| (|Mapping| |#1| |#1| |#1|))
   "\\spad{mapDown!(t,{}p,{}f)} returns \\spad{t} after traversing \\spad{t} in \"preorder\" (node then left then right) fashion replacing the successive interior nodes as follows. The root value \\spad{x} is replaced by \\spad{q} \\spad{:=} \\spad{f}(\\spad{p},{} \\spad{x}). The mapDown!(\\spad{l},{} \\spad{q},{} \\spad{f}) and mapDown!(\\spad{r},{} \\spad{q},{} \\spad{f}) are evaluated for the left and right subtrees \\spad{l} and \\spad{r} of \\spad{t}."))
 (|mapUp!|
  (($ $ $ (|Mapping| |#1| |#1| |#1| |#1| |#1|))
   "\\spad{mapUp!(t,{}t1,{}f)} traverses \\spad{t} in an \"endorder\" (left then right then node) fashion returning \\spad{t} with the value at each successive interior node of \\spad{t} replaced by \\spad{f}(\\spad{l},{} \\spad{r},{} \\spad{l1},{} \\spad{r1}) where \\spad{l} and \\spad{r} are the values at the immediate left and right nodes. Values \\spad{l1} and \\spad{r1} are values at the corresponding nodes of a balanced binary tree \\spad{t1},{} of identical shape at \\spad{t}.")
  ((|#1| $ (|Mapping| |#1| |#1| |#1|))
   "\\spad{mapUp!(t,{}f)} traverses balanced binary tree \\spad{t} in an \"endorder\" (left then right then node) fashion returning \\spad{t} with the value at each successive interior node of \\spad{t} replaced by \\spad{f}(\\spad{l},{} \\spad{r}) where \\spad{l} and \\spad{r} are the values at the immediate left and right nodes."))
 (|setleaves!|
  (($ $ (|List| |#1|))
   "\\spad{setleaves!(t,{} ls)} sets the leaves of \\spad{t} in left-to-right order to the elements of \\spad{ls}."))
 (|balancedBinaryTree|
  (($ (|NonNegativeInteger|) |#1|)
   "\\spad{balancedBinaryTree(n,{} s)} creates a balanced binary tree with \\spad{n} nodes each with value \\spad{s}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|BoundedDistributiveLattice|) 
((|constructor|
  (NIL
   "not every lattice is distributive so treat this \\indented{13}{as a separate case} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))) 
NIL 
(|BezoutMatrix| R UP M |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{BezoutMatrix} contains functions for computing resultants and discriminants using Bezout matrices,{} and functions related with Sylvester matrix and subresultant."))
 (|bezoutDiscriminant|
  ((|#1| |#2|)
   "\\spad{bezoutDiscriminant(p)} computes the discriminant of a polynomial \\spad{p} by computing the determinant of a Bezout matrix."))
 (|bezoutResultant|
  ((|#1| |#2| |#2|)
   "\\spad{bezoutResultant(p,{} q)} computes the resultant of the two polynomials \\spad{p} and \\spad{q} by computing the determinant of a Bezout matrix."))
 (|subresultants|
  (((|IndexedVector| |#2| (|Zero|)) |#2| |#2|)
   "\\spad{subresultants(p,{} q)} returns a vector of subresultants of \\spad{p} and \\spad{q},{} in ascending order,{} starting with index 0."))
 (|bezoutMatrix|
  ((|#3| |#2| |#2|)
   "\\spad{bezoutMatrix(p,{} q)} returns the Bezout matrix for the two polynomials \\spad{p} and \\spad{q}."))
 (|subSylvesterMatrix|
  ((|#3| |#3| (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{subSylvesterMatrix(S,{} j,{} i)} returns sub-Sylvester matrix jSi.")
  ((|#3| |#3| (|NonNegativeInteger|))
   "\\spad{subSylvesterMatrix(S,{} j)} returns the \\spad{j}th sub-Sylvester matrix \\spad{jS}."))
 (|sylvesterMatrix|
  ((|#3| |#2| |#2|)
   "\\spad{sylvesterMatrix(p,{} q)} returns the Sylvester matrix for the two nonzero polynomials \\spad{p} and \\spad{q}."))) 
((|HasCategory| |#1| '(|CommutativeRing|))) 
(|BezoutMatrixWrapper| R UP) 
((|constructor|
  (NIL
   "This is a wrapper package for BezoutMatrix,{} to avoid manually filling up type arguments."))) 
((|HasCategory| |#1| '(|CommutativeRing|))) 
(|BagAggregate&| A S) 
((|constructor|
  (NIL
   "A bag aggregate is an aggregate for which one can insert and extract objects,{} and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks,{} queues,{} and dequeues."))
 (|inspect|
  ((|#2| $) "\\spad{inspect(u)} returns an (random) element from a bag."))
 (|insert!|
  (($ |#2| $)
   "\\spad{insert!(x,{} u)} inserts item \\spad{x} into bag \\spad{u}."))
 (|extract!|
  ((|#2| $)
   "\\spad{extract!(u)} destructively removes a (random) item from bag \\spad{u}."))) 
NIL 
(|BagAggregate| S) 
((|constructor|
  (NIL
   "A bag aggregate is an aggregate for which one can insert and extract objects,{} and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks,{} queues,{} and dequeues."))
 (|inspect|
  ((|#1| $) "\\spad{inspect(u)} returns an (random) element from a bag."))
 (|insert!|
  (($ |#1| $)
   "\\spad{insert!(x,{} u)} inserts item \\spad{x} into bag \\spad{u}."))
 (|extract!|
  ((|#1| $)
   "\\spad{extract!(u)} destructively removes a (random) item from bag \\spad{u}."))) 
NIL 
(|Bialgebra| R |MxM|) 
((|constructor|
  (NIL
   "A bialgebra is a coalgebra which at the same time is an algebra such that the comultiplication is also an algebra homomorphism. MxM: Module(\\spad{R}) should be replaced by a more restricted category,{} but it is not clear at this point which one."))) 
NIL 
(|BiCPO| S) 
((|constructor|
  (NIL
   "Complete partial Order,{} partial order that is guaranteed to have both a join and a meet of any two elements. For more documentation see: \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))) 
NIL 
(|BinaryExpansion|) 
((|constructor|
  (NIL
   "This domain allows rational numbers to be presented as repeating binary expansions."))
 (|binary|
  (($ (|Fraction| (|Integer|)))
   "\\spad{binary(r)} converts a rational number to a binary expansion."))
 (|fractionPart|
  (((|Fraction| (|Integer|)) $)
   "\\spad{fractionPart(b)} returns the fractional part of a binary expansion."))
 (|coerce|
  (((|RadixExpansion| 2) $)
   "\\spad{coerce(b)} converts a binary expansion to a radix expansion with base 2.")
  (((|Fraction| (|Integer|)) $)
   "\\spad{coerce(b)} converts a binary expansion to a rational number."))) 
((|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|RealConstant|))
 (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|StepThrough|))
 (|HasCategory| (|Integer|) (LIST '|InnerEvalable| '(|Symbol|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Eltable| '(|Integer|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|DifferentialRing|))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegerNumberSystem|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|Integer|) '(|CharacteristicNonZero|)))) 
(|Bits|) 
((|constructor|
  (NIL "\\spadtype{Bits} provides logical functions for Indexed Bits."))
 (|bits|
  (($ (|NonNegativeInteger|) (|Boolean|))
   "\\spad{bits(n,{} b)} creates bits with \\spad{n} values of \\spad{b}"))) 
((AND (|HasCategory| (|Boolean|) (LIST '|Evalable| '(|Boolean|)))
      (|HasCategory| (|Boolean|) '(|SetCategory|)))
 (|HasCategory| (|Boolean|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Boolean|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Boolean|) '(|BasicType|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Boolean|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Boolean|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Boolean|) '(|OrderedSet|)))) 
(|BitStreamFrame|) 
((|constructor|
  (NIL
   "An example of a frame taken from Vickers section 3.7 Date Created: Aug 2015"))
 (|starts|
  (($ (|String|))
   "construct bit stream by parsing string containing 0,{} 1 and *")
  (($ (|List| (|Boolean|))) "construct bit stream"))) 
NIL 
(|BoundedJoinSemilattice|) 
((|constructor|
  (NIL
   "join semilattice with bottom \\indented{2}{Different from exterior Grassmann product operator as} \\indented{2}{that anticommutes.} \\indented{2}{need to check precedence when used as an infix operator} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (|_\|_| (($) "bottom (\\spad{false} in logic)."))) 
NIL 
(|BoundedLattice|) 
((|constructor|
  (NIL
   "lattice with top and bottom \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))) 
NIL 
(|BoundedMeetSemilattice|) 
((|constructor|
  (NIL
   "meet semilattice with top \\indented{2}{Implementations in set,{} logic and orders} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (T$ (($) "Top (\\spad{true} in logic)."))) 
NIL 
(|BiModule| R S) 
((|constructor|
  (NIL
   "A \\spadtype{BiModule} is both a left and right module with respect to potentially different rings. \\blankline"))) 
NIL 
(|Boolean|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{Boolean} is the elementary logic with 2 values:} \\spad{true} and \\spad{false}"))
 (|test|
  (((|Boolean|) $)
   "\\spad{test(b)} returns \\spad{b} and is provided for compatibility with the new compiler."))
 (|implies|
  (($ $ $)
   "\\spad{implies(a,{} b)} returns the logical implication of Boolean \\spad{a} and \\spad{b}."))
 (|nor|
  (($ $ $)
   "\\spad{nor(a,{} b)} returns the logical negation of \\spad{a} or \\spad{b}."))
 (|nand|
  (($ $ $)
   "\\spad{nand(a,{} b)} returns the logical negation of \\spad{a} and \\spad{b}."))
 (|xor|
  (($ $ $)
   "\\spad{xor(a,{} b)} returns the logical exclusive {\\em or} of Boolean \\spad{a} and \\spad{b}."))
 (|or|
  (($ $ $)
   "\\spad{a or b} returns the logical inclusive {\\em or} of Boolean \\spad{a} and \\spad{b}."))
 (|and|
  (($ $ $)
   "\\spad{a and b} returns the logical {\\em and} of Boolean \\spad{a} and \\spad{b}."))
 (|not| (($ $) "\\spad{not n} returns the negation of \\spad{n}."))) 
NIL 
(|BasicOperator|) 
((|constructor|
  (NIL
   "A basic operator is an object that can be applied to a list of arguments from a set,{} the result being a kernel over that set."))
 (|setProperties|
  (($ $ (|AssociationList| (|Symbol|) (|None|)))
   "\\spad{setProperties(op,{} l)} sets the property list of \\spad{op} to \\spad{l}. Argument \\spad{op} is modified \"in place\",{} \\spadignore{i.e.} no copy is made."))
 (|setProperty|
  (($ $ (|Symbol|) (|None|))
   "\\spad{setProperty(op,{} s,{} v)} attaches property \\spad{s} to \\spad{op},{} and sets its value to \\spad{v}. Argument \\spad{op} is modified \"in place\",{} \\spadignore{i.e.} no copy is made."))
 (|property|
  (((|Union| (|None|) "failed") $ (|Symbol|))
   "\\spad{property(op,{} s)} returns the value of property \\spad{s} if it is attached to \\spad{op},{} and \"failed\" otherwise."))
 (|deleteProperty!|
  (($ $ (|Symbol|))
   "\\spad{deleteProperty!(op,{} s)} unattaches property \\spad{s} from \\spad{op}. Argument \\spad{op} is modified \"in place\",{} \\spadignore{i.e.} no copy is made."))
 (|assert|
  (($ $ (|Symbol|))
   "\\spad{assert(op,{} s)} attaches property \\spad{s} to \\spad{op}. Argument \\spad{op} is modified \"in place\",{} \\spadignore{i.e.} no copy is made."))
 (|has?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{has?(op,{} s)} tests if property \\spad{s} is attached to \\spad{op}."))
 (|is?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{is?(op,{} s)} tests if the name of \\spad{op} is \\spad{s}."))
 (|input|
  (((|Union| (|Mapping| (|InputForm|) (|List| (|InputForm|))) "failed") $)
   "\\spad{input(op)} returns the \"\\%input\" property of \\spad{op} if it has one attached,{} \"failed\" otherwise.")
  (($ $ (|Mapping| (|InputForm|) (|List| (|InputForm|))))
   "\\spad{input(op,{} foo)} attaches foo as the \"\\%input\" property of \\spad{op}. If \\spad{op} has a \"\\%input\" property \\spad{f},{} then \\spad{op(a1,{}...,{}an)} gets converted to InputForm as \\spad{f(a1,{} ...,{} an)}."))
 (|display|
  (($ $ (|Mapping| (|OutputForm|) (|OutputForm|)))
   "\\spad{display(op,{} foo)} attaches foo as the \"\\%display\" property of \\spad{op}. If \\spad{op} has a \"\\%display\" property \\spad{f},{} then \\spad{op(a)} gets converted to OutputForm as \\spad{f(a)}. Argument \\spad{op} must be unary.")
  (($ $ (|Mapping| (|OutputForm|) (|List| (|OutputForm|))))
   "\\spad{display(op,{} foo)} attaches foo as the \"\\%display\" property of \\spad{op}. If \\spad{op} has a \"\\%display\" property \\spad{f},{} then \\spad{op(a1,{}...,{}an)} gets converted to OutputForm as \\spad{f(a1,{} ...,{} an)}.")
  (((|Union| (|Mapping| (|OutputForm|) (|List| (|OutputForm|))) "failed") $)
   "\\spad{display(op)} returns the \"\\%display\" property of \\spad{op} if it has one attached,{} and \"failed\" otherwise."))
 (|comparison|
  (($ $ (|Mapping| (|Boolean|) $ $))
   "\\spad{comparison(op,{} foo?)} attaches foo? as the \"\\%less?\" property to \\spad{op}. If \\spad{op1} and \\spad{op2} have the same name,{} and one of them has a \"\\%less?\" property \\spad{f},{} then \\spad{f(op1,{} op2)} is called to decide whether \\spad{op1 < op2}."))
 (|equality|
  (($ $ (|Mapping| (|Boolean|) $ $))
   "\\spad{equality(op,{} foo?)} attaches foo? as the \"\\%equal?\" property to \\spad{op}. If \\spad{op1} and \\spad{op2} have the same name,{} and one of them has an \"\\%equal?\" property \\spad{f},{} then \\spad{f(op1,{} op2)} is called to decide whether \\spad{op1} and \\spad{op2} should be considered equal."))
 (|weight|
  (($ $ (|NonNegativeInteger|))
   "\\spad{weight(op,{} n)} attaches the weight \\spad{n} to \\spad{op}.")
  (((|NonNegativeInteger|) $)
   "\\spad{weight(op)} returns the weight attached to \\spad{op}."))
 (|nary?|
  (((|Boolean|) $)
   "\\spad{nary?(op)} tests if \\spad{op} has arbitrary arity."))
 (|unary?|
  (((|Boolean|) $) "\\spad{unary?(op)} tests if \\spad{op} is unary."))
 (|nullary?|
  (((|Boolean|) $) "\\spad{nullary?(op)} tests if \\spad{op} is nullary."))
 (|arity|
  (((|Union| (|NonNegativeInteger|) "failed") $)
   "\\spad{arity(op)} returns \\spad{n} if \\spad{op} is \\spad{n}-ary,{} and \"failed\" if \\spad{op} has arbitrary arity."))
 (|operator|
  (($ (|Symbol|) (|NonNegativeInteger|))
   "\\spad{operator(f,{} n)} makes \\spad{f} into an \\spad{n}-ary operator.")
  (($ (|Symbol|))
   "\\spad{operator(f)} makes \\spad{f} into an operator with arbitrary arity."))
 (|copy| (($ $) "\\spad{copy(op)} returns a copy of \\spad{op}."))
 (|properties|
  (((|AssociationList| (|Symbol|) (|None|)) $)
   "\\spad{properties(op)} returns the list of all the properties currently attached to \\spad{op}."))
 (|name| (((|Symbol|) $) "\\spad{name(op)} returns the name of \\spad{op}."))) 
NIL 
(|BasicOperatorFunctions1| A) 
((|constructor|
  (NIL
   "This package exports functions to set some commonly used properties of operators,{} including properties which contain functions."))
 (|constantOpIfCan|
  (((|Union| |#1| "failed") (|BasicOperator|))
   "\\spad{constantOpIfCan(op)} returns \\spad{a} if \\spad{op} is the constant nullary operator always returning \\spad{a},{} \"failed\" otherwise."))
 (|constantOperator|
  (((|BasicOperator|) |#1|)
   "\\spad{constantOperator(a)} returns a nullary operator op such that \\spad{op()} always evaluate to \\spad{a}."))
 (|derivative|
  (((|Union| (|List| (|Mapping| |#1| (|List| |#1|))) "failed")
    (|BasicOperator|))
   "\\spad{derivative(op)} returns the value of the \"\\%diff\" property of \\spad{op} if it has one,{} and \"failed\" otherwise.")
  (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| |#1|))
   "\\spad{derivative(op,{} foo)} attaches foo as the \"\\%diff\" property of \\spad{op}. If \\spad{op} has an \"\\%diff\" property \\spad{f},{} then applying a derivation \\spad{D} to \\spad{op}(a) returns \\spad{f(a) * D(a)}. Argument \\spad{op} must be unary.")
  (((|BasicOperator|) (|BasicOperator|)
    (|List| (|Mapping| |#1| (|List| |#1|))))
   "\\spad{derivative(op,{} [foo1,{} ...,{} foon])} attaches [\\spad{foo1},{} ...,{} foon] as the \"\\%diff\" property of \\spad{op}. If \\spad{op} has an \"\\%diff\" property \\spad{[f1,{} ...,{} fn]} then applying a derivation \\spad{D} to \\spad{op(a1,{} ...,{} an)} returns \\spad{f1(a1,{} ...,{} an) * D(a1) + ... + fn(a1,{} ...,{} an) * D(an)}."))
 (|evaluate|
  (((|Union| (|Mapping| |#1| (|List| |#1|)) "failed") (|BasicOperator|))
   "\\spad{evaluate(op)} returns the value of the \"\\%eval\" property of \\spad{op} if it has one,{} and \"failed\" otherwise.")
  (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| |#1|))
   "\\spad{evaluate(op,{} foo)} attaches foo as the \"\\%eval\" property of \\spad{op}. If \\spad{op} has an \"\\%eval\" property \\spad{f},{} then applying \\spad{op} to a returns the result of \\spad{f(a)}. Argument \\spad{op} must be unary.")
  (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| (|List| |#1|)))
   "\\spad{evaluate(op,{} foo)} attaches foo as the \"\\%eval\" property of \\spad{op}. If \\spad{op} has an \"\\%eval\" property \\spad{f},{} then applying \\spad{op} to \\spad{(a1,{} ...,{} an)} returns the result of \\spad{f(a1,{} ...,{} an)}.")
  (((|Union| |#1| "failed") (|BasicOperator|) (|List| |#1|))
   "\\spad{evaluate(op,{} [a1,{}...,{}an])} checks if \\spad{op} has an \"\\%eval\" property \\spad{f}. If it has,{} then \\spad{f(a1,{} ...,{} an)} is returned,{} and \"failed\" otherwise."))) 
NIL 
(|BoundIntegerRoots| F UP) 
((|constructor|
  (NIL
   "\\spadtype{BoundIntegerRoots} provides functions to find lower bounds on the integer roots of a polynomial."))
 (|integerBound|
  (((|Integer|) |#2|)
   "\\spad{integerBound(p)} returns a lower bound on the negative integer roots of \\spad{p},{} and 0 if \\spad{p} has no negative integer roots."))) 
NIL 
(|BalancedPAdicInteger| |p|) 
((|constructor|
  (NIL
   "Stream-based implementation of \\spad{Zp:} \\spad{p}-adic numbers are represented as sum(\\spad{i} = 0..,{} a[\\spad{i}] * p^i),{} where the a[\\spad{i}] lie in -(\\spad{p} - 1)\\spad{/2},{} ...,{} (\\spad{p} - 1)\\spad{/2}."))) 
NIL 
(|BalancedPAdicRational| |p|) 
((|constructor|
  (NIL
   "Stream-based implementation of \\spad{Qp:} numbers are represented as sum(\\spad{i} = \\spad{k}..,{} a[\\spad{i}] * p^i),{} where the a[\\spad{i}] lie in -(\\spad{p} - 1)\\spad{/2},{} ...,{} (\\spad{p} - 1)\\spad{/2}."))) 
((|HasCategory| (|BalancedPAdicInteger| |#1|)
                '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|CharacteristicNonZero|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|RealConstant|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedSet|))
 (OR (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedSet|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|StepThrough|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|InnerEvalable| '(|Symbol|)
                      (LIST '|BalancedPAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|Evalable|
                      (LIST '|BalancedPAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|Eltable|
                      (LIST '|BalancedPAdicInteger| (|devaluate| |#1|))
                      (LIST '|BalancedPAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|DifferentialRing|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|)
                (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|EuclideanDomain|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|IntegerNumberSystem|))
 (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|Comparable|))
 (OR (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|Comparable|))
     (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|BalancedPAdicInteger| |#1|)
                     '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|BalancedPAdicInteger| |#1|)
                      '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|BalancedPAdicInteger| |#1|) '(|CharacteristicNonZero|)))) 
(|BinaryRecursiveAggregate&| A S) 
((|constructor|
  (NIL
   "A binary-recursive aggregate has 0,{} 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure"))
 (|setright!|
  (($ $ $)
   "\\spad{setright!(a,{} b)} sets the right child of \\spad{a} to be \\spad{b}."))
 (|setleft!|
  (($ $ $)
   "\\spad{setleft!(a,{} b)} sets the left child of \\spad{a} to be \\spad{b}."))
 (|setelt!|
  (($ $ "right" $)
   "\\spad{setelt!(a,{} \"right\",{} b)} (also written \\spad{a.right := b}) is equivalent to \\spad{setright!(a,{} b)}.")
  (($ $ "left" $)
   "\\spad{setelt!(a,{} \"left\",{} b)} (also written \\spad{a.left := b}) is equivalent to \\spad{setleft!(a,{} b)}."))
 (|right| (($ $) "\\spad{right(a)} returns the right child."))
 (|elt|
  (($ $ "right")
   "\\spad{elt(a,{} \"right\")} (also written: \\spad{a.right}) is equivalent to \\spad{right(a)}.")
  (($ $ "left")
   "\\spad{elt(a,{} \"left\")} (also written: \\spad{a.left}) is equivalent to \\spad{left(a)}."))
 (|left| (($ $) "\\spad{left(a)} returns the left child."))) 
((|HasCategory| |#1| '(|shallowlyMutable|))) 
(|BinaryRecursiveAggregate| S) 
((|constructor|
  (NIL
   "A binary-recursive aggregate has 0,{} 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure"))
 (|setright!|
  (($ $ $)
   "\\spad{setright!(a,{} b)} sets the right child of \\spad{a} to be \\spad{b}."))
 (|setleft!|
  (($ $ $)
   "\\spad{setleft!(a,{} b)} sets the left child of \\spad{a} to be \\spad{b}."))
 (|setelt!|
  (($ $ "right" $)
   "\\spad{setelt!(a,{} \"right\",{} b)} (also written \\spad{a.right := b}) is equivalent to \\spad{setright!(a,{} b)}.")
  (($ $ "left" $)
   "\\spad{setelt!(a,{} \"left\",{} b)} (also written \\spad{a.left := b}) is equivalent to \\spad{setleft!(a,{} b)}."))
 (|right| (($ $) "\\spad{right(a)} returns the right child."))
 (|elt|
  (($ $ "right")
   "\\spad{elt(a,{} \"right\")} (also written: \\spad{a.right}) is equivalent to \\spad{right(a)}.")
  (($ $ "left")
   "\\spad{elt(a,{} \"left\")} (also written: \\spad{a.left}) is equivalent to \\spad{left(a)}."))
 (|left| (($ $) "\\spad{left(a)} returns the left child."))) 
NIL 
(|BrillhartTests| UP) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Frederic Lehobey,{} James \\spad{H}. Davenport} Date Created: 28 June 1994 Basic Operations: brillhartIrreducible? Related Domains: Also See: AMS Classifications: Keywords: factorization Examples: References: [1] John Brillhart,{} Note on Irreducibility Testing,{} Mathematics of Computation,{} vol. 35,{} num. 35,{} Oct. 1980,{} 1379-1381 [2] James Davenport,{} On Brillhart Irreducibility. To appear. [3] John Brillhart,{} On the Euler and Bernoulli polynomials,{} \\spad{J}. Reine Angew. Math.,{} \\spad{v}. 234,{} (1969),{} \\spad{pp}. 45-64"))
 (|noLinearFactor?|
  (((|Boolean|) |#1|)
   "\\spad{noLinearFactor?(p)} returns \\spad{true} if \\spad{p} can be shown to have no linear factor by a theorem of Lehmer,{} \\spad{false} else. \\spad{I} insist on the fact that \\spad{false} does not mean that \\spad{p} has a linear factor."))
 (|brillhartTrials|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{brillhartTrials(n)} sets to \\spad{n} the number of tests in \\spadfun{brillhartIrreducible?} and returns the previous value.")
  (((|NonNegativeInteger|))
   "\\spad{brillhartTrials()} returns the number of tests in \\spadfun{brillhartIrreducible?}."))
 (|brillhartIrreducible?|
  (((|Boolean|) |#1| (|Boolean|))
   "\\spad{brillhartIrreducible?(p,{} noLinears)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by a remark of Brillhart,{} \\spad{false} else. If noLinears is \\spad{true},{} we are being told \\spad{p} has no linear factors \\spad{false} does not mean that \\spad{p} is reducible.")
  (((|Boolean|) |#1|)
   "\\spad{brillhartIrreducible?(p)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by a remark of Brillhart,{} \\spad{false} is inconclusive."))) 
NIL 
(|BinarySearchTree| S) 
((|constructor|
  (NIL
   "BinarySearchTree(\\spad{S}) is the domain of binary trees where elements are ordered across the tree. A binary search tree is either empty or has a value which is an \\spad{S},{} and a left and a right which are both BinarySearchTree(\\spad{S})."))
 (|split|
  (((|Record| (|:| |less| $) (|:| |greater| $)) |#1| $)
   "\\spad{split(x,{} b)} splits binary search tree \\spad{b} into two trees,{} one with elements less than \\spad{x},{} the other with elements greater than or equal to \\spad{x}."))
 (|insertRoot!|
  (($ |#1| $)
   "\\spad{insertRoot!(x,{} b)} inserts element \\spad{x} as the root of binary search tree \\spad{b}."))
 (|insert!|
  (($ |#1| $)
   "\\spad{insert!(x,{} b)} inserts element \\spad{x} as a leave into binary search tree \\spad{b}."))
 (|binarySearchTree|
  (($ (|List| |#1|))
   "\\spad{binarySearchTree(l)} constructs a binary search tree with elements from list \\spad{l}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|BitAggregate&| S) 
((|constructor|
  (NIL
   "The bit aggregate category models aggregates representing large quantities of Boolean data."))
 (|xor|
  (($ $ $)
   "\\spad{xor(a,{} b)} returns the logical {\\em exclusive-or} of bit aggregates \\spad{a} and \\spad{b}."))
 (|or|
  (($ $ $)
   "\\spad{a or b} returns the logical {\\em or} of bit aggregates \\spad{a} and \\spad{b}."))
 (|and|
  (($ $ $)
   "\\spad{a and b} returns the logical {\\em and} of bit aggregates \\spad{a} and \\spad{b}."))
 (|nor|
  (($ $ $)
   "\\spad{nor(a,{} b)} returns the logical {\\em nor} of bit aggregates \\spad{a} and \\spad{b}."))
 (|nand|
  (($ $ $)
   "\\spad{nand(a,{} b)} returns the logical {\\em nand} of bit aggregates \\spad{a} and \\spad{b}."))
 (|not|
  (($ $)
   "\\spad{not(b)} returns the logical {\\em not} of bit aggregate \\spad{b}."))) 
NIL 
(|BitAggregate|) 
((|constructor|
  (NIL
   "The bit aggregate category models aggregates representing large quantities of Boolean data."))
 (|xor|
  (($ $ $)
   "\\spad{xor(a,{} b)} returns the logical {\\em exclusive-or} of bit aggregates \\spad{a} and \\spad{b}."))
 (|or|
  (($ $ $)
   "\\spad{a or b} returns the logical {\\em or} of bit aggregates \\spad{a} and \\spad{b}."))
 (|and|
  (($ $ $)
   "\\spad{a and b} returns the logical {\\em and} of bit aggregates \\spad{a} and \\spad{b}."))
 (|nor|
  (($ $ $)
   "\\spad{nor(a,{} b)} returns the logical {\\em nor} of bit aggregates \\spad{a} and \\spad{b}."))
 (|nand|
  (($ $ $)
   "\\spad{nand(a,{} b)} returns the logical {\\em nand} of bit aggregates \\spad{a} and \\spad{b}."))
 (|not|
  (($ $)
   "\\spad{not(b)} returns the logical {\\em not} of bit aggregate \\spad{b}."))) 
NIL 
(|BinaryTreeCategory&| A S) 
((|constructor|
  (NIL
   "\\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or has a \\spadfun{node} consisting of a value and a \\spadfun{left} and \\spadfun{right} which are both binary trees."))
 (|node|
  (($ $ |#2| $)
   "\\spad{node(l,{} v,{} r)} creates a binary tree with value \\spad{v},{} left subtree \\spad{l},{} and right subtree \\spad{r}."))) 
NIL 
(|BinaryTreeCategory| S) 
((|constructor|
  (NIL
   "\\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or has a \\spadfun{node} consisting of a value and a \\spadfun{left} and \\spadfun{right} which are both binary trees."))
 (|node|
  (($ $ |#1| $)
   "\\spad{node(l,{} v,{} r)} creates a binary tree with value \\spad{v},{} left subtree \\spad{l},{} and right subtree \\spad{r}."))) 
NIL 
(|BinaryTournament| S) 
((|constructor|
  (NIL
   "\\spadtype{BinaryTournament(S)} is the domain of binary trees where elements are ordered down the tree. A binary tournament is either empty or is a node containing a \\spadfun{value} of type \\spad{S},{} and a \\spadfun{left} and a \\spadfun{right} which are both \\spadtype{BinaryTree(S)}"))
 (|insert!|
  (($ |#1| $)
   "\\spad{insert!(x,{} b)} inserts element \\spad{x} as a leave into binary tournament \\spad{b}."))
 (|binaryTournament|
  (($ (|List| |#1|))
   "\\spad{binaryTournament(ls)} creates a binary tournament with the elements of \\spad{ls} as values of the nodes."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|BinaryTree| S) 
((|constructor|
  (NIL
   "\\spadtype{BinaryTree(S)} is the domain of all binary trees. A binary tree over \\spad{S} is either empty or has a \\spadfun{value} which is an \\spad{S} and a \\spadfun{right} and \\spadfun{left} which are both BinaryTree(\\spad{S})."))
 (|binaryTree|
  (($ $ |#1| $)
   "\\spad{binaryTree(l,{} v,{} r)} creates a binary tree with value \\spad{v} and left subtree \\spad{l} and right subtree \\spad{r}.")
  (($ |#1|)
   "\\spad{binaryTree(v)} is an non-empty binary tree with value \\spad{v},{} and left and right empty."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|CancellationAbelianMonoid|) 
((|constructor|
  (NIL
   "This is an \\spadtype{AbelianMonoid} with the cancellation property,{} \\spadignore{i.e.} \\spad{ a+b = a+c => b=c }. This is formalised by the partial subtraction operator,{} which satisfies the axioms listed below: \\blankline"))
 (|subtractIfCan|
  (((|Union| $ "failed") $ $)
   "\\spad{subtractIfCan(x,{} y)} returns an element \\spad{z} such that \\spad{z+y=x} or \"failed\" if no such element exists."))) 
NIL 
(|CachableSet|) 
((|constructor|
  (NIL
   "A cachable set is a set whose elements keep an integer as part of their structure."))
 (|setPosition|
  (((|Void|) $ (|NonNegativeInteger|))
   "\\spad{setPosition(x,{} n)} associates the integer \\spad{n} to \\spad{x}."))
 (|position|
  (((|NonNegativeInteger|) $)
   "\\spad{position(x)} returns the integer \\spad{n} associated to \\spad{x}."))) 
NIL 
(|CylindricalAlgebraicDecompositionPackage| |TheField|) 
((|specialise|
  (((|List| (|SparseUnivariatePolynomial| |#1|)) (|List| (|Polynomial| |#1|))
    (|Cell| |#1|))
   "\\spad{specialise(lp,{} c)} specializes all \\spad{p} in \\spad{lp} to the sample point of \\spad{c}."))
 (|projectionSet|
  (((|List| (|Polynomial| |#1|))
    (|List| (|SparseUnivariatePolynomial| (|Polynomial| |#1|))))
   "\\spad{projectionSet(lup)} performs one projection step"))
 (|cylindricalDecomposition|
  (((|List| (|Cell| |#1|)) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)))
   "\\spad{cylindricalDecomposition(lp,{} lv)} computes cylindrical decomposition of \\spad{lp} in using variable order given by \\spad{lv}")
  (((|List| (|Cell| |#1|)) (|List| (|Polynomial| |#1|)))
   "\\spad{cylindricalDecomposition(lp)} is cylindricalDecomposition(\\spad{lp},{} \\spad{lv}) where \\spad{lv} is list of variables in \\spad{lp}."))) 
NIL 
(|CylindricalAlgebraicDecompositionUtilities| R P) 
((|gcdBasis|
  (((|List| |#2|) (|List| |#2|))
   "\\spad{gcdBasis(lp)} computes \\spad{gcd} basis of \\spad{lp}"))
 (|squareFreeBasis|
  (((|List| |#2|) (|List| |#2|))
   "\\spad{squareFreeBasis(lp)} computes \\spad{gcd} basis of square-free parts of elements of \\spad{lp}"))) 
NIL 
(|CardinalNumber|) 
((|constructor|
  (NIL
   "Members of the domain CardinalNumber are values indicating the cardinality of sets,{} both finite and infinite. Arithmetic operations are defined on cardinal numbers as follows. \\blankline If \\spad{x = \\#X} and \\spad{y = \\#Y} then \\indented{2}{\\spad{x+y\\space{2}= \\#(X+Y)}\\space{3}\\tab{30}disjoint union} \\indented{2}{\\spad{x-y\\space{2}= \\#(X-Y)}\\space{3}\\tab{30}relative complement} \\indented{2}{\\spad{x*y\\space{2}= \\#(X*Y)}\\space{3}\\tab{30}cartesian product} \\indented{2}{\\spad{x^y = \\#(X^Y)}\\space{2}\\tab{30}\\spad{X^Y = \\{g| g: Y->X\\}}} \\blankline The non-negative integers have a natural construction as cardinals \\indented{2}{\\spad{0 = \\#\\{\\}},{} \\spad{1 = \\{0\\}},{} \\spad{2 = \\{0,{} 1\\}},{} ...,{} \\spad{n = \\{i| 0 <= i < n\\}}.} \\blankline That \\spad{0} acts as a zero for the multiplication of cardinals is equivalent to the axiom of choice. \\blankline The generalized continuum hypothesis asserts \\center{\\spad{2^Aleph i = Aleph(i+1)}} and is independent of the axioms of set theory [Goedel 1940]. \\blankline Three commonly encountered cardinal numbers are \\indented{3}{\\spad{a = \\#Z}\\space{7}\\tab{30}countable infinity} \\indented{3}{\\spad{c = \\#R}\\space{7}\\tab{30}the continuum} \\indented{3}{\\spad{f = \\#\\{g| g: [0,{} 1]->R\\}}} \\blankline In this domain,{} these values are obtained using \\indented{3}{\\spad{a := Aleph 0},{} \\spad{c := 2^a},{} \\spad{f := 2^c}.} \\blankline"))
 (|generalizedContinuumHypothesisAssumed|
  (((|Boolean|) (|Boolean|))
   "\\spad{generalizedContinuumHypothesisAssumed(bool)} is used to dictate whether the hypothesis is to be assumed."))
 (|generalizedContinuumHypothesisAssumed?|
  (((|Boolean|))
   "\\spad{generalizedContinuumHypothesisAssumed?()} tests if the hypothesis is currently assumed."))
 (|countable?|
  (((|Boolean|) $)
   "\\spad{countable?(\\spad{a})} determines whether \\spad{a} is a countable cardinal,{} \\spadignore{i.e.} an integer or \\spad{Aleph 0}."))
 (|finite?|
  (((|Boolean|) $)
   "\\spad{finite?(\\spad{a})} determines whether \\spad{a} is a finite cardinal,{} \\spadignore{i.e.} an integer."))
 (|Aleph|
  (($ (|NonNegativeInteger|))
   "\\spad{Aleph(n)} provides the named (infinite) cardinal number."))
 (^
  (($ $ $)
   "\\spad{x^y} returns \\spad{\\#(X^Y)} where \\spad{X^Y} is defined \\indented{1}{as \\spad{\\{g| g: Y->X\\}}.}"))
 (-
  (((|Union| $ "failed") $ $)
   "\\spad{x - y} returns an element \\spad{z} such that \\spad{z+y=x} or \"failed\" if no such element exists."))) 
NIL 
(|CartesianTensor| |minix| |dim| R) 
((|constructor|
  (NIL
   "CartesianTensor(minix,{} dim,{} \\spad{R}) provides Cartesian tensors with components belonging to a commutative ring \\spad{R}. These tensors can have any number of indices. Each index takes values from \\spad{minix} to \\spad{minix + dim - 1}."))
 (|sample| (($) "\\spad{sample()} returns an object of type \\%."))
 (|unravel|
  (($ (|List| |#3|))
   "\\spad{unravel(t)} produces a tensor from a list of components such that \\indented{2}{\\spad{unravel(ravel(t)) = t}.}"))
 (|ravel|
  (((|List| |#3|) $)
   "\\spad{ravel(t)} produces a list of components from a tensor such that \\indented{2}{\\spad{unravel(ravel(t)) = t}.}"))
 (|leviCivitaSymbol|
  (($)
   "\\spad{leviCivitaSymbol()} is the rank \\spad{dim} tensor defined by \\spad{leviCivitaSymbol()(i1,{} ...idim) = +1/0/-1} if \\spad{i1,{} ...,{} idim} is an even/is nota /is an odd permutation of \\spad{minix,{} ...,{} minix+dim-1}."))
 (|kroneckerDelta|
  (($)
   "\\spad{kroneckerDelta()} is the rank 2 tensor defined by \\indented{3}{\\spad{kroneckerDelta()(i,{} j)}} \\indented{6}{\\spad{= 1\\space{2}if i = j}} \\indented{6}{\\spad{= 0 if\\space{2}i \\~= j}}"))
 (|reindex|
  (($ $ (|List| (|Integer|)))
   "\\spad{reindex(t,{} [i1,{} ...,{} idim])} permutes the indices of \\spad{t}. For example,{} if \\spad{r = reindex(t,{} [4,{} 1,{} 2,{} 3])} for a rank 4 tensor \\spad{t},{} then \\spad{r} is the rank for tensor given by \\indented{4}{\\spad{r(i,{} j,{} k,{} l) = t(l,{} i,{} j,{} k)}.}"))
 (|transpose|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{transpose(t,{} i,{} j)} exchanges the \\spad{i}\\spad{-}th and \\spad{j}\\spad{-}th indices of \\spad{t}. For example,{} if \\spad{r = transpose(t,{} 2,{} 3)} for a rank 4 tensor \\spad{t},{} then \\spad{r} is the rank 4 tensor given by \\indented{4}{\\spad{r(i,{} j,{} k,{} l) = t(i,{} k,{} j,{} l)}.}")
  (($ $)
   "\\spad{transpose(t)} exchanges the first and last indices of \\spad{t}. For example,{} if \\spad{r = transpose(t)} for a rank 4 tensor \\spad{t},{} then \\spad{r} is the rank 4 tensor given by \\indented{4}{\\spad{r(i,{} j,{} k,{} l) = t(l,{} j,{} k,{} i)}.}"))
 (|contract|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{contract(t,{} i,{} j)} is the contraction of tensor \\spad{t} which sums along the \\spad{i}\\spad{-}th and \\spad{j}\\spad{-}th indices. For example,{} if \\spad{r = contract(t,{} 1,{} 3)} for a rank 4 tensor \\spad{t},{} then \\spad{r} is the rank 2 \\spad{(= 4 - 2)} tensor given by \\indented{4}{\\spad{r(i,{} j) = sum(h=1..dim,{} t(h,{} i,{} h,{} j))}.}")
  (($ $ (|Integer|) $ (|Integer|))
   "\\spad{contract(t,{} i,{} s,{} j)} is the inner product of tenors \\spad{s} and \\spad{t} which sums along the \\spad{k1}\\spad{-}th index of \\spad{t} and the \\spad{k2}\\spad{-}th index of \\spad{s}. For example,{} if \\spad{r = contract(s,{} 2,{} t,{} 1)} for rank 3 tensors rank 3 tensors \\spad{s} and \\spad{t},{} then \\spad{r} is the rank 4 \\spad{(= 3 + 3 - 2)} tensor given by \\indented{4}{\\spad{r(i,{} j,{} k,{} l) = sum(h=1..dim,{} s(i,{} h,{} j)*t(h,{} k,{} l))}.}"))
 (*
  (($ $ $)
   "\\spad{s*t} is the inner product of the tensors \\spad{s} and \\spad{t} which contracts the last index of \\spad{s} with the first index of \\spad{t},{} \\spadignore{i.e.} \\indented{4}{\\spad{t*s = contract(t,{} rank t,{} s,{} 1)}} \\indented{4}{\\spad{t*s = sum(k=1..N,{} t[i1,{} ..,{} iN,{} k]*s[k,{} j1,{} ..,{} jM])}} This is compatible with the use of \\spad{M*v} to denote the matrix-vector inner product."))
 (|product|
  (($ $ $)
   "\\spad{product(s,{} t)} is the outer product of the tensors \\spad{s} and \\spad{t}. For example,{} if \\spad{r = product(s,{} t)} for rank 2 tensors \\spad{s} and \\spad{t},{} then \\spad{r} is a rank 4 tensor given by \\indented{4}{\\spad{r(i,{} j,{} k,{} l) = s(i,{} j)*t(k,{} l)}.}"))
 (|elt|
  ((|#3| $ (|List| (|Integer|)))
   "\\spad{elt(t,{} [i1,{} ...,{} iN])} gives a component of a rank \\spad{N} tensor.")
  ((|#3| $ (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{elt(t,{} i,{} j,{} k,{} l)} gives a component of a rank 4 tensor.")
  ((|#3| $ (|Integer|) (|Integer|) (|Integer|))
   "\\spad{elt(t,{} i,{} j,{} k)} gives a component of a rank 3 tensor.")
  ((|#3| $ (|Integer|) (|Integer|))
   "\\spad{elt(t,{} i,{} j)} gives a component of a rank 2 tensor.")
  ((|#3| $ (|Integer|))
   "\\spad{elt(t,{} i)} gives a component of a rank 1 tensor.")
  ((|#3| $) "\\spad{elt(t)} gives the component of a rank 0 tensor."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(t)} returns the tensorial rank of \\spad{t} (that is,{} the number of indices). This is the same as the graded module degree."))
 (|coerce|
  (($ (|List| $))
   "\\spad{coerce([t_1,{} ...,{} t_dim])} allows tensors to be constructed using lists.")
  (($ (|List| |#3|))
   "\\spad{coerce([r_1,{} ...,{} r_dim])} allows tensors to be constructed using lists.")
  (($ (|SquareMatrix| |#2| |#3|))
   "\\spad{coerce(m)} views a matrix as a rank 2 tensor.")
  (($ (|DirectProduct| |#2| |#3|))
   "\\spad{coerce(v)} views a vector as a rank 1 tensor."))) 
NIL 
(|CartesianTensorFunctions2| |minix| |dim| S T$) 
((|constructor|
  (NIL
   "This package provides functions to enable conversion of tensors given conversion of the components."))
 (|map|
  (((|CartesianTensor| |#1| |#2| |#4|) (|Mapping| |#4| |#3|)
    (|CartesianTensor| |#1| |#2| |#3|))
   "\\spad{map(f,{} ts)} does a componentwise conversion of the tensor \\spad{ts} to a tensor with components of type \\spad{T}."))
 (|reshape|
  (((|CartesianTensor| |#1| |#2| |#4|) (|List| |#4|)
    (|CartesianTensor| |#1| |#2| |#3|))
   "\\spad{reshape(lt,{} ts)} organizes the list of components \\spad{lt} into a tensor with the same shape as \\spad{ts}."))) 
NIL 
(|CharacterClass|) 
((|constructor|
  (NIL
   "This domain allows classes of characters to be defined and manipulated efficiently."))
 (|alphanumeric|
  (($)
   "\\spad{alphanumeric()} returns the class of all characters for which \\spadfunFrom{alphanumeric?}{Character} is \\spad{true}."))
 (|alphabetic|
  (($)
   "\\spad{alphabetic()} returns the class of all characters for which \\spadfunFrom{alphabetic?}{Character} is \\spad{true}."))
 (|lowerCase|
  (($)
   "\\spad{lowerCase()} returns the class of all characters for which \\spadfunFrom{lowerCase?}{Character} is \\spad{true}."))
 (|upperCase|
  (($)
   "\\spad{upperCase()} returns the class of all characters for which \\spadfunFrom{upperCase?}{Character} is \\spad{true}."))
 (|hexDigit|
  (($)
   "\\spad{hexDigit()} returns the class of all characters for which \\spadfunFrom{hexDigit?}{Character} is \\spad{true}."))
 (|digit|
  (($)
   "\\spad{digit()} returns the class of all characters for which \\spadfunFrom{digit?}{Character} is \\spad{true}."))
 (|charClass|
  (($ (|List| (|Character|)))
   "\\spad{charClass(l)} creates a character class which contains exactly the characters given in the list \\spad{l}.")
  (($ (|String|))
   "\\spad{charClass(s)} creates a character class which contains exactly the characters given in the string \\spad{s}."))) 
((|HasCategory| (|Character|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Character|) '(|Comparable|))
 (|HasCategory| (|Character|) '(|Finite|))
 (AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
      (|HasCategory| (|Character|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
       (|HasCategory| (|Character|) '(|Finite|)))
  (AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
       (|HasCategory| (|Character|) '(|SetCategory|))))
 (|HasCategory| (|Character|) '(|BasicType|))
 (|HasCategory| (|Character|) '(|OrderedSet|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|OrderedSet|)))) 
(|CommonDenominator| R Q A) 
((|constructor|
  (NIL
   "CommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain."))
 (|splitDenominator|
  (((|Record| (|:| |num| |#3|) (|:| |den| |#1|)) |#3|)
   "\\spad{splitDenominator([q1,{} ...,{} qn])} returns \\spad{[[p1,{} ...,{} pn],{} d]} such that \\spad{\\spad{qi} = pi/d} and \\spad{d} is a common denominator for the \\spad{qi}\\spad{'s}."))
 (|clearDenominator|
  ((|#3| |#3|)
   "\\spad{clearDenominator([q1,{} ...,{} qn])} returns \\spad{[p1,{} ...,{} pn]} such that \\spad{\\spad{qi} = pi/d} where \\spad{d} is a common denominator for the \\spad{qi}\\spad{'s}."))
 (|commonDenominator|
  ((|#1| |#3|)
   "\\spad{commonDenominator([q1,{} ...,{} qn])} returns a common denominator \\spad{d} for \\spad{q1},{} ...,{} \\spad{qn}."))) 
NIL 
(|ComplexDoubleFloatMatrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|))
 (OR (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (OR (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (AND
  (|HasCategory| (|Complex| (|DoubleFloat|))
                 (LIST '|Evalable| (LIST '|Complex| '(|DoubleFloat|))))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (OR
  (AND
   (|HasCategory| (|Complex| (|DoubleFloat|))
                  (LIST '|Evalable| (LIST '|Complex| '(|DoubleFloat|))))
   (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|)))
  (AND
   (|HasCategory| (|Complex| (|DoubleFloat|))
                  (LIST '|Evalable| (LIST '|Complex| '(|DoubleFloat|))))
   (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|))))
 (|HasCategory| (|Complex| (|DoubleFloat|))
                (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR
  (|HasCategory| (|Complex| (|DoubleFloat|))
                 (LIST '|CoercibleTo| '(|OutputForm|)))
  (AND
   (|HasCategory| (|Complex| (|DoubleFloat|))
                  (LIST '|Evalable| (LIST '|Complex| '(|DoubleFloat|))))
   (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|))))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|AbelianGroup|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SemiRng|))
 (AND (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Monoid|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SemiRng|)))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|EuclideanDomain|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|IntegralDomain|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|CommutativeRing|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Field|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|)))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))) 
(|ComplexDoubleFloatVector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))
 (|vector|
  (($ (|List| (|Complex| (|DoubleFloat|))))
   "\\spad{vector(l)} converts the list \\spad{l} to a vector."))
 (|qnew|
  (($ (|Integer|))
   "\\spad{qnew(n)} creates a new uninitialized vector of length \\spad{n}."))) 
((|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))
 (|HasCategory| (|Complex| (|DoubleFloat|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
 (OR (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|))
 (AND
  (|HasCategory| (|Complex| (|DoubleFloat|))
                 (LIST '|Evalable| (LIST '|Complex| '(|DoubleFloat|))))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (OR (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (OR (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))
     (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (|HasCategory| (|Complex| (|DoubleFloat|))
                (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR
  (|HasCategory| (|Complex| (|DoubleFloat|))
                 (LIST '|CoercibleTo| '(|OutputForm|)))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|AbelianSemiGroup|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|AbelianMonoid|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|AbelianGroup|))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SemiGroup|))
 (AND (|HasCategory| (|Complex| (|DoubleFloat|)) '(|AbelianMonoid|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SemiRng|)))
 (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Ring|))
 (AND (|HasCategory| (|Complex| (|DoubleFloat|)) '(|RadicalCategory|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Ring|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
  (|HasCategory| (|Complex| (|DoubleFloat|))
                 (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Complex| (|DoubleFloat|)) '(|OrderedSet|)))
  (|HasCategory| (|Complex| (|DoubleFloat|)) '(|SetCategory|)))) 
(|Cell| |TheField|) 
((|simpleCells|
  (((|List| (|SimpleCell| |#1| (|SparseUnivariatePolynomial| |#1|))) $)
   "\\spad{simpleCells(c)} returns lists of simple cells determining \\spad{c}. That is \\spad{c} = makeCell(simpleCells(\\spad{c}))"))
 (|projection|
  (((|Union| $ "failed") $)
   "\\spad{projection(c)} projects \\spad{c} with respect to main variable"))
 (|variablesOf|
  (((|List| (|Symbol|)) $)
   "\\spad{variablesOf(c)} returns list of variables of \\spad{c}"))
 (|mainVariableOf|
  (((|Symbol|) $)
   "\\spad{mainVariableOf(c)} returns main variable of \\spad{c}"))
 (|makeCell|
  (($ (|SimpleCell| |#1| (|SparseUnivariatePolynomial| |#1|)) $)
   "\\spad{makeCell(c,{} sc)} creates a cell which consists of \\spad{sc} in main variable and which has projection \\spad{c}")
  (($ (|List| (|SimpleCell| |#1| (|SparseUnivariatePolynomial| |#1|))))
   "\\spad{makeCell(lc)} creates a cell from list of simple cells \\spad{lc}"))
 (|hasDimension?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{hasDimension?(c)} returns \\spad{true} if \\spad{c} is of positive dimension. Otherwise hasDimension?(\\spad{c}) returns \\spad{false}."))
 (|dimension|
  (((|NonNegativeInteger|) $)
   "\\spad{dimension(c)} returns dimension of \\spad{c}"))
 (|samplePoint|
  (((|List| |#1|) $)
   "\\spad{samplePoint(c)} returns the sample point of \\spad{c}"))) 
NIL 
(|CubicalFacet|) 
((|constructor|
  (NIL
   "\\indented{2}{A single vertex,{} edge,{} square,{} cube...} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/} Date Created: April 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:"))
 (|allSubsets|
  (((|List| $) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{allSubsets of} a given length returned in reverse order subsets returned are not oriented")
  (((|List| $) $ (|NonNegativeInteger|))
   "\\spad{allSubsets of} a given facet returned in reverse order subsets returned are not oriented"))
 (|sameFace?|
  (((|Boolean|) $ $)
   "\\spad{true} if this is the same face although the orientation may be different."))
 (|boundary|
  (((|List| $) $)
   "construct the boundary. This is like hollowing out the facet."))
 (|product|
  (($ $ $)
   "This function returns the product of two cubical facets. Unlike the simplex case,{} the product is a single facet"))
 (|position|
  (((|Integer|) $ (|List| $))
   "return index of \\spad{e} in \\spad{lst}. Index will be negative if \\spad{e} has negative multiplier."))
 (|setMult| (($ $ (|Integer|)) "sets multiplier of face"))
 (|getIntervals|
  (((|List| (|Segment| (|Integer|))) $)
   "returns intervals in face one for each dimension"))
 (|cubicalFacet|
  (($ (|Integer|) (|CubicalFacet|)) "Copy constructor which can change mul")
  (($ (|Integer|) (|List| (|List| (|Integer|))))
   "Constructor for cubical facet")
  (($ (|Integer|) (|List| (|Segment| (|Integer|))))
   "Constructor for cubical facet intervals are always stored in low..high order orientation is calculated by the number of intervals that have to be flipped to put it in order."))) 
NIL 
(|CombinatorialFunctionCategory|) 
((|constructor| (NIL "Category for the usual combinatorial functions."))
 (|permutation|
  (($ $ $)
   "\\spad{permutation(n,{} m)} returns the number of permutations of \\spad{n} objects taken \\spad{m} at a time. Note: \\spad{permutation(n,{} m) = n!/(n-m)!}."))
 (|factorial|
  (($ $)
   "\\spad{factorial(n)} computes the factorial of \\spad{n} (denoted in the literature by \\spad{n!}) Note: \\spad{n! = n (n-1)! when n > 0}; also,{} \\spad{0! = 1}."))
 (|binomial|
  (($ $ $)
   "\\spad{binomial(n,{} r)} returns the \\spad{(n,{} r)} binomial coefficient (often denoted in the literature by \\spad{C(n,{} r)}). Note: \\spad{C(n,{} r) = n!/(r!(n-r)!)} where \\spad{n >= r >= 0}."))) 
NIL 
(|ChainComplex|) 
((|constructor|
  (NIL
   "\\indented{2}{Delta Complexes are defined by a sequence of 'face maps',{} These} \\indented{2}{can be represented by a list of matrices.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/} Date Created: March 2016 Basic Operations: Related packages: Related categories: Related Domains: CoChainComplex Also See: AMS Classifications:"))
 (|homology|
  (((|List| (|Homology|)) $) "calculate homology using SmithNormalForm"))
 (|validate|
  (((|Boolean|) $)
   "\\spad{true} if this is a valid chain complex,{} that is: 1. maps compose 2. product of adjacent maps is zero"))
 (|transition_matrices|
  (((|List| (|Matrix| (|Integer|))) $)
   "\\spad{transition_matrices(a)} gives list of transition matrices of a."))
 (|chainComplex| (($ (|List| (|Matrix| (|Integer|)))) "constructor"))) 
NIL 
(|Character|) 
((|constructor| (NIL "This domain provides the basic character data type."))
 (|alphanumeric?|
  (((|Boolean|) $)
   "\\spad{alphanumeric?(c)} tests if \\spad{c} is either a letter or number,{} \\spadignore{i.e.} one of 0..9,{} a..\\spad{z} or A..\\spad{Z}."))
 (|lowerCase?|
  (((|Boolean|) $)
   "\\spad{lowerCase?(c)} tests if \\spad{c} is an lower case letter,{} \\spadignore{i.e.} one of a..\\spad{z}."))
 (|upperCase?|
  (((|Boolean|) $)
   "\\spad{upperCase?(c)} tests if \\spad{c} is an upper case letter,{} \\spadignore{i.e.} one of A..\\spad{Z}."))
 (|alphabetic?|
  (((|Boolean|) $)
   "\\spad{alphabetic?(c)} tests if \\spad{c} is a letter,{} \\spadignore{i.e.} one of a..\\spad{z} or A..\\spad{Z}."))
 (|hexDigit?|
  (((|Boolean|) $)
   "\\spad{hexDigit?(c)} tests if \\spad{c} is a hexadecimal numeral,{} \\spadignore{i.e.} one of 0..9,{} a..\\spad{f} or A..\\spad{F}."))
 (|digit?|
  (((|Boolean|) $)
   "\\spad{digit?(c)} tests if \\spad{c} is a digit character,{} \\spadignore{i.e.} one of 0..9."))
 (|lowerCase|
  (($ $)
   "\\spad{lowerCase(c)} converts an upper case letter to the corresponding lower case letter. If \\spad{c} is not an upper case letter,{} then it is returned unchanged."))
 (|upperCase|
  (($ $)
   "\\spad{upperCase(c)} converts a lower case letter to the corresponding upper case letter. If \\spad{c} is not a lower case letter,{} then it is returned unchanged."))
 (|newline| (($) "\\spad{newline()} provides the newline character."))
 (|escape|
  (($)
   "\\spad{escape()} provides the escape character,{} \\spad{_},{} which is used to allow quotes and other characters {\\em within} strings."))
 (|quote|
  (($) "\\spad{quote()} provides the string quote character,{} \\spad{\"}."))
 (|space| (($) "\\spad{space()} provides the blank character."))
 (|char|
  (($ (|String|))
   "\\spad{char(s)} provides a character from a string \\spad{s} of length one.")
  (($ (|Integer|))
   "\\spad{char(i)} provides a character corresponding to the integer code \\spad{i}. It is always \\spad{true} that \\spad{ord char i = i}."))
 (|ord|
  (((|Integer|) $)
   "\\spad{ord(c)} provides an integral code corresponding to the character \\spad{c}. It is always \\spad{true} that \\spad{char ord c = c}."))) 
NIL 
(|CharacteristicNonZero|) 
((|constructor| (NIL "Rings of Characteristic Non Zero"))
 (|charthRoot|
  (((|Union| $ "failed") $)
   "\\spad{charthRoot(x)} returns the \\spad{p}th root of \\spad{x} where \\spad{p} is the characteristic of the ring."))) 
NIL 
(|CharacteristicPolynomialPackage| R) 
((|constructor|
  (NIL
   "This package provides a characteristicPolynomial function for any matrix over a commutative ring."))
 (|characteristicPolynomial|
  ((|#1| (|Matrix| |#1|) |#1|)
   "\\spad{characteristicPolynomial(m,{} r)} computes the characteristic polynomial of the matrix \\spad{m} evaluated at the point \\spad{r}. In particular,{} if \\spad{r} is the polynomial \\spad{'x},{} then it returns the characteristic polynomial expressed as a polynomial in \\spad{'x}."))) 
NIL 
(|CharacteristicPolynomial2| F) 
((|constructor|
  (NIL
   "This package computes characteristic polynomial \\indented{1}{using Danilewski method.}"))
 (|char_pol|
  (((|SparseUnivariatePolynomial| |#1|) (|Matrix| |#1|))
   "\\spad{char_pol(m)} computes characteristic polynomial of \\spad{m}."))
 (|danilewski|
  (((|Record| (|:| |matrix| (|Matrix| |#1|))
              (|:| |block_list| (|List| (|Integer|))))
    (|Matrix| |#1|))
   "\\spad{danilewski(m)} converts \\spad{m} to block form where each block represents transposition of multiplication by a polynomial."))) 
NIL 
(|CharacteristicPolynomial3| R) 
((|constructor|
  (NIL
   "This package computes characteristic polynomial \\indented{1}{via interpolation from values at several points.} \\indented{1}{Additionally,{} it computes determinant of matrix of} \\indented{1}{fractions by clearing common denominators of rows.} \\indented{1}{The determinant routine can be used to compute characteristic} \\indented{1}{polynomial instead of regular determinant.}"))
 (|char_pol_via_den_interpolation|
  (((|SparseUnivariatePolynomial| (|Fraction| |#1|))
    (|Matrix| (|Fraction| |#1|)))
   "\\spad{char_pol_via_den_interpolation(m)} computes characteristic polynomial of \\spad{m}."))
 (|det_via_common_denominator|
  (((|Fraction| |#1|) (|Matrix| (|Fraction| |#1|)))
   "\\spad{det_via_common_denominator(m)} computes determinant of \\spad{m}."))
 (|char_pol_via_interpolation|
  (((|SparseUnivariatePolynomial| |#1|) (|Matrix| |#1|))
   "\\spad{char_pol_via_interpolation(m)} computes characteristic polynomial of \\spad{m}."))) 
((|HasCategory| |#1| '(|GcdDomain|))) 
(|CharacteristicZero|) 
((|constructor| (NIL "Rings of Characteristic Zero."))) 
NIL 
(|ChangeOfVariable| F UP UPUP) 
((|constructor|
  (NIL "Tools to send a point to infinity on an algebraic curve."))
 (|chvar|
  (((|Record| (|:| |func| (|List| |#3|)) (|:| |poly| |#3|)
              (|:| |c1| (|Fraction| |#2|)) (|:| |c2| (|Fraction| |#2|))
              (|:| |deg| (|NonNegativeInteger|)))
    (|List| |#3|) |#3|)
   "\\spad{chvar(lf,{} p)} is like chvar(\\spad{f},{} \\spad{p}) but handles list of functions")
  (((|Record| (|:| |func| |#3|) (|:| |poly| |#3|) (|:| |c1| (|Fraction| |#2|))
              (|:| |c2| (|Fraction| |#2|)) (|:| |deg| (|NonNegativeInteger|)))
    |#3| |#3|)
   "\\spad{chvar(f(x,{} y),{} p(x,{} y))} returns \\spad{[g(z,{} t),{} q(z,{} t),{} c1(x),{} c2(x),{} n]} such that under the change of variable \\spad{z = c1(x)},{} \\spad{t = y * c2(x)},{} one gets \\spad{f(x,{} y) = c1'(x)g(c1(x),{} c2(x)y)} The algebraic relation between \\spad{x} and \\spad{y} is \\spad{p(x,{} y) = 0}. The algebraic relation between \\spad{z} and \\spad{t} is \\spad{q(z,{} t) = 0}."))
 (|eval|
  ((|#3| |#3| (|Fraction| |#2|) (|Fraction| |#2|))
   "\\spad{eval(p(x,{} y),{} f(x),{} g(x))} returns \\spad{p(f(x),{} y * g(x))}."))
 (|goodPoint|
  ((|#1| (|List| |#3|) |#3|)
   "\\spad{goodPoint([p1,{} ...,{} pn],{} q)} returns an integer a such that a is neither a pole of \\spad{\\spad{pi}(x,{} y)} for some \\spad{i} nor a branch point of \\spad{q(x,{} y) = 0}."))
 (|rootPoly|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|))
              (|:| |coef| (|Fraction| |#2|)) (|:| |radicand| |#2|))
    (|Fraction| |#2|) (|NonNegativeInteger|))
   "\\spad{rootPoly(g,{} n)} returns \\spad{[m,{} c,{} P]} such that \\spad{c * g ^ (1/n) = P ^ (1/m)} thus if \\spad{y^n = g},{} then \\spad{z^m = P} where \\spad{z = c * y}."))
 (|radPoly|
  (((|Union|
     (|Record| (|:| |radicand| (|Fraction| |#2|))
               (|:| |deg| (|NonNegativeInteger|)))
     "failed")
    |#3|)
   "\\spad{radPoly(p(x,{} y))} returns \\spad{[c(x),{} n]} if \\spad{p} is of the form \\spad{y^n - c(x)},{} \"failed\" otherwise."))
 (|mkIntegral|
  (((|Record| (|:| |coef| (|Fraction| |#2|)) (|:| |poly| |#3|)) |#3|)
   "\\spad{mkIntegral(p(x,{} y))} returns \\spad{[c(x),{} q(x,{} z)]} such that \\spad{z = c * y} is integral. The algebraic relation between \\spad{x} and \\spad{y} is \\spad{p(x,{} y) = 0}. The algebraic relation between \\spad{x} and \\spad{z} is \\spad{q(x,{} z) = 0}."))) 
NIL 
(|ComplexIntegerSolveLinearPolynomialEquation| R CR) 
((|constructor|
  (NIL
   "This package provides the generalized euclidean algorithm which is needed as the basic step for factoring polynomials."))
 (|solveLinearPolynomialEquation|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#2|)) "failed")
    (|List| (|SparseUnivariatePolynomial| |#2|))
    (|SparseUnivariatePolynomial| |#2|))
   "\\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} where (\\spad{fi} relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g} = sum \\spad{ai} prod \\spad{fj} (\\spad{j} \\spad{\\=} \\spad{i}) or equivalently g/prod \\spad{fj} = sum (ai/fi) or returns \"failed\" if no such list exists"))) 
NIL 
(|CartanKuranishi| JB D) 
((|constructor|
  (NIL
   "\\spadtype{CartanKuranishi} is a package for the completion of a given differential equation to an involutive equation. Procedures for Cartan characters and Hilbert polynomial are also provided. Based on the Cartan-Kuranishi theorem as it is used in formal theory."))
 (|complete2|
  (((|Record| (|:| |IDe| (|JetDifferentialEquation| |#1| |#2|))
              (|:| |ISys| (|List| |#2|)) (|:| |Order| (|NonNegativeInteger|))
              (|:| |NumProj| (|NonNegativeInteger|))
              (|:| |Dim| (|NonNegativeInteger|))
              (|:| |CarChar| (|List| (|NonNegativeInteger|))))
    (|JetDifferentialEquation| |#1| |#2|))
   "\\spad{complete2(de)} is like \\spadfun{complete} but returns the involutive equation \\spad{IDe},{} a basis \\spad{ISys} for the involutive system without prolongations,{} its order \\spad{Order},{} the number \\spad{NumProj} of needed projections and the Cartan characters \\spad{CarChar}."))
 (|complete|
  (((|Void|) (|JetDifferentialEquation| |#1| |#2|))
   "\\spad{complete(de)} completes \\spad{de} to an involutive equation. No result is returned; the display depends of the setting of the output flags with \\spadfun{setOutput}."))
 (|bound|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{bound(n,{} m,{} q)} computes an upper bound for the number of prolongations needed to make the symbol of an equation of order \\spad{q} with \\spad{n} independent and \\spad{m} dependent variables involutive."))
 (|gaugeHilbert|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))
    (|NonNegativeInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{gaugeHilbert(q,{} gamma)} computes the gauge correction to the Hilbert polynomial for a system of order \\spad{q} with \\spad{gamma} gauge functions."))
 (|gauge|
  (((|List| (|Integer|)) (|NonNegativeInteger|) (|Integer|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{gauge(q,{} j,{} gamma)} computes the gauge corrections to the number of arbitrary functions of differentiation order \\spad{j} for a system of order \\spad{q} with \\spad{gamma} gauge functions."))
 (|arbFunctions|
  (((|List| (|Integer|)) (|NonNegativeInteger|) (|Integer|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{arbFunctions(q,{} j,{} cc)} uses the Cartan characters \\spad{cc} to compute the number of arbitrary functions of differentiation order \\spad{j} in the general solution of a differential equation of order \\spad{q}."))
 (|alphaHilbert|
  (((|List| (|NonNegativeInteger|))
    (|SparseUnivariatePolynomial| (|Fraction| (|Integer|))))
   "\\spad{alphaHilbert(hp)} computes the Cartan characters for the Hilbert polynomial \\spad{hp}."))
 (|hilbert|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))
    (|List| (|NonNegativeInteger|)))
   "\\spad{hilbert(cc)} computes the Hilbert polynomial to the Cartan characters \\spad{cc}."))
 (|alpha|
  (((|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{alpha(q,{} beta)} computes the Cartan characters for a differential equation of order \\spad{q} and with characters \\spad{beta}."))
 (|stirling|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{stirling(i,{} k,{} q)} computes the corresponding modified Stirling number."))
 (|setRedMode|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{setRedMode(i)} sets the flag for the reduction mode. Returns old value. Current values are: \\spad{i = 0} --> No reduction of integrability conditions etc. \\spad{i = 1} --> Autoreduction of complete system and reduction \\indented{16}{of all integrability conditions.} Default is 0."))
 (|setSimpMode|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{setSimpMode(i)} sets the simplification mode used in \\spad{JetDifferentialEquation}. Returns old value."))
 (|setOutMode|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{setOutput(i)} controls amount of generated output during the completion algorithm: \\spad{i = 0} --> no display,{} \\spad{i = 1} --> result is displayed,{} \\spad{i = 2} --> Cartan characters are displayed,{} \\spad{i = 3} --> integrability conditions are traced,{} \\spad{i = 4} --> intermediate dimensions are traced,{} \\spad{i = 5} --> all intermediate systems are traced,{} \\spad{i = 6} --> all intermediate systems and symbols are traced,{} if \\spad{i > 10} then TeX output is produced. Default is 0. The old value is returned."))) 
NIL 
(|Collection&| A S) 
((|constructor|
  (NIL
   "A collection is a homogeneous aggregate which can be built from a list of members. The operation used to build the aggregate is generically named \\spadfun{construct}. However,{} each collection provides its own special function with the same name as the data type,{} except with an initial lower case letter,{} \\spadignore{e.g.} \\spadfun{list} for \\spadtype{List},{} \\spadfun{flexibleArray} for \\spadtype{FlexibleArray},{} and so on."))
 (|removeDuplicates|
  (($ $)
   "\\spad{removeDuplicates(u)} returns a copy of \\spad{u} with all duplicates removed."))
 (|select|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{select(p,{} u)} returns a copy of \\spad{u} containing only those elements such \\spad{p(x)} is \\spad{true}. Note: \\spad{select(p,{} u) = [x for x in u | p(x)]}."))
 (|remove|
  (($ |#2| $)
   "\\spad{remove(x,{} u)} returns a copy of \\spad{u} with all elements equal to \\spad{x} removed. Note: \\spad{remove(x,{} u) = [y for y in u | y ~= x]}.")
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{remove(p,{} u)} returns a copy of \\spad{u} removing all elements \\spad{x} such that \\spad{p(x)} is \\spad{true}. Note: \\spad{remove(p,{} u) = [x for x in u | not p(x)]}."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#2| |#2|) $ |#2| |#2|)
   "\\spad{reduce(f,{} u,{} x,{} z)} reduces the binary operation \\spad{f} across \\spad{u},{} stopping when an \"absorbing element\" \\spad{z} is encountered. As for \\spad{reduce(f,{} u,{} x)},{} \\spad{x} is the identity element of \\spad{f}. Same as \\spad{reduce(f,{} u,{} x)} when \\spad{u} contains no element \\spad{z}. Thus the third argument \\spad{x} is returned when \\spad{u} is empty.")
  ((|#2| (|Mapping| |#2| |#2| |#2|) $ |#2|)
   "\\spad{reduce(f,{} u,{} x)} reduces the binary operation \\spad{f} across \\spad{u},{} where \\spad{x} is the identity operation of \\spad{f}. Same as \\spad{reduce(f,{} u)} if \\spad{u} has 2 or more elements. Returns \\spad{f(y,{} x)} if \\spad{u} has one element \\spad{y}. Returns \\spad{x} if \\spad{u} is empty. For example,{} \\spad{reduce(+,{} u,{} 0)} returns the sum of the elements of \\spad{u}.")
  ((|#2| (|Mapping| |#2| |#2| |#2|) $)
   "\\spad{reduce(f,{} u)} reduces the binary operation \\spad{f} across \\spad{u}. For example,{} if \\spad{u} is \\spad{[x,{} y,{} ...,{} z]} then \\spad{reduce(f,{} u)} returns \\spad{f(..f(f(x,{} y),{} ...),{} z)}. Note: if \\spad{u} has one element \\spad{x},{} \\spad{reduce(f,{} u)} returns \\spad{x}. Error: if \\spad{u} is empty."))
 (|find|
  (((|Union| |#2| "failed") (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{find(p,{} u)} returns the first \\spad{x} in \\spad{u} such that \\spad{p(x)} is \\spad{true},{} and \"failed\" otherwise."))
 (|construct|
  (($ (|List| |#2|))
   "\\spad{construct([x,{} y,{} ...,{} z])} returns the collection of elements \\spad{x,{} y,{} ...,{} z} ordered as given. Equivalently written as \\spad{[x,{} y,{} ...,{} z]\\$D},{} where \\spad{D} is the domain. \\spad{D} may be omitted for those of type List."))) 
((|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#1| '(|finiteAggregate|))) 
(|Collection| S) 
((|constructor|
  (NIL
   "A collection is a homogeneous aggregate which can be built from a list of members. The operation used to build the aggregate is generically named \\spadfun{construct}. However,{} each collection provides its own special function with the same name as the data type,{} except with an initial lower case letter,{} \\spadignore{e.g.} \\spadfun{list} for \\spadtype{List},{} \\spadfun{flexibleArray} for \\spadtype{FlexibleArray},{} and so on."))
 (|removeDuplicates|
  (($ $)
   "\\spad{removeDuplicates(u)} returns a copy of \\spad{u} with all duplicates removed."))
 (|select|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{select(p,{} u)} returns a copy of \\spad{u} containing only those elements such \\spad{p(x)} is \\spad{true}. Note: \\spad{select(p,{} u) = [x for x in u | p(x)]}."))
 (|remove|
  (($ |#1| $)
   "\\spad{remove(x,{} u)} returns a copy of \\spad{u} with all elements equal to \\spad{x} removed. Note: \\spad{remove(x,{} u) = [y for y in u | y ~= x]}.")
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{remove(p,{} u)} returns a copy of \\spad{u} removing all elements \\spad{x} such that \\spad{p(x)} is \\spad{true}. Note: \\spad{remove(p,{} u) = [x for x in u | not p(x)]}."))
 (|reduce|
  ((|#1| (|Mapping| |#1| |#1| |#1|) $ |#1| |#1|)
   "\\spad{reduce(f,{} u,{} x,{} z)} reduces the binary operation \\spad{f} across \\spad{u},{} stopping when an \"absorbing element\" \\spad{z} is encountered. As for \\spad{reduce(f,{} u,{} x)},{} \\spad{x} is the identity element of \\spad{f}. Same as \\spad{reduce(f,{} u,{} x)} when \\spad{u} contains no element \\spad{z}. Thus the third argument \\spad{x} is returned when \\spad{u} is empty.")
  ((|#1| (|Mapping| |#1| |#1| |#1|) $ |#1|)
   "\\spad{reduce(f,{} u,{} x)} reduces the binary operation \\spad{f} across \\spad{u},{} where \\spad{x} is the identity operation of \\spad{f}. Same as \\spad{reduce(f,{} u)} if \\spad{u} has 2 or more elements. Returns \\spad{f(y,{} x)} if \\spad{u} has one element \\spad{y}. Returns \\spad{x} if \\spad{u} is empty. For example,{} \\spad{reduce(+,{} u,{} 0)} returns the sum of the elements of \\spad{u}.")
  ((|#1| (|Mapping| |#1| |#1| |#1|) $)
   "\\spad{reduce(f,{} u)} reduces the binary operation \\spad{f} across \\spad{u}. For example,{} if \\spad{u} is \\spad{[x,{} y,{} ...,{} z]} then \\spad{reduce(f,{} u)} returns \\spad{f(..f(f(x,{} y),{} ...),{} z)}. Note: if \\spad{u} has one element \\spad{x},{} \\spad{reduce(f,{} u)} returns \\spad{x}. Error: if \\spad{u} is empty."))
 (|find|
  (((|Union| |#1| "failed") (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{find(p,{} u)} returns the first \\spad{x} in \\spad{u} such that \\spad{p(x)} is \\spad{true},{} and \"failed\" otherwise."))
 (|construct|
  (($ (|List| |#1|))
   "\\spad{construct([x,{} y,{} ...,{} z])} returns the collection of elements \\spad{x,{} y,{} ...,{} z} ordered as given. Equivalently written as \\spad{[x,{} y,{} ...,{} z]\\$D},{} where \\spad{D} is the domain. \\spad{D} may be omitted for those of type List."))) 
NIL 
(|CliffordAlgebra| |n| K |bLin|) 
((|constructor|
  (NIL
   "CliffordAlgebra(\\spad{n},{} \\spad{K},{} bLin) defines a module of dimension \\spad{2^n} over \\spad{K},{} given a bilinear form bLin on \\spad{K^n}. \\blankline Examples of Clifford Algebras are: gaussians,{} quaternions,{} exterior algebras and spin algebras."))
 (|setMode|
  (((|Boolean|) (|String|) (|Boolean|))
   "allows override of parameters such as orthogonal used for debugging"))
 (|conj|
  (($ $)
   "implements Clifford conjugate for a multivector by involution and reverse of each term separately using: grade: 0 1 2 3... multi: 1 \\spad{-1} \\spad{-1} 1..."))
 (|reverse|
  (($ $)
   "implements reverse for a single term by using: grade: 0 1 2 3... multi: 1 1 \\spad{-1} \\spad{-1}..."))
 (|gradeInvolution|
  (($ $) "\\spad{x} = ((\\spad{-1})^grade(\\spad{x}))\\spad{*x}"))
 (~ (($ $) "reverse,{} complement,{} canonical dual basis"))
 (|rc| (($ $ $) "right contraction inner product"))
 (|lc| (($ $ $) "left contraction inner product"))
 (|\\/|
  (($ $ $)
   "Implement regressive inner,{} meet product operator need to check precidence when used as an infix operator"))
 (|/\\|
  (($ $ $)
   "Implement exterior grassmann product operator need to check precidence when used as an infix operator"))
 (|toTable|
  (((|Matrix| $) (|Mapping| $ $))
   "displays table of unary function such as inverse,{} reverse,{} complement,{} or dual basis could have returned type 'List List \\%' but matrix displays better")
  (((|Matrix| $) (|Mapping| $ $ $))
   "displays multiplication table for binary operation which is represented as a function with two parameters. row number represents first operand in binary order column number represents second operand in binary order could have returned type 'List List \\%' but matrix displays better"))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(x)} computes the multiplicative inverse of \\spad{x} or \"failed\" if \\spad{x} is not invertible."))
 (|coefficient|
  ((|#2| $ (|List| (|PositiveInteger|)))
   "\\spad{coefficient(x,{} [i1,{} i2,{} ...,{} iN])} extracts the coefficient of \\spad{e(i1)*e(i2)*...*e(iN)} in \\spad{x}."))
 (|monomial|
  (($ |#2| (|List| (|PositiveInteger|)))
   "\\spad{monomial(c,{} [i1,{} i2,{} ...,{} iN])} produces the value given by \\spad{c*e(i1)*e(i2)*...*e(iN)}."))
 (|grade|
  (((|NonNegativeInteger|) $)
   "return the max grade of multivector,{} for example 1 is grade 0 \\spad{e1} is grade 1 e1/\\e2 is grade 2 and so on"))
 (|ePseudoscalar| (($) "unit pseudoscalar"))
 (|eFromBinaryMap|
  (($ (|NonNegativeInteger|))
   "\\spad{eFromBinaryMap(n)} sets the appropriate Grassmann basis,{} for example: eFromBinaryMap(0) = 1 (scalar) eFromBinaryMap(1) = \\spad{e1} eFromBinaryMap(2) = \\spad{e2} eFromBinaryMap(3) = e1/\\e2"))
 (|multivector|
  (($ (|List| |#2|))
   "to allow entries like: 1+2*e1+3*e2+4*e1e2 = multivector[1,{} 2,{} 3,{} 4]"))
 (|ee| (($ (|List| (|PositiveInteger|))) "to allow entries like: ee[1,{} 2]"))
 (|e|
  (($ (|PositiveInteger|))
   "\\spad{e(n)} produces phi(e_i) where e_i is \\spad{i}-th basis vector in \\spad{K^n} and phi is canonical embedding of \\spad{K^n} into Clifford algebra."))) 
NIL 
(|ConstantLinearDependence| R F) 
((|constructor|
  (NIL
   "\\spad{ConstantLinearDependence(R,{} F)} supports solving linear systems with coefficients in \\spad{Expression(R)} over constants. The parameter \\spad{ld} to each function is a list of derivations to use. By definition element \\spad{f} from \\spad{Expression(R)} is a constant if for each \\spad{d} in \\spad{ld} we have \\spad{d(f) = 0}. We assume that inputs are normalized in such a way that field of constants is generated by constant kernels."))
 (|constant_subspace|
  (((|Record| (|:| |transform| (|Matrix| |#2|))
              (|:| |basis| (|List| (|Vector| |#2|))))
    (|List| (|Vector| |#2|)) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{constant_subspace(b,{} ld)} returns [\\spad{M},{} \\spad{nb}] such that \\spad{nb} is basis of subspace spanned by \\spad{b} over \\spad{F} consistng of vectors with constant coordinates. \\spad{M} is the transformation matrix,{} \\spadignore{i.e.} \\spad{mnb} = \\spad{M} \\spad{mb} where \\spad{mb} (\\spad{mnb} respectively) is matrix having \\spad{b} (\\spad{nb} respectively) as rows."))
 (|nullSpaceOverConstants|
  (((|List| (|Vector| |#2|)) (|Matrix| |#2|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{nullSpaceOverConstants(A,{} ld)} returns basis of the homogeneous system \\spad{A*vc = 0} where \\spad{vc} is a vector of constants."))
 (|reducedSystem|
  (((|Matrix| |#2|) (|Matrix| |#2|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{reducedSystem(A,{} ld)} returns a matrix of constants \\spad{B} such that \\spad{A x = 0} and \\spad{B x = 0} have the same solutions over constants.")
  (((|Record| (|:| |mat| (|Matrix| |#2|)) (|:| |vec| (|Vector| |#2|)))
    (|Matrix| |#2|) (|Vector| |#2|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{reducedSystem(A,{} v,{} ld)} returns matrix of constants \\spad{B} and vector of constants \\spad{w} such that \\spad{A x = v} and \\spad{B x = w} have the same solutions over constants."))
 (|solveLinearOverConstants|
  (((|Record| (|:| |particular| (|Union| (|Vector| |#2|) #1="failed"))
              (|:| |basis| (|List| (|Vector| |#2|))))
    (|Matrix| |#2|) (|Vector| |#2|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{solveLinearOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#2|) #1#))
              (|:| |basis| (|List| (|Vector| |#2|))))
    (|Vector| |#2|) |#2| (|List| (|Mapping| |#2| |#2|)))
   "\\spad{solveLinearOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}"))
 (|particularSolutionOverConstants|
  (((|Union| (|Vector| |#2|) #1#) (|Matrix| |#2|) (|Vector| |#2|)
    (|List| (|Mapping| |#2| |#2|)))
   "\\spad{solveLinearlyOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such rational numbers \\spad{ci}\\spad{'s} exist.")
  (((|Union| (|Vector| |#2|) #1#) (|Vector| |#2|) |#2|
    (|List| (|Mapping| |#2| |#2|)))
   "\\spad{particularSolutionOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such constants numbers \\spad{ci}\\spad{'s} exist."))
 (|linearDependenceOverConstants|
  (((|Union| (|Vector| |#2|) "failed") (|Vector| |#2|)
    (|List| (|Mapping| |#2| |#2|)))
   "\\spad{linearlyDependenceOverConstants([v1,{} ...,{} vn],{} ld)} returns \\spad{[c1,{} ...,{} cn]} if \\spad{c1*v1 + ... + cn*vn = 0} and not all the \\spad{ci}\\spad{'s} are 0,{} \"failed\" if the \\spad{vi}\\spad{'s} are linearly independent over constants."))
 (|linearlyDependentOverConstants?|
  (((|Boolean|) (|Vector| |#2|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{linearlyDependentOverConstants?([v1,{} ...,{} vn],{} ld)} returns \\spad{true} if the \\spad{vi}\\spad{'s} are linearly dependent over constants,{} \\spad{false} otherwise."))) 
NIL 
(|TwoDimensionalPlotClipping|) 
((|constructor|
  (NIL
   "\\indented{1}{The purpose of this package is to provide reasonable plots of} functions with singularities."))
 (|clipWithRanges|
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|List| (|List| (|Point| (|DoubleFloat|)))) (|DoubleFloat|) (|DoubleFloat|)
    (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{clipWithRanges(pointLists,{} xMin,{} xMax,{} yMin,{} yMax)} performs clipping on a list of lists of points,{} \\spad{pointLists}. Clipping is done within the specified ranges of \\spad{xMin},{} \\spad{xMax} and \\spad{yMin},{} \\spad{yMax}. This function is used internally by the \\pspadfun{iClipParametric} subroutine in this package."))
 (|clipParametric|
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|Plot|) (|Fraction| (|Integer|)) (|Fraction| (|Integer|)))
   "\\spad{clipParametric(p,{} frac,{} sc)} performs two-dimensional clipping on a plot,{} \\spad{p},{} from the domain \\spadtype{Plot} for the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)}; the fraction parameter is specified by \\spad{frac} and the scale parameter is specified by \\spad{sc} for use in the \\pspadfun{iClipParametric} subroutine,{} which is called by this function.")
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|Plot|))
   "\\spad{clipParametric(p)} performs two-dimensional clipping on a plot,{} \\spad{p},{} from the domain \\spadtype{Plot} for the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)}; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\pspadfun{iClipParametric} subroutine,{} which is called by this function."))
 (|clip|
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|List| (|List| (|Point| (|DoubleFloat|)))))
   "\\spad{clip(ll)} performs two-dimensional clipping on a list of lists of points,{} \\spad{ll}; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\pspadfun{iClipParametric} subroutine,{} which is called by this function.")
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|List| (|Point| (|DoubleFloat|))))
   "\\spad{clip(l)} performs two-dimensional clipping on a curve \\spad{l},{} which is a list of points; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\pspadfun{iClipParametric} subroutine,{} which is called by this function.")
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|Plot|) (|Fraction| (|Integer|)) (|Fraction| (|Integer|)))
   "\\spad{clip(p,{} frac,{} sc)} performs two-dimensional clipping on a plot,{} \\spad{p},{} from the domain \\spadtype{Plot} for the graph of one variable \\spad{y = f(x)}; the fraction parameter is specified by \\spad{frac} and the scale parameter is specified by \\spad{sc} for use in the \\spadfun{clip} function.")
  (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|)))))
              (|:| |xValues| (|Segment| (|DoubleFloat|)))
              (|:| |yValues| (|Segment| (|DoubleFloat|))))
    (|Plot|))
   "\\spad{clip(p)} performs two-dimensional clipping on a plot,{} \\spad{p},{} from the domain \\spadtype{Plot} for the graph of one variable,{} \\spad{y = f(x)}; the default parameters \\spad{1/4} for the fraction and \\spad{5/1} for the scale are used in the \\spadfun{clip} function."))) 
NIL 
(|ComplexRootPackage| UP |Par|) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides functions complexZeros} for finding the complex zeros of univariate polynomials with complex rational number coefficients. The results are to any user specified precision and are returned as either complex rational number or complex floating point numbers depending on the type of the second argument which specifies the precision."))
 (|complexZeros|
  (((|List| (|Complex| |#2|)) |#1| |#2|)
   "\\spad{complexZeros(poly,{} eps)} finds the complex zeros of the univariate polynomial \\spad{poly} to precision eps with solutions returned as complex floats or rationals depending on the type of eps."))) 
NIL 
(|Coalgebra| R |MxM|) 
((|constructor|
  (NIL
   "A coalgebra A over a ring is an \\spad{R}-module with a coassociative comultiplication from A to the tensor product of A with itself and which possesses a counit."))
 (|counit|
  ((|#1| $) "\\spad{counit(x)} evaluates the counit at an element \\spad{x}"))
 (|coproduct|
  ((|#2| $)
   "\\spad{coproduct(x)} computes the coproduct of an element \\spad{x}"))) 
NIL 
(|CoChainComplex| VS) 
((|constructor|
  (NIL
   "\\indented{2}{Delta Complexes are defined by a sequence of 'face maps',{} These can} \\indented{2}{be represented by a list of matrices.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/cochain/} Date Created: Jan 2016 Basic Operations: Related packages: Related categories: Related Domains: ChainComplex Also See: AMS Classifications:"))
 (|coHomology|
  (((|List| (|Homology|)) $) "calculate homology using SmithNormalForm"))
 (|coboundary|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|List| |#1|))
   "calculate coboundary at dimension \\spad{n} for a given input"))
 (|validate|
  (((|Boolean|) $)
   "\\spad{true} if this is a valid chain complex,{} that is: 1. maps compose 2. product of adjacent coboundary maps is zero"))
 (|coChainComplex|
  (($ (|ChainComplex|)) "constructor from \\spad{ChainComplex}")
  (($ (|List| (|Matrix| (|Integer|)))) "constructor"))) 
NIL 
(|CoDcpo| S) 
((|constructor|
  (NIL
   "Directed-complete Order,{} partial order that is guaranteed to have a meet of any two elements. For more documentation see: \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (|meet|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "returns the meet of 'a' and \\spad{'b'} In this version of meet nodes are represented as index values. Not every poset will have a meet but CoDCPO will."))) 
NIL 
(|Color|) 
((|constructor|
  (NIL
   "Color() specifies a domain of 27 colors provided in the \\Language{} system (the colors mix additively)."))
 (|color|
  (($ (|Integer|))
   "\\spad{color(i)} returns a color of the indicated hue \\spad{i}."))
 (|numberOfHues|
  (((|PositiveInteger|))
   "\\spad{numberOfHues()} returns the number of total hues,{} set in totalHues."))
 (|hue|
  (((|Integer|) $)
   "\\spad{hue(c)} returns the hue index of the indicated color \\spad{c}."))
 (|blue|
  (($) "\\spad{blue()} returns the position of the blue hue from total hues."))
 (|green|
  (($)
   "\\spad{green()} returns the position of the green hue from total hues."))
 (|yellow|
  (($)
   "\\spad{yellow()} returns the position of the yellow hue from total hues."))
 (|red|
  (($) "\\spad{red()} returns the position of the red hue from total hues."))
 (+
  (($ $ $)
   "\\spad{c1 + c2} additively mixes the two colors \\spad{c1} and \\spad{c2}."))
 (*
  (($ (|DoubleFloat|) $)
   "\\spad{s * c},{} returns the color \\spad{c},{} whose weighted shade has been scaled by \\spad{s}.")
  (($ (|PositiveInteger|) $)
   "\\spad{s * c},{} returns the color \\spad{c},{} whose weighted shade has been scaled by \\spad{s}."))) 
NIL 
(|CombinatorialFunction| R F) 
((|constructor|
  (NIL "Provides combinatorial functions over an integral domain."))
 (|ipow|
  ((|#2| (|List| |#2|)) "\\spad{ipow(l)} should be local but conditional."))
 (|iidprod|
  ((|#2| (|List| |#2|)) "\\spad{iidprod(l)} should be local but conditional."))
 (|iidsum|
  ((|#2| (|List| |#2|)) "\\spad{iidsum(l)} should be local but conditional."))
 (|iipow|
  ((|#2| (|List| |#2|)) "\\spad{iipow(l)} should be local but conditional."))
 (|iiperm|
  ((|#2| (|List| |#2|)) "\\spad{iiperm(l)} should be local but conditional."))
 (|iibinom|
  ((|#2| (|List| |#2|)) "\\spad{iibinom(l)} should be local but conditional."))
 (|iifact| ((|#2| |#2|) "\\spad{iifact(x)} should be local but conditional."))
 (|product|
  ((|#2| |#2| (|SegmentBinding| |#2|))
   "\\spad{product(f(n),{} n = a..b)} returns \\spad{f}(a) * ... * \\spad{f}(\\spad{b}) as a formal product.")
  ((|#2| |#2| (|Symbol|))
   "\\spad{product(f(n),{} n)} returns the formal product \\spad{P}(\\spad{n}) which verifies \\spad{P}(\\spad{n+1})\\spad{/P}(\\spad{n}) = \\spad{f}(\\spad{n})."))
 (|summation|
  ((|#2| |#2| (|SegmentBinding| |#2|))
   "\\spad{summation(f(n),{} n = a..b)} returns \\spad{f}(a) + ... + \\spad{f}(\\spad{b}) as a formal sum.")
  ((|#2| |#2| (|Symbol|))
   "\\spad{summation(f(n),{} n)} returns the formal sum \\spad{S}(\\spad{n}) which verifies \\spad{S}(\\spad{n+1}) - \\spad{S}(\\spad{n}) = \\spad{f}(\\spad{n})."))
 (|factorials|
  ((|#2| |#2| (|Symbol|))
   "\\spad{factorials(f,{} x)} rewrites the permutations and binomials in \\spad{f} involving \\spad{x} in terms of factorials.")
  ((|#2| |#2|)
   "\\spad{factorials(f)} rewrites the permutations and binomials in \\spad{f} in terms of factorials."))
 (|factorial|
  ((|#2| |#2|)
   "\\spad{factorial(n)} returns the factorial of \\spad{n},{} \\spadignore{i.e.} \\spad{n!}."))
 (|permutation|
  ((|#2| |#2| |#2|)
   "\\spad{permutation(n,{} r)} returns the number of permutations of \\spad{n} objects taken \\spad{r} at a time,{} \\spadignore{i.e.} \\spad{n!/}(\\spad{n}-\\spad{r})!."))
 (|binomial|
  ((|#2| |#2| |#2|)
   "\\spad{binomial(n,{} r)} returns the number of subsets of \\spad{r} objects taken among \\spad{n} objects,{} \\spadignore{i.e.} \\spad{n!/}(\\spad{r!} * (\\spad{n}-\\spad{r})!)."))
 (^ ((|#2| |#2| |#2|) "\\spad{a ^ b} returns the formal exponential a^b."))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F}; error if \\spad{op} is not a combinatorial operator."))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} returns \\spad{true} if \\spad{op} is a combinatorial operator."))) 
NIL 
(|IntegerCombinatoricFunctions| I) 
((|constructor|
  (NIL
   "The \\spadtype{IntegerCombinatoricFunctions} package provides some standard functions in combinatorics."))
 (|catalan|
  ((|#1| |#1|) "\\spad{catalan(n)} returns the \\spad{n}-th Catalan number"))
 (|stirling2|
  ((|#1| |#1| |#1|)
   "\\spad{stirling2(n,{} m)} returns the Stirling number of the second kind denoted \\spad{SS[n,{} m]}."))
 (|stirling1|
  ((|#1| |#1| |#1|)
   "\\spad{stirling1(n,{} m)} returns the Stirling number of the first kind denoted \\spad{S[n,{} m]}."))
 (|permutation|
  ((|#1| |#1| |#1|)
   "\\spad{permutation(n)} returns \\spad{!P(n,{} r) = n!/(n-r)!}. This is the number of permutations of \\spad{n} objects taken \\spad{r} at a time."))
 (|distinct_partition|
  ((|#1| |#1|)
   "\\spad{distinct_partition(n)} returns the number of partitions of the integer \\spad{n} with distinct members. This is the number of ways that \\spad{n} can be written as a sum of distinct positive integers. For \\spad{n > 0} this is the same as number of ways that \\spad{n} can be written as a sum of odd positive integers."))
 (|partition|
  ((|#1| |#1|)
   "\\spad{partition(n)} returns the number of partitions of the integer \\spad{n}. This is the number of distinct ways that \\spad{n} can be written as a sum of positive integers."))
 (|multinomial|
  ((|#1| |#1| (|List| |#1|))
   "\\spad{multinomial(n,{} [m1,{} m2,{} ...,{} mk])} returns the multinomial coefficient \\spad{n!/(m1! m2! ... mk!)}."))
 (|factorial|
  ((|#1| |#1|)
   "\\spad{factorial(n)} returns \\spad{n!}. this is the product of all integers between 1 and \\spad{n} (inclusive). Note: \\spad{0!} is defined to be 1."))
 (|binomial|
  ((|#1| |#1| |#1|)
   "\\spad{binomial(n,{} r)} returns the binomial coefficient \\spad{C(n,{} r) = n!/(r! (n-r)!)},{} where \\spad{n >= r >= 0}. This is the number of combinations of \\spad{n} objects taken \\spad{r} at a time."))) 
NIL 
(|CombinatorialOpsCategory|) 
((|constructor|
  (NIL
   "CombinatorialOpsCategory is the category obtaining by adjoining summations and products to the usual combinatorial operations."))
 (|product|
  (($ $ (|SegmentBinding| $))
   "\\spad{product(f(n),{} n = a..b)} returns \\spad{f}(a) * ... * \\spad{f}(\\spad{b}) as a formal product.")
  (($ $ (|Symbol|))
   "\\spad{product(f(n),{} n)} returns the formal product \\spad{P}(\\spad{n}) which verifies \\spad{P}(\\spad{n+1})\\spad{/P}(\\spad{n}) = \\spad{f}(\\spad{n})."))
 (|summation|
  (($ $ (|SegmentBinding| $))
   "\\spad{summation(f(n),{} n = a..b)} returns \\spad{f}(a) + ... + \\spad{f}(\\spad{b}) as a formal sum.")
  (($ $ (|Symbol|))
   "\\spad{summation(f(n),{} n)} returns the formal sum \\spad{S}(\\spad{n}) which verifies \\spad{S}(\\spad{n+1}) - \\spad{S}(\\spad{n}) = \\spad{f}(\\spad{n})."))
 (|factorials|
  (($ $ (|Symbol|))
   "\\spad{factorials(f,{} x)} rewrites the permutations and binomials in \\spad{f} involving \\spad{x} in terms of factorials.")
  (($ $)
   "\\spad{factorials(f)} rewrites the permutations and binomials in \\spad{f} in terms of factorials."))) 
NIL 
(|Commutator|) 
((|constructor| (NIL "A type for basic commutators"))
 (|mkcomm| (($ $ $) "\\spad{mkcomm(i,{} j)} \\undocumented{}")
  (($ (|Integer|)) "\\spad{mkcomm(i)} \\undocumented{}"))) 
NIL 
(|CommonOperators|) 
((|constructor|
  (NIL
   "This package exports the elementary operators,{} with some semantics already attached to them. The semantics that is attached here is not dependent on the set in which the operators will be applied."))
 (|operator|
  (((|BasicOperator|) (|Symbol|))
   "\\spad{operator(s)} returns an operator with name \\spad{s},{} with the appropriate semantics if \\spad{s} is known. If \\spad{s} is not known,{} the result has no semantics."))) 
NIL 
(|CommuteUnivariatePolynomialCategory| R UP UPUP) 
((|constructor|
  (NIL
   "A package for swapping the order of two variables in a tower of two UnivariatePolynomialCategory extensions."))
 (|swap|
  ((|#3| |#3|)
   "\\spad{swap(p(x,{} y))} returns \\spad{p}(\\spad{y},{} \\spad{x})."))) 
NIL 
(|Comparable|) 
((|constructor|
  (NIL
   "The class of sets equipped with possibly unnatural linear order (needed for technical reasons)."))
 (|smaller?|
  (((|Boolean|) $ $)
   "\\spad{smaller?(x,{} y)} is a strict total ordering on the elements of the set."))) 
NIL 
(|ComplexCategory&| S R) 
((|constructor|
  (NIL
   "This category represents the extension of a ring by a square root of \\spad{-1}."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number,{} or \"failed\" if \\spad{x} is not a rational number."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(x)} returns \\spad{x} as a rational number. Error: if \\spad{x} is not a rational number."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(x)} tests if \\spad{x} is a rational number."))
 (|polarCoordinates|
  (((|Record| (|:| |r| |#2|) (|:| |phi| |#2|)) $)
   "\\spad{polarCoordinates(x)} returns (\\spad{r},{} phi) such that \\spad{x} = \\spad{r} * exp(\\%\\spad{i} * phi)."))
 (|argument|
  ((|#2| $)
   "\\spad{argument(x)} returns the angle made by (1,{} 0) and \\spad{x}."))
 (|abs|
  (($ $)
   "\\spad{abs(x)} returns the absolute value of \\spad{x} = sqrt(norm(\\spad{x}))."))
 (|exquo|
  (((|Union| $ "failed") $ |#2|)
   "\\spad{exquo(x,{} r)} returns the exact quotient of \\spad{x} by \\spad{r},{} or \"failed\" if \\spad{r} does not divide \\spad{x} exactly."))
 (|norm| ((|#2| $) "\\spad{norm(x)} returns \\spad{x} * conjugate(\\spad{x})"))
 (|real| ((|#2| $) "\\spad{real(x)} returns real part of \\spad{x}."))
 (|imag| ((|#2| $) "\\spad{imag(x)} returns imaginary part of \\spad{x}."))
 (|complex|
  (($ |#2| |#2|) "\\spad{complex(x,{} y)} constructs \\spad{x} + \\%i*y."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(x + \\%i y)} returns \\spad{x} - \\%\\spad{i} \\spad{y}."))
 (|imaginary| (($) "\\spad{imaginary()} = sqrt(\\spad{-1}) = \\%\\spad{i}."))) 
((|HasCategory| |#2| '(|EuclideanDomain|))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|RadicalCategory|))
 (|HasCategory| |#2| '(|TranscendentalFunctionCategory|))
 (|HasCategory| |#2| '(|arbitraryPrecision|))
 (|HasCategory| |#2| '(|RealNumberSystem|))
 (|HasCategory| |#2| '(|RealConstant|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|IntegerNumberSystem|))
 (|HasCategory| |#2| '(|IntegralDomain|)) (|HasCategory| |#2| '(|Comparable|))) 
(|ComplexCategory| R) 
((|constructor|
  (NIL
   "This category represents the extension of a ring by a square root of \\spad{-1}."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number,{} or \"failed\" if \\spad{x} is not a rational number."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(x)} returns \\spad{x} as a rational number. Error: if \\spad{x} is not a rational number."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(x)} tests if \\spad{x} is a rational number."))
 (|polarCoordinates|
  (((|Record| (|:| |r| |#1|) (|:| |phi| |#1|)) $)
   "\\spad{polarCoordinates(x)} returns (\\spad{r},{} phi) such that \\spad{x} = \\spad{r} * exp(\\%\\spad{i} * phi)."))
 (|argument|
  ((|#1| $)
   "\\spad{argument(x)} returns the angle made by (1,{} 0) and \\spad{x}."))
 (|abs|
  (($ $)
   "\\spad{abs(x)} returns the absolute value of \\spad{x} = sqrt(norm(\\spad{x}))."))
 (|exquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{exquo(x,{} r)} returns the exact quotient of \\spad{x} by \\spad{r},{} or \"failed\" if \\spad{r} does not divide \\spad{x} exactly."))
 (|norm| ((|#1| $) "\\spad{norm(x)} returns \\spad{x} * conjugate(\\spad{x})"))
 (|real| ((|#1| $) "\\spad{real(x)} returns real part of \\spad{x}."))
 (|imag| ((|#1| $) "\\spad{imag(x)} returns imaginary part of \\spad{x}."))
 (|complex|
  (($ |#1| |#1|) "\\spad{complex(x,{} y)} constructs \\spad{x} + \\%i*y."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(x + \\%i y)} returns \\spad{x} - \\%\\spad{i} \\spad{y}."))
 (|imaginary| (($) "\\spad{imaginary()} = sqrt(\\spad{-1}) = \\%\\spad{i}."))) 
NIL 
(|compCode|) 
((|constructor|
  (NIL
   "Maps abstract computational structures to real-world FriCAS code \\blankline This allows FriCAS domains to be created from an instance of Lambda it also allows FriCAS categories to be created from an instance of intuitionisticLogic. \\blankline So by the Curry-Howard isomorphism we can coerce to the intuitionisticLogic from Lambda. This gives an isomorphism where theorems in intuitionistic logic correspond to type signatures in combinatory logic and programs in intuitionistic logic correspond to the proofs of those theorems in combinatory logic. \\blankline As an example of this in Haskell see \"Djinn,{} a theorem prover in Haskell,{} for Haskell\" here: http://lambda-the-ultimate.\\spad{org/node/1178} \\blankline see also: Philip Wadler - Theorems for free! http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html"))
 (|writePackage|
  (((|Void|) (|List| (|Lambda| (|Typed|))) (|String|) (|String|) (|String|)
    (|String|))
   "writes a package to a file."))
 (|writeCategory|
  (((|Void|) (|List| (|ILogic|)) (|String|) (|String|) (|String|))
   "writes a category to a file."))) 
NIL 
(|Complex| R) 
((|constructor|
  (NIL
   "\\spadtype {Complex(R)} creates the domain of elements of the form \\spad{a + b * i} where \\spad{a} and \\spad{b} come from the ring \\spad{R},{} and \\spad{i} is a new element such that \\spad{i^2 = -1}."))) 
((|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|FiniteFieldCategory|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|FiniteFieldCategory|)))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|Finite|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|TranscendentalFunctionCategory|))
 (AND (|HasCategory| |#1| '(|RadicalCategory|))
      (|HasCategory| |#1| '(|TranscendentalFunctionCategory|)))
 (|HasCategory| |#1| '(|arbitraryPrecision|))
 (|HasCategory| |#1| '(|RealConstant|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))
 (OR (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|FiniteFieldCategory|))
     (|HasCategory| |#1| '(|IntegerNumberSystem|)))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#1| '(|OpenMath|)) (|HasCategory| |#1| '(|RealNumberSystem|))
 (AND (|HasCategory| |#1| '(|RealNumberSystem|))
      (|HasCategory| |#1| '(|TranscendentalFunctionCategory|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|FiniteFieldCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|FiniteFieldCategory|))
  (|HasCategory| |#1| '(|IntegerNumberSystem|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|Field|))
  (|HasCategory| |#1| '(|IntegerNumberSystem|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|FiniteFieldCategory|))
  (|HasCategory| |#1| '(|IntegerNumberSystem|))
  (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegerNumberSystem|))
  (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#1| '(|Field|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegerNumberSystem|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR
  (AND (|HasCategory| |#1| '(|EuclideanDomain|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| $ '(|CharacteristicNonZero|)))
  (AND (|HasCategory| |#1| '(|FiniteFieldCategory|))
       (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|EuclideanDomain|))
          (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))) 
(|ComplexFunctions2| R S) 
((|constructor|
  (NIL
   "This package extends maps from underlying rings to maps between complex over those rings."))
 (|map|
  (((|Complex| |#2|) (|Mapping| |#2| |#1|) (|Complex| |#1|))
   "\\spad{map(f,{} u)} maps \\spad{f} onto real and imaginary parts of \\spad{u}."))) 
NIL 
(|ComplexPattern| R S CS) 
((|constructor|
  (NIL "This package supports converting complex expressions to patterns"))
 (|convert|
  (((|Pattern| |#1|) |#3|)
   "\\spad{convert(cs)} converts the complex expression \\spad{cs} to a pattern"))) 
NIL 
(|SubSpaceComponentProperty|) 
((|constructor|
  (NIL "This domain implements some global properties of subspaces."))
 (|copy| (($ $) "\\spad{copy(x)} \\undocumented"))
 (|solid| (((|Boolean|) $ (|Boolean|)) "\\spad{solid(x,{} b)} \\undocumented"))
 (|close| (((|Boolean|) $ (|Boolean|)) "\\spad{close(x,{} b)} \\undocumented"))
 (|solid?| (((|Boolean|) $) "\\spad{solid?(x)} \\undocumented"))
 (|closed?| (((|Boolean|) $) "\\spad{closed?(x)} \\undocumented"))
 (|new| (($) "\\spad{new()} \\undocumented"))) 
NIL 
(|compUtil| UT) 
((|constructor| (NIL "macro to simplify output"))
 (|coerce|
  (((|ILogic|) (|SKICombinators| |#1|))
   "\\spad{coerce combinators} to intuitionistic logic this is known as the Curry-Howard isomorphism it uses the following rules: rule SI1: Ski[Kab] \\spad{=>} a \\spad{->} (\\spad{b} \\spad{->} a),{} rule SI2: Ski[Sabc] \\spad{=>} (a \\spad{->} (\\spad{b} \\spad{->} \\spad{c})) \\spad{->} ((a \\spad{->} \\spad{b}) \\spad{->} (a \\spad{->} \\spad{c})),{} rule SI3: Ski[a a-\\spad{>b}] \\spad{=>} \\spad{b} the last rule is function application (modus ponens)")
  (((|SKICombinators| |#1|) (|Lambda| |#1|))
   "\\spad{coerce Lambda} term to SKI combinators. this process is known as abstraction elimination. it is done by applying the following rules until all lambda terms have been eliminated. rule LS1: Lam[\\spad{x}] \\spad{=>} \\spad{x} rule LS2: Lam[(\\spad{E1} \\spad{E2})] \\spad{=>} (Lam[\\spad{E1}] Lam[\\spad{E2}]) rule LS3: Lam[\\spad{\\x}.\\spad{E}] \\spad{=>} (\\spad{K} Lam[\\spad{E}]) (if \\spad{x} does not occur free in \\spad{E}) rule LS4: Lam[\\spad{\\x}.\\spad{x}] \\spad{=>} \\spad{I} rule LS5: Lam[\\spad{\\x}.\\y.\\spad{E}] \\spad{=>} Lam[\\spad{\\x}.Lam[\\y.\\spad{E}]] (if \\spad{x} occurs free in \\spad{E}) rule LS6: Lam[\\spad{\\x}.(\\spad{E1} \\spad{E2})] \\spad{=>} (\\spad{S} Lam[\\spad{\\x}.\\spad{E1}] Lam[\\spad{\\x}.\\spad{E2}])")
  (((|Lambda| |#1|) (|SKICombinators| |#1|))
   "\\spad{coerce SKI} combinators to Lambda term. this conversion is done by applying the following rules rule SL1: Ski[\\spad{I}] = \\spad{\\x}.0 rule SL2: Ski[\\spad{K}] = \\spad{\\x}.\\y.1 rule SL3: Ski[\\spad{S}] = \\spad{\\x}.\\y.\\spad{\\z}.(2 0 (1 0)) rule SL4: Ski[(\\spad{E1} \\spad{E2})] = (Ski[\\spad{E1}] Ski[\\spad{E2}])"))) 
NIL 
(|CommutativeRing|) 
((|constructor|
  (NIL
   "The category of commutative rings with unity,{} \\spadignore{i.e.} rings where \\spadop{*} is commutative,{} and which have a multiplicative identity. element."))) 
NIL 
(|ContinuedFraction| R) 
((|constructor|
  (NIL
   "\\spadtype{ContinuedFraction} implements general \\indented{1}{continued fractions.\\space{2}This version is not restricted to simple,{}} \\indented{1}{finite fractions and uses the \\spadtype{Stream} as a} \\indented{1}{representation.\\space{2}The arithmetic functions assume that the} \\indented{1}{approximants alternate below/above the convergence point.} \\indented{1}{This is enforced by ensuring the partial numerators and partial} \\indented{1}{denominators are greater than 0 in the Euclidean domain view of \\spad{R}} \\indented{1}{(\\spadignore{i.e.} \\spad{sizeLess?(0,{} x)}).}"))
 (|complete|
  (($ $)
   "\\spad{complete(x)} causes all entries in \\spadvar{\\spad{x}} to be computed. Normally entries are only computed as needed. If \\spadvar{\\spad{x}} is an infinite continued fraction,{} a user-initiated interrupt is necessary to stop the computation."))
 (|extend|
  (($ $ (|Integer|))
   "\\spad{extend(x,{} n)} causes the first \\spadvar{\\spad{n}} entries in the continued fraction \\spadvar{\\spad{x}} to be computed. Normally entries are only computed as needed."))
 (|denominators|
  (((|Stream| |#1|) $)
   "\\spad{denominators(x)} returns the stream of denominators of the approximants of the continued fraction \\spadvar{\\spad{x}}. If the continued fraction is finite,{} then the stream will be finite."))
 (|numerators|
  (((|Stream| |#1|) $)
   "\\spad{numerators(x)} returns the stream of numerators of the approximants of the continued fraction \\spadvar{\\spad{x}}. If the continued fraction is finite,{} then the stream will be finite."))
 (|convergents|
  (((|Stream| (|Fraction| |#1|)) $)
   "\\spad{convergents(x)} returns the stream of the convergents of the continued fraction \\spadvar{\\spad{x}}. If the continued fraction is finite,{} then the stream will be finite."))
 (|approximants|
  (((|Stream| (|Fraction| |#1|)) $)
   "\\spad{approximants(x)} returns the stream of approximants of the continued fraction \\spadvar{\\spad{x}}. If the continued fraction is finite,{} then the stream will be infinite and periodic with period 1."))
 (|reducedForm|
  (($ $)
   "\\spad{reducedForm(x)} puts the continued fraction \\spadvar{\\spad{x}} in reduced form,{} \\spadignore{i.e.} the function returns an equivalent continued fraction of the form \\spad{continuedFraction(b0,{} [1,{} 1,{} 1,{} ...],{} [b1,{} b2,{} b3,{} ...])}."))
 (|wholePart|
  ((|#1| $)
   "\\spad{wholePart(x)} extracts the whole part of \\spadvar{\\spad{x}}. That is,{} if \\spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \\spad{wholePart(x) = b0}."))
 (|partialQuotients|
  (((|Stream| |#1|) $)
   "\\spad{partialQuotients(x)} extracts the partial quotients in \\spadvar{\\spad{x}}. That is,{} if \\spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \\spad{partialQuotients(x) = [b0,{} b1,{} b2,{} b3,{} ...]}."))
 (|partialDenominators|
  (((|Stream| |#1|) $)
   "\\spad{partialDenominators(x)} extracts the denominators in \\spadvar{\\spad{x}}. That is,{} if \\spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \\spad{partialDenominators(x) = [b1,{} b2,{} b3,{} ...]}."))
 (|partialNumerators|
  (((|Stream| |#1|) $)
   "\\spad{partialNumerators(x)} extracts the numerators in \\spadvar{\\spad{x}}. That is,{} if \\spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \\spad{partialNumerators(x) = [a1,{} a2,{} a3,{} ...]}."))
 (|reducedContinuedFraction|
  (($ |#1| (|Stream| |#1|))
   "\\spad{reducedContinuedFraction(b0,{} b)} constructs a continued fraction in the following way: if \\spad{b = [b1,{} b2,{} ...]} then the result is the continued fraction \\spad{b0 + 1/(b1 + 1/(b2 + ...))}. That is,{} the result is the same as \\spad{continuedFraction(b0,{} [1,{} 1,{} 1,{} ...],{} [b1,{} b2,{} b3,{} ...])}."))
 (|continuedFraction|
  (($ |#1| (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{continuedFraction(b0,{} a,{} b)} constructs a continued fraction in the following way: if \\spad{a = [a1,{} a2,{} ...]} and \\spad{b = [b1,{} b2,{} ...]} then the result is the continued fraction \\spad{b0 + a1/(b1 + a2/(b2 + ...))}.")
  (($ (|Fraction| |#1|))
   "\\spad{continuedFraction(r)} converts the fraction \\spadvar{\\spad{r}} with components of type \\spad{R} to a continued fraction over \\spad{R}."))) 
NIL 
(|CoordinateSystems| R) 
((|constructor|
  (NIL
   "CoordinateSystems provides coordinate transformation functions for plotting. Functions in this package return conversion functions which take points expressed in other coordinate systems and return points with the corresponding Cartesian coordinates."))
 (|conical|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1| |#1|)
   "\\spad{conical(a,{} b)} transforms from conical coordinates to Cartesian coordinates: \\spad{conical(a,{} b)} is a function which will map the point \\spad{(lambda,{} mu,{} nu)} to \\spad{x = lambda*mu*nu/(a*b)},{} \\spad{y = lambda/a*sqrt((mu^2-a^2)*(nu^2-a^2)/(a^2-b^2))},{} \\spad{z = lambda/b*sqrt((mu^2-b^2)*(nu^2-b^2)/(b^2-a^2))}."))
 (|toroidal|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{toroidal(a)} transforms from toroidal coordinates to Cartesian coordinates: \\spad{toroidal(a)} is a function which will map the point \\spad{(u,{} v,{} phi)} to \\spad{x = a*sinh(v)*cos(phi)/(cosh(v)-cos(u))},{} \\spad{y = a*sinh(v)*sin(phi)/(cosh(v)-cos(u))},{} \\spad{z = a*sin(u)/(cosh(v)-cos(u))}."))
 (|bipolarCylindrical|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{bipolarCylindrical(a)} transforms from bipolar cylindrical coordinates to Cartesian coordinates: \\spad{bipolarCylindrical(a)} is a function which will map the point \\spad{(u,{} v,{} z)} to \\spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \\spad{y = a*sin(u)/(cosh(v)-cos(u))},{} \\spad{z}."))
 (|bipolar|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{bipolar(a)} transforms from bipolar coordinates to Cartesian coordinates: \\spad{bipolar(a)} is a function which will map the point \\spad{(u,{} v)} to \\spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \\spad{y = a*sin(u)/(cosh(v)-cos(u))}."))
 (|oblateSpheroidal|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{oblateSpheroidal(a)} transforms from oblate spheroidal coordinates to Cartesian coordinates: \\spad{oblateSpheroidal(a)} is a function which will map the point \\spad{(\\spad{xi},{} eta,{} phi)} to \\spad{x = a*sinh(\\spad{xi})*sin(eta)*cos(phi)},{} \\spad{y = a*sinh(\\spad{xi})*sin(eta)*sin(phi)},{} \\spad{z = a*cosh(\\spad{xi})*cos(eta)}."))
 (|prolateSpheroidal|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{prolateSpheroidal(a)} transforms from prolate spheroidal coordinates to Cartesian coordinates: \\spad{prolateSpheroidal(a)} is a function which will map the point \\spad{(\\spad{xi},{} eta,{} phi)} to \\spad{x = a*sinh(\\spad{xi})*sin(eta)*cos(phi)},{} \\spad{y = a*sinh(\\spad{xi})*sin(eta)*sin(phi)},{} \\spad{z = a*cosh(\\spad{xi})*cos(eta)}."))
 (|ellipticCylindrical|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{ellipticCylindrical(a)} transforms from elliptic cylindrical coordinates to Cartesian coordinates: \\spad{ellipticCylindrical(a)} is a function which will map the point \\spad{(u,{} v,{} z)} to \\spad{x = a*cosh(u)*cos(v)},{} \\spad{y = a*sinh(u)*sin(v)},{} \\spad{z}."))
 (|elliptic|
  (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|)
   "\\spad{elliptic(a)} transforms from elliptic coordinates to Cartesian coordinates: \\spad{elliptic(a)} is a function which will map the point \\spad{(u,{} v)} to \\spad{x = a*cosh(u)*cos(v)},{} \\spad{y = a*sinh(u)*sin(v)}."))
 (|paraboloidal|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{paraboloidal(pt)} transforms \\spad{pt} from paraboloidal coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,{} v,{} phi)} to \\spad{x = u*v*cos(phi)},{} \\spad{y = u*v*sin(phi)},{} \\spad{z = 1/2 * (u^2 - v^2)}."))
 (|parabolicCylindrical|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{parabolicCylindrical(pt)} transforms \\spad{pt} from parabolic cylindrical coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,{} v,{} z)} to \\spad{x = 1/2*(u^2 - v^2)},{} \\spad{y = u*v},{} \\spad{z}."))
 (|parabolic|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{parabolic(pt)} transforms \\spad{pt} from parabolic coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,{} v)} to \\spad{x = 1/2*(u^2 - v^2)},{} \\spad{y = u*v}."))
 (|spherical|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{spherical(pt)} transforms \\spad{pt} from spherical coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,{} theta,{} phi)} to \\spad{x = r*sin(phi)*cos(theta)},{} \\spad{y = r*sin(phi)*sin(theta)},{} \\spad{z = r*cos(phi)}."))
 (|cylindrical|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{cylindrical(pt)} transforms \\spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,{} theta,{} z)} to \\spad{x = r * cos(theta)},{} \\spad{y = r * sin(theta)},{} \\spad{z}."))
 (|polar|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{polar(pt)} transforms \\spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,{} theta)} to \\spad{x = r * cos(theta)} ,{} \\spad{y = r * sin(theta)}."))
 (|cartesian|
  (((|Point| |#1|) (|Point| |#1|))
   "\\spad{cartesian(pt)} returns the Cartesian coordinates of point \\spad{pt}."))) 
NIL 
(|CharacteristicPolynomialInMonogenicalAlgebra| R |PolR| E) 
((|constructor|
  (NIL
   "This package implements characteristicPolynomials for monogenic algebras using resultants"))
 (|characteristicPolynomial|
  ((|#2| |#3|)
   "\\spad{characteristicPolynomial(e)} returns the characteristic polynomial of \\spad{e} using resultants"))) 
NIL 
(|ComplexPatternMatch| R S CS) 
((|constructor|
  (NIL
   "This package supports matching patterns involving complex expressions"))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#3|))
   "\\spad{patternMatch(cexpr,{} pat,{} res)} matches the pattern \\spad{pat} to the complex expression \\spad{cexpr}. res contains the variables of \\spad{pat} which are already matched and their matches."))) 
((|HasCategory| (|Polynomial| |#2|)
                (LIST '|PatternMatchable| (|devaluate| |#1|)))) 
(|CRApackage| R) 
((|constructor|
  (NIL
   "This package implements asymptotically efficient Chinese reconstruction"))
 (|multiEuclideanTree|
  (((|List| |#1|) (|List| |#1|) |#1|)
   "\\spad{multiEuclideanTree(l,{} r)} \\undocumented{}"))
 (|chineseRemainder|
  (((|List| |#1|) (|List| (|List| |#1|)) (|List| |#1|))
   "\\spad{chineseRemainder(llv,{} lm)} returns a list of values,{} each of which corresponds to the Chinese remainder of the associated element of \\spad{llv} and \\spad{lm}. This is more efficient than applying chineseRemainder several times.")
  ((|#1| (|List| |#1|) (|List| |#1|))
   "\\spad{chineseRemainder(lv,{} lm)} returns a value \\spad{v} such that,{} if \\spad{x} is \\spad{lv.i} modulo \\spad{lm.i} for all \\spad{i},{} then \\spad{x} is \\spad{v} modulo \\spad{lm(1)*lm(2)*...*lm(n)}."))
 (|modTree|
  (((|List| |#1|) |#1| (|List| |#1|))
   "\\spad{modTree(r,{} l)} \\undocumented{}"))) 
NIL 
(|ComplexRootFindingPackage| R UP) 
((|constructor|
  (NIL
   "\\spadtype{ComplexRootFindingPackage} provides functions to find all roots of a polynomial \\spad{p} over the complex number by using Plesken\\spad{'s} idea to calculate in the polynomial ring modulo \\spad{f} and employing the Chinese Remainder Theorem. In this first version,{} the precision (see \\spadfunFrom{digits}{Float}) is not increased when this is necessary to avoid rounding errors. Hence it is the user\\spad{'s} responsibility to increase the precision if necessary. Note also,{} if this package is called with \\spadignore{e.g.} \\spadtype{Fraction Integer},{} the precise calculations could require a lot of time. Also note that evaluating the zeros is not necessarily a good check whether the result is correct: already evaluation can cause rounding errors."))
 (|startPolynomial|
  (((|Record| (|:| |start| |#2|) (|:| |factors| (|Factored| |#2|))) |#2|)
   "\\spad{startPolynomial(p)} uses the ideas of Schoenhage\\spad{'s} variant of Graeffe\\spad{'s} method to construct circles which separate roots to get a good start polynomial,{} \\spadignore{i.e.} one whose image under the Chinese Remainder Isomorphism has both entries of norm smaller and greater or equal to 1. In case the roots are found during internal calculations. The corresponding factors are in {\\em factors} which are otherwise 1."))
 (|setErrorBound|
  ((|#1| |#1|)
   "\\spad{setErrorBound(eps)} changes the internal error bound,{} by default being {\\em 10 ^ (-3)} to \\spad{eps},{} if \\spad{R} is a member in the category \\spadtype{QuotientFieldCategory Integer}. The internal {\\em globalDigits} is set to {\\em ceiling(1/r)^2*10} being {\\em 10^7} by default."))
 (|schwerpunkt|
  (((|Complex| |#1|) |#2|)
   "\\spad{schwerpunkt(p)} determines the 'Schwerpunkt' of the roots of the polynomial \\spad{p} of degree \\spad{n},{} \\spadignore{i.e.} the center of gravity,{} which is {\\em coefficient of \\spad{x^(n-1)}} divided by {\\em n times coefficient of \\spad{x^n}}."))
 (|rootRadius|
  ((|#1| |#2|)
   "\\spad{rootRadius(p)} calculates the root radius of \\spad{p} with a maximal error quotient of {\\em 1+globalEps},{} where {\\em globalEps} is the internal error bound,{} which can be set by {\\em setErrorBound}.")
  ((|#1| |#2| |#1|)
   "\\spad{rootRadius(p,{} errQuot)} calculates the root radius of \\spad{p} with a maximal error quotient of {\\em errQuot}."))
 (|reciprocalPolynomial|
  ((|#2| |#2|)
   "\\spad{reciprocalPolynomial(p)} calulates a polynomial which has exactly the inverses of the non-zero roots of \\spad{p} as roots,{} and the same number of 0-roots."))
 (|pleskenSplit|
  (((|Factored| |#2|) |#2| |#1|)
   "\\spad{pleskenSplit(poly,{} eps)} determines a start polynomial {\\em start}\\\\ by using \"startPolynomial then it increases the exponent \\spad{n} of {\\em start ^ n mod poly} to get an approximate factor of {\\em poly},{} in general of degree \"degree \\spad{poly} \\spad{-1\"}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough.")
  (((|Factored| |#2|) |#2| |#1| (|Boolean|))
   "\\spad{pleskenSplit(poly,{} eps,{} info)} determines a start polynomial {\\em start} by using \"startPolynomial then it increases the exponent \\spad{n} of {\\em start ^ n mod poly} to get an approximate factor of {\\em poly},{} in general of degree \"degree \\spad{poly} \\spad{-1\"}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough. If {\\em info} is {\\em true},{} then information messages are issued."))
 (|norm|
  ((|#1| |#2|)
   "\\spad{norm(p)} determines sum of absolute values of coefficients Note: this function depends on \\spadfunFrom{abs}{Complex}."))
 (|graeffe|
  ((|#2| |#2|)
   "\\spad{graeffe p} determines \\spad{q} such that \\spad{q(-z^2) = p(z)*p(-z)}. Note that the roots of \\spad{q} are the squares of the roots of \\spad{p}."))
 (|factor|
  (((|Factored| |#2|) |#2|)
   "\\spad{factor(p)} tries to factor \\spad{p} into linear factors with error at most {\\em globalEps},{} the internal error bound,{} which can be set by {\\em setErrorBound}. An overall error bound {\\em eps0} is determined and iterated tree-like calls to {\\em pleskenSplit} are used to get the factorization.")
  (((|Factored| |#2|) |#2| |#1|)
   "\\spad{factor(p,{} eps)} tries to factor \\spad{p} into linear factors with error at most {\\em eps}. An overall error bound {\\em eps0} is determined and iterated tree-like calls to {\\em pleskenSplit} are used to get the factorization.")
  (((|Factored| |#2|) |#2| |#1| (|Boolean|))
   "\\spad{factor(p,{} eps,{} info)} tries to factor \\spad{p} into linear factors with error at most {\\em eps}. An overall error bound {\\em eps0} is determined and iterated tree-like calls to {\\em pleskenSplit} are used to get the factorization. If {\\em info} is {\\em true},{} then information messages are given."))
 (|divisorCascade|
  (((|List| (|Record| (|:| |factors| (|List| |#2|)) (|:| |error| |#1|))) |#2|
    |#2|)
   "\\spad{divisorCascade(p,{} tp)} assumes that degree of polynomial {\\em tp} is smaller than degree of polynomial \\spad{p},{} both monic. A sequence of divisions is calculated using the remainder,{} made monic,{} as divisor for the the next division. The result contains also the error of the factorizations,{} \\spadignore{i.e.} the norm of the remainder polynomial.")
  (((|List| (|Record| (|:| |factors| (|List| |#2|)) (|:| |error| |#1|))) |#2|
    |#2| (|Boolean|))
   "\\spad{divisorCascade(p,{} tp)} assumes that degree of polynomial {\\em tp} is smaller than degree of polynomial \\spad{p},{} both monic. A sequence of divisions are calculated using the remainder,{} made monic,{} as divisor for the next division. The result contains also the error of the factorizations,{} \\spadignore{i.e.} the norm of the remainder polynomial. If {\\em info} is {\\em true},{} then information messages are issued."))
 (|complexZeros|
  (((|List| (|Complex| |#1|)) |#2| |#1|)
   "\\spad{complexZeros(p,{} eps)} tries to determine all complex zeros of the polynomial \\spad{p} with accuracy given by {\\em eps}.")
  (((|List| (|Complex| |#1|)) |#2|)
   "\\spad{complexZeros(p)} tries to determine all complex zeros of the polynomial \\spad{p} with accuracy given by the package constant {\\em globalEps} which you may change by {\\em setErrorBound}."))) 
NIL 
(|CyclicStreamTools| S ST) 
((|constructor|
  (NIL "This package provides tools for working with cyclic streams."))
 (|computeCycleEntry|
  ((|#2| |#2| |#2|)
   "\\spad{computeCycleEntry(x,{} cycElt)},{} where cycElt is a pointer to a node in the cyclic part of the cyclic stream \\spad{x},{} returns a pointer to the first node in the cycle"))
 (|computeCycleLength|
  (((|NonNegativeInteger|) |#2|)
   "\\spad{computeCycleLength(s)} returns the length of the cycle of a cyclic stream \\spad{t},{} where \\spad{s} is a pointer to a node in the cyclic part of \\spad{t}."))
 (|cycleElt|
  (((|Union| |#2| "failed") |#2|)
   "\\spad{cycleElt(s)} returns a pointer to a node in the cycle if the stream \\spad{s} is cyclic and returns \"failed\" if \\spad{s} is not cyclic"))) 
NIL 
(|ComplexTrigonometricManipulations| R F) 
((|constructor|
  (NIL
   "\\spadtype{ComplexTrigonometricManipulations} provides function that compute the real and imaginary parts of complex functions."))
 (|complexForm|
  (((|Complex| (|Expression| |#1|)) |#2|)
   "\\spad{complexForm(f)} returns \\spad{[real f,{} imag f]}."))
 (|trigs|
  ((|#2| |#2|)
   "\\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions."))
 (|real?|
  (((|Boolean|) |#2|)
   "\\spad{real?(f)} returns \\spad{true} if \\spad{f = real f}."))
 (|imag|
  (((|Expression| |#1|) |#2|)
   "\\spad{imag(f)} returns the imaginary part of \\spad{f} where \\spad{f} is a complex function."))
 (|real|
  (((|Expression| |#1|) |#2|)
   "\\spad{real(f)} returns the real part of \\spad{f} where \\spad{f} is a complex function."))
 (|complexElementary|
  ((|#2| |#2| (|Symbol|))
   "\\spad{complexElementary(f,{} x)} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log,{} exp}.")
  ((|#2| |#2|)
   "\\spad{complexElementary(f)} rewrites \\spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log,{} exp}."))
 (|complexNormalize|
  ((|#2| |#2| (|Symbol|))
   "\\spad{complexNormalize(f,{} x)} rewrites \\spad{f} using the least possible number of complex independent kernels involving \\spad{x}.")
  ((|#2| |#2|)
   "\\spad{complexNormalize(f)} rewrites \\spad{f} using the least possible number of complex independent kernels."))) 
NIL 
(|FiniteCubicalComplex| VS) 
((|constructor|
  (NIL
   "\\indented{2}{A Finite Cubical Complex} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/} Date Created: April 2016 Basic Operations: Related packages: Related categories: Related Domains: Also See: AMS Classifications:"))
 (|coerce|
  (((|DeltaComplex| |#1|) $) "\\spad{coerce CubicalComplex} to DeltaComplex"))
 (|chain|
  (((|ChainComplex|) $)
   "returns a matrix sequence representing the face maps in linear algebra form"))
 (|boundary|
  (($ $)
   "Boundary operator. Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can."))
 (|homology|
  (((|List| (|Homology|)) $) "calculate homology using SmithNormalForm"))
 (|fundamentalGroup|
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|))
   "Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. TODO write a faster implementation which only generates edge and square faceMaps. This version has options to: simplify - if \\spad{true} attempts to simplify the group presentation trace - if \\spad{true} outputs trace of simplification rules used.")
  (((|GroupPresentation|) $)
   "Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\\spad{'t} want this use alternative function of same name. TODO write a faster implementation which only generates edge and square faceMaps."))
 (|product| (($ $ $) "Forms product of two cubical complexes."))
 (|addImpliedFaces|
  (((|List| (|List| (|CubicalFacet|))) $)
   "a function to take a set of faces and add those that are implied by the cubicalComplex conventions (if they don\\spad{'t} already exist). For example,{} if the input is a square [1..2,{} 1..2] then we would add its edges [1..1,{} 1..2],{} [2..2,{} 1..2],{} [1..2,{} 1..1],{} and [1..2,{} 2..2]."))
 (|grade|
  (((|List| (|List| (|CubicalFacet|))) $)
   "A function to grade faces according to the number of non-degenerate intervals. This nests the lists according to their order Vertices,{} edges,{} squares and so on."))
 (|addCube|
  (($ $ (|CubicalFacet|))
   "Add a facet to this simplex If the facet is also in the list then,{} do not append,{} instead change the multiplier."))
 (|maxIndex| (((|NonNegativeInteger|) $) "find the maximum index."))
 (|cubicalComplex| (($ (|List| |#1|)) "construct empty cubical complex")
  (($ (|List| |#1|) (|List| (|List| (|List| (|Integer|)))))
   "constructor where the cubes are supplied")
  (($ (|List| |#1|) (|List| (|List| (|Segment| (|Integer|)))))
   "constructor where the cubes are supplied")
  (($ (|List| |#1|) (|List| (|CubicalFacet|)))
   "constructor where the cubes are supplied"))) 
NIL 
(|CubicalComplexFactory|) 
((|constructor|
  (NIL
   "Provides functions to construct various Cubical complexes. For more information see: http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/factory/"))
 (|kleinBottle|
  (((|FiniteCubicalComplex| (|Integer|)))
   "generate a cubical complex of the surface of a Klein bottle."))
 (|projectiveSpace|
  (((|FiniteCubicalComplex| (|Integer|)) (|NonNegativeInteger|))
   "Generate a cubical complex of the surface of a projective plane. A one sided surface which cannot be embedded in 3D space without intersecting itself. There are no external boundaries,{} every edge connects two faces. (A punctured projective plane is equivalent to a Moebius band)"))
 (|moebiusBand|
  (((|FiniteCubicalComplex| (|Integer|)))
   "Generate a cubical complex of the surface of a Moebius band. A one sided surface with a single external boundary line."))
 (|band|
  (((|FiniteCubicalComplex| (|Integer|)))
   "Generate a cubical complex of the surface of a cylinder without ends"))
 (|torusSurface|
  (((|FiniteCubicalComplex| (|Integer|)))
   "generate a cubical complex of the surface of an 3-dimensional torus."))
 (|sphereSurface|
  (((|FiniteCubicalComplex| (|Integer|)) (|NonNegativeInteger|))
   "Generate a cubical complex equivalent to the surface of a hyper-sphere. That is,{} the surface of a volume with no holes in it,{} so we use the faces of a single cube."))
 (|sphereSolid|
  (((|FiniteCubicalComplex| (|Integer|)) (|NonNegativeInteger|))
   "Generate a cubical complex equivalent to a solid hyper-sphere. That is,{} a solid volume with no holes in it,{} so we use a single \\spad{n}-dimensional cube."))) 
NIL 
(|CoerceVectorMatrixPackage| R) 
((|constructor|
  (NIL
   "CoerceVectorMatrixPackage: an unexposed,{} technical package for data conversions"))
 (|coerce|
  (((|Vector| (|Matrix| (|Fraction| (|Polynomial| |#1|))))
    (|Vector| (|Matrix| |#1|)))
   "\\spad{coerce(v)} coerces a vector \\spad{v} with entries in \\spadtype{Matrix R} as vector over \\spadtype{Matrix Fraction Polynomial R}"))
 (|coerceP|
  (((|Vector| (|Matrix| (|Polynomial| |#1|))) (|Vector| (|Matrix| |#1|)))
   "\\spad{coerceP(v)} coerces a vector \\spad{v} with entries in \\spadtype{Matrix R} as vector over \\spadtype{Matrix Polynomial R}"))) 
NIL 
(|CyclicGroup| |n| |g|) 
((|constructor| (NIL "A domain for finite cyclic groups."))
 (|exponent|
  (((|Integer|) $)
   "\\spad{exponent(g^k)} returns the representative integer \\$\\spad{k}\\$."))
 (|generator| (($) "\\spad{generator()} returns the generator."))) 
NIL 
(|CycleIndicators|) 
((|constructor| (NIL "Enumeration by cycle indices."))
 (|skewSFunction|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|List| (|Integer|))
    (|List| (|Integer|)))
   "\\spad{skewSFunction(li1,{} li2)} is the \\spad{S}-function \\indented{1}{of the partition difference \\spad{li1 - li2}} \\indented{1}{expressed in terms of power sum symmetric functions.}"))
 (|SFunction|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|List| (|Integer|)))
   "\\spad{SFunction(\\spad{li})} is the \\spad{S}-function of the partition \\spad{\\spad{li}} \\indented{1}{expressed in terms of power sum symmetric functions.}"))
 (|wreath|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|)))
    (|SymmetricPolynomial| (|Fraction| (|Integer|)))
    (|SymmetricPolynomial| (|Fraction| (|Integer|))))
   "\\spad{wreath(s1,{} s2)} is the cycle index of the wreath product \\indented{1}{of the two groups whose cycle indices are \\spad{s1} and} \\indented{1}{\\spad{s2}.}"))
 (|eval|
  (((|Fraction| (|Integer|)) (|SymmetricPolynomial| (|Fraction| (|Integer|))))
   "\\spad{eval s} is the sum of the coefficients of a cycle index."))
 (|cup|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|)))
    (|SymmetricPolynomial| (|Fraction| (|Integer|)))
    (|SymmetricPolynomial| (|Fraction| (|Integer|))))
   "\\spad{cup(s1,{} s2)},{} introduced by Redfield,{} \\indented{1}{is the scalar product of two cycle indices,{} in which the} \\indented{1}{power sums are retained to produce a cycle index.}"))
 (|cap|
  (((|Fraction| (|Integer|)) (|SymmetricPolynomial| (|Fraction| (|Integer|)))
    (|SymmetricPolynomial| (|Fraction| (|Integer|))))
   "\\spad{cap(s1,{} s2)},{} introduced by Redfield,{} \\indented{1}{is the scalar product of two cycle indices.}"))
 (|graphs|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{graphs n} is the cycle index of the group induced on \\indented{1}{the edges of a graph by applying the symmetric function to the} \\indented{1}{\\spad{n} nodes.}"))
 (|dihedral|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{dihedral n} is the cycle index of the \\indented{1}{dihedral group of degree \\spad{n}.}"))
 (|cyclic|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{cyclic n} is the cycle index of the \\indented{1}{cyclic group of degree \\spad{n}.}"))
 (|alternating|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{alternating n} is the cycle index of the \\indented{1}{alternating group of degree \\spad{n}.}"))
 (|elementary|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{elementary n} is the \\spad{n} th elementary symmetric \\indented{1}{function expressed in terms of power sums.}"))
 (|powerSum|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{powerSum n} is the \\spad{n} th power sum symmetric \\indented{1}{function.}"))
 (|complete|
  (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{complete n} is the \\spad{n} th complete homogeneous \\indented{1}{symmetric function expressed in terms of power sums.} \\indented{1}{Alternatively it is the cycle index of the symmetric} \\indented{1}{group of degree \\spad{n}.}"))) 
NIL 
(|CyclotomicUtilities|) 
((|constructor|
  (NIL
   "\\indented{1}{Author: \\spad{W}. Hebisch} References: \\indented{1}{A. Arnold,{} \\spad{M}. Monagan,{} Calculating cyclotomic polynomials,{}} \\indented{1}{Math. Comp. 80 (276) 2011,{} 2359-2379.}"))
 (|cocyclotomic_decomposition|
  (((|List| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|))
   "\\spad{cocyclotomic_decomposition(n)} computes list of irreducible factors of \\spad{x^n + 1} over integers."))
 (|cyclotomic_decomposition|
  (((|List| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|))
   "\\spad{cyclotomic_decomposition(n)} computes list of irreducible factors of \\spad{x^n - 1} over integers."))
 (|cyclotomic?|
  (((|Union| (|Integer|) "failed") (|SparseUnivariatePolynomial| (|Integer|)))
   "\\spad{cyclotomic?(p)} checks if \\spad{p} is a cyclotomic polynomial. If yes returns \\spad{n} such that \\spad{p = cyclotomic(n)}. Otherwise returns \"failed\"."))
 (|inverse_cyclotomic|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{inverse_cyclotomic(n)} computes \\spad{n}-th inverse cyclotomic polynomial,{} that is \\spad{(x^n - 1)/cyclotomic(n)}."))
 (|cyclotomic_array|
  (((|PrimitiveArray| (|Integer|)) (|Integer|))
   "\\spad{cyclotomic_array(n)} computes pa containing lower half of coefficients of \\spad{n}-th cyclotomic polynomial. maximal index in \\spad{pa} is \\spad{eulerPhi(n)/2}. Due to symmetry this is enough to reconstruct cyclotomic polynomial from computed coefficients."))
 (|cyclotomic|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{cyclotomic(n)} computes \\spad{n}-th cyclotomic polynomial."))) 
NIL 
(|CyclotomicPolynomialPackage|) 
((|constructor| (NIL "This package \\undocumented{}"))
 (|cyclotomicFactorization|
  (((|Factored| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|))
   "\\spad{cyclotomicFactorization(n)} returns prime factors of \\spad{x^n - 1} over integers."))
 (|cyclotomic|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{cyclotomic(n)} returns \\spad{n}-th cyclotomic polynomial,{} that is minimal polynomial over rationals of primitive \\spad{n}-th root of 1."))
 (|cyclotomicDecomposition|
  (((|List| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|))
   "\\spad{cyclotomicDecomposition(n)} returns prime factors of \\spad{x^n - 1} over integers."))) 
NIL 
(|Database| S) 
((|constructor|
  (NIL
   "\\indented{1}{This domain implements a simple view of a database whose fields are} indexed by symbols"))
 (|coerce|
  (($ (|List| |#1|)) "\\spad{coerce(l)} makes a database out of a list"))
 (-
  (($ $ $)
   "\\spad{db1-db2} returns the difference of databases \\spad{db1} and \\spad{db2} \\spadignore{i.e.} consisting of elements in \\spad{db1} but not in \\spad{db2}"))
 (+
  (($ $ $)
   "\\spad{db1+db2} returns the merge of databases \\spad{db1} and \\spad{db2}"))
 (|fullDisplay|
  (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{fullDisplay(db,{} start,{} end )} prints full details of entries in the range \\spad{start..end} in \\spad{db}.")
  (((|Void|) $)
   "\\spad{fullDisplay(db)} prints full details of each entry in \\spad{db}.")
  (((|Void|) $) "\\spad{fullDisplay(x)} displays \\spad{x} in detail"))
 (|display|
  (((|Void|) $)
   "\\spad{display(db)} prints a summary line for each entry in \\spad{db}.")
  (((|Void|) $) "\\spad{display(x)} displays \\spad{x} in some form"))
 (|elt|
  (((|DataList| (|String|)) $ (|Symbol|))
   "\\spad{elt(db,{} s)} returns the \\spad{s} field of each element of \\spad{db}.")
  (($ $ (|QueryEquation|))
   "\\spad{elt(db,{} q)} returns all elements of \\spad{db} which satisfy \\spad{q}.")
  (((|String|) $ (|Symbol|))
   "\\spad{elt(x,{} s)} returns an element of \\spad{x} indexed by \\spad{s}"))) 
NIL 
(|DoubleResultantPackage| F UP UPUP R) 
((|constructor|
  (NIL
   "This package provides functions for computing the residues of a function on an algebraic curve."))
 (|doubleResultant|
  ((|#2| |#4| (|Mapping| |#2| |#2|))
   "\\spad{doubleResultant(f,{} ')} returns \\spad{p}(\\spad{x}) whose roots are rational multiples of the residues of \\spad{f} at all its finite poles. Argument ' is the derivation to use."))) 
NIL 
(|Dcpo| S) 
((|constructor|
  (NIL
   "Directed-complete partial order,{} partial order that is guaranteed to have a join of any two elements. For more documentation see: \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (|join|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "returns the join of 'a' and \\spad{'b'} In this version of join nodes are represented as index values. Not every poset will have a join but DCPO will."))) 
NIL 
(|DistinctDegreeFactorize| F FP) 
((|constructor|
  (NIL
   "Package for the factorization of a univariate polynomial with coefficients in a finite field. The algorithm used is the \"distinct degree\" algorithm of Cantor-Zassenhaus,{} modified to use trace instead of the norm and a table for computing Frobenius as suggested by Naudin and Quitte ."))
 (|irreducible?|
  (((|Boolean|) |#2|)
   "\\spad{irreducible?(p)} tests whether the polynomial \\spad{p} is irreducible."))
 (|tracePowMod|
  ((|#2| |#2| (|NonNegativeInteger|) |#2|)
   "\\spad{tracePowMod(u,{} k,{} v)} produces the sum of \\spad{u^(q^i)} for \\spad{i} running and \\spad{q=} size \\spad{F}"))
 (|trace2PowMod|
  ((|#2| |#2| (|NonNegativeInteger|) |#2|)
   "\\spad{trace2PowMod(u,{} k,{} v)} produces the sum of \\spad{u^(2^i)} for \\spad{i} running from 1 to \\spad{k} all computed modulo the polynomial \\spad{v}."))
 (|exptMod|
  ((|#2| |#2| (|NonNegativeInteger|) |#2|)
   "\\spad{exptMod(u,{} k,{} v)} raises the polynomial \\spad{u} to the \\spad{k}th power modulo the polynomial \\spad{v}."))
 (|separateFactors|
  (((|List| |#2|)
    (|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |prod| |#2|))))
   "\\spad{separateFactors(lfact)} takes the list produced by \\spadfunFrom{separateDegrees}{DistinctDegreeFactorization} and produces the complete list of factors."))
 (|separateDegrees|
  (((|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |prod| |#2|)))
    |#2|)
   "\\spad{separateDegrees(p)} splits the square free polynomial \\spad{p} into factors each of which is a product of irreducibles of the same degree."))
 (|distdfact|
  (((|Record| (|:| |cont| |#1|)
              (|:| |factors|
                   (|List|
                    (|Record| (|:| |irr| |#2|)
                              (|:| |pow| (|NonNegativeInteger|))))))
    |#2| (|Boolean|))
   "\\spad{distdfact(p,{} sqfrflag)} produces the complete factorization of the polynomial \\spad{p} returning an internal data structure. If argument sqfrflag is \\spad{true},{} the polynomial is assumed square free."))
 (|factorSquareFree|
  (((|Factored| |#2|) |#2|)
   "\\spad{factorSquareFree(p)} produces the complete factorization of the square free polynomial \\spad{p}."))
 (|factor|
  (((|Factored| |#2|) |#2|)
   "\\spad{factor(p)} produces the complete factorization of the polynomial \\spad{p}."))) 
NIL 
(|DecimalExpansion|) 
((|constructor|
  (NIL
   "This domain allows rational numbers to be presented as repeating decimal expansions."))
 (|decimal|
  (($ (|Fraction| (|Integer|)))
   "\\spad{decimal(r)} converts a rational number to a decimal expansion."))
 (|fractionPart|
  (((|Fraction| (|Integer|)) $)
   "\\spad{fractionPart(d)} returns the fractional part of a decimal expansion."))
 (|coerce|
  (((|RadixExpansion| 10) $)
   "\\spad{coerce(d)} converts a decimal expansion to a radix expansion with base 10.")
  (((|Fraction| (|Integer|)) $)
   "\\spad{coerce(d)} converts a decimal expansion to a rational number."))) 
((|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|RealConstant|))
 (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|StepThrough|))
 (|HasCategory| (|Integer|) (LIST '|InnerEvalable| '(|Symbol|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Eltable| '(|Integer|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|DifferentialRing|))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegerNumberSystem|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|Integer|) '(|CharacteristicNonZero|)))) 
(|ElementaryFunctionDefiniteIntegration| R F) 
((|constructor|
  (NIL
   "\\spadtype{ElementaryFunctionDefiniteIntegration} provides functions to compute definite integrals of elementary functions."))
 (|innerint|
  (((|Union| (|:| |f1| (|OrderedCompletion| |#2|))
             (|:| |f2| (|List| (|OrderedCompletion| |#2|)))
             (|:| |fail| #1="failed") (|:| |pole| #2="potentialPole"))
    |#2| (|Symbol|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|)
    (|Boolean|))
   "\\spad{innerint(f,{} x,{} a,{} b,{} ignore?)} should be local but conditional"))
 (|integrate|
  (((|Union| (|:| |f1| (|OrderedCompletion| |#2|))
             (|:| |f2| (|List| (|OrderedCompletion| |#2|))) (|:| |fail| #1#)
             (|:| |pole| #2#))
    |#2| (|SegmentBinding| (|OrderedCompletion| |#2|)) (|String|))
   "\\spad{integrate(f,{} x = a..b,{} \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters),{} then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".")
  (((|Union| (|:| |f1| (|OrderedCompletion| |#2|))
             (|:| |f2| (|List| (|OrderedCompletion| |#2|))) (|:| |fail| #1#)
             (|:| |pole| #2#))
    |#2| (|SegmentBinding| (|OrderedCompletion| |#2|)))
   "\\spad{integrate(f,{} x = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b}."))) 
NIL 
(|RationalFunctionDefiniteIntegration| R) 
((|constructor|
  (NIL
   "\\spadtype{RationalFunctionDefiniteIntegration} provides functions to compute definite integrals of rational functions."))
 (|integrate|
  (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|)))
             (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|))))
             (|:| |fail| #1="failed") (|:| |pole| #2="potentialPole"))
    (|Fraction| (|Polynomial| |#1|))
    (|SegmentBinding| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))))
    (|String|))
   "\\spad{integrate(f,{} x = a..b,{} \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters),{} then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".")
  (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|)))
             (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|))))
             (|:| |fail| #1#) (|:| |pole| #2#))
    (|Fraction| (|Polynomial| |#1|))
    (|SegmentBinding| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))))
   "\\spad{integrate(f,{} x = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b}.")
  (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|)))
             (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|))))
             (|:| |fail| #1#) (|:| |pole| #2#))
    (|Fraction| (|Polynomial| |#1|))
    (|SegmentBinding| (|OrderedCompletion| (|Expression| |#1|))) (|String|))
   "\\spad{integrate(f,{} x = a..b,{} \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters),{} then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".")
  (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|)))
             (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|))))
             (|:| |fail| #1#) (|:| |pole| #2#))
    (|Fraction| (|Polynomial| |#1|))
    (|SegmentBinding| (|OrderedCompletion| (|Expression| |#1|))))
   "\\spad{integrate(f,{} x = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b}. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b}."))) 
NIL 
(|DegreeReductionPackage| R1 R2) 
((|constructor| (NIL "This package \\undocumented{}"))
 (|cyclotomic_roots|
  (((|List| (|Expression| |#2|)) (|PositiveInteger|))
   "\\spad{cyclotomic_roots(n)} returns list of roots of \\spad{n}-th cyclotomic polynomial."))
 (|expand|
  (((|List| (|Expression| |#2|)) (|Expression| |#2|) (|PositiveInteger|))
   "\\spad{expand(f,{} n)} returns list of all solutions \\spad{y} to equation \\spad{y^n} = \\spad{f}"))
 (|reduce|
  (((|Record| (|:| |pol| (|SparseUnivariatePolynomial| |#1|))
              (|:| |deg| (|PositiveInteger|)))
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{reduce(p)} returns [\\spad{q},{} \\spad{d}] such that \\spad{p}(\\spad{x}) = \\spad{q}(\\spad{x^d}) and \\spad{d} is maximal with this property"))) 
NIL 
(|DeltaComplex| VS) 
((|constructor|
  (NIL
   "\\indented{2}{Similar to Simplicial Complex but faces (edges,{} triangles,{} etc.)} \\indented{2}{are indexed by 'face maps' into the next lower face map until} \\indented{2}{we get down to the vertices.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/delta/} Date Created: Feb 2016 Basic Operations: Related packages: Related categories: Related Domains: FiniteSimplicialComplex is a simpler and more \\indented{3}{compact representation which can be used if edges,{} triangles,{}} \\indented{3}{etc. don\\spad{'t} need to be indexed.} Also See: AMS Classifications:"))
 (|coerce|
  (((|FiniteSimplicialComplex| |#1|) $)
   "\\spad{coerce DeltaComplex} to FiniteSimplicialComplex"))
 (|coHomology|
  (((|List| (|Homology|)) $) "calculate cohomology using SmithNormalForm"))
 (|homology|
  (((|List| (|Homology|)) $) "calculate homology using SmithNormalForm"))
 (|fundamentalGroup|
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|))
   "Generates fundamental group from this simplicial complex.")
  (((|GroupPresentation|) $)
   "Generates fundamental group from this simplicial complex."))
 (|oneSkeleton|
  (((|UndirectedGraph| (|NonNegativeInteger|)) $)
   "generates graph AKA 1-skeleton"))
 (|coChain|
  (((|CoChainComplex| |#1|) $)
   "returns a matrix sequence representing the face maps in linear algebra form"))
 (|chain|
  (((|ChainComplex|) $)
   "returns a matrix sequence representing the face maps in linear algebra form"))
 (|faceMap|
  (((|List| (|List| (|Integer|))) $ (|NonNegativeInteger|))
   "returns an individual face map specified by \\spad{n}. Where \\spad{'n'} is the dimension required,{} so \\spad{n=1} returns one dimensional faces (edges),{} \\spad{n=2} returns two dimensional faces (triamgles),{} and so on. used by fundamentalGroup."))
 (|triangle|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "a simplicial complex with one triangle"))
 (|link|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "a simplicial complex with one link"))
 (|deltaComplex|
  (($ (|FiniteCubicalComplex| |#1|))
   "construct from FiniteCubicalComplex. This builds indexes of edges,{} squares and so on.")
  (($ (|FiniteSimplicialComplex| |#1|))
   "construct from FiniteSimplicialComplex. This builds indexes of edges,{} triangles and so on.")
  (($ (|List| |#1|) (|NonNegativeInteger|)
    (|List| (|List| (|List| (|Integer|)))))
   "constructor where the simplices are supplied"))) 
NIL 
(|DeltaComplexFactory| VS) 
((|constructor|
  (NIL
   "Provides functions to construct various minimal delta complexes which can be smaller than if constructed from SimplicialComplexes."))
 (|kleinBottle| (((|DeltaComplex| |#1|)) "generate a minimal Klein bottle."))
 (|projectiveSpace|
  (((|DeltaComplex| |#1|) (|Integer|)) "Generate a minimal projective space."))
 (|torusSurface|
  (((|DeltaComplex| |#1|)) "generate a minimal 3-dimensional torus surface."))
 (|dunceHat|
  (((|DeltaComplex| |#1|)) "generate a minimal dunceHat from 3 edges."))
 (|circle|
  (((|DeltaComplex| |#1|))
   "Generate a minimal circle from an edge from vertex A to A."))) 
NIL 
(|Dequeue| S) 
((|constructor| (NIL "Linked list implementation of a Dequeue"))
 (|dequeue|
  (($ (|List| |#1|))
   "\\spad{dequeue([x,{} y,{} ...,{} z])} creates a dequeue with first (top or front) element \\spad{x},{} second element \\spad{y},{} ...,{} and last (bottom or back) element \\spad{z}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|DeRhamComplex| |CoefRing| |listIndVar|) 
((|constructor|
  (NIL
   "The deRham complex of Euclidean space,{} that is,{} the class of differential forms of arbitrary degree over a coefficient ring. See Flanders,{} Harley,{} Differential Forms,{} With Applications to the Physical Sciences,{} New York,{} Academic Press,{} 1963."))
 (|exteriorDifferential|
  (($ $)
   "\\spad{exteriorDifferential(df)} returns the exterior derivative (gradient,{} curl,{} divergence,{} ...) of the differential form \\spad{df}."))
 (|totalDifferential|
  (($ (|Expression| |#1|))
   "\\spad{totalDifferential(x)} returns the total differential (gradient) form for element \\spad{x}."))
 (|map|
  (($ (|Mapping| (|Expression| |#1|) (|Expression| |#1|)) $)
   "\\spad{map(f,{} df)} replaces each coefficient \\spad{x} of differential form \\spad{df} by \\spad{f(x)}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(df)} returns the homogeneous degree of differential form \\spad{df}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(df)} tests if differential form \\spad{df} is a 0-form,{} \\spadignore{i.e.} if degree(\\spad{df}) = 0."))
 (|homogeneous?|
  (((|Boolean|) $)
   "\\spad{homogeneous?(df)} tests if all of the terms of differential form \\spad{df} have the same degree."))
 (|generator|
  (($ (|NonNegativeInteger|))
   "\\spad{generator(n)} returns the \\spad{n}th basis term for a differential form."))
 (|coefficient|
  (((|Expression| |#1|) $ $)
   "\\spad{coefficient(df,{} u)},{} where \\spad{df} is a differential form,{} returns the coefficient of \\spad{df} containing the basis term \\spad{u} if such a term exists,{} and 0 otherwise."))
 (|reductum|
  (($ $)
   "\\spad{reductum(df)},{} where \\spad{df} is a differential form,{} returns \\spad{df} minus the leading term of \\spad{df} if \\spad{df} has two or more terms,{} and 0 otherwise."))
 (|leadingBasisTerm|
  (($ $)
   "\\spad{leadingBasisTerm(df)} returns the leading basis term of differential form \\spad{df}."))
 (|leadingCoefficient|
  (((|Expression| |#1|) $)
   "\\spad{leadingCoefficient(df)} returns the leading coefficient of differential form \\spad{df}."))) 
NIL 
(|DoubleFloatElementaryFunctions|) 
NIL 
NIL 
(|DefiniteIntegrationTools| R F) 
((|constructor|
  (NIL
   "\\spadtype{DefiniteIntegrationTools} provides common tools used by the definite integration of both rational and elementary functions."))
 (|checkForZero|
  (((|Union| (|Boolean|) "failed") (|SparseUnivariatePolynomial| |#2|)
    (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|))
   "\\spad{checkForZero(p,{} a,{} b,{} incl?)} is \\spad{true} if \\spad{p} has a zero between a and \\spad{b},{} \\spad{false} otherwise,{} \"failed\" if this cannot be determined. Check for a and \\spad{b} inclusive if incl? is \\spad{true},{} exclusive otherwise.")
  (((|Union| (|Boolean|) "failed") (|Polynomial| |#1|) (|Symbol|)
    (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|))
   "\\spad{checkForZero(p,{} x,{} a,{} b,{} incl?)} is \\spad{true} if \\spad{p} has a zero for \\spad{x} between a and \\spad{b},{} \\spad{false} otherwise,{} \"failed\" if this cannot be determined. Check for a and \\spad{b} inclusive if incl? is \\spad{true},{} exclusive otherwise."))
 (|computeInt|
  (((|Union| (|OrderedCompletion| |#2|) "failed") (|Kernel| |#2|) |#2|
    (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|))
   "\\spad{computeInt(x,{} g,{} a,{} b,{} eval?)} returns the integral of \\spad{f} for \\spad{x} between a and \\spad{b},{} assuming that \\spad{g} is an indefinite integral of \\spad{f} and \\spad{f} has no pole between a and \\spad{b}. If \\spad{eval?} is \\spad{true},{} then \\spad{g} can be evaluated safely at \\spad{a} and \\spad{b},{} provided that they are finite values. Otherwise,{} limits must be computed."))
 (|ignore?|
  (((|Boolean|) (|String|))
   "\\spad{ignore?(s)} is \\spad{true} if \\spad{s} is the string that tells the integrator to assume that the function has no pole in the integration interval."))) 
NIL 
(|DoubleFloat|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{DoubleFloat} is intended to make accessible} hardware floating point arithmetic in \\Language{},{} either native double precision,{} or IEEE. On most machines,{} there will be hardware support for the arithmetic operations: \\spadfunFrom{+}{DoubleFloat},{} \\spadfunFrom{*}{DoubleFloat},{} \\spadfunFrom{/}{DoubleFloat} and possibly also the \\spadfunFrom{sqrt}{DoubleFloat} operation. The operations \\spadfunFrom{exp}{DoubleFloat},{} \\spadfunFrom{log}{DoubleFloat},{} \\spadfunFrom{sin}{DoubleFloat},{} \\spadfunFrom{cos}{DoubleFloat},{} \\spadfunFrom{atan}{DoubleFloat} are normally coded in software based on minimax polynomial/rational approximations. Some general comments about the accuracy of the operations: the operations \\spadfunFrom{+}{DoubleFloat},{} \\spadfunFrom{*}{DoubleFloat},{} \\spadfunFrom{/}{DoubleFloat} and \\spadfunFrom{sqrt}{DoubleFloat} are expected to be fully accurate. The operations \\spadfunFrom{exp}{DoubleFloat},{} \\spadfunFrom{log}{DoubleFloat},{} \\spadfunFrom{sin}{DoubleFloat},{} \\spadfunFrom{cos}{DoubleFloat} and \\spadfunFrom{atan}{DoubleFloat} are not expected to be fully accurate. In particular,{} \\spadfunFrom{sin}{DoubleFloat} and \\spadfunFrom{cos}{DoubleFloat} will lose all precision for large arguments. \\blankline The \\spadtype{Float} domain provides an alternative to the \\spad{DoubleFloat} domain. It provides an arbitrary precision model of floating point arithmetic. This means that accuracy problems like those above are eliminated by increasing the working precision where necessary. \\spadtype{Float} provides some special functions such as \\spadfunFrom{erf}{\\spad{DoubleFloatSpecialFunctions2}},{} the error function in addition to the elementary functions. The disadvantage of \\spadtype{Float} is that it is much more expensive than small floats when the latter can be used."))
 (|rationalApproximation|
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n,{} b)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< b^(-n)} (that is,{} \\spad{|(r-f)/f| < b^(-n)}).")
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< 10^(-n)}."))
 (|doubleFloatFormat|
  (((|String|) (|String|))
   "change the output format for doublefloats using lisp format strings"))
 (|qsqrt|
  (($ $)
   "\\spad{qsqrt(x)} computes square root of \\spad{x}. It assumes that \\spad{x >= 0}."))
 (|qlog|
  (($ $)
   "\\spad{qlog(x)} computes natural logarithm of \\spad{x}. It assumes that \\spad{x > 0}."))
 (|atan|
  (($ $ $)
   "\\spad{atan(x,{} y)} computes the arc tangent from \\spad{x} with phase \\spad{y}."))
 (|log10|
  (($ $)
   "\\spad{log10(x)} computes the logarithm with base 10 for \\spad{x}."))
 (|log2|
  (($ $) "\\spad{log2(x)} computes the logarithm with base 2 for \\spad{x}."))
 (|exp1|
  (($) "\\spad{exp1()} returns the natural log base \\spad{2.718281828...}."))) 
((|HasCategory| $ '(|arbitraryPrecision|))
 (AND (|not| (|HasCategory| $ '(|arbitraryExponent|)))
      (|not| (|HasCategory| $ '(|arbitraryPrecision|))))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))) 
(|DoubleFloatMatrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|DoubleFloat|) '(|Comparable|))
 (|HasCategory| (|DoubleFloat|) '(|OrderedSet|))
 (|HasCategory| (|DoubleFloat|) '(|BasicType|))
 (|HasCategory| (|DoubleFloat|) '(|SetCategory|))
 (OR (|HasCategory| (|DoubleFloat|) '(|BasicType|))
     (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (OR (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (AND (|HasCategory| (|DoubleFloat|) (LIST '|Evalable| '(|DoubleFloat|)))
      (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|DoubleFloat|) (LIST '|Evalable| '(|DoubleFloat|)))
       (|HasCategory| (|DoubleFloat|) '(|Comparable|)))
  (AND (|HasCategory| (|DoubleFloat|) (LIST '|Evalable| '(|DoubleFloat|)))
       (|HasCategory| (|DoubleFloat|) '(|SetCategory|))))
 (|HasCategory| (|DoubleFloat|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|DoubleFloat|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|DoubleFloat|) (LIST '|Evalable| '(|DoubleFloat|)))
          (|HasCategory| (|DoubleFloat|) '(|SetCategory|))))
 (|HasCategory| (|DoubleFloat|) '(|AbelianGroup|))
 (|HasCategory| (|DoubleFloat|) '(|SemiRng|))
 (AND (|HasCategory| (|DoubleFloat|) '(|Monoid|))
      (|HasCategory| (|DoubleFloat|) '(|SemiRng|)))
 (|HasCategory| (|DoubleFloat|) '(|EuclideanDomain|))
 (|HasCategory| (|DoubleFloat|) '(|IntegralDomain|))
 (|HasCategory| (|DoubleFloat|) '(|CommutativeRing|))
 (|HasCategory| (|DoubleFloat|) '(|Field|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|DoubleFloat|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|BasicType|)))
  (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))) 
(|DoubleFloatSpecialFunctions|) 
((|constructor|
  (NIL
   "This package provides special functions for double precision real and complex floating point."))
 (|besselK|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{besselK(v,{} x)} is the modified Bessel function of the second kind,{} \\spad{K(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.} Note: The default implementation uses the relation \\indented{2}{\\spad{K(v,{} x) = \\%pi/2*(I(-v,{} x) - I(v,{} x))/sin(v*\\%\\spad{pi})}} so is not valid for integer values of \\spad{v}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{besselK(v,{} x)} is the modified Bessel function of the second kind,{} \\spad{K(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.} Note: The default implementation uses the relation \\indented{2}{\\spad{K(v,{} x) = \\%pi/2*(I(-v,{} x) - I(v,{} x))/sin(v*\\%\\spad{pi})}.} so is not valid for integer values of \\spad{v}."))
 (|besselI|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{besselI(v,{} x)} is the modified Bessel function of the first kind,{} \\spad{I(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.}")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{besselI(v,{} x)} is the modified Bessel function of the first kind,{} \\spad{I(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.}"))
 (|besselY|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{besselY(v,{} x)} is the Bessel function of the second kind,{} \\spad{Y(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.} Note: The default implementation uses the relation \\indented{2}{\\spad{Y(v,{} x) = (J(v,{} x) cos(v*\\%\\spad{pi}) - J(-v,{} x))/sin(v*\\%\\spad{pi})}} so is not valid for integer values of \\spad{v}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{besselY(v,{} x)} is the Bessel function of the second kind,{} \\spad{Y(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.} Note: The default implementation uses the relation \\indented{2}{\\spad{Y(v,{} x) = (J(v,{} x) cos(v*\\%\\spad{pi}) - J(-v,{} x))/sin(v*\\%\\spad{pi})}} so is not valid for integer values of \\spad{v}."))
 (|besselJ|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{besselJ(v,{} x)} is the Bessel function of the first kind,{} \\spad{J(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.}")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{besselJ(v,{} x)} is the Bessel function of the first kind,{} \\spad{J(v,{} x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.}"))
 (|polygamma|
  (((|Complex| (|DoubleFloat|)) (|NonNegativeInteger|)
    (|Complex| (|DoubleFloat|)))
   "\\spad{polygamma(n,{} x)} is the \\spad{n}-th derivative of \\spad{digamma(x)}."))
 (|digamma|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{digamma(x)} is the function,{} \\spad{psi(x)},{} defined by \\indented{2}{\\spad{psi(x) = Gamma'(x)/Gamma(x)}.}"))) 
NIL 
(|DoubleFloatSpecialFunctions2|) 
NIL 
NIL 
(|DoubleFloatVector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))
 (|qnew|
  (($ (|Integer|))
   "\\spad{qnew(n)} creates a new uninitialized vector of length \\spad{n}."))) 
((|HasCategory| (|DoubleFloat|) '(|OrderedSet|))
 (|HasCategory| (|DoubleFloat|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|DoubleFloat|) '(|BasicType|))
 (|HasCategory| (|DoubleFloat|) '(|Comparable|))
 (OR (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
 (|HasCategory| (|DoubleFloat|) '(|SetCategory|))
 (AND (|HasCategory| (|DoubleFloat|) (LIST '|Evalable| '(|DoubleFloat|)))
      (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (OR (|HasCategory| (|DoubleFloat|) '(|BasicType|))
     (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|OrderedSet|))
     (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (OR (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|OrderedSet|))
     (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (|HasCategory| (|DoubleFloat|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|DoubleFloat|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|DoubleFloat|) '(|Comparable|))
     (|HasCategory| (|DoubleFloat|) '(|OrderedSet|))
     (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (|HasCategory| (|DoubleFloat|) '(|AbelianSemiGroup|))
 (|HasCategory| (|DoubleFloat|) '(|AbelianMonoid|))
 (|HasCategory| (|DoubleFloat|) '(|AbelianGroup|))
 (|HasCategory| (|DoubleFloat|) '(|SemiGroup|))
 (AND (|HasCategory| (|DoubleFloat|) '(|AbelianMonoid|))
      (|HasCategory| (|DoubleFloat|) '(|SemiRng|)))
 (|HasCategory| (|DoubleFloat|) '(|Ring|))
 (AND (|HasCategory| (|DoubleFloat|) '(|RadicalCategory|))
      (|HasCategory| (|DoubleFloat|) '(|Ring|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|DoubleFloat|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
  (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
  (|HasCategory| (|DoubleFloat|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|DoubleFloat|) '(|OrderedSet|)))
  (|HasCategory| (|DoubleFloat|) '(|SetCategory|)))) 
(|DirectedGraph| S) 
((|constructor|
  (NIL
   "Category of directed graphs,{} allows us to model graph theory \\blankline"))
 (|coerce| (($ (|List| |#1|)) "\\spad{coerce List} to graph")
           (($ (|FinitePoset| |#1|)) "\\spad{coerce FinitePoset} to graph")
           (($ (|PermutationGroup| |#1|))
            "\\spad{coerce PermutationGroup} to graph"))
 (~
  (($ $)
   "The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http://en.wikipedia.org/wiki/Complement_graph"))
 (|closedCartesian|
  (($ $ $ (|Mapping| |#1| |#1| |#1|))
   "\\spad{closedCartesian(a,{} b,{} f)} builds Cartesian product of a and \\spad{b} and then maps it back to \\% using \\spad{f}."))
 (|closedTensor|
  (($ $ $ (|Mapping| |#1| |#1| |#1|))
   "\\spad{closedTensor(a,{} b,{} f)} builds tensor product of a and \\spad{b} and then maps it back to \\% using \\spad{f}."))
 (|cartesian|
  (((|DirectedGraph| (|Product| |#1| |#1|)) $ $)
   "\\spad{cartesian(a,{} b)} returns a Cartesian product: the vertex set of \\spad{G} \\spad{o} \\spad{H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}) and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) \\indented{1}{are adjacent in \\spad{G} \\spad{o} \\spad{H} if and only if either} \\spad{u} = \\spad{v} and u' is adjacent with \\spad{v'} in \\spad{H},{} or u' = \\spad{v'} and \\spad{u} is adjacent with \\spad{v} in \\spad{G}."))
 (*
  (((|DirectedGraph| (|Product| |#1| |#1|)) $ $)
   "\\spad{\"*\"}(a,{}\\spad{b}) returns a tensor product : the tensor product \\spad{G*H} of graphs \\spad{G} and \\spad{H} is a graph such that the vertex set of \\spad{G*H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}); and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) are adjacent in \\spad{G} \\times \\spad{H} if and only if u' is adjacent with \\spad{v'} and \\spad{u} is adjacent with \\spad{v}."))
 (|directedGraph|
  (($ (|FinitePoset| |#1|))
   "\\spad{directedGraph(poset)} constructs graph from a partially ordered set. This will be a graph with,{} at most,{} one arrow between any two nodes.")
  (($ (|List| (|Permutation| |#1|)))
   "\\spad{directedGraph(perms)} constructs graph from a list of permutations: \\spad{perms}.")
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "\\spad{directedGraph(ob,{} am)} constructs graph with objects \\spad{ob} and adjacency matrix am.")
  (($ (|List| |#1|)
    (|List|
     (|Record| (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)))))
   "\\spad{directedGraph(obs,{} ars)} constructs graph with objects \\spad{obs} and arrows ars. This constructor just has pure abstract graph information without decoration information.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "\\spad{directedGraph(ob,{} ar)} constructs graph with objects \\spad{ob} and arrows ar,{} more objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|)))))
   "\\spad{directedGraph(ob)} is a constructor for graph with given objects \\spad{ob},{} more objects and arrows can be added later if required.")
  (($ (|List| |#1|))
   "\\spad{directedGraph(ob)} is a constructor for graph with given list of object names and no arrows. Use this version of the constructor if you don\\spad{'t} want to create specific \\spad{x},{} \\spad{y} coordinates. more objects and arrows can be added later if required."))) 
NIL 
(|DenavitHartenbergMatrix| R) 
((|constructor|
  (NIL
   "\\indented{1}{A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:} \\indented{1}{\\spad{nx ox ax px}} \\indented{1}{\\spad{ny oy ay py}} \\indented{1}{\\spad{nz oz az pz}} \\indented{2}{\\spad{0\\space{2}0\\space{2}0\\space{2}1}} (\\spad{n},{} \\spad{o},{} and a are the direction cosines)"))
 (|translate|
  (($ |#1| |#1| |#1|)
   "\\spad{translate(X,{} Y,{} Z)} returns a dhmatrix for translation by \\spad{X},{} \\spad{Y},{} and \\spad{Z}"))
 (|scale|
  (($ |#1| |#1| |#1|)
   "\\spad{scale(sx,{} sy,{} sz)} returns a dhmatrix for scaling in the \\spad{X},{} \\spad{Y} and \\spad{Z} directions"))
 (|rotatez|
  (($ |#1|)
   "\\spad{rotatez(r)} returns a dhmatrix for rotation about axis \\spad{Z} for \\spad{r} degrees"))
 (|rotatey|
  (($ |#1|)
   "\\spad{rotatey(r)} returns a dhmatrix for rotation about axis \\spad{Y} for \\spad{r} degrees"))
 (|rotatex|
  (($ |#1|)
   "\\spad{rotatex(r)} returns a dhmatrix for rotation about axis \\spad{X} for \\spad{r} degrees"))
 (|identity| (($) "\\spad{identity()} create the identity dhmatrix"))
 (*
  (((|Point| |#1|) $ (|Point| |#1|))
   "\\spad{t*p} applies the dhmatrix \\spad{t} to point \\spad{p}"))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRng|))
 (AND (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|Dictionary&| A S) 
((|constructor|
  (NIL
   "A dictionary is an aggregate in which entries can be inserted,{} searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones."))) 
NIL 
(|Dictionary| S) 
((|constructor|
  (NIL
   "A dictionary is an aggregate in which entries can be inserted,{} searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones."))) 
NIL 
(|DifferentialExtension&| S R) 
((|constructor|
  (NIL
   "Differential extensions of a ring \\spad{R}. Given a differentiation on \\spad{R},{} extend it to a differentiation on \\%."))
 (D
  (($ $ (|Mapping| |#2| |#2|) (|NonNegativeInteger|))
   "\\spad{D(x,{} deriv,{} n)} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R}.")
  (($ $ (|Mapping| |#2| |#2|))
   "\\spad{D(x,{} deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R}."))
 (|differentiate|
  (($ $ (|Mapping| |#2| |#2|) (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} deriv,{} n)} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R}.")
  (($ $ (|Mapping| |#2| |#2|))
   "\\spad{differentiate(x,{} deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R}."))) 
((|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))) 
(|DifferentialExtension| R) 
((|constructor|
  (NIL
   "Differential extensions of a ring \\spad{R}. Given a differentiation on \\spad{R},{} extend it to a differentiation on \\%."))
 (D
  (($ $ (|Mapping| |#1| |#1|) (|NonNegativeInteger|))
   "\\spad{D(x,{} deriv,{} n)} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R}.")
  (($ $ (|Mapping| |#1| |#1|))
   "\\spad{D(x,{} deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R}."))
 (|differentiate|
  (($ $ (|Mapping| |#1| |#1|) (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} deriv,{} n)} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R}.")
  (($ $ (|Mapping| |#1| |#1|))
   "\\spad{differentiate(x,{} deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R}."))) 
NIL 
(|DifferentialRing&| S) 
((|constructor|
  (NIL
   "An ordinary differential ring,{} that is,{} a ring with an operation \\spadfun{differentiate}. \\blankline"))
 (D
  (($ $ (|NonNegativeInteger|))
   "\\spad{D(x,{} n)} returns the \\spad{n}-th derivative of \\spad{x}.")
  (($ $)
   "\\spad{D(x)} returns the derivative of \\spad{x}. This function is a simple differential operator where no variable needs to be specified."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} n)} returns the \\spad{n}-th derivative of \\spad{x}.")
  (($ $)
   "\\spad{differentiate(x)} returns the derivative of \\spad{x}. This function is a simple differential operator where no variable needs to be specified."))) 
NIL 
(|DifferentialRing|) 
((|constructor|
  (NIL
   "An ordinary differential ring,{} that is,{} a ring with an operation \\spadfun{differentiate}. \\blankline"))
 (D
  (($ $ (|NonNegativeInteger|))
   "\\spad{D(x,{} n)} returns the \\spad{n}-th derivative of \\spad{x}.")
  (($ $)
   "\\spad{D(x)} returns the derivative of \\spad{x}. This function is a simple differential operator where no variable needs to be specified."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} n)} returns the \\spad{n}-th derivative of \\spad{x}.")
  (($ $)
   "\\spad{differentiate(x)} returns the derivative of \\spad{x}. This function is a simple differential operator where no variable needs to be specified."))) 
NIL 
(|DihedralGroup| |n| |a| |b|) 
((|constructor|
  (NIL
   "\\spad{DihedralGroup(n,{} a,{} b)} is the dihedral group generated by a rotation a of order \\spad{n} and a reflection \\spad{b}."))
 (|exponentb|
  (((|Integer|) $)
   "\\spad{exponentb(x)} returns the exponent of the reflection \\spad{b} in the normal form of \\spad{x} as integer"))
 (|exponenta|
  (((|Integer|) $)
   "\\spad{exponenta(x)} returns the exponent of the rotation a in the normal form of \\spad{x} as integer"))
 (|expb|
  (((|IntegerMod| 2) $)
   "\\spad{expa(x)} returns the exponent of the reflection \\spad{b} in the normal form of \\spad{x}"))
 (|expa|
  (((|IntegerMod| |#1|) $)
   "\\spad{expa(x)} returns the exponent of the rotation a in the normal form of \\spad{x}"))) 
NIL 
(|DictionaryOperations&| A S) 
((|constructor|
  (NIL
   "This category is a collection of operations common to both categories \\spadtype{Dictionary} and \\spadtype{MultiDictionary}"))
 (|select!|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{select!(p,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\spad{p(x)} is not \\spad{true}."))
 (|remove!|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{remove!(p,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\spad{p(x)} is \\spad{true}.")
  (($ |#2| $)
   "\\spad{remove!(x,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{y} such that \\spad{y = x}."))
 (|dictionary|
  (($ (|List| |#2|))
   "\\spad{dictionary([x,{} y,{} ...,{} z])} creates a dictionary consisting of entries \\spad{x,{} y,{} ...,{} z}.")
  (($)
   "\\spad{dictionary()}\\$\\spad{D} creates an empty dictionary of type \\spad{D}."))) 
((|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#1| '(|finiteAggregate|))) 
(|DictionaryOperations| S) 
((|constructor|
  (NIL
   "This category is a collection of operations common to both categories \\spadtype{Dictionary} and \\spadtype{MultiDictionary}"))
 (|select!|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{select!(p,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\spad{p(x)} is not \\spad{true}."))
 (|remove!|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{remove!(p,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\spad{p(x)} is \\spad{true}.")
  (($ |#1| $)
   "\\spad{remove!(x,{} d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{y} such that \\spad{y = x}."))
 (|dictionary|
  (($ (|List| |#1|))
   "\\spad{dictionary([x,{} y,{} ...,{} z])} creates a dictionary consisting of entries \\spad{x,{} y,{} ...,{} z}.")
  (($)
   "\\spad{dictionary()}\\$\\spad{D} creates an empty dictionary of type \\spad{D}."))) 
NIL 
(|DiophantineSolutionPackage|) 
((|constructor|
  (NIL
   "any solution of a homogeneous linear Diophantine equation can be represented as a sum of minimal solutions,{} which form a \"basis\" (a minimal solution cannot be represented as a nontrivial sum of solutions) in the case of an inhomogeneous linear Diophantine equation,{} each solution is the sum of a inhomogeneous solution and any number of homogeneous solutions therefore,{} it suffices to compute two sets: \\indented{3}{1. all minimal inhomogeneous solutions} \\indented{3}{2. all minimal homogeneous solutions} the algorithm implemented is a completion procedure,{} which enumerates all solutions in a recursive depth-first-search it can be seen as finding monotone paths in a graph for more details see Reference"))
 (|dioSolve|
  (((|Record| (|:| |varOrder| (|List| (|Symbol|)))
              (|:| |inhom|
                   (|Union| (|List| (|Vector| (|NonNegativeInteger|)))
                            "failed"))
              (|:| |hom| (|List| (|Vector| (|NonNegativeInteger|)))))
    (|Equation| (|Polynomial| (|Integer|))))
   "\\spad{dioSolve(u)} computes a basis of all minimal solutions for linear homogeneous Diophantine equation \\spad{u},{} then all minimal solutions of inhomogeneous equation"))) 
NIL 
(|DirectProductCategory&| S |dim| R) 
((|constructor|
  (NIL
   "\\indented{2}{This category represents a finite cartesian product of a given type.} Many categorical properties are preserved under this construction."))
 (*
  (($ $ |#3|)
   "\\spad{y * r} multiplies each component of the vector \\spad{y} by the element \\spad{r}.")
  (($ |#3| $)
   "\\spad{r * y} multiplies the element \\spad{r} times each component of the vector \\spad{y}."))
 (|dot|
  ((|#3| $ $)
   "\\spad{dot(x,{} y)} computes the inner product of the vectors \\spad{x} and \\spad{y}."))
 (|unitVector|
  (($ (|PositiveInteger|))
   "\\spad{unitVector(n)} produces a vector with 1 in position \\spad{n} and zero elsewhere."))
 (|directProduct|
  (($ (|Vector| |#3|))
   "\\spad{directProduct(v)} converts the vector \\spad{v} to a direct product. Error: if the length of \\spad{v} is different from dim."))) 
((|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
 (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
 (|HasCategory| |#3| '(|OrderedSet|)) (|HasCategory| |#3| '(|unitsKnown|))
 (|HasCategory| |#3| '(|CommutativeRing|)) (|HasCategory| |#3| '(|Finite|))
 (|HasCategory| |#3| '(|SemiGroup|)) (|HasCategory| |#3| '(|SemiRng|))
 (|HasCategory| |#3| '(|Monoid|)) (|HasCategory| |#3| '(|AbelianMonoid|))
 (|HasCategory| |#3| '(|Ring|)) (|HasCategory| |#3| '(|SetCategory|))) 
(|DirectProductCategory| |dim| R) 
((|constructor|
  (NIL
   "\\indented{2}{This category represents a finite cartesian product of a given type.} Many categorical properties are preserved under this construction."))
 (*
  (($ $ |#2|)
   "\\spad{y * r} multiplies each component of the vector \\spad{y} by the element \\spad{r}.")
  (($ |#2| $)
   "\\spad{r * y} multiplies the element \\spad{r} times each component of the vector \\spad{y}."))
 (|dot|
  ((|#2| $ $)
   "\\spad{dot(x,{} y)} computes the inner product of the vectors \\spad{x} and \\spad{y}."))
 (|unitVector|
  (($ (|PositiveInteger|))
   "\\spad{unitVector(n)} produces a vector with 1 in position \\spad{n} and zero elsewhere."))
 (|directProduct|
  (($ (|Vector| |#2|))
   "\\spad{directProduct(v)} converts the vector \\spad{v} to a direct product. Error: if the length of \\spad{v} is different from dim."))) 
NIL 
(|DirectProduct| |dim| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type represents the finite direct or cartesian product of an} underlying component type. This contrasts with simple vectors in that the members can be viewed as having constant length. Thus many categorical properties can by lifted from the underlying component type. Component extraction operations are provided but no updating operations. Thus new direct product elements can either be created by converting vector elements using the \\spadfun{directProduct} function or by taking appropriate linear combinations of basis vectors provided by the \\spad{unitVector} operation."))) 
((|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#2| '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| '(|unitsKnown|)) (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRng|))
 (|HasCategory| |#2| '(|Ring|)) (|HasCategory| |#2| '(|Monoid|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|Finite|))
 (OR (|HasCategory| |#2| '(|Finite|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| |#2| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|OrderedSet|)))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| '(|DifferentialRing|))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|Monoid|)))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|))
      (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|SemiGroup|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR (|HasCategory| |#2| '(|Monoid|)) (|HasCategory| |#2| '(|SemiGroup|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|BasicType|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
 (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|)))
  (|HasCategory| |#2| '(|Ring|)))
 (AND
  (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND
      (|HasCategory| |#2|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| |#2| '(|SemiRng|)))
     (AND (|HasCategory| |#2| '(|AbelianMonoid|))
          (|HasCategory| |#2| '(|SemiRng|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Finite|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Monoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiRng|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|SemiRng|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|SemiRng|)) (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|)))) 
(|DirectProductFunctions2| |dim| A B) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides operations which all take as arguments} direct products of elements of some type \\spad{A} and functions from \\spad{A} to another type \\spad{B}. The operations all iterate over their vector argument and either return a value of type \\spad{B} or a direct product over \\spad{B}."))
 (|map|
  (((|DirectProduct| |#1| |#3|) (|Mapping| |#3| |#2|)
    (|DirectProduct| |#1| |#2|))
   "\\spad{map(f,{} v)} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values."))
 (|reduce|
  ((|#3| (|Mapping| |#3| |#2| |#3|) (|DirectProduct| |#1| |#2|) |#3|)
   "\\spad{reduce(func,{} vec,{} ident)} combines the elements in \\spad{vec} using the binary function \\spad{func}. Argument ident is returned if the vector is empty."))
 (|scan|
  (((|DirectProduct| |#1| |#3|) (|Mapping| |#3| |#2| |#3|)
    (|DirectProduct| |#1| |#2|) |#3|)
   "\\spad{scan(func,{} vec,{} ident)} creates a new vector whose elements are the result of applying reduce to the binary function \\spad{func},{} increasing initial subsequences of the vector \\spad{vec},{} and the element ident."))) 
NIL 
(|DirichletRing| |Coef|) 
((|constructor|
  (NIL
   "DirichletRing is the ring of arithmetical functions with Dirichlet convolution as multiplication"))
 (|additive?|
  (((|Boolean|) $ (|PositiveInteger|))
   "\\spad{additive?(a,{} n)} returns \\spad{true} if the first \\spad{n} coefficients of a are additive"))
 (|multiplicative?|
  (((|Boolean|) $ (|PositiveInteger|))
   "\\spad{multiplicative?(a,{} n)} returns \\spad{true} if the first \\spad{n} coefficients of a are multiplicative"))
 (|zeta| (($) "\\spad{zeta()} returns the function which is constantly one"))) 
((|HasCategory| |#1| '(|CommutativeRing|))) 
(|DisplayPackage|) 
((|constructor|
  (NIL
   "DisplayPackage allows one to print strings in a nice manner,{} including highlighting substrings."))
 (|sayLength|
  (((|Integer|) (|List| (|String|)))
   "\\spad{sayLength(l)} returns the length of a list of strings \\spad{l} as an integer.")
  (((|Integer|) (|String|))
   "\\spad{sayLength(s)} returns the length of a string \\spad{s} as an integer."))
 (|say|
  (((|Void|) (|List| (|String|)))
   "\\spad{say(l)} sends a list of strings \\spad{l} to output.")
  (((|Void|) (|String|)) "\\spad{say(s)} sends a string \\spad{s} to output."))
 (|center|
  (((|List| (|String|)) (|List| (|String|)) (|Integer|) (|String|))
   "\\spad{center(l,{} i,{} s)} takes a list of strings \\spad{l},{} and centers them within a list of strings which is \\spad{i} characters long,{} in which the remaining spaces are filled with strings composed of as many repetitions as possible of the last string parameter \\spad{s}.")
  (((|String|) (|String|) (|Integer|) (|String|))
   "\\spad{center(s,{} i,{} s)} takes the first string \\spad{s},{} and centers it within a string of length \\spad{i},{} in which the other elements of the string are composed of as many replications as possible of the second indicated string,{} \\spad{s} which must have a length greater than that of an empty string."))
 (|copies|
  (((|String|) (|Integer|) (|String|))
   "\\spad{copies(i,{} s)} will take a string \\spad{s} and create a new string composed of \\spad{i} copies of \\spad{s}."))
 (|newLine|
  (((|String|)) "\\spad{newLine()} sends a new line command to output."))
 (|bright|
  (((|List| (|String|)) (|List| (|String|)))
   "\\spad{bright(l)} sets the font property of a list of strings,{} \\spad{l},{} to bold-face type.")
  (((|List| (|String|)) (|String|))
   "\\spad{bright(s)} sets the font property of the string \\spad{s} to bold-face type."))) 
NIL 
(|DistributionCategory| R) 
((|constructor| (NIL "Category of distributions formally given by moments."))
 (|subordinationConvolution|
  (($ $ $)
   "\\spad{subordinationConvolution(x,{} y)} returns the subordination convolution of the distributions \\spad{x} and \\spad{y}"))
 (|orthogonalConvolution|
  (($ $ $)
   "\\spad{orthogonalConvolution(x,{} y)} returns the orthogonal convolution of the distributions \\spad{x} and \\spad{y}"))
 (^
  (($ $ (|PositiveInteger|))
   "\\spad{x^k} constructs the distribution of the \\spad{k}th power of the random variable with distribution \\spad{X} by picking every \\spad{k}-th moment."))
 (|monotoneConvolution|
  (($ $ $)
   "\\spad{monotoneConvolution(x,{} y)} returns the monotone convolution of the distributions \\spad{x} and \\spad{y}"))
 (|booleanConvolution|
  (($ $ $)
   "\\spad{booleanConvolution(x,{} y)} returns the boolean convolution of the distributions \\spad{x} and \\spad{y}"))
 (|freeConvolution|
  (($ $ $)
   "\\spad{freeConvolution(x,{} y)} returns the free convolution of the distributions \\spad{x} and \\spad{y}"))
 (|classicalConvolution|
  (($ $ $)
   "\\spad{classicalConvolution(x,{} y)} returns the classical convolution of the distributions \\spad{x} and \\spad{y}"))
 (|orthogonalPolynomials|
  (((|Stream| (|SparseUnivariatePolynomial| (|Fraction| |#1|))) $)
   "\\spad{orthogonalPolynomials(x)} returns the stream of orthogonal polynomials.")
  (((|Stream| (|SparseUnivariatePolynomial| |#1|)) $)
   "\\spad{orthogonalPolynomials(x)} returns the stream of orthogonal polynomials."))
 (|jacobiParameters|
  (((|Record| (|:| |an| (|Stream| (|Fraction| |#1|)))
              (|:| |bn| (|Stream| (|Fraction| |#1|))))
    $)
   "\\spad{jacobiParameters(x)} returns the pair of streams of Jacobi parameters of the distribution \\spad{x}.")
  (((|Record| (|:| |an| (|Stream| |#1|)) (|:| |bn| (|Stream| |#1|))) $)
   "\\spad{jacobiParameters(x)} returns the pair of streams of Jacobi parameters of the distribution \\spad{x}."))
 (|monotoneCumulants|
  (((|Sequence| |#1|) $)
   "\\spad{monotoneCumulants(x)} returns the sequence of monotone cumulants of the distribution \\spad{x}."))
 (|hankelDeterminants|
  (((|Stream| |#1|) $)
   "\\spad{hankelDeterminants(x)} returns the stream of hankel determinants of the distribution \\spad{x}."))
 (|booleanCumulants|
  (((|Sequence| |#1|) $)
   "\\spad{booleanCumulants(x)} returns the sequence of boolean cumulants of the distribution \\spad{x}."))
 (|freeCumulants|
  (((|Sequence| |#1|) $)
   "\\spad{freeCumulants(x)} returns the sequence of free cumulants of the distribution \\spad{x}."))
 (|classicalCumulants|
  (((|Sequence| |#1|) $)
   "\\spad{classicalCumulants(x)} returns sequence of classical cumulants of the distribution \\spad{x}"))
 (|moments|
  (((|Sequence| |#1|) $)
   "\\spad{moments(x)} returns the sequence of moments of the distribution \\spad{x}"))
 (|booleanCumulant|
  ((|#1| $ (|PositiveInteger|))
   "\\spad{booleanCumulant(x,{} n)} returns the \\spad{n}-th boolean cumulant of the distribution \\spad{x}"))
 (|freeCumulant|
  ((|#1| $ (|PositiveInteger|))
   "\\spad{freeCumulant(x,{} n)} returns the \\spad{n}-th free cumulant of the distribution \\spad{x}"))
 (|classicalCumulant|
  ((|#1| $ (|PositiveInteger|))
   "\\spad{classicalCumulant(x,{} n)} returns the \\spad{n}-th classical cumulant of the distribution \\spad{x}"))
 (|moment|
  ((|#1| $ (|NonNegativeInteger|))
   "\\spad{moment(x,{} n)} returns the \\spad{n}-th moment of the distribution \\spad{x}"))
 ((|Zero|) (($) "\\spad{0} is the Dirac distribution"))) 
NIL 
(|DistributionPackage| R) 
((|constructor| (NIL "Various popular distributions."))
 (|arcsineDistribution|
  (((|Distribution| |#1|) |#1|)
   "\\spad{arcsineDistribution(a)} produces the arcsine distribution of variance \\spad{a}."))
 (|bernoulliDistribution01|
  (((|Distribution| |#1|) |#1|)
   "\\spad{bernoulliDistribution01(a)} produces the distribution of a projection of trace a"))
 (|freePoissonDistribution|
  (((|Distribution| |#1|) |#1|)
   "\\spad{freePoissonDistribution(a)} produces a free Poisson distribution of variance \\spad{a}."))
 (|wignerDistribution|
  (((|Distribution| |#1|) |#1|)
   "\\spad{wignerDistribution(a)} produces a Wigner distribution of variance \\spad{a}."))
 (|poissonDistribution|
  (((|Distribution| |#1|) |#1|)
   "\\spad{poissonDistribution(a)} produces a Poisson distribution of variance \\spad{a}."))
 (|gaussianDistribution|
  (((|Distribution| |#1|) |#1|)
   "\\spad{gaussianDistribution(a)} produces a gaussian distribution of variance \\spad{a}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|DistributiveLattice|) 
((|constructor|
  (NIL
   "not every lattice is distributive so treat this \\indented{13}{as a separate case} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))) 
NIL 
(|DistributionPolynomialPackage| R S UPS) 
((|constructor|
  (NIL
   "A package to apply polynomial transformations to distributions and integrate polynomials with respect to distributions."))
 (|apply|
  (((|Distribution| |#2|) |#3| (|Distribution| |#1|))
   "\\spad{apply(p,{} d)} computes the distribution of the random variable \\spad{p(X)}\\$ where \\spad{X} has distribution \\spad{d}."))
 (|integrate|
  ((|#2| |#3| (|Distribution| |#1|))
   "\\spad{integrate(p,{} d)} integrates the polynomial \\spad{p} against the distribution \\spad{d}. Same as \\spad{eval(d,{} p)}."))
 (|eval|
  ((|#2| (|Distribution| |#1|) |#3|)
   "\\spad{eval(d,{} p)} evaluates the distribution \\spad{d} as a linear functional on the polynomial \\spad{p}. Same as \\spad{integrate(p,{} d)}."))) 
NIL 
(|Distribution| R) 
((|constructor|
  (NIL
   "Domain for distributions formally given by moments. moments and different kinds of cumulants are stored in streams and computed on demand."))
 (|freeMultiplicativeConvolution|
  (($ $ $)
   "\\spad{freeMultiplicativeConvolution(mu,{} nu)} computes the free multiplicative convolution of the distributions \\spad{mu} and \\spad{nu}."))
 (|distributionBySTransform|
  (($ (|Fraction| (|Integer|)) (|Fraction| (|Integer|)) (|Sequence| |#1|))
   "\\spad{distributionBySTransform(series)} initiates a distribution with given \\spad{S}-transform \\spad{series}.")
  (($
    (|Record| (|:| |puiseux| (|Fraction| (|Integer|)))
              (|:| |laurent| (|Fraction| (|Integer|)))
              (|:| |coef| (|Sequence| |#1|))))
   "\\spad{distributionBySTransform(series)} initiates a distribution with given \\spad{S}-transform \\spad{series}."))
 (|distributionByMonotoneCumulants|
  (($ (|Stream| |#1|))
   "\\spad{distributionByMonotoneCumulants(hh)} initiates a distribution with given monotone cumulants \\spad{hh}.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByMonotoneCumulants(hh)} initiates a distribution with given monotone cumulants \\spad{hh}."))
 (|construct|
  (($ (|Sequence| |#1|) (|Sequence| |#1|) (|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{construct(mom,{} ccum,{} fcum,{} bcum)} constructs a distribution with moments \\spad{mom},{} classical cumulants \\spad{ccum},{} free cumulants \\spad{fcum} and boolean cumulants \\spad{bcum}. The user must make sure that these are consistent,{} otherwise the results are unpredictable!"))
 (|booleanCumulantFromJacobi|
  ((|#1| (|Integer|) (|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{booleanCumulantFromJacobi(n,{} aa,{} bb)} computes the \\spad{n}th Boolean cumulant from the given Jacobiparameters \\spad{aa} and \\spad{bb}."))
 (|distributionByJacobiParameters|
  (($ (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{distributionByJacobiParameters(aa,{} bb)} initiates a distribution with given Jacobi parameters \\spad{[aa,{} bb]}.")
  (($ (|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{distributionByJacobiParameters(aa,{} bb)} initiates a distribution with given Jacobi parameters \\spad{[aa,{} bb]}."))
 (|distributionByBooleanCumulants|
  (($ (|Stream| |#1|))
   "\\spad{distributionByBooleanCumulants(bb)} initiates a distribution with given Boolean cumulants \\spad{bb}.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByBooleanCumulants(bb)} initiates a distribution with given Boolean cumulants \\spad{bb}."))
 (|distributionByFreeCumulants|
  (($ (|Stream| |#1|))
   "\\spad{distributionByFreeCumulants(cc)} initiates a distribution with given free cumulants \\spad{cc}.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByFreeCumulants(cc)} initiates a distribution with given free cumulants \\spad{cc}."))
 (|distributionByClassicalCumulants|
  (($ (|Stream| |#1|))
   "\\spad{distributionByEvenMoments(kk)} initiates a distribution with given classical cumulants \\spad{kk}.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByEvenMoments(kk)} initiates a distribution with given classical cumulants \\spad{kk}."))
 (|distributionByEvenMoments|
  (($ (|Stream| |#1|))
   "\\spad{distributionByEvenMoments(mm)} initiates a distribution with given even moments \\spad{mm} and odd moments zero.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByEvenMoments(mm)} initiates a distribution with given even moments \\spad{mm} and odd moments zero."))
 (|distributionByMoments|
  (($ (|Stream| |#1|))
   "\\spad{distributionByMoments(mm)} initiates a distribution with given moments \\spad{mm}.")
  (($ (|Sequence| |#1|))
   "\\spad{distributionByMoments(mm)} initiates a distribution with given moments \\spad{mm}."))) 
((|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|not| (|HasCategory| |#1| '(|Field|))))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|DistributionFunctions2| R1 R2) 
((|constructor|
  (NIL "A package to map distributions between different rings."))
 (|R1_to_R2_coercion|
  ((|#2| |#1|) "\\spad{R1_to_R2_coercion should} be local but conditional"))
 (|coerce|
  (((|Distribution| |#2|) (|Distribution| |#1|))
   "\\spad{coerce(x)} coerces a distribution from the ring \\spad{R1} to \\spad{R2}."))
 (|mapall|
  (((|Distribution| |#2|) (|Mapping| |#2| |#1|) (|Distribution| |#1|))
   "\\spad{map(f,{} x)} maps the moments and cumulants from the ring \\spad{R1} to \\spad{R2}."))) 
NIL 
(|DivisionRing&| S) 
((|constructor|
  (NIL
   "A division ring (sometimes called a skew field),{} \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses."))
 (|inv|
  (($ $)
   "\\spad{inv x} returns the multiplicative inverse of \\spad{x}. Error: if \\spad{x} is 0."))
 (^
  (($ $ (|Integer|))
   "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n}."))) 
NIL 
(|DivisionRing|) 
((|constructor|
  (NIL
   "A division ring (sometimes called a skew field),{} \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses."))
 (|inv|
  (($ $)
   "\\spad{inv x} returns the multiplicative inverse of \\spad{x}. Error: if \\spad{x} is 0."))
 (^
  (($ $ (|Integer|))
   "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n}."))) 
NIL 
(|DistributedJetBundlePolynomial| R JB LJV E) 
((|constructor|
  (NIL
   "\\spadtype{DistributedJetBundlePolynomial} implements polynomials in a distributed representation. The unknowns come from a finite list of jet variables. The implementation is basically a copy of the one of \\spadtype{GeneralDistributedMultivariatePolynomial}."))
 (|groebner|
  (((|List| $) (|List| $))
   "\\spad{groebner(lp)} computes a Groebner basis for the ideal generated by the list of polynomials \\spad{lp}."))
 (|const|
  ((|#1| $)
   "\\spad{const(p)} coerces a polynomial into an element of the coefficient ring,{} if it is constant. Otherwise an error occurs."))
 (|convert|
  (((|JetBundlePolynomial| |#1| |#2|) $)
   "\\spad{convert(p)} converts a polynomial \\spad{p} in distributive representation into a polynomial in recursive representation.")
  (($ (|JetBundlePolynomial| |#1| |#2|))
   "\\spad{convert(p)} converts a polynomial \\spad{p} in recursive representation into a polynomial in distributive representation."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#4| '(|Comparable|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2|
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|DoublyLinkedAggregate| S) 
((|constructor|
  (NIL
   "A doubly-linked aggregate serves as a model for a doubly-linked list,{} that is,{} a list which has links to both next and previous nodes and thus can be efficiently traversed in both directions."))
 (|setnext!|
  (($ $ $)
   "\\spad{setnext!(u,{} v)} destructively sets the next node of doubly-linked aggregate \\spad{u} to \\spad{v},{} returning \\spad{v}."))
 (|setprevious!|
  (($ $ $)
   "\\spad{setprevious!(u,{} v)} destructively sets the previous node of doubly-linked aggregate \\spad{u} to \\spad{v},{} returning \\spad{v}."))
 (|concat!|
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively concatenates doubly-linked aggregate \\spad{v} to the end of doubly-linked aggregate \\spad{u}."))
 (|next|
  (($ $)
   "\\spad{next(l)} returns the doubly-linked aggregate beginning with its next element. Error: if \\spad{l} has no next element. Note: \\spad{next(l) = rest(l)} and \\spad{previous(next(l)) = l}."))
 (|previous|
  (($ $)
   "\\spad{previous(l)} returns the doubly-link list beginning with its previous element. Error: if \\spad{l} has no previous element. Note: \\spad{next(previous(l)) = l}."))
 (|tail|
  (($ $)
   "\\spad{tail(l)} returns the doubly-linked aggregate \\spad{l} starting at its second element. Error: if \\spad{l} is empty."))
 (|head|
  (($ $)
   "\\spad{head(l)} returns the first element of a doubly-linked aggregate \\spad{l}. Error: if \\spad{l} is empty."))
 (|last|
  ((|#1| $)
   "\\spad{last(l)} returns the last element of a doubly-linked aggregate \\spad{l}. Error: if \\spad{l} is empty."))) 
NIL 
(|DataList| S) 
((|constructor| (NIL "This domain provides some nice functions on lists"))
 (|elt|
  (((|NonNegativeInteger|) $ "count")
   "\\spad{l.\"count\"} returns the number of elements in \\spad{l}.")
  (($ $ "sort")
   "\\spad{l.sort} returns \\spad{l} with elements sorted. Note: \\spad{l.sort = sort(l)}")
  (($ $ "unique")
   "\\spad{l.unique} returns \\spad{l} with duplicates removed. Note: \\spad{l.unique = removeDuplicates(l)}."))
 (|datalist|
  (($ (|List| |#1|)) "\\spad{datalist(l)} creates a datalist from \\spad{l}"))
 (|coerce|
  (((|List| |#1|) $)
   "\\spad{coerce(x)} returns the list of elements in \\spad{x}")
  (($ (|List| |#1|)) "\\spad{coerce(l)} creates a datalist from \\spad{l}"))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))) 
(|DiscreteLogarithmPackage| M) 
((|constructor|
  (NIL
   "DiscreteLogarithmPackage implements help functions for discrete logarithms in monoids using small cyclic groups."))
 (|shanksDiscLogAlgorithm|
  (((|Union| (|NonNegativeInteger|) "failed") |#1| |#1| (|NonNegativeInteger|))
   "\\spad{shanksDiscLogAlgorithm(b,{} a,{} p)} computes \\spad{s} with \\spad{b^s = a} for assuming that \\spad{a} and \\spad{b} are elements in a 'small' cyclic group of order \\spad{p} by Shank\\spad{'s} algorithm. Note: this is a subroutine of the function \\spadfun{discreteLog}."))
 (^
  (($ $ (|Integer|))
   "\\spad{x ^ n} returns \\spad{x} raised to the integer power \\spad{n}"))) 
NIL 
(|DistributedMultivariatePolynomial| |vl| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is lexicographic specified by the variable list parameter with the most significant variable first in the list."))
 (|reorder|
  (($ $ (|List| (|Integer|)))
   "\\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|)))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| (|DirectProduct| (|call| LENGTH |#1|) (|NonNegativeInteger|))
                '(|Comparable|))
 (|HasCategory| |#2| '(|Field|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#2| '(|Ring|))
  (|HasCategory| (|OrderedVariableList| |#1|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|GcdDomain|))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|DirectProductMatrixModule| |n| R M S) 
((|constructor|
  (NIL
   "This constructor provides a direct product type with a left matrix-module view."))) 
((|HasCategory| |#4| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#4| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#4| '(|OrderedSet|))
 (OR (|HasCategory| |#4| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#4| '(|OrderedSet|)))
 (|HasCategory| |#4| '(|unitsKnown|)) (|HasCategory| |#4| '(|CommutativeRing|))
 (|HasCategory| |#4| '(|SemiRng|)) (|HasCategory| |#4| '(|Ring|))
 (|HasCategory| |#4| '(|Monoid|))
 (OR (|HasCategory| |#4| '(|CommutativeRing|))
     (|HasCategory| |#4| '(|SemiRng|)))
 (|HasCategory| |#4| '(|Finite|))
 (OR (|HasCategory| |#4| '(|Finite|))
     (|HasCategory| |#4| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#4| '(|OrderedSet|)))
 (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#4| '(|DifferentialRing|))
 (OR (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#4| '(|CommutativeRing|))
     (|HasCategory| |#4| '(|DifferentialRing|)) (|HasCategory| |#4| '(|Ring|))
     (|HasCategory| |#4| '(|SemiRng|)))
 (OR (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#4| '(|CommutativeRing|))
     (|HasCategory| |#4| '(|DifferentialRing|)) (|HasCategory| |#4| '(|Ring|)))
 (|HasCategory| |#4| '(|SetCategory|))
 (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#4| '(|Finite|)) (|HasCategory| |#4| '(|OrderedSet|)))
 (AND (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#4| '(|Ring|)))
 (AND (|HasCategory| |#4| '(|DifferentialRing|))
      (|HasCategory| |#4| '(|Ring|)))
 (AND (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#4| '(|Ring|)))
 (|HasCategory| |#4| '(|SemiGroup|))
 (OR (|HasCategory| |#4| '(|Monoid|)) (|HasCategory| |#4| '(|SemiGroup|)))
 (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|SetCategory|)))
  (|HasCategory| |#4| '(|Ring|)))
 (AND
  (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#3| '(|AbelianMonoid|))
 (|HasCategory| |#4| '(|AbelianMonoid|))
 (AND (|HasCategory| |#4| '(|AbelianMonoid|)) (|HasCategory| |#4| '(|Monoid|)))
 (AND (|HasCategory| |#4| '(|AbelianMonoid|))
      (|HasCategory| |#4| '(|SemiRng|)))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#3| '(|AbelianGroup|))
 (|HasCategory| |#4| '(|AbelianGroup|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#4| '(|AbelianGroup|)))
 (|HasCategory| |#4| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|CommutativeRing|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|DifferentialRing|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|Finite|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|Monoid|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|OrderedSet|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|Ring|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|SemiGroup|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|SemiRng|)))
  (AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
       (|HasCategory| |#4| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#4|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#4|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|Finite|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|Monoid|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|Ring|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|SemiRng|)))
  (AND
   (|HasCategory| |#4| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#4| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|CommutativeRing|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|DifferentialRing|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|Finite|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|Monoid|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|OrderedSet|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|Ring|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|SemiGroup|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|SemiRng|)))
  (AND (|HasCategory| |#4| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#4| '(|SetCategory|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#4| '(|AbelianGroup|))
     (|HasCategory| |#4| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#4| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#4| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#4| '(|AbelianGroup|))
     (|HasCategory| |#4| '(|AbelianMonoid|))
     (|HasCategory| |#4| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#4| '(|AbelianMonoid|))
     (AND (|HasCategory| |#4| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (AND (|HasCategory| |#4| '(|AbelianGroup|))
          (|HasCategory| |#4| '(|SemiRng|)))
     (|HasCategory| |#4| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#4| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#4| '(|AbelianGroup|))
     (AND (|HasCategory| |#4| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))) 
(|DirectProductModule| |n| R S) 
((|constructor|
  (NIL
   "This constructor provides a direct product of \\spad{R}-modules with an \\spad{R}-module view."))) 
((|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#3| '(|OrderedSet|))
 (OR (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)))
 (|HasCategory| |#3| '(|unitsKnown|)) (|HasCategory| |#3| '(|CommutativeRing|))
 (|HasCategory| |#3| '(|SemiRng|)) (|HasCategory| |#3| '(|Ring|))
 (|HasCategory| |#3| '(|Monoid|))
 (OR (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#3| '(|Finite|))
 (OR (|HasCategory| |#3| '(|Finite|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)))
 (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#3| '(|DifferentialRing|))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|)) (|HasCategory| |#3| '(|Ring|))
     (|HasCategory| |#3| '(|SemiRng|)))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|)) (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|SetCategory|))
 (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
      (|HasCategory| |#3| '(|SetCategory|)))
 (|HasCategory| |#3| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#3| '(|Finite|)) (|HasCategory| |#3| '(|OrderedSet|)))
 (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#3| '(|Ring|)))
 (AND (|HasCategory| |#3| '(|DifferentialRing|))
      (|HasCategory| |#3| '(|Ring|)))
 (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|SemiGroup|))
 (OR (|HasCategory| |#3| '(|Monoid|)) (|HasCategory| |#3| '(|SemiGroup|)))
 (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#3| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SetCategory|)))
  (|HasCategory| |#3| '(|Ring|)))
 (AND
  (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#3| '(|SetCategory|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#3| '(|AbelianMonoid|))
 (AND (|HasCategory| |#3| '(|AbelianMonoid|)) (|HasCategory| |#3| '(|Monoid|)))
 (AND (|HasCategory| |#3| '(|AbelianMonoid|))
      (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#3| '(|AbelianGroup|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|)))
 (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Finite|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Monoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedSet|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Ring|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SemiGroup|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SemiRng|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#3|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#3|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Finite|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Monoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Ring|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SemiRng|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Finite|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Monoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedSet|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Ring|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SemiGroup|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SemiRng|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SetCategory|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#3| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#3| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (AND (|HasCategory| |#3| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#3| '(|AbelianGroup|))
          (|HasCategory| |#3| '(|SemiRng|)))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#3| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (AND (|HasCategory| |#3| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))) 
(|DifferentialPolynomialCategory&| A R S V E) 
((|constructor|
  (NIL
   "\\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition,{} it implements defaults for the basic functions. The functions \\spadfun{order} and \\spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \\spadfun{leader},{} \\spadfun{initial},{} \\spadfun{separant},{} \\spadfun{differentialVariables},{} and \\spadfun{isobaric?}. Furthermore,{} if the ground ring is a differential ring,{} then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \\spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \\spadfun{makeVariable}. \\blankline To construct a domain using this constructor,{} one needs to provide a ground ring \\spad{R},{} an ordered set \\spad{S} of differential indeterminates,{} a ranking \\spad{V} on the set of derivatives of the differential indeterminates,{} and a set \\spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates. \\blankline"))
 (|separant|
  (($ $)
   "\\spad{separant(p)} returns the partial derivative of the differential polynomial \\spad{p} with respect to its leader."))
 (|initial|
  (($ $)
   "\\spad{initial(p)} returns the leading coefficient when the differential polynomial \\spad{p} is written as a univariate polynomial in its leader."))
 (|leader|
  ((|#4| $)
   "\\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \\spad{p} Note: an error occurs if \\spad{p} is in the ground ring."))
 (|isobaric?|
  (((|Boolean|) $)
   "\\spad{isobaric?(p)} returns \\spad{true} if every differential monomial appearing in the differential polynomial \\spad{p} has same weight,{} and returns \\spad{false} otherwise."))
 (|weight|
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{weight(p,{} s)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")
  (((|NonNegativeInteger|) $)
   "\\spad{weight(p)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p}."))
 (|weights|
  (((|List| (|NonNegativeInteger|)) $ |#3|)
   "\\spad{weights(p,{} s)} returns a list of weights of differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{weights(p)} returns a list of weights of differential monomials appearing in differential polynomial \\spad{p}."))
 (|degree|
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{degree(p,{} s)} returns the maximum degree of the differential polynomial \\spad{p} viewed as a differential polynomial in the differential indeterminate \\spad{s} alone."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(p)} returns the order of the differential polynomial \\spad{p},{} which is the maximum number of differentiations of a differential indeterminate,{} among all those appearing in \\spad{p}.")
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{order(p,{} s)} returns the order of the differential polynomial \\spad{p} in differential indeterminate \\spad{s}."))
 (|differentialVariables|
  (((|List| |#3|) $)
   "\\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \\spad{p}."))
 (|makeVariable|
  (((|Mapping| $ (|NonNegativeInteger|)) $)
   "\\spad{makeVariable(p)} views \\spad{p} as an element of a differential ring,{} in such a way that the \\spad{n}-th derivative of \\spad{p} may be simply referenced as \\spad{z}.\\spad{n} where \\spad{z} \\spad{:=} makeVariable(\\spad{p}). Note: In the interpreter,{} \\spad{z} is given as an internal map,{} which may be ignored.")
  (((|Mapping| $ (|NonNegativeInteger|)) |#3|)
   "\\spad{makeVariable(s)} views \\spad{s} as a differential indeterminate,{} in such a way that the \\spad{n}-th derivative of \\spad{s} may be simply referenced as \\spad{z}.\\spad{n} where \\spad{z} \\spad{:=} makeVariable(\\spad{s}). Note: In the interpreter,{} \\spad{z} is given as an internal map,{} which may be ignored."))) 
((|HasCategory| |#2| '(|DifferentialRing|))) 
(|DifferentialPolynomialCategory| R S V E) 
((|constructor|
  (NIL
   "\\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition,{} it implements defaults for the basic functions. The functions \\spadfun{order} and \\spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \\spadfun{leader},{} \\spadfun{initial},{} \\spadfun{separant},{} \\spadfun{differentialVariables},{} and \\spadfun{isobaric?}. Furthermore,{} if the ground ring is a differential ring,{} then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \\spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \\spadfun{makeVariable}. \\blankline To construct a domain using this constructor,{} one needs to provide a ground ring \\spad{R},{} an ordered set \\spad{S} of differential indeterminates,{} a ranking \\spad{V} on the set of derivatives of the differential indeterminates,{} and a set \\spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates. \\blankline"))
 (|separant|
  (($ $)
   "\\spad{separant(p)} returns the partial derivative of the differential polynomial \\spad{p} with respect to its leader."))
 (|initial|
  (($ $)
   "\\spad{initial(p)} returns the leading coefficient when the differential polynomial \\spad{p} is written as a univariate polynomial in its leader."))
 (|leader|
  ((|#3| $)
   "\\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \\spad{p} Note: an error occurs if \\spad{p} is in the ground ring."))
 (|isobaric?|
  (((|Boolean|) $)
   "\\spad{isobaric?(p)} returns \\spad{true} if every differential monomial appearing in the differential polynomial \\spad{p} has same weight,{} and returns \\spad{false} otherwise."))
 (|weight|
  (((|NonNegativeInteger|) $ |#2|)
   "\\spad{weight(p,{} s)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")
  (((|NonNegativeInteger|) $)
   "\\spad{weight(p)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p}."))
 (|weights|
  (((|List| (|NonNegativeInteger|)) $ |#2|)
   "\\spad{weights(p,{} s)} returns a list of weights of differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{weights(p)} returns a list of weights of differential monomials appearing in differential polynomial \\spad{p}."))
 (|degree|
  (((|NonNegativeInteger|) $ |#2|)
   "\\spad{degree(p,{} s)} returns the maximum degree of the differential polynomial \\spad{p} viewed as a differential polynomial in the differential indeterminate \\spad{s} alone."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(p)} returns the order of the differential polynomial \\spad{p},{} which is the maximum number of differentiations of a differential indeterminate,{} among all those appearing in \\spad{p}.")
  (((|NonNegativeInteger|) $ |#2|)
   "\\spad{order(p,{} s)} returns the order of the differential polynomial \\spad{p} in differential indeterminate \\spad{s}."))
 (|differentialVariables|
  (((|List| |#2|) $)
   "\\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \\spad{p}."))
 (|makeVariable|
  (((|Mapping| $ (|NonNegativeInteger|)) $)
   "\\spad{makeVariable(p)} views \\spad{p} as an element of a differential ring,{} in such a way that the \\spad{n}-th derivative of \\spad{p} may be simply referenced as \\spad{z}.\\spad{n} where \\spad{z} \\spad{:=} makeVariable(\\spad{p}). Note: In the interpreter,{} \\spad{z} is given as an internal map,{} which may be ignored.")
  (((|Mapping| $ (|NonNegativeInteger|)) |#2|)
   "\\spad{makeVariable(s)} views \\spad{s} as a differential indeterminate,{} in such a way that the \\spad{n}-th derivative of \\spad{s} may be simply referenced as \\spad{z}.\\spad{n} where \\spad{z} \\spad{:=} makeVariable(\\spad{s}). Note: In the interpreter,{} \\spad{z} is given as an internal map,{} which may be ignored."))) 
NIL 
(|DequeueAggregate| S) 
((|constructor|
  (NIL
   "A dequeue is a doubly ended stack,{} that is,{} a bag where first items inserted are the first items extracted,{} at either the front or the back end of the data structure."))
 (|reverse!|
  (($ $)
   "\\spad{reverse!(d)} destructively replaces \\spad{d} by its reverse dequeue,{} \\spadignore{i.e.} the top (front) element is now the bottom (back) element,{} and so on."))
 (|extractBottom!|
  ((|#1| $)
   "\\spad{extractBottom!(d)} destructively extracts the bottom (back) element from the dequeue \\spad{d}. Error: if \\spad{d} is empty."))
 (|extractTop!|
  ((|#1| $)
   "\\spad{extractTop!(d)} destructively extracts the top (front) element from the dequeue \\spad{d}. Error: if \\spad{d} is empty."))
 (|insertBottom!|
  ((|#1| |#1| $)
   "\\spad{insertBottom!(x,{} d)} destructively inserts \\spad{x} into the dequeue \\spad{d} at the bottom (back) of the dequeue."))
 (|insertTop!|
  ((|#1| |#1| $)
   "\\spad{insertTop!(x,{} d)} destructively inserts \\spad{x} into the dequeue \\spad{d},{} that is,{} at the top (front) of the dequeue. The element previously at the top of the dequeue becomes the second in the dequeue,{} and so on."))
 (|bottom|
  ((|#1| $)
   "\\spad{bottom(d)} returns the element at the bottom (back) of the dequeue."))) 
NIL 
(|TopLevelDrawFunctions| |Ex|) 
((|constructor|
  (NIL
   "TopLevelDrawFunctions provides top level functions for drawing graphics of expressions."))
 (|makeObject|
  (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| |#1|)
    (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)))
   "\\spad{makeObject(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{h(t)} is the default title.")
  (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| |#1|)
    (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{makeObject(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{h(t)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|)) |#1| (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)))
   "\\spad{makeObject(f(x,{} y),{} x = a..b,{} y = c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{f(x,{} y)} appears as the default title.")
  (((|ThreeSpace| (|DoubleFloat|)) |#1| (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(f(x,{} y),{} x = a..b,{} y = c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{f(x,{} y)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| |#1|)
    (|SegmentBinding| (|Float|)))
   "\\spad{makeObject(curve(f(t),{} g(t),{} h(t)),{} t = a..b)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{h(t)} is the default title.")
  (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| |#1|)
    (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(curve(f(t),{} g(t),{} h(t)),{} t = a..b,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{h(t)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|GraphImage|) (|ParametricPlaneCurve| |#1|) (|SegmentBinding| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{makeObject(curve(f(t),{} g(t)),{} t = a..b,{} l)} creates the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|GraphImage|) |#1| (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(f(x),{} x = a..b,{} l)} creates the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))
 (|draw|
  (((|ThreeDimensionalViewport|) (|ParametricSurface| |#1|)
    (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)))
   "\\spad{draw(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d)} draws the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{h(t)} is the default title.")
  (((|ThreeDimensionalViewport|) (|ParametricSurface| |#1|)
    (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{draw(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d,{} l)} draws the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{h(t)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|) |#1| (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)))
   "\\spad{draw(f(x,{} y),{} x = a..b,{} y = c..d)} draws the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{f(x,{} y)} appears in the title bar.")
  (((|ThreeDimensionalViewport|) |#1| (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(f(x,{} y),{} x = a..b,{} y = c..d,{} l)} draws the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; \\spad{f(x,{} y)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| |#1|)
    (|SegmentBinding| (|Float|)))
   "\\spad{draw(curve(f(t),{} g(t),{} h(t)),{} t = a..b)} draws the graph of the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{h(t)} is the default title.")
  (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| |#1|)
    (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(curve(f(t),{} g(t),{} h(t)),{} t = a..b,{} l)} draws the graph of the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{h(t)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| |#1|)
    (|SegmentBinding| (|Float|)))
   "\\spad{draw(curve(f(t),{} g(t)),{} t = a..b)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{(f(t),{} g(t))} appears in the title bar.")
  (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| |#1|)
    (|SegmentBinding| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(curve(f(t),{} g(t)),{} t = a..b,{} l)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{(f(t),{} g(t))} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|) |#1| (|SegmentBinding| (|Float|)))
   "\\spad{draw(f(x),{} x = a..b)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{f(x)} appears in the title bar.")
  (((|TwoDimensionalViewport|) |#1| (|SegmentBinding| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{draw(f(x),{} x = a..b,{} l)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; \\spad{f(x)} is the default title,{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))) 
NIL 
(|TopLevelDrawFunctionsForCompiledFunctions|) 
((|constructor|
  (NIL
   "TopLevelDrawFunctionsForCompiledFunctions provides top level functions for drawing graphics of expressions."))
 (|recolor|
  (((|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
               (|DoubleFloat|)))
   "\\spad{recolor()},{} uninteresting to top level user; exported in order to compile package."))
 (|makeObject|
  (((|ThreeSpace| (|DoubleFloat|))
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{makeObject(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{f(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{f(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{makeObject(f,{} a..b,{} c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)},{} and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|Float|)))
   "\\spad{makeObject(sp,{} curve(f,{} g,{} h),{} a..b)} returns the space \\spad{sp} of the domain \\spadtype{ThreeSpace} with the addition of the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{makeObject(curve(f,{} g,{} h),{} a..b,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)))
   "\\spad{makeObject(sp,{} curve(f,{} g,{} h),{} a..b)} returns the space \\spad{sp} of the domain \\spadtype{ThreeSpace} with the addition of the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|ThreeSpace| (|DoubleFloat|))
    (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(curve(f,{} g,{} h),{} a..b,{} l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|GraphImage|)
    (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(curve(f,{} g),{} a..b,{} l)} creates the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|GraphImage|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{makeObject(f,{} a..b,{} l)} creates the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))
 (|draw|
  (((|ThreeDimensionalViewport|)
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{draw(surface(f,{} g,{} h),{} a..b,{} c..d)} draws the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}.")
  (((|ThreeDimensionalViewport|)
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(surface(f,{} g,{} h),{} a..b,{} c..d)} draws the graph of the parametric surface \\spad{x = f(u,{} v)},{} \\spad{y = g(u,{} v)},{} \\spad{z = h(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{draw(f,{} a..b,{} c..d)} draws the graph of the parametric surface \\spad{f(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)} The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(f,{} a..b,{} c..d)} draws the graph of the parametric surface \\spad{f(u,{} v)} as \\spad{u} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{v} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)))
   "\\spad{draw(f,{} a..b,{} c..d)} draws the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(f,{} a..b,{} c..d,{} l)} draws the graph of \\spad{z = f(x,{} y)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)} and \\spad{y} ranges from \\spad{min(c,{} d)} to \\spad{max(c,{} d)}. and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|Float|)))
   "\\spad{draw(f,{} a..b,{} l)} draws the graph of the parametric curve \\spad{f} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|))
    (|List| (|DrawOption|)))
   "\\spad{draw(f,{} a..b,{} l)} draws the graph of the parametric curve \\spad{f} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|)
    (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)))
   "\\spad{draw(curve(f,{} g,{} h),{} a..b,{} l)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|ThreeDimensionalViewport|)
    (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(curve(f,{} g,{} h),{} a..b,{} l)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t),{} z = h(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|)
    (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)))
   "\\spad{draw(curve(f,{} g),{} a..b)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|TwoDimensionalViewport|)
    (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(curve(f,{} g),{} a..b,{} l)} draws the graph of the parametric curve \\spad{x = f(t),{} y = g(t)} as \\spad{t} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)))
   "\\spad{draw(f,{} a..b)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}.")
  (((|TwoDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|Float|)) (|List| (|DrawOption|)))
   "\\spad{draw(f,{} a..b,{} l)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,{} b)} to \\spad{max(a,{} b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))) 
NIL 
(|TopLevelDrawFunctionsForAlgebraicCurves| R |Ex|) 
((|constructor|
  (NIL
   "TopLevelDrawFunctionsForAlgebraicCurves provides top level functions for drawing non-singular algebraic curves."))
 (|makeObject|
  (((|GraphImage|) (|Equation| |#2|) (|Symbol|) (|Symbol|)
    (|List| (|DrawOption|)))
   "\\spad{makeObject(f(x,{} y) = g(x,{} y),{} x,{} y,{} l)} creates the graph of a polynomial equation. The list \\spad{l} of draw options must specify a region in the plane in which the curve is to sketched."))
 (|draw|
  (((|TwoDimensionalViewport|) (|Equation| |#2|) (|Symbol|) (|Symbol|)
    (|List| (|DrawOption|)))
   "\\spad{draw(f(x,{} y) = g(x,{} y),{} x,{} y,{} l)} draws the graph of a polynomial equation. The list \\spad{l} of draw options must specify a region in the plane in which the curve is to sketched."))) 
NIL 
(|DrawComplex|) 
((|constructor|
  (NIL
   "\\spadtype{DrawComplex} provides some facilities for drawing complex functions."))
 (|setClipValue|
  (((|DoubleFloat|) (|DoubleFloat|))
   "\\spad{setClipValue(x)} sets to \\spad{x} the maximum value to plot when drawing complex functions. Returns \\spad{x}."))
 (|setImagSteps|
  (((|Integer|) (|Integer|))
   "\\spad{setImagSteps(i)} sets to \\spad{i} the number of steps to use in the imaginary direction when drawing complex functions. Returns \\spad{i}."))
 (|setRealSteps|
  (((|Integer|) (|Integer|))
   "\\spad{setRealSteps(i)} sets to \\spad{i} the number of steps to use in the real direction when drawing complex functions. Returns \\spad{i}."))
 (|drawComplexVectorField|
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{drawComplexVectorField(f,{} rRange,{} iRange)} draws a complex vector field using arrows on the \\spad{x--y} plane. These vector fields should be viewed from the top by pressing the \"XY\" translate button on the 3-\\spad{d} viewport control panel.\\newline Sample call: \\indented{3}{\\spad{f z == sin z}} \\indented{3}{\\spad{drawComplexVectorField(f,{} -2..2,{} -2..2)}} Parameter descriptions: \\indented{2}{\\spad{f} : the function to draw} \\indented{2}{\\spad{rRange} : the range of the real values} \\indented{2}{iRange : the range of the imaginary values} Call the functions \\spadfunFrom{setRealSteps}{DrawComplex} and \\spadfunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction."))
 (|drawComplex|
  (((|ThreeDimensionalViewport|)
    (|Mapping| (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Boolean|))
   "\\spad{drawComplex(f,{} rRange,{} iRange,{} arrows?)} draws a complex function as a height field. It uses the complex norm as the height and the complex argument as the color. It will optionally draw arrows on the surface indicating the direction of the complex value.\\newline Sample call: \\indented{2}{\\spad{f z == exp(1/z)}} \\indented{2}{\\spad{drawComplex(f,{} 0.3..3,{} 0..2*\\%\\spad{pi},{} false)}} Parameter descriptions: \\indented{2}{\\spad{f:}\\space{2}the function to draw} \\indented{2}{\\spad{rRange} : the range of the real values} \\indented{2}{\\spad{iRange} : the range of imaginary values} \\indented{2}{arrows? : a flag indicating whether to draw the phase arrows for \\spad{f}} Call the functions \\spadfunFrom{setRealSteps}{DrawComplex} and \\spadfunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction."))) 
NIL 
(|DrawNumericHack| R) 
((|constructor|
  (NIL
   "Hack for the draw interface. DrawNumericHack provides a \"coercion\" from something of the form \\spad{x = a..b} where \\spad{a} and \\spad{b} are formal expressions to a binding of the form \\spad{x = c..d} where \\spad{c} and \\spad{d} are the numerical values of \\spad{a} and \\spad{b}. This \"coercion\" fails if \\spad{a} and \\spad{b} contains symbolic variables,{} but is meant for expressions involving \\%\\spad{pi}."))
 (|coerce|
  (((|SegmentBinding| (|Float|)) (|SegmentBinding| (|Expression| |#1|)))
   "\\spad{coerce(x = a..b)} returns \\spad{x = c..d} where \\spad{c} and \\spad{d} are the numerical values of \\spad{a} and \\spad{b}."))) 
NIL 
(|TopLevelDrawFunctionsForPoints|) 
((|constructor|
  (NIL
   "TopLevelDrawFunctionsForPoints provides top level functions for drawing curves and surfaces described by sets of points."))
 (|draw|
  (((|ThreeDimensionalViewport|) (|List| (|DoubleFloat|))
    (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|List| (|DrawOption|)))
   "\\spad{draw(lx,{} ly,{} lz,{} l)} draws the surface constructed by projecting the values in the \\spad{lz} list onto the rectangular grid formed by the The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|ThreeDimensionalViewport|) (|List| (|DoubleFloat|))
    (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)))
   "\\spad{draw(lx,{} ly,{} lz)} draws the surface constructed by projecting the values in the \\spad{lz} list onto the rectangular grid formed by the \\spad{lx X ly}.")
  (((|TwoDimensionalViewport|) (|List| (|Point| (|DoubleFloat|)))
    (|List| (|DrawOption|)))
   "\\spad{draw(lp,{} l)} plots the curve constructed from the list of points \\spad{lp}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|) (|List| (|Point| (|DoubleFloat|))))
   "\\spad{draw(lp)} plots the curve constructed from the list of points \\spad{lp}.")
  (((|TwoDimensionalViewport|) (|List| (|DoubleFloat|))
    (|List| (|DoubleFloat|)) (|List| (|DrawOption|)))
   "\\spad{draw(lx,{} ly,{} l)} plots the curve constructed of points (\\spad{x},{} \\spad{y}) for \\spad{x} in \\spad{lx} for \\spad{y} in \\spad{ly}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")
  (((|TwoDimensionalViewport|) (|List| (|DoubleFloat|))
    (|List| (|DoubleFloat|)))
   "\\spad{draw(lx,{} ly)} plots the curve constructed of points (\\spad{x},{} \\spad{y}) for \\spad{x} in \\spad{lx} for \\spad{y} in \\spad{ly}."))) 
NIL 
(|DrawOption|) 
((|constructor|
  (NIL
   "DrawOption allows the user to specify defaults for the creation and rendering of plots."))
 (|option?|
  (((|Boolean|) (|List| $) (|Symbol|))
   "\\spad{option?()} is not to be used at the top level; option? internally returns \\spad{true} for drawing options which are indicated in a draw command,{} or \\spad{false} for those which are not."))
 (|option|
  (((|Union| (|Any|) "failed") (|List| $) (|Symbol|))
   "\\spad{option()} is not to be used at the top level; option determines internally which drawing options are indicated in a draw command."))
 (|unit|
  (($ (|List| (|Float|)))
   "\\spad{unit(lf)} will mark off the units according to the indicated list \\spad{lf}. This option is expressed in the form \\spad{unit == [f1,{} f2]}."))
 (|coord|
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))))
   "\\spad{coord(p)} specifies a change of coordinates of point \\spad{p}. This option is expressed in the form \\spad{coord == p}."))
 (|tubePoints|
  (($ (|PositiveInteger|))
   "\\spad{tubePoints(n)} specifies the number of points,{} \\spad{n},{} defining the circle which creates the tube around a 3D curve,{} the default is 6. This option is expressed in the form \\spad{tubePoints == n}."))
 (|var2Steps|
  (($ (|PositiveInteger|))
   "\\spad{var2Steps(n)} indicates the number of subdivisions,{} \\spad{n},{} of the second range variable. This option is expressed in the form \\spad{var2Steps == n}."))
 (|var1Steps|
  (($ (|PositiveInteger|))
   "\\spad{var1Steps(n)} indicates the number of subdivisions,{} \\spad{n},{} of the first range variable. This option is expressed in the form \\spad{var1Steps == n}."))
 (|space|
  (($ (|ThreeSpace| (|DoubleFloat|)))
   "\\spad{space specifies} the space into which we will draw. If none is given then a new space is created."))
 (|ranges|
  (($ (|List| (|Segment| (|Float|))))
   "\\spad{ranges(l)} provides a list of user-specified ranges \\spad{l}. This option is expressed in the form \\spad{ranges == l}."))
 (|range|
  (($ (|List| (|Segment| (|Fraction| (|Integer|)))))
   "\\spad{range([i])} provides a user-specified range \\spad{i}. This option is expressed in the form \\spad{range == [i]}.")
  (($ (|List| (|Segment| (|Float|))))
   "\\spad{range([l])} provides a user-specified range \\spad{l}. This option is expressed in the form \\spad{range == [l]}."))
 (|tubeRadius|
  (($ (|Float|))
   "\\spad{tubeRadius(r)} specifies a radius,{} \\spad{r},{} for a tube plot around a 3D curve; is expressed in the form \\spad{tubeRadius == 4}."))
 (|colorFunction|
  (($
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
               (|DoubleFloat|)))
   "\\spad{colorFunction(f(x,{} y,{} z))} specifies the color for three dimensional plots as a function of \\spad{x},{} \\spad{y},{} and \\spad{z} coordinates. This option is expressed in the form \\spad{colorFunction == f(x,{} y,{} z)}.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
   "\\spad{colorFunction(f(u,{} v))} specifies the color for three dimensional plots as a function based upon the two parametric variables. This option is expressed in the form \\spad{colorFunction == f(u,{} v)}.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
   "\\spad{colorFunction(f(z))} specifies the color based upon the \\spad{z}-component of three dimensional plots. This option is expressed in the form \\spad{colorFunction == f(z)}."))
 (|curveColor|
  (($ (|Palette|))
   "\\spad{curveColor(p)} specifies a color index for 2D graph curves from the spadcolors palette \\spad{p}. This option is expressed in the form \\spad{curveColor ==p}.")
  (($ (|Float|))
   "\\spad{curveColor(v)} specifies a color,{} \\spad{v},{} for 2D graph curves. This option is expressed in the form \\spad{curveColor == v}."))
 (|pointColor|
  (($ (|Palette|))
   "\\spad{pointColor(p)} specifies a color index for 2D graph points from the spadcolors palette \\spad{p}. This option is expressed in the form \\spad{pointColor == p}.")
  (($ (|Float|))
   "\\spad{pointColor(v)} specifies a color,{} \\spad{v},{} for 2D graph points. This option is expressed in the form \\spad{pointColor == v}."))
 (|coordinates|
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))))
   "\\spad{coordinates(p)} specifies a change of coordinate systems of point \\spad{p}. This option is expressed in the form \\spad{coordinates == p}."))
 (|toScale|
  (($ (|Boolean|))
   "\\spad{toScale(b)} specifies whether or not a plot is to be drawn to scale; if \\spad{b} is \\spad{true} it is drawn to scale,{} if \\spad{b} is \\spad{false} it is not. This option is expressed in the form \\spad{toScale == b}."))
 (|style|
  (($ (|String|))
   "\\spad{style(s)} specifies the drawing style in which the graph will be plotted by the indicated string \\spad{s}. This option is expressed in the form \\spad{style == s}."))
 (|title|
  (($ (|String|))
   "\\spad{title(s)} specifies a title for a plot by the indicated string \\spad{s}. This option is expressed in the form \\spad{title == s}."))
 (|viewpoint|
  (($
    (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|))
              (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|))
              (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|))
              (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))))
   "\\spad{viewpoint(vp)} creates a viewpoint data structure corresponding to the list of values. The values are interpreted as [theta,{} phi,{} scale,{} scaleX,{} scaleY,{} scaleZ,{} deltaX,{} deltaY]. This option is expressed in the form \\spad{viewpoint == ls}."))
 (|clip|
  (($ (|List| (|Segment| (|Float|))))
   "\\spad{clip([l])} provides ranges for user-defined clipping as specified in the list \\spad{l}. This option is expressed in the form \\spad{clip == [l]}.")
  (($ (|Boolean|))
   "\\spad{clip(b)} turns 2D clipping on if \\spad{b} is \\spad{true},{} or off if \\spad{b} is \\spad{false}. This option is expressed in the form \\spad{clip == b}."))
 (|adaptive|
  (($ (|Boolean|))
   "\\spad{adaptive(b)} turns adaptive 2D plotting on if \\spad{b} is \\spad{true},{} or off if \\spad{b} is \\spad{false}. This option is expressed in the form \\spad{adaptive == b}."))) 
NIL 
(|DrawOptionFunctions0|) 
((|constructor| (NIL "This package \\undocumented{}"))
 (|units|
  (((|List| (|Float|)) (|List| (|DrawOption|)) (|List| (|Float|)))
   "\\spad{units(l,{} u)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{unit}. If the option does not exist the value,{} \\spad{u} is returned."))
 (|coord|
  (((|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))
    (|List| (|DrawOption|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))))
   "\\spad{coord(l,{} p)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{coord}. If the option does not exist the value,{} \\spad{p} is returned."))
 (|tubeRadius|
  (((|Float|) (|List| (|DrawOption|)) (|Float|))
   "\\spad{tubeRadius(l,{} n)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{tubeRadius}. If the option does not exist the value,{} \\spad{n} is returned."))
 (|tubePoints|
  (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|))
   "\\spad{tubePoints(l,{} n)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{tubePoints}. If the option does not exist the value,{} \\spad{n} is returned."))
 (|space|
  (((|ThreeSpace| (|DoubleFloat|)) (|List| (|DrawOption|)))
   "\\spad{space(l)} takes a list of draw options,{} \\spad{l},{} and checks to see if it contains the option \\spad{space}. If the option doesn\\spad{'t} exist,{} then an empty space is returned."))
 (|var2Steps|
  (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|))
   "\\spad{var2Steps(l,{} n)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{var2Steps}. If the option does not exist the value,{} \\spad{n} is returned."))
 (|var1Steps|
  (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|))
   "\\spad{var1Steps(l,{} n)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{var1Steps}. If the option does not exist the value,{} \\spad{n} is returned."))
 (|ranges|
  (((|List| (|Segment| (|Float|))) (|List| (|DrawOption|))
    (|List| (|Segment| (|Float|))))
   "\\spad{ranges(l,{} r)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{ranges}. If the option does not exist the value,{} \\spad{r} is returned."))
 (|curveColorPalette|
  (((|Palette|) (|List| (|DrawOption|)) (|Palette|))
   "\\spad{curveColorPalette(l,{} p)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{curveColorPalette}. If the option does not exist the value,{} \\spad{p} is returned."))
 (|pointColorPalette|
  (((|Palette|) (|List| (|DrawOption|)) (|Palette|))
   "\\spad{pointColorPalette(l,{} p)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{pointColorPalette}. If the option does not exist the value,{} \\spad{p} is returned."))
 (|toScale|
  (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|))
   "\\spad{toScale(l,{} b)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{toScale}. If the option does not exist the value,{} \\spad{b} is returned."))
 (|style|
  (((|String|) (|List| (|DrawOption|)) (|String|))
   "\\spad{style(l,{} s)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{style}. If the option does not exist the value,{} \\spad{s} is returned."))
 (|title|
  (((|String|) (|List| (|DrawOption|)) (|String|))
   "\\spad{title(l,{} s)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{title}. If the option does not exist the value,{} \\spad{s} is returned."))
 (|viewpoint|
  (((|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|))
              (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|))
              (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|))
              (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)))
    (|List| (|DrawOption|))
    (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|))
              (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|))
              (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|))
              (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))))
   "\\spad{viewpoint(l,{} ls)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{viewpoint}. IF the option does not exist,{} the value \\spad{ls} is returned."))
 (|clipBoolean|
  (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|))
   "\\spad{clipBoolean(l,{} b)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{clipBoolean}. If the option does not exist the value,{} \\spad{b} is returned."))
 (|adaptive|
  (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|))
   "\\spad{adaptive(l,{} b)} takes the list of draw options,{} \\spad{l},{} and checks the list to see if it contains the option \\spad{adaptive}. If the option does not exist the value,{} \\spad{b} is returned."))) 
NIL 
(|DrawOptionFunctions1| S) 
((|constructor| (NIL "This package \\undocumented{}"))
 (|option|
  (((|Union| |#1| "failed") (|List| (|DrawOption|)) (|Symbol|))
   "\\spad{option(l,{} s)} determines whether the indicated drawing option,{} \\spad{s},{} is contained in the list of drawing options,{} \\spad{l},{} which is defined by the draw command."))) 
NIL 
(|DifferentialSparseMultivariatePolynomial| R S V) 
((|constructor|
  (NIL
   "\\spadtype{DifferentialSparseMultivariatePolynomial} implements an ordinary differential polynomial ring by combining a domain belonging to the category \\spadtype{DifferentialVariableCategory} with the domain \\spadtype{SparseMultivariatePolynomial}. \\blankline"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| |#3| (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|IndexedExponents| |#3|) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#3| (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#3|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| |#3|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| |#3|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#3| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#3|
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|DistributionContinuedFractionPackage| R |z|) 
((|constructor|
  (NIL
   "A package to compute Jacobi continued fractions of Cauchy transforms."))
 (|JContinuedFraction|
  (((|ContinuedFraction| (|UnivariatePolynomial| |#2| (|Fraction| |#1|)))
    (|Distribution| |#1|) (|UnivariatePolynomial| |#2| (|Fraction| |#1|)))
   "\\spad{JContinuedFraction(d,{} z)} returns the Cauchy transform as a continued fraction at \\spad{z}.")
  (((|ContinuedFraction| (|UnivariatePolynomial| |#2| |#1|))
    (|Distribution| |#1|) (|UnivariatePolynomial| |#2| |#1|))
   "\\spad{JContinuedFraction(d,{} z)} returns the Cauchy transform as a continued fraction at \\spad{z}."))) 
((|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|not| (|HasCategory| |#1| '(|Field|))))) 
(|DifferentialVariableCategory&| A S) 
((|constructor|
  (NIL
   "\\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If \\spad{x},{} ...,{} \\spad{y} is an ordered set of differential indeterminates,{} and the prime notation is used for differentiation,{} then the set of derivatives (including zero-th order) of the differential indeterminates is \\spad{x},{} \\spad{x'},{} \\spad{x''},{} ...,{} \\spad{y},{} \\spad{y'},{} \\spad{y''},{} ... (Note: in the interpreter,{} the \\spad{n}-th derivative of \\spad{y} is displayed as \\spad{y} with a subscript \\spad{n}.) This set is viewed as a set of algebraic indeterminates,{} totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \\blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives,{} and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates,{} just as one associates a domain in the category \\spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \\spadfun{<}. For example,{} one may define one derivative to be less than another by lexicographically comparing first the \\spadfun{order},{} then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \\blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates,{} Very often,{} a grading is the first step in ordering the set of monomials. For differential polynomial domains,{} this constructor provides a function \\spadfun{weight},{} which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example,{} one may define the weight of a derivative to be simply its \\spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials,{} providing a graded ring structure."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(s)} returns \\spad{s},{} viewed as the zero-th order derivative of \\spad{s}."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(v,{} n)} returns the \\spad{n}-th derivative of \\spad{v}.")
  (($ $) "\\spad{differentiate(v)} returns the derivative of \\spad{v}."))
 (|weight|
  (((|NonNegativeInteger|) $)
   "\\spad{weight(v)} returns the weight of the derivative \\spad{v}."))
 (|variable|
  ((|#2| $)
   "\\spad{variable(v)} returns \\spad{s} if \\spad{v} is any derivative of the differential indeterminate \\spad{s}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(v)} returns \\spad{n} if \\spad{v} is the \\spad{n}-th derivative of any differential indeterminate."))
 (|makeVariable|
  (($ |#2| (|NonNegativeInteger|))
   "\\spad{makeVariable(s,{} n)} returns the \\spad{n}-th derivative of a differential indeterminate \\spad{s} as an algebraic indeterminate."))) 
NIL 
(|DifferentialVariableCategory| S) 
((|constructor|
  (NIL
   "\\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If \\spad{x},{} ...,{} \\spad{y} is an ordered set of differential indeterminates,{} and the prime notation is used for differentiation,{} then the set of derivatives (including zero-th order) of the differential indeterminates is \\spad{x},{} \\spad{x'},{} \\spad{x''},{} ...,{} \\spad{y},{} \\spad{y'},{} \\spad{y''},{} ... (Note: in the interpreter,{} the \\spad{n}-th derivative of \\spad{y} is displayed as \\spad{y} with a subscript \\spad{n}.) This set is viewed as a set of algebraic indeterminates,{} totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \\blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives,{} and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates,{} just as one associates a domain in the category \\spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \\spadfun{<}. For example,{} one may define one derivative to be less than another by lexicographically comparing first the \\spadfun{order},{} then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \\blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates,{} Very often,{} a grading is the first step in ordering the set of monomials. For differential polynomial domains,{} this constructor provides a function \\spadfun{weight},{} which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example,{} one may define the weight of a derivative to be simply its \\spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials,{} providing a graded ring structure."))
 (|coerce|
  (($ |#1|)
   "\\spad{coerce(s)} returns \\spad{s},{} viewed as the zero-th order derivative of \\spad{s}."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(v,{} n)} returns the \\spad{n}-th derivative of \\spad{v}.")
  (($ $) "\\spad{differentiate(v)} returns the derivative of \\spad{v}."))
 (|weight|
  (((|NonNegativeInteger|) $)
   "\\spad{weight(v)} returns the weight of the derivative \\spad{v}."))
 (|variable|
  ((|#1| $)
   "\\spad{variable(v)} returns \\spad{s} if \\spad{v} is any derivative of the differential indeterminate \\spad{s}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(v)} returns \\spad{n} if \\spad{v} is the \\spad{n}-th derivative of any differential indeterminate."))
 (|makeVariable|
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{makeVariable(s,{} n)} returns the \\spad{n}-th derivative of a differential indeterminate \\spad{s} as an algebraic indeterminate."))) 
NIL 
(|ExtAlgBasis|) 
((|constructor|
  (NIL
   "A domain used in the construction of the exterior algebra on a set \\spad{X} over a ring \\spad{R}. This domain represents the set of all ordered subsets of the set \\spad{X},{} assumed to be in correspondance with {1,{} 2,{} 3,{} ...}. The ordered subsets are themselves ordered lexicographically and are in bijective correspondance with an ordered basis of the exterior algebra. In this domain we are dealing strictly with the exponents of basis elements which can only be 0 or 1. \\blankline The multiplicative identity element of the exterior algebra corresponds to the empty subset of \\spad{X}. A coerce from List Integer to an ordered basis element is provided to allow the convenient input of expressions. Another exported function forgets the ordered structure and simply returns the list corresponding to an ordered subset."))
 (|Nul|
  (($ (|NonNegativeInteger|))
   "\\spad{Nul()} gives the basis element 1 for the algebra generated by \\spad{n} generators."))
 (|exponents|
  (((|List| (|Integer|)) $)
   "\\spad{exponents(x)} converts a domain element into a list of zeros and ones corresponding to the exponents in the basis element that \\spad{x} represents."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(x)} gives the numbers of 1\\spad{'s} in \\spad{x},{} \\spadignore{i.e.} the number of non-zero exponents in the basis element that \\spad{x} represents."))
 (|coerce|
  (($ (|List| (|Integer|)))
   "\\spad{coerce(l)} converts a list of 0\\spad{'s} and 1\\spad{'s} into a basis element,{} where 1 (respectively 0) designates that the variable of the corresponding index of \\spad{l} is (respectively,{} is not) present. Error: if an element of \\spad{l} is not 0 or 1."))) 
NIL 
(|ElementaryFunction| R F) 
((|constructor| (NIL "Provides elementary functions over an integral domain."))
 (|localReal?|
  (((|Boolean|) |#2|) "\\spad{localReal?(x)} should be local but conditional"))
 (|specialTrigs|
  (((|Union| |#2| "failed") |#2|
    (|List| (|Record| (|:| |func| |#2|) (|:| |pole| (|Boolean|)))))
   "\\spad{specialTrigs(x,{} l)} should be local but conditional"))
 (|iiacsch| ((|#2| |#2|) "\\spad{iiacsch(x)} should be local but conditional"))
 (|iiasech| ((|#2| |#2|) "\\spad{iiasech(x)} should be local but conditional"))
 (|iiacoth| ((|#2| |#2|) "\\spad{iiacoth(x)} should be local but conditional"))
 (|iiatanh| ((|#2| |#2|) "\\spad{iiatanh(x)} should be local but conditional"))
 (|iiacosh| ((|#2| |#2|) "\\spad{iiacosh(x)} should be local but conditional"))
 (|iiasinh| ((|#2| |#2|) "\\spad{iiasinh(x)} should be local but conditional"))
 (|iicsch| ((|#2| |#2|) "\\spad{iicsch(x)} should be local but conditional"))
 (|iisech| ((|#2| |#2|) "\\spad{iisech(x)} should be local but conditional"))
 (|iicoth| ((|#2| |#2|) "\\spad{iicoth(x)} should be local but conditional"))
 (|iitanh| ((|#2| |#2|) "\\spad{iitanh(x)} should be local but conditional"))
 (|iicosh| ((|#2| |#2|) "\\spad{iicosh(x)} should be local but conditional"))
 (|iisinh| ((|#2| |#2|) "\\spad{iisinh(x)} should be local but conditional"))
 (|iiacsc| ((|#2| |#2|) "\\spad{iiacsc(x)} should be local but conditional"))
 (|iiasec| ((|#2| |#2|) "\\spad{iiasec(x)} should be local but conditional"))
 (|iiacot| ((|#2| |#2|) "\\spad{iiacot(x)} should be local but conditional"))
 (|iiatan| ((|#2| |#2|) "\\spad{iiatan(x)} should be local but conditional"))
 (|iiacos| ((|#2| |#2|) "\\spad{iiacos(x)} should be local but conditional"))
 (|iiasin| ((|#2| |#2|) "\\spad{iiasin(x)} should be local but conditional"))
 (|iicsc| ((|#2| |#2|) "\\spad{iicsc(x)} should be local but conditional"))
 (|iisec| ((|#2| |#2|) "\\spad{iisec(x)} should be local but conditional"))
 (|iicot| ((|#2| |#2|) "\\spad{iicot(x)} should be local but conditional"))
 (|iitan| ((|#2| |#2|) "\\spad{iitan(x)} should be local but conditional"))
 (|iicos| ((|#2| |#2|) "\\spad{iicos(x)} should be local but conditional"))
 (|iisin| ((|#2| |#2|) "\\spad{iisin(x)} should be local but conditional"))
 (|iilog| ((|#2| |#2|) "\\spad{iilog(x)} should be local but conditional"))
 (|iiexp| ((|#2| |#2|) "\\spad{iiexp(x)} should be local but conditional"))
 (|iisqrt3| ((|#2|) "\\spad{iisqrt3()} should be local but conditional"))
 (|iisqrt2| ((|#2|) "\\spad{iisqrt2()} should be local but conditional"))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(p)} returns an elementary operator with the same symbol as \\spad{p}"))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(p)} returns \\spad{true} if operator \\spad{p} is elementary"))
 (|pi| ((|#2|) "\\spad{\\spad{pi}()} returns the \\spad{pi} operator"))
 (|acsch|
  ((|#2| |#2|)
   "\\spad{acsch(x)} applies the inverse hyperbolic cosecant operator to \\spad{x}"))
 (|asech|
  ((|#2| |#2|)
   "\\spad{asech(x)} applies the inverse hyperbolic secant operator to \\spad{x}"))
 (|acoth|
  ((|#2| |#2|)
   "\\spad{acoth(x)} applies the inverse hyperbolic cotangent operator to \\spad{x}"))
 (|atanh|
  ((|#2| |#2|)
   "\\spad{atanh(x)} applies the inverse hyperbolic tangent operator to \\spad{x}"))
 (|acosh|
  ((|#2| |#2|)
   "\\spad{acosh(x)} applies the inverse hyperbolic cosine operator to \\spad{x}"))
 (|asinh|
  ((|#2| |#2|)
   "\\spad{asinh(x)} applies the inverse hyperbolic sine operator to \\spad{x}"))
 (|csch|
  ((|#2| |#2|)
   "\\spad{csch(x)} applies the hyperbolic cosecant operator to \\spad{x}"))
 (|sech|
  ((|#2| |#2|)
   "\\spad{sech(x)} applies the hyperbolic secant operator to \\spad{x}"))
 (|coth|
  ((|#2| |#2|)
   "\\spad{coth(x)} applies the hyperbolic cotangent operator to \\spad{x}"))
 (|tanh|
  ((|#2| |#2|)
   "\\spad{tanh(x)} applies the hyperbolic tangent operator to \\spad{x}"))
 (|cosh|
  ((|#2| |#2|)
   "\\spad{cosh(x)} applies the hyperbolic cosine operator to \\spad{x}"))
 (|sinh|
  ((|#2| |#2|)
   "\\spad{sinh(x)} applies the hyperbolic sine operator to \\spad{x}"))
 (|acsc|
  ((|#2| |#2|)
   "\\spad{acsc(x)} applies the inverse cosecant operator to \\spad{x}"))
 (|asec|
  ((|#2| |#2|)
   "\\spad{asec(x)} applies the inverse secant operator to \\spad{x}"))
 (|acot|
  ((|#2| |#2|)
   "\\spad{acot(x)} applies the inverse cotangent operator to \\spad{x}"))
 (|atan|
  ((|#2| |#2|)
   "\\spad{atan(x)} applies the inverse tangent operator to \\spad{x}"))
 (|acos|
  ((|#2| |#2|)
   "\\spad{acos(x)} applies the inverse cosine operator to \\spad{x}"))
 (|asin|
  ((|#2| |#2|)
   "\\spad{asin(x)} applies the inverse sine operator to \\spad{x}"))
 (|csc|
  ((|#2| |#2|) "\\spad{csc(x)} applies the cosecant operator to \\spad{x}"))
 (|sec|
  ((|#2| |#2|) "\\spad{sec(x)} applies the secant operator to \\spad{x}"))
 (|cot|
  ((|#2| |#2|) "\\spad{cot(x)} applies the cotangent operator to \\spad{x}"))
 (|tan|
  ((|#2| |#2|) "\\spad{tan(x)} applies the tangent operator to \\spad{x}"))
 (|cos|
  ((|#2| |#2|) "\\spad{cos(x)} applies the cosine operator to \\spad{x}"))
 (|sin| ((|#2| |#2|) "\\spad{sin(x)} applies the sine operator to \\spad{x}"))
 (|log|
  ((|#2| |#2|) "\\spad{log(x)} applies the logarithm operator to \\spad{x}"))
 (|exp|
  ((|#2| |#2|) "\\spad{exp(x)} applies the exponential operator to \\spad{x}"))) 
NIL 
(|ExpressionFactorPolynomial| R F) 
((|poly_factor|
  (((|Factored|
     (|SparseUnivariatePolynomial|
      (|SparseMultivariatePolynomial| |#1| (|Kernel| |#2|))))
    (|SparseUnivariatePolynomial|
     (|SparseMultivariatePolynomial| |#1| (|Kernel| |#2|))))
   "\\spad{poly_factor(p)} should be local but conditional."))
 (|factor|
  (((|Factored| (|SparseUnivariatePolynomial| |#2|))
    (|SparseUnivariatePolynomial| |#2|) (|List| |#2|))
   "\\spad{factor(p,{} [k1,{} ...,{} kn])} factors \\spad{p} into irreducible factors over field generated by its coefficients and \\spad{k1},{} ...,{} \\spad{kn}."))
 (|factorPolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| |#2|))
    (|SparseUnivariatePolynomial| |#2|))
   "\\spad{factorPolynomial(p)} factors \\spad{p} into irreducible factors over field generated by its coefficients."))) 
NIL 
(|ElementaryFunctionsGeneralizedUnivariatePowerSeries| |Coef| |Expon| PS) 
((|constructor| (NIL "Author: Waldek Hebisch"))) 
NIL 
(|ElementaryFunctionStructurePackage| R F) 
((|constructor|
  (NIL
   "ElementaryFunctionStructurePackage provides functions to test the algebraic independence of various elementary functions,{} using the Risch structure theorem (real and complex versions). It also provides transformations on elementary functions which are not considered simplifications."))
 (|irootDep|
  (((|Union| (|:| |vec| (|Vector| (|Fraction| (|Integer|)))) (|:| |func| |#2|)
             (|:| |fail| (|Boolean|)))
    (|Kernel| |#2|))
   "\\spad{irootDep(k)} is a local function with a conditional implementation."))
 (|tanQ|
  ((|#2| (|Fraction| (|Integer|)) |#2|)
   "\\spad{tanQ(q,{} a)} is a local function with a conditional implementation."))
 (|rmap|
  ((|#2| (|Mapping| |#2| (|Kernel| |#2|)) |#2|)
   "\\spad{rmap(f,{} e)} rewrites \\spad{e} replacing each kernel \\spad{k} in \\spad{e} by \\spad{f}(\\spad{k})"))
 (|rootNormalize|
  ((|#2| |#2| (|Kernel| |#2|))
   "\\spad{rootNormalize(f,{} k)} returns \\spad{f} rewriting either \\spad{k} which must be an \\spad{n}th-root in terms of radicals already in \\spad{f},{} or some radicals in \\spad{f} in terms of \\spad{k}."))
 (|validExponential|
  (((|Union| |#2| "failed") (|List| (|Kernel| |#2|)) |#2| (|Symbol|))
   "\\spad{validExponential([k1,{} ...,{} kn],{} f,{} x)} returns \\spad{g} if \\spad{exp(f)=g} and \\spad{g} involves only \\spad{k1...kn},{} and \"failed\" otherwise."))
 (|realLiouvillian|
  ((|#2| |#2| (|Symbol|))
   "\\spad{realLiouvillian(f,{} x)} rewrites \\spad{f} elementary kernels of \\spad{f} in terms 4 fundamental real elementary functions: \\spad{log,{} exp,{} tan,{} atan}. Additionally,{} it rewrites Liouvillian functions of \\spad{x} as indefinite integrals to support better normalization.")
  ((|#2| |#2|)
   "\\spad{realLiouvillian(f)} rewrites \\spad{f} elementary kernels of \\spad{f} in terms 4 fundamental real elementary functions: \\spad{log,{} exp,{} tan,{} atan}. Additionally,{} it rewrites Liouvillian functions as indefinite integrals to support better normalization."))
 (|realElementary|
  ((|#2| |#2| (|Symbol|))
   "\\spad{realElementary(f,{} x)} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 4 fundamental real transcendental elementary functions: \\spad{log,{} exp,{} tan,{} atan}.")
  ((|#2| |#2|)
   "\\spad{realElementary(f)} rewrites \\spad{f} in terms of the 4 fundamental real transcendental elementary functions: \\spad{log,{} exp,{} tan,{} atan}."))
 (|rischNormalize|
  (((|Record| (|:| |funcs| (|List| |#2|)) (|:| |kers| (|List| (|Kernel| |#2|)))
              (|:| |vals| (|List| |#2|)))
    (|List| |#2|) (|List| (|Symbol|)))
   "\\spad{rischNormalize(lf,{} lx)} returns \\spad{[lg,{} [k1,{} ...,{} kn],{} [h1,{} ...,{} hn]]} such that \\spad{lg = normalize(lf,{} lx)} and each \\spad{\\spad{ki}} was rewritten as \\spad{\\spad{hi}} during the normalization.")
  (((|Record| (|:| |func| |#2|) (|:| |kers| (|List| (|Kernel| |#2|)))
              (|:| |vals| (|List| |#2|)))
    |#2| (|List| (|Symbol|)))
   "\\spad{rischNormalize(f,{} lx)} is rischNormalize([\\spad{f}],{} \\spad{lx})")
  (((|Record| (|:| |func| |#2|) (|:| |kers| (|List| (|Kernel| |#2|)))
              (|:| |vals| (|List| |#2|)))
    |#2| (|Symbol|))
   "\\spad{rischNormalize(f,{} x)} is rischNormalize([\\spad{f}],{} [\\spad{x}]) rischNormalize(\\spad{f},{} \\spad{x}) returns \\spad{[g,{} [k1,{} ...,{} kn],{} [h1,{} ...,{} hn]]} such that \\spad{g = normalize(f,{} x)} and each \\spad{\\spad{ki}} was rewritten as \\spad{\\spad{hi}} during the normalization."))
 (|normalize|
  (((|List| |#2|) (|List| |#2|) (|List| (|Symbol|)))
   "\\spad{normalize([f1,{} ...,{} fn],{} lx)} rewrites \\spad{f1,{} ...,{} fn} using the least possible number of real algebraically independent kernels. Additionally,{} it tries to ensure that any expression in resulting kernels which syntactically depends on a variable \\spad{x} from \\spad{lx} has nonzero derivative with respect to \\spad{x}.")
  ((|#2| |#2| (|Symbol|))
   "\\spad{normalize(f,{} x)} is normalize([\\spad{f}],{} [\\spad{x}])")
  (((|List| |#2|) (|List| |#2|))
   "\\spad{normalize(lf)} is normalize(\\spad{lf},{} [])")
  ((|#2| |#2|)
   "\\spad{normalize(f)} rewrites \\spad{f} using the least possible number of real algebraically independent kernels."))) 
NIL 
(|ElementaryFunctionsUnivariateLaurentSeries| |Coef| UTS ULS) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return \"failed\" when this is not possible."))
 (|acsch|
  ((|#3| |#3|)
   "\\spad{acsch(z)} returns the inverse hyperbolic cosecant of Laurent series \\spad{z}."))
 (|asech|
  ((|#3| |#3|)
   "\\spad{asech(z)} returns the inverse hyperbolic secant of Laurent series \\spad{z}."))
 (|acoth|
  ((|#3| |#3|)
   "\\spad{acoth(z)} returns the inverse hyperbolic cotangent of Laurent series \\spad{z}."))
 (|atanh|
  ((|#3| |#3|)
   "\\spad{atanh(z)} returns the inverse hyperbolic tangent of Laurent series \\spad{z}."))
 (|acosh|
  ((|#3| |#3|)
   "\\spad{acosh(z)} returns the inverse hyperbolic cosine of Laurent series \\spad{z}."))
 (|asinh|
  ((|#3| |#3|)
   "\\spad{asinh(z)} returns the inverse hyperbolic sine of Laurent series \\spad{z}."))
 (|csch|
  ((|#3| |#3|)
   "\\spad{csch(z)} returns the hyperbolic cosecant of Laurent series \\spad{z}."))
 (|sech|
  ((|#3| |#3|)
   "\\spad{sech(z)} returns the hyperbolic secant of Laurent series \\spad{z}."))
 (|coth|
  ((|#3| |#3|)
   "\\spad{coth(z)} returns the hyperbolic cotangent of Laurent series \\spad{z}."))
 (|tanh|
  ((|#3| |#3|)
   "\\spad{tanh(z)} returns the hyperbolic tangent of Laurent series \\spad{z}."))
 (|cosh|
  ((|#3| |#3|)
   "\\spad{cosh(z)} returns the hyperbolic cosine of Laurent series \\spad{z}."))
 (|sinh|
  ((|#3| |#3|)
   "\\spad{sinh(z)} returns the hyperbolic sine of Laurent series \\spad{z}."))
 (|acsc|
  ((|#3| |#3|)
   "\\spad{acsc(z)} returns the arc-cosecant of Laurent series \\spad{z}."))
 (|asec|
  ((|#3| |#3|)
   "\\spad{asec(z)} returns the arc-secant of Laurent series \\spad{z}."))
 (|acot|
  ((|#3| |#3|)
   "\\spad{acot(z)} returns the arc-cotangent of Laurent series \\spad{z}."))
 (|atan|
  ((|#3| |#3|)
   "\\spad{atan(z)} returns the arc-tangent of Laurent series \\spad{z}."))
 (|acos|
  ((|#3| |#3|)
   "\\spad{acos(z)} returns the arc-cosine of Laurent series \\spad{z}."))
 (|asin|
  ((|#3| |#3|)
   "\\spad{asin(z)} returns the arc-sine of Laurent series \\spad{z}."))
 (|csc|
  ((|#3| |#3|)
   "\\spad{csc(z)} returns the cosecant of Laurent series \\spad{z}."))
 (|sec|
  ((|#3| |#3|)
   "\\spad{sec(z)} returns the secant of Laurent series \\spad{z}."))
 (|cot|
  ((|#3| |#3|)
   "\\spad{cot(z)} returns the cotangent of Laurent series \\spad{z}."))
 (|tan|
  ((|#3| |#3|)
   "\\spad{tan(z)} returns the tangent of Laurent series \\spad{z}."))
 (|cos|
  ((|#3| |#3|)
   "\\spad{cos(z)} returns the cosine of Laurent series \\spad{z}."))
 (|sin|
  ((|#3| |#3|) "\\spad{sin(z)} returns the sine of Laurent series \\spad{z}."))
 (|log|
  ((|#3| |#3|)
   "\\spad{log(z)} returns the logarithm of Laurent series \\spad{z}."))
 (|exp|
  ((|#3| |#3|)
   "\\spad{exp(z)} returns the exponential of Laurent series \\spad{z}."))
 (^
  ((|#3| |#3| (|Fraction| (|Integer|)))
   "\\spad{s ^ r} raises a Laurent series \\spad{s} to a rational power \\spad{r}"))) 
((|HasCategory| |#1| '(|Field|))) 
(|ElementaryFunctionsUnivariatePuiseuxSeries| |Coef| ULS UPXS EFULS) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return \"failed\" when this is not possible."))
 (|acsch|
  ((|#3| |#3|)
   "\\spad{acsch(z)} returns the inverse hyperbolic cosecant of a Puiseux series \\spad{z}."))
 (|asech|
  ((|#3| |#3|)
   "\\spad{asech(z)} returns the inverse hyperbolic secant of a Puiseux series \\spad{z}."))
 (|acoth|
  ((|#3| |#3|)
   "\\spad{acoth(z)} returns the inverse hyperbolic cotangent of a Puiseux series \\spad{z}."))
 (|atanh|
  ((|#3| |#3|)
   "\\spad{atanh(z)} returns the inverse hyperbolic tangent of a Puiseux series \\spad{z}."))
 (|acosh|
  ((|#3| |#3|)
   "\\spad{acosh(z)} returns the inverse hyperbolic cosine of a Puiseux series \\spad{z}."))
 (|asinh|
  ((|#3| |#3|)
   "\\spad{asinh(z)} returns the inverse hyperbolic sine of a Puiseux series \\spad{z}."))
 (|csch|
  ((|#3| |#3|)
   "\\spad{csch(z)} returns the hyperbolic cosecant of a Puiseux series \\spad{z}."))
 (|sech|
  ((|#3| |#3|)
   "\\spad{sech(z)} returns the hyperbolic secant of a Puiseux series \\spad{z}."))
 (|coth|
  ((|#3| |#3|)
   "\\spad{coth(z)} returns the hyperbolic cotangent of a Puiseux series \\spad{z}."))
 (|tanh|
  ((|#3| |#3|)
   "\\spad{tanh(z)} returns the hyperbolic tangent of a Puiseux series \\spad{z}."))
 (|cosh|
  ((|#3| |#3|)
   "\\spad{cosh(z)} returns the hyperbolic cosine of a Puiseux series \\spad{z}."))
 (|sinh|
  ((|#3| |#3|)
   "\\spad{sinh(z)} returns the hyperbolic sine of a Puiseux series \\spad{z}."))
 (|acsc|
  ((|#3| |#3|)
   "\\spad{acsc(z)} returns the arc-cosecant of a Puiseux series \\spad{z}."))
 (|asec|
  ((|#3| |#3|)
   "\\spad{asec(z)} returns the arc-secant of a Puiseux series \\spad{z}."))
 (|acot|
  ((|#3| |#3|)
   "\\spad{acot(z)} returns the arc-cotangent of a Puiseux series \\spad{z}."))
 (|atan|
  ((|#3| |#3|)
   "\\spad{atan(z)} returns the arc-tangent of a Puiseux series \\spad{z}."))
 (|acos|
  ((|#3| |#3|)
   "\\spad{acos(z)} returns the arc-cosine of a Puiseux series \\spad{z}."))
 (|asin|
  ((|#3| |#3|)
   "\\spad{asin(z)} returns the arc-sine of a Puiseux series \\spad{z}."))
 (|csc|
  ((|#3| |#3|)
   "\\spad{csc(z)} returns the cosecant of a Puiseux series \\spad{z}."))
 (|sec|
  ((|#3| |#3|)
   "\\spad{sec(z)} returns the secant of a Puiseux series \\spad{z}."))
 (|cot|
  ((|#3| |#3|)
   "\\spad{cot(z)} returns the cotangent of a Puiseux series \\spad{z}."))
 (|tan|
  ((|#3| |#3|)
   "\\spad{tan(z)} returns the tangent of a Puiseux series \\spad{z}."))
 (|cos|
  ((|#3| |#3|)
   "\\spad{cos(z)} returns the cosine of a Puiseux series \\spad{z}."))
 (|sin|
  ((|#3| |#3|)
   "\\spad{sin(z)} returns the sine of a Puiseux series \\spad{z}."))
 (|log|
  ((|#3| |#3|)
   "\\spad{log(z)} returns the logarithm of a Puiseux series \\spad{z}."))
 (|exp|
  ((|#3| |#3|)
   "\\spad{exp(z)} returns the exponential of a Puiseux series \\spad{z}."))
 (^
  ((|#3| |#3| (|Fraction| (|Integer|)))
   "\\spad{z ^ r} raises a Puiseaux series \\spad{z} to a rational power \\spad{r}"))) 
((|HasCategory| |#1| '(|Field|))) 
(|ExtensibleLinearAggregate&| A S) 
((|constructor|
  (NIL
   "An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists which are represented by linked structures so as to make insertion,{} deletion,{} and concatenation efficient. However,{} access to elements of these extensible aggregates is generally slow since access is made from the end. See \\spadtype{FlexibleArray} for an exception."))
 (|removeDuplicates!|
  (($ $)
   "\\spad{removeDuplicates!(u)} destructively removes duplicates from \\spad{u}."))
 (|select!|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{select!(p,{} u)} destructively changes \\spad{u} by keeping only values \\spad{x} such that \\spad{p(x)}."))
 (|merge!|
  (($ $ $)
   "\\spad{merge!(u,{} v)} destructively merges \\spad{u} and \\spad{v} in ascending order.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $)
   "\\spad{merge!(p,{} u,{} v)} destructively merges \\spad{u} and \\spad{v} using predicate \\spad{p}."))
 (|insert!|
  (($ $ $ (|Integer|))
   "\\spad{insert!(v,{} u,{} i)} destructively inserts aggregate \\spad{v} into \\spad{u} at position \\spad{i}.")
  (($ |#2| $ (|Integer|))
   "\\spad{insert!(x,{} u,{} i)} destructively inserts \\spad{x} into \\spad{u} at position \\spad{i}."))
 (|remove!|
  (($ |#2| $)
   "\\spad{remove!(x,{} u)} destructively removes all values \\spad{x} from \\spad{u}.")
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{remove!(p,{} u)} destructively removes all elements \\spad{x} of \\spad{u} such that \\spad{p(x)} is \\spad{true}."))
 (|delete!|
  (($ $ (|UniversalSegment| (|Integer|)))
   "\\spad{delete!(u,{} i..j)} destructively deletes elements \\spad{u}.\\spad{i} through \\spad{u}.\\spad{j}.")
  (($ $ (|Integer|))
   "\\spad{delete!(u,{} i)} destructively deletes the \\spad{i}th element of \\spad{u}."))
 (|concat!|
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively appends \\spad{v} to the end of \\spad{u}. \\spad{v} is unchanged")
  (($ $ |#2|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}."))) 
((|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|BasicType|))) 
(|ExtensibleLinearAggregate| S) 
((|constructor|
  (NIL
   "An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists which are represented by linked structures so as to make insertion,{} deletion,{} and concatenation efficient. However,{} access to elements of these extensible aggregates is generally slow since access is made from the end. See \\spadtype{FlexibleArray} for an exception."))
 (|removeDuplicates!|
  (($ $)
   "\\spad{removeDuplicates!(u)} destructively removes duplicates from \\spad{u}."))
 (|select!|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{select!(p,{} u)} destructively changes \\spad{u} by keeping only values \\spad{x} such that \\spad{p(x)}."))
 (|merge!|
  (($ $ $)
   "\\spad{merge!(u,{} v)} destructively merges \\spad{u} and \\spad{v} in ascending order.")
  (($ (|Mapping| (|Boolean|) |#1| |#1|) $ $)
   "\\spad{merge!(p,{} u,{} v)} destructively merges \\spad{u} and \\spad{v} using predicate \\spad{p}."))
 (|insert!|
  (($ $ $ (|Integer|))
   "\\spad{insert!(v,{} u,{} i)} destructively inserts aggregate \\spad{v} into \\spad{u} at position \\spad{i}.")
  (($ |#1| $ (|Integer|))
   "\\spad{insert!(x,{} u,{} i)} destructively inserts \\spad{x} into \\spad{u} at position \\spad{i}."))
 (|remove!|
  (($ |#1| $)
   "\\spad{remove!(x,{} u)} destructively removes all values \\spad{x} from \\spad{u}.")
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{remove!(p,{} u)} destructively removes all elements \\spad{x} of \\spad{u} such that \\spad{p(x)} is \\spad{true}."))
 (|delete!|
  (($ $ (|UniversalSegment| (|Integer|)))
   "\\spad{delete!(u,{} i..j)} destructively deletes elements \\spad{u}.\\spad{i} through \\spad{u}.\\spad{j}.")
  (($ $ (|Integer|))
   "\\spad{delete!(u,{} i)} destructively deletes the \\spad{i}th element of \\spad{u}."))
 (|concat!|
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively appends \\spad{v} to the end of \\spad{u}. \\spad{v} is unchanged")
  (($ $ |#1|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}."))) 
NIL 
(|ElementaryFunctionCategory&| S) 
((|constructor| (NIL "Category for the elementary functions."))
 (^ (($ $ $) "\\spad{x^y} returns \\spad{x} to the power \\spad{y}."))
 (|exp| (($ $) "\\spad{exp(x)} returns \\%\\spad{e} to the power \\spad{x}."))
 (|log|
  (($ $)
   "\\spad{log(x)} returns the natural logarithm of \\spad{x}. When evaluated into some subset of the complex numbers,{} the branch cut lies along the negative real axis,{} continuous with quadrant II. The domain does not contain the origin."))) 
NIL 
(|ElementaryFunctionCategory|) 
((|constructor| (NIL "Category for the elementary functions."))
 (^ (($ $ $) "\\spad{x^y} returns \\spad{x} to the power \\spad{y}."))
 (|exp| (($ $) "\\spad{exp(x)} returns \\%\\spad{e} to the power \\spad{x}."))
 (|log|
  (($ $)
   "\\spad{log(x)} returns the natural logarithm of \\spad{x}. When evaluated into some subset of the complex numbers,{} the branch cut lies along the negative real axis,{} continuous with quadrant II. The domain does not contain the origin."))) 
NIL 
(|EllipticFunctionsUnivariateTaylorSeries| |Coef| UTS) 
((|constructor|
  (NIL
   "The elliptic functions \\spad{sn},{} \\spad{sc} and \\spad{dn} are expanded as Taylor series."))
 (|sncndn|
  (((|List| (|Stream| |#1|)) (|Stream| |#1|) |#1|)
   "\\spad{sncndn(s,{} c)} is used internally."))
 (|ellipticPi|
  ((|#2| |#2| |#1| |#1|)
   "\\spad{ellipticPi(z,{} n,{} m)} expands the elliptic integral \\spad{Pi} as a Taylor series in \\spad{z}."))
 (|ellipticF|
  ((|#2| |#2| |#1|)
   "\\spad{ellipticF(z,{} m)} expands the elliptic integral \\spad{F} as a Taylor series in \\spad{z}."))
 (|ellipticE|
  ((|#2| |#2| |#1|)
   "\\spad{ellipticE(z,{} m)} expands the elliptic integral \\spad{E} as a Taylor series in \\spad{z}."))
 (|jacobiDn|
  ((|#2| |#2| |#1|)
   "\\spad{jacobiDn(z,{} m)} expands the elliptic function \\spad{dn} as a Taylor \\indented{1}{series in \\spad{z}.}"))
 (|jacobiCn|
  ((|#2| |#2| |#1|)
   "\\spad{jacobiCn(z,{} m)} expands the elliptic function \\spad{cn} as a Taylor \\indented{1}{series in \\spad{z}.}"))
 (|jacobiSn|
  ((|#2| |#2| |#1|)
   "\\spad{jacobiSn(z,{} m)} expands the elliptic function \\spad{sn} as a Taylor \\indented{1}{series in \\spad{z}.}"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|ExpressionLinearSolve| R F) 
((|constructor|
  (NIL
   "Solver for linear systems represented as list \\indented{1}{of expressions.\\space{2}More efficient than using solve because} \\indented{1}{it does not check that system really is linear.}"))
 (|lin_sol|
  (((|Union| (|List| |#2|) "failed") (|List| |#2|) (|List| (|Symbol|)))
   "\\spad{lin_sol(eql,{} vl)} solves system of equations \\spad{eql} for variables in \\spad{vl}. Equations must be linear in variables from \\spad{vl}."))) 
NIL 
(|DoubleFloatEllipticIntegrals|) 
((|constructor|
  (NIL
   "\\spad{DoubleFloatEllipticIntegrals} implements machine A package for computing machine precision real and complex elliptic integrals,{} using algorithms given by Carlson. Note: Complex versions may misbehave for very large/small arguments and close to branch cuts."))
 (|ellipticPi|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind."))
 (|ellipticE|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind")
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.")
  (((|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind."))
 (|ellipticK|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticK(z,{} m)} is the incomplete elliptic integral of the first kind.")
  (((|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticK(z,{} m)} is the complete elliptic integral of the first kind."))
 (|ellipticF|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind."))
 (|ellipticRJ|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "ellipticRF(\\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{p}) computes integral from 0 to infinity of \\spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
    (|DoubleFloat|))
   "\\spad{ellipticRJ(x,{} y,{} z,{} p)} computes integral from 0 to infinity of \\spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}."))
 (|ellipticRF|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticRF(x,{} y,{} z)} computes integral from 0 to infinity of \\spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticRF(x,{} y,{} z)} computes integral from 0 to infinity of \\spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}."))
 (|ellipticRD|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticRD(x,{} y,{} z)} computes integral from 0 to infinity of \\spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticRD(x,{} y,{} z)} computes integral from 0 to infinity of \\spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}."))
 (|ellipticRC|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "\\spad{ellipticRC(x,{} y)} computes integral from 0 to infinity of \\spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}.")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{ellipticRC(x,{} y)} computes integral from 0 to infinity of \\spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}."))) 
NIL 
(|Eltable| D I) 
((|constructor|
  (NIL
   "An eltable over domains \\spad{D} and \\spad{I} is a structure which can be viewed as a function from \\spad{D} to \\spad{I}. Examples of eltable structures range from data structures,{} \\spadignore{e.g.} those of type \\spadtype{List},{} to algebraic structures,{} \\spadignore{e.g.} \\spadtype{Polynomial}."))
 (|elt|
  ((|#2| $ |#1|)
   "\\spad{elt(u,{} i)} (also written: \\spad{u}.\\spad{i}) returns the element of \\spad{u} indexed by \\spad{i}. Error: if \\spad{i} is not an index of \\spad{u}."))) 
NIL 
(|EltableAggregate&| S |Dom| |Im|) 
((|constructor|
  (NIL
   "An eltable aggregate is one which can be viewed as a function. For example,{} the list \\spad{[1,{} 7,{} 4]} can be applied to 1,{} 2,{} and 3 respectively and will return the integers 1,{} 7,{} and 4; thus this list may be viewed as mapping 1 to 1,{} 2 to 7 and 3 to 4. In general,{} an aggregate can map members of a domain {\\em Dom} to an image domain {\\em Im}."))
 (|qsetelt!|
  ((|#3| $ |#2| |#3|)
   "\\spad{qsetelt!(u,{} x,{} y)} sets the image of \\spad{x} to be \\spad{y} under \\spad{u},{} without checking that \\spad{x} is in the domain of \\spad{u}. If such a check is required use the function \\spad{setelt!}."))
 (|setelt!|
  ((|#3| $ |#2| |#3|)
   "\\spad{setelt!(u,{} x,{} y)} sets the image of \\spad{x} to be \\spad{y} under \\spad{u},{} if \\spad{x} is in the domain of \\spad{u}. Error: if \\spad{x} is not in the domain of \\spad{u}."))
 (|qelt|
  ((|#3| $ |#2|)
   "\\spad{qelt(u,{} x)} applies \\spad{u} to \\spad{x} without checking whether \\spad{x} is in the domain of \\spad{u}. If \\spad{x} is not in the domain of \\spad{u} a memory-access violation may occur. If a check on whether \\spad{x} is in the domain of \\spad{u} is required,{} use the function \\spad{elt}."))
 (|elt|
  ((|#3| $ |#2| |#3|)
   "\\spad{elt(u,{} x,{} y)} applies \\spad{u} to \\spad{x} if \\spad{x} is in the domain of \\spad{u},{} and returns \\spad{y} otherwise."))) 
((|HasCategory| |#1| '(|shallowlyMutable|))) 
(|EltableAggregate| |Dom| |Im|) 
((|constructor|
  (NIL
   "An eltable aggregate is one which can be viewed as a function. For example,{} the list \\spad{[1,{} 7,{} 4]} can be applied to 1,{} 2,{} and 3 respectively and will return the integers 1,{} 7,{} and 4; thus this list may be viewed as mapping 1 to 1,{} 2 to 7 and 3 to 4. In general,{} an aggregate can map members of a domain {\\em Dom} to an image domain {\\em Im}."))
 (|qsetelt!|
  ((|#2| $ |#1| |#2|)
   "\\spad{qsetelt!(u,{} x,{} y)} sets the image of \\spad{x} to be \\spad{y} under \\spad{u},{} without checking that \\spad{x} is in the domain of \\spad{u}. If such a check is required use the function \\spad{setelt!}."))
 (|setelt!|
  ((|#2| $ |#1| |#2|)
   "\\spad{setelt!(u,{} x,{} y)} sets the image of \\spad{x} to be \\spad{y} under \\spad{u},{} if \\spad{x} is in the domain of \\spad{u}. Error: if \\spad{x} is not in the domain of \\spad{u}."))
 (|qelt|
  ((|#2| $ |#1|)
   "\\spad{qelt(u,{} x)} applies \\spad{u} to \\spad{x} without checking whether \\spad{x} is in the domain of \\spad{u}. If \\spad{x} is not in the domain of \\spad{u} a memory-access violation may occur. If a check on whether \\spad{x} is in the domain of \\spad{u} is required,{} use the function \\spad{elt}."))
 (|elt|
  ((|#2| $ |#1| |#2|)
   "\\spad{elt(u,{} x,{} y)} applies \\spad{u} to \\spad{x} if \\spad{x} is in the domain of \\spad{u},{} and returns \\spad{y} otherwise."))) 
NIL 
(|EuclideanModularRing| S R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor|
  (NIL
   "These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{ModularRing},{} \\spadtype{ModularField}"))
 (|elt|
  ((|#2| $ |#2|) "\\spad{elt(x,{} r)} or \\spad{x}.\\spad{r} \\undocumented"))
 (|inv| (($ $) "\\spad{inv(x)} \\undocumented"))
 (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} \\undocumented"))
 (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,{} y)} \\undocumented"))
 (|reduce| (($ |#2| |#3|) "\\spad{reduce(r,{} m)} \\undocumented"))
 (|coerce| ((|#2| $) "\\spad{coerce(x)} \\undocumented"))
 (|modulus| ((|#3| $) "\\spad{modulus(x)} \\undocumented"))) 
NIL 
(|EntireRing&| S) 
((|constructor|
  (NIL
   "Entire Rings (non-commutative Integral Domains),{} \\spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \\blankline"))
 (|unit?|
  (((|Boolean|) $)
   "\\spad{unit?(x)} tests whether \\spad{x} is a unit,{} \\spadignore{i.e.} is invertible."))
 (|associates?|
  (((|Boolean|) $ $)
   "\\spad{associates?(x,{} y)} tests whether \\spad{x} and \\spad{y} are associates,{} \\spadignore{i.e.} differ by a unit factor."))
 (|unitCanonical|
  (($ $) "\\spad{unitCanonical(x)} returns \\spad{unitNormal(x).canonical}."))
 (|unitNormal|
  (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $)
   "\\spad{unitNormal(x)} tries to choose a canonical element from the associate class of \\spad{x}. The attribute canonicalUnitNormal,{} if asserted,{} means that the \"canonical\" element is the same across all associates of \\spad{x} if \\spad{unitNormal(x) = [u,{} c,{} a]} then \\spad{u*c = x},{} \\spad{a*u = 1}."))
 (|exquo|
  (((|Union| $ "failed") $ $)
   "\\spad{exquo(a,{} b)} either returns an element \\spad{c} such that \\spad{c*b=a} or \"failed\" if no such element can be found."))) 
NIL 
(|EntireRing|) 
((|constructor|
  (NIL
   "Entire Rings (non-commutative Integral Domains),{} \\spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \\blankline"))
 (|unit?|
  (((|Boolean|) $)
   "\\spad{unit?(x)} tests whether \\spad{x} is a unit,{} \\spadignore{i.e.} is invertible."))
 (|associates?|
  (((|Boolean|) $ $)
   "\\spad{associates?(x,{} y)} tests whether \\spad{x} and \\spad{y} are associates,{} \\spadignore{i.e.} differ by a unit factor."))
 (|unitCanonical|
  (($ $) "\\spad{unitCanonical(x)} returns \\spad{unitNormal(x).canonical}."))
 (|unitNormal|
  (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $)
   "\\spad{unitNormal(x)} tries to choose a canonical element from the associate class of \\spad{x}. The attribute canonicalUnitNormal,{} if asserted,{} means that the \"canonical\" element is the same across all associates of \\spad{x} if \\spad{unitNormal(x) = [u,{} c,{} a]} then \\spad{u*c = x},{} \\spad{a*u = 1}."))
 (|exquo|
  (((|Union| $ "failed") $ $)
   "\\spad{exquo(a,{} b)} either returns an element \\spad{c} such that \\spad{c*b=a} or \"failed\" if no such element can be found."))) 
NIL 
(|EigenPackage| R) 
((|constructor|
  (NIL
   "This is a package for the exact computation of eigenvalues and eigenvectors. This package works for matrices with coefficients which are rational functions over a ring where we can factor polynomials. Eigenvalues not in base field are represented by their minimal polynomial."))
 (|eigenvectors|
  (((|List|
     (|Record|
      (|:| |eigval|
           (|Union| (|Fraction| (|Polynomial| |#1|))
                    (|SuchThat| (|Symbol|) (|Polynomial| |#1|))))
      (|:| |eigmult| (|NonNegativeInteger|))
      (|:| |eigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))))))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \\spad{m}. The eigenvalues in base field and the corresponding eigenvectors are explicitly computed,{} while the other ones are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a \"generic\" root of such a polynomial."))
 (|generalizedEigenvectors|
  (((|List|
     (|Record|
      (|:| |eigval|
           (|Union| (|Fraction| (|Polynomial| |#1|))
                    (|SuchThat| (|Symbol|) (|Polynomial| |#1|))))
      (|:| |geneigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))))))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{generalizedEigenvectors(m)} returns the generalized returns the generalized eigenvectors of the matrix \\spad{m}."))
 (|eigenvalues|
  (((|List|
     (|Union| (|Fraction| (|Polynomial| |#1|))
              (|SuchThat| (|Symbol|) (|Polynomial| |#1|))))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{eigenvalues(m)} returns the eigenvalues of the matrix \\spad{m}."))
 (|generalizedEigenvector|
  (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))
    (|Record|
     (|:| |eigval|
          (|Union| (|Fraction| (|Polynomial| |#1|))
                   (|SuchThat| (|Symbol|) (|Polynomial| |#1|))))
     (|:| |eigmult| (|NonNegativeInteger|))
     (|:| |eigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{generalizedEigenvector(eigen,{} m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \\spad{eigen},{} as returned by the function eigenvectors.")
  (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))
    (|Union| (|Fraction| (|Polynomial| |#1|))
             (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{generalizedEigenvector(alpha,{} m,{} k,{} g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \\spad{alpha}. The integers \\spad{k} and \\spad{g} are respectively the algebraic and the geometric multiplicity of tye eigenvalue \\spad{alpha}."))
 (|eigenvector|
  (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))
    (|Union| (|Fraction| (|Polynomial| |#1|))
             (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{eigenvector(eigval,{} m)} returns the eigenvectors belonging to the eigenvalue \\spad{eigval} for the matrix \\spad{m}."))
 (|characteristicPolynomial|
  (((|Polynomial| |#1|) (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{characteristicPolynomial(m)} returns the characteristicPolynomial of the matrix \\spad{m} using a new generated symbol symbol as the main variable.")
  (((|Polynomial| |#1|) (|Matrix| (|Fraction| (|Polynomial| |#1|))) (|Symbol|))
   "\\spad{characteristicPolynomial(m,{} var)} returns the characteristicPolynomial of the matrix \\spad{m} using the symbol var as the main variable."))) 
((|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))) 
(|Equation| S) 
((|constructor|
  (NIL
   "Equations as mathematical objects. All properties of the basis domain,{} \\spadignore{e.g.} being an abelian group are carried over the equation domain,{} by performing the structural operations on the left and on the right hand side."))
 (|subst|
  (($ $ $)
   "\\spad{subst(eq1,{} eq2)} substitutes \\spad{eq2} into both sides of \\spad{eq1} the \\spad{lhs} of \\spad{eq2} should be a kernel"))
 (|inv|
  (($ $) "\\spad{inv(x)} returns the multiplicative inverse of \\spad{x}."))
 (/
  (($ $ $)
   "\\spad{e1/e2} produces a new equation by dividing the left and right hand sides of equations \\spad{e1} and \\spad{e2}."))
 (|factorAndSplit|
  (((|List| $) $)
   "\\spad{factorAndSplit(eq)} make the right hand side 0 and factors the new left hand side. Each factor is equated to 0 and put into the resulting list without repetitions."))
 (|rightOne|
  (((|Union| $ "failed") $)
   "\\spad{rightOne(eq)} divides by the right hand side.")
  (((|Union| $ "failed") $)
   "\\spad{rightOne(eq)} divides by the right hand side,{} if possible."))
 (|leftOne|
  (((|Union| $ "failed") $)
   "\\spad{leftOne(eq)} divides by the left hand side.")
  (((|Union| $ "failed") $)
   "\\spad{leftOne(eq)} divides by the left hand side,{} if possible."))
 (*
  (($ $ |#1|)
   "\\spad{eqn*x} produces a new equation by multiplying both sides of equation eqn by \\spad{x}.")
  (($ |#1| $)
   "\\spad{x*eqn} produces a new equation by multiplying both sides of equation eqn by \\spad{x}."))
 (-
  (($ $ |#1|)
   "\\spad{eqn-x} produces a new equation by subtracting \\spad{x} from both sides of equation eqn.")
  (($ |#1| $)
   "\\spad{x-eqn} produces a new equation by subtracting both sides of equation eqn from \\spad{x}."))
 (|rightZero| (($ $) "\\spad{rightZero(eq)} subtracts the right hand side."))
 (|leftZero| (($ $) "\\spad{leftZero(eq)} subtracts the left hand side."))
 (+
  (($ $ |#1|)
   "\\spad{eqn+x} produces a new equation by adding \\spad{x} to both sides of equation eqn.")
  (($ |#1| $)
   "\\spad{x+eqn} produces a new equation by adding \\spad{x} to both sides of equation eqn."))
 (|eval|
  (($ $ (|List| $))
   "\\spad{eval(eqn,{} [x1=v1,{} ... xn=vn])} replaces \\spad{xi} by \\spad{vi} in equation \\spad{eqn}.")
  (($ $ $)
   "\\spad{eval(eqn,{} x=f)} replaces \\spad{x} by \\spad{f} in equation \\spad{eqn}."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} eqn)} constructs a new equation by applying \\spad{f} to both sides of eqn."))
 (|rhs|
  ((|#1| $)
   "\\spad{rhs(eqn)} returns the right hand side of equation \\spad{eqn}."))
 (|lhs|
  ((|#1| $)
   "\\spad{lhs(eqn)} returns the left hand side of equation \\spad{eqn}."))
 (|swap|
  (($ $)
   "\\spad{swap(eq)} interchanges left and right hand side of equation \\spad{eq}."))
 (|equation| (($ |#1| |#1|) "\\spad{equation(a,{} b)} creates an equation."))
 (= (($ |#1| |#1|) "\\spad{a=b} creates an equation."))) 
((|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|SetCategory|)) (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|Group|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Monoid|)))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|AbelianMonoid|))
          (|HasCategory| |#1| '(|CommutativeRing|)))
     (AND (|HasCategory| |#1| '(|AbelianMonoid|))
          (|HasCategory| |#1| '(|Ring|)))
     (|HasCategory| |#1| '(|Monoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|AbelianMonoid|))
          (|HasCategory| |#1| '(|CommutativeRing|)))
     (AND (|HasCategory| |#1| '(|AbelianMonoid|))
          (|HasCategory| |#1| '(|Ring|))))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Group|)))
 (|HasCategory| |#1| '(|SemiGroup|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Monoid|))
     (|HasCategory| |#1| '(|SemiGroup|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Group|))
     (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|Ring|))
     (|HasCategory| |#1| '(|SemiGroup|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|ExpressionSpace|))) 
(|EquationFunctions2| S R) 
((|constructor|
  (NIL "This package provides operations for mapping the sides of equations."))
 (|map|
  (((|Equation| |#2|) (|Mapping| |#2| |#1|) (|Equation| |#1|))
   "\\spad{map(f,{} eq)} returns an equation where \\spad{f} is applied to the sides of eq"))) 
NIL 
(|EqTable| |Key| |Entry|) 
((|constructor|
  (NIL
   "This domain provides tables where the keys are compared using \\spadfun{eq?}. Thus keys are considered equal only if they are the same instance of a structure."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|ErrorFunctions|) 
((|constructor|
  (NIL
   "ErrorFunctions implements error functions callable from the system interpreter. Typically,{} these functions would be called in user functions. The simple forms of the functions take one argument which is either a string (an error message) or a list of strings which all together make up a message. The list can contain formatting codes (see below). The more sophisticated versions takes two arguments where the first argument is the name of the function from which the error was invoked and the second argument is either a string or a list of strings,{} as above. When you use the one argument version in an interpreter function,{} the system will automatically insert the name of the function as the new first argument. Thus in the user interpreter function \\indented{2}{\\spad{f x == if x < 0 then error \"negative argument\" else x}} the call to error will actually be of the form \\indented{2}{\\spad{error(\"f\",{}\"negative argument\")}} because the interpreter will have created a new first argument. \\blankline Formatting codes: error messages may contain the following formatting codes (they should either start or end a string or else have blanks around them): \\indented{3}{\\spad{\\%l}\\space{6}start a new line} \\indented{3}{\\spad{\\%b}\\space{6}start printing in a bold font (where available)} \\indented{3}{\\spad{\\%d}\\space{6}stop\\space{2}printing in a bold font (where available)} \\indented{3}{\\spad{ \\%ceon}\\space{2}start centering message lines} \\indented{3}{\\spad{\\%ceoff}\\space{2}stop\\space{2}centering message lines} \\indented{3}{\\spad{\\%rjon}\\space{3}start displaying lines \"ragged left\"} \\indented{3}{\\spad{\\%rjoff}\\space{2}stop\\space{2}displaying lines \"ragged left\"} \\indented{3}{\\spad{\\%i}\\space{6}indent\\space{3}following lines 3 additional spaces} \\indented{3}{\\spad{\\%u}\\space{6}unindent following lines 3 additional spaces} \\indented{3}{\\spad{\\%xN}\\space{5}insert \\spad{N} blanks (eg,{} \\spad{\\%x10} inserts 10 blanks)} \\blankline"))
 (|error|
  (((|Exit|) (|String|) (|List| (|String|)))
   "\\spad{error(nam,{} lmsg)} displays error messages lmsg preceded by a message containing the name \\spad{nam} of the function in which the error is contained.")
  (((|Exit|) (|String|) (|String|))
   "\\spad{error(nam,{} msg)} displays error message \\spad{msg} preceded by a message containing the name \\spad{nam} of the function in which the error is contained.")
  (((|Exit|) (|List| (|String|)))
   "\\spad{error(lmsg)} displays error message \\spad{lmsg} and terminates.")
  (((|Exit|) (|String|))
   "\\spad{error(msg)} displays error message \\spad{msg} and terminates."))) 
NIL 
(|ExpressionSpace&| S) 
((|constructor|
  (NIL
   "An expression space is a set which is closed under certain operators."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd? x} is \\spad{true} if \\spad{x} is an odd integer."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even? x} is \\spad{true} if \\spad{x} is an even integer."))
 (|definingPolynomial|
  (($ $)
   "\\spad{definingPolynomial(x)} returns an expression \\spad{p} such that \\spad{p(x) = 0}."))
 (|minPoly|
  (((|SparseUnivariatePolynomial| $) (|Kernel| $))
   "\\spad{minPoly(k)} returns \\spad{p} such that \\spad{p(k) = 0}."))
 (|eval|
  (($ $ (|BasicOperator|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|BasicOperator|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}."))
 (|freeOf?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{freeOf?(x,{} s)} tests if \\spad{x} does not contain any operator whose name is \\spad{s}.")
  (((|Boolean|) $ $)
   "\\spad{freeOf?(x,{} y)} tests if \\spad{x} does not contain any occurrence of \\spad{y},{} where \\spad{y} is a single kernel."))
 (|map|
  (($ (|Mapping| $ $) (|Kernel| $))
   "\\spad{map(f,{} k)} returns \\spad{op(f(x1),{} ...,{} f(xn))} where \\spad{k = op(x1,{} ...,{} xn)}."))
 (|kernel|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{kernel(op,{} [f1,{} ...,{} fn])} constructs \\spad{op(f1,{} ...,{} fn)} without evaluating it.")
  (($ (|BasicOperator|) $)
   "\\spad{kernel(op,{} x)} constructs \\spad{op}(\\spad{x}) without evaluating it."))
 (|is?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{is?(x,{} s)} tests if \\spad{x} is a kernel and if the name of its operator is \\spad{s}.")
  (((|Boolean|) $ (|BasicOperator|))
   "\\spad{is?(x,{} op)} tests if \\spad{x} is a kernel and if its operator is op."))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} tests if \\% accepts \\spad{op} as applicable to its elements."))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\%."))
 (|operators|
  (((|List| (|BasicOperator|)) $)
   "\\spad{operators(f)} returns all the basic operators appearing in \\spad{f},{} no matter what their levels are."))
 (|tower|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{tower([f1,{}...,{}fn])} returns all the kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} no matter what their levels are.")
  (((|List| (|Kernel| $)) $)
   "\\spad{tower(f)} returns all the kernels appearing in \\spad{f},{} no matter what their levels are."))
 (|kernels|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{kernels([f1,{}...,{}fn])} returns the list of all the top-level kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} but not the ones appearing in the arguments of the top-level kernels.")
  (((|List| (|Kernel| $)) $)
   "\\spad{kernels(f)} returns the list of all the top-level kernels appearing in \\spad{f},{} but not the ones appearing in the arguments of the top-level kernels."))
 (|mainKernel|
  (((|Union| (|Kernel| $) "failed") $)
   "\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level,{} or \"failed\" if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant)."))
 (|height|
  (((|NonNegativeInteger|) $)
   "\\spad{height(f)} returns the highest nesting level appearing in \\spad{f}. Constants have height 0. Symbols have height 1. For any operator op and expressions \\spad{f1},{} ...,{} \\spad{fn},{} \\spad{op(f1,{} ...,{} fn)} has height equal to \\spad{1 + max(height(f1),{} ...,{} height(fn))}."))
 (|distribute|
  (($ $ $)
   "\\spad{distribute(f,{} g)} expands all the kernels in \\spad{f} that contain \\spad{g} in their arguments and that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or a \\spadfunFrom{paren}{ExpressionSpace} expression.")
  (($ $)
   "\\spad{distribute(f)} expands all the kernels in \\spad{f} that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or \\spadfunFrom{paren}{ExpressionSpace} expression."))
 (|paren|
  (($ $)
   "\\spad{paren(f)} returns (\\spad{f}). This prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(paren 1)} returns the formal kernel log((1))."))
 (|box|
  (($ $)
   "\\spad{box(f)} returns \\spad{f} with a 'box' around it that prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(box 1)} returns the formal kernel log(1)."))
 (|subst|
  (($ $ (|List| (|Kernel| $)) (|List| $))
   "\\spad{subst(f,{} [k1...,{} kn],{} [g1,{} ...,{} gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|List| (|Equation| $)))
   "\\spad{subst(f,{} [k1 = g1,{} ...,{} kn = gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|Equation| $))
   "\\spad{subst(f,{} k = g)} replaces the kernel \\spad{k} by \\spad{g} formally in \\spad{f}."))
 (|elt|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{elt(op,{} [x1,{} ...,{} xn])} or \\spad{op}([\\spad{x1},{} ...,{} \\spad{xn}]) applies the \\spad{n}-ary operator \\spad{op} to \\spad{x1},{} ...,{} \\spad{xn}.")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p,{} o)} applies the 9-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q},{} \\spad{p} and \\spad{o}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p)} applies the 8-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q} and \\spad{p}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q)} applies the 7-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r} and \\spad{q}")
  (($ (|BasicOperator|) $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r)} applies the 6-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s} and \\spad{r}")
  (($ (|BasicOperator|) $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s)} applies the 5-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t} and \\spad{s}")
  (($ (|BasicOperator|) $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t}) applies the 4-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z} and \\spad{t}.")
  (($ (|BasicOperator|) $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z}) applies the ternary operator \\spad{op} to \\spad{x},{} \\spad{y} and \\spad{z}.")
  (($ (|BasicOperator|) $ $)
   "\\spad{elt(op,{} x,{} y)} or \\spad{op}(\\spad{x},{} \\spad{y}) applies the binary operator \\spad{op} to \\spad{x} and \\spad{y}.")
  (($ (|BasicOperator|) $)
   "\\spad{elt(op,{} x)} or \\spad{op}(\\spad{x}) applies the unary operator \\spad{op} to \\spad{x}."))) 
((|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|Ring|))) 
(|ExpressionSpace|) 
((|constructor|
  (NIL
   "An expression space is a set which is closed under certain operators."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd? x} is \\spad{true} if \\spad{x} is an odd integer."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even? x} is \\spad{true} if \\spad{x} is an even integer."))
 (|definingPolynomial|
  (($ $)
   "\\spad{definingPolynomial(x)} returns an expression \\spad{p} such that \\spad{p(x) = 0}."))
 (|minPoly|
  (((|SparseUnivariatePolynomial| $) (|Kernel| $))
   "\\spad{minPoly(k)} returns \\spad{p} such that \\spad{p(k) = 0}."))
 (|eval|
  (($ $ (|BasicOperator|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|BasicOperator|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}."))
 (|freeOf?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{freeOf?(x,{} s)} tests if \\spad{x} does not contain any operator whose name is \\spad{s}.")
  (((|Boolean|) $ $)
   "\\spad{freeOf?(x,{} y)} tests if \\spad{x} does not contain any occurrence of \\spad{y},{} where \\spad{y} is a single kernel."))
 (|map|
  (($ (|Mapping| $ $) (|Kernel| $))
   "\\spad{map(f,{} k)} returns \\spad{op(f(x1),{} ...,{} f(xn))} where \\spad{k = op(x1,{} ...,{} xn)}."))
 (|kernel|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{kernel(op,{} [f1,{} ...,{} fn])} constructs \\spad{op(f1,{} ...,{} fn)} without evaluating it.")
  (($ (|BasicOperator|) $)
   "\\spad{kernel(op,{} x)} constructs \\spad{op}(\\spad{x}) without evaluating it."))
 (|is?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{is?(x,{} s)} tests if \\spad{x} is a kernel and if the name of its operator is \\spad{s}.")
  (((|Boolean|) $ (|BasicOperator|))
   "\\spad{is?(x,{} op)} tests if \\spad{x} is a kernel and if its operator is op."))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} tests if \\% accepts \\spad{op} as applicable to its elements."))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\%."))
 (|operators|
  (((|List| (|BasicOperator|)) $)
   "\\spad{operators(f)} returns all the basic operators appearing in \\spad{f},{} no matter what their levels are."))
 (|tower|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{tower([f1,{}...,{}fn])} returns all the kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} no matter what their levels are.")
  (((|List| (|Kernel| $)) $)
   "\\spad{tower(f)} returns all the kernels appearing in \\spad{f},{} no matter what their levels are."))
 (|kernels|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{kernels([f1,{}...,{}fn])} returns the list of all the top-level kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} but not the ones appearing in the arguments of the top-level kernels.")
  (((|List| (|Kernel| $)) $)
   "\\spad{kernels(f)} returns the list of all the top-level kernels appearing in \\spad{f},{} but not the ones appearing in the arguments of the top-level kernels."))
 (|mainKernel|
  (((|Union| (|Kernel| $) "failed") $)
   "\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level,{} or \"failed\" if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant)."))
 (|height|
  (((|NonNegativeInteger|) $)
   "\\spad{height(f)} returns the highest nesting level appearing in \\spad{f}. Constants have height 0. Symbols have height 1. For any operator op and expressions \\spad{f1},{} ...,{} \\spad{fn},{} \\spad{op(f1,{} ...,{} fn)} has height equal to \\spad{1 + max(height(f1),{} ...,{} height(fn))}."))
 (|distribute|
  (($ $ $)
   "\\spad{distribute(f,{} g)} expands all the kernels in \\spad{f} that contain \\spad{g} in their arguments and that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or a \\spadfunFrom{paren}{ExpressionSpace} expression.")
  (($ $)
   "\\spad{distribute(f)} expands all the kernels in \\spad{f} that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or \\spadfunFrom{paren}{ExpressionSpace} expression."))
 (|paren|
  (($ $)
   "\\spad{paren(f)} returns (\\spad{f}). This prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(paren 1)} returns the formal kernel log((1))."))
 (|box|
  (($ $)
   "\\spad{box(f)} returns \\spad{f} with a 'box' around it that prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(box 1)} returns the formal kernel log(1)."))
 (|subst|
  (($ $ (|List| (|Kernel| $)) (|List| $))
   "\\spad{subst(f,{} [k1...,{} kn],{} [g1,{} ...,{} gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|List| (|Equation| $)))
   "\\spad{subst(f,{} [k1 = g1,{} ...,{} kn = gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|Equation| $))
   "\\spad{subst(f,{} k = g)} replaces the kernel \\spad{k} by \\spad{g} formally in \\spad{f}."))
 (|elt|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{elt(op,{} [x1,{} ...,{} xn])} or \\spad{op}([\\spad{x1},{} ...,{} \\spad{xn}]) applies the \\spad{n}-ary operator \\spad{op} to \\spad{x1},{} ...,{} \\spad{xn}.")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p,{} o)} applies the 9-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q},{} \\spad{p} and \\spad{o}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p)} applies the 8-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q} and \\spad{p}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q)} applies the 7-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r} and \\spad{q}")
  (($ (|BasicOperator|) $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r)} applies the 6-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s} and \\spad{r}")
  (($ (|BasicOperator|) $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s)} applies the 5-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t} and \\spad{s}")
  (($ (|BasicOperator|) $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t}) applies the 4-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z} and \\spad{t}.")
  (($ (|BasicOperator|) $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z}) applies the ternary operator \\spad{op} to \\spad{x},{} \\spad{y} and \\spad{z}.")
  (($ (|BasicOperator|) $ $)
   "\\spad{elt(op,{} x,{} y)} or \\spad{op}(\\spad{x},{} \\spad{y}) applies the binary operator \\spad{op} to \\spad{x} and \\spad{y}.")
  (($ (|BasicOperator|) $)
   "\\spad{elt(op,{} x)} or \\spad{op}(\\spad{x}) applies the unary operator \\spad{op} to \\spad{x}."))) 
NIL 
(|ExpressionSpaceFunctions1| F S) 
((|constructor|
  (NIL
   "This package allows a map from any expression space into any object to be lifted to a kernel over the expression set,{} using a given property of the operator of the kernel."))
 (|map|
  ((|#2| (|Mapping| |#2| |#1|) (|Symbol|) (|Kernel| |#1|))
   "\\spad{map(f,{} p,{} k)} uses the property \\spad{p} of the operator of \\spad{k},{} in order to lift \\spad{f} and apply it to \\spad{k}."))) 
NIL 
(|ExpressionSpaceFunctions2| E F) 
((|constructor|
  (NIL
   "This package allows a mapping \\spad{E} \\spad{->} \\spad{F} to be lifted to a kernel over \\spad{E}; This lifting can fail if the operator of the kernel cannot be applied in \\spad{F}; Do not use this package with \\spad{E} = \\spad{F},{} since this may drop some properties of the operators."))
 (|map|
  ((|#2| (|Mapping| |#2| |#1|) (|Kernel| |#1|))
   "\\spad{map(f,{} k)} returns \\spad{g = op(f(a1),{} ...,{} f(an))} where \\spad{k = op(a1,{} ...,{} an)}."))) 
NIL 
(|EuclideanDomain&| S) 
((|constructor|
  (NIL
   "A constructive euclidean domain,{} \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes: \\indented{2}{multiplicativeValuation\\tab{25}\\spad{Size(a*b)=Size(a)*Size(b)}} \\indented{2}{additiveValuation\\tab{25}\\spad{Size(a*b)=Size(a)+Size(b)}}"))
 (|multiEuclidean|
  (((|Union| (|List| $) "failed") (|List| $) $)
   "\\spad{multiEuclidean([f1,{} ...,{} fn],{} z)} returns a list of coefficients \\spad{[a1,{} ...,{} an]} such that \\spad{ z / prod \\spad{fi} = sum aj/fj}. If no such list of coefficients exists,{} \"failed\" is returned."))
 (|extendedEuclidean|
  (((|Union| (|Record| (|:| |coef1| $) (|:| |coef2| $)) "failed") $ $ $)
   "\\spad{extendedEuclidean(x,{} y,{} z)} either returns a record rec where \\spad{rec.coef1*x+rec.coef2*y=z} or returns \"failed\" if \\spad{z} cannot be expressed as a linear combination of \\spad{x} and \\spad{y}.")
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{extendedEuclidean(x,{} y)} returns a record rec where \\spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \\spad{gcd} of \\spad{x} and \\spad{y}. The \\spad{gcd} is unique only up to associates if \\spadtype{canonicalUnitNormal} is not asserted. \\spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments."))
 (|rem|
  (($ $ $)
   "\\spad{x rem y} is the same as \\spad{divide(x,{} y).remainder}. See \\spadfunFrom{divide}{EuclideanDomain}."))
 (|quo|
  (($ $ $)
   "\\spad{x quo y} is the same as \\spad{divide(x,{} y).quotient}. See \\spadfunFrom{divide}{EuclideanDomain}."))
 (|divide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{divide(x,{} y)} divides \\spad{x} by \\spad{y} producing a record containing a \\spad{quotient} and \\spad{remainder},{} where the remainder is smaller (see \\spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \\spad{y}."))
 (|euclideanSize|
  (((|NonNegativeInteger|) $)
   "\\spad{euclideanSize(x)} returns the euclidean size of the element \\spad{x}. Error: if \\spad{x} is zero."))
 (|sizeLess?|
  (((|Boolean|) $ $)
   "\\spad{sizeLess?(x,{} y)} tests whether \\spad{x} is strictly smaller than \\spad{y} with respect to the \\spadfunFrom{euclideanSize}{EuclideanDomain}."))) 
NIL 
(|EuclideanDomain|) 
((|constructor|
  (NIL
   "A constructive euclidean domain,{} \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes: \\indented{2}{multiplicativeValuation\\tab{25}\\spad{Size(a*b)=Size(a)*Size(b)}} \\indented{2}{additiveValuation\\tab{25}\\spad{Size(a*b)=Size(a)+Size(b)}}"))
 (|multiEuclidean|
  (((|Union| (|List| $) "failed") (|List| $) $)
   "\\spad{multiEuclidean([f1,{} ...,{} fn],{} z)} returns a list of coefficients \\spad{[a1,{} ...,{} an]} such that \\spad{ z / prod \\spad{fi} = sum aj/fj}. If no such list of coefficients exists,{} \"failed\" is returned."))
 (|extendedEuclidean|
  (((|Union| (|Record| (|:| |coef1| $) (|:| |coef2| $)) "failed") $ $ $)
   "\\spad{extendedEuclidean(x,{} y,{} z)} either returns a record rec where \\spad{rec.coef1*x+rec.coef2*y=z} or returns \"failed\" if \\spad{z} cannot be expressed as a linear combination of \\spad{x} and \\spad{y}.")
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{extendedEuclidean(x,{} y)} returns a record rec where \\spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \\spad{gcd} of \\spad{x} and \\spad{y}. The \\spad{gcd} is unique only up to associates if \\spadtype{canonicalUnitNormal} is not asserted. \\spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments."))
 (|rem|
  (($ $ $)
   "\\spad{x rem y} is the same as \\spad{divide(x,{} y).remainder}. See \\spadfunFrom{divide}{EuclideanDomain}."))
 (|quo|
  (($ $ $)
   "\\spad{x quo y} is the same as \\spad{divide(x,{} y).quotient}. See \\spadfunFrom{divide}{EuclideanDomain}."))
 (|divide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{divide(x,{} y)} divides \\spad{x} by \\spad{y} producing a record containing a \\spad{quotient} and \\spad{remainder},{} where the remainder is smaller (see \\spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \\spad{y}."))
 (|euclideanSize|
  (((|NonNegativeInteger|) $)
   "\\spad{euclideanSize(x)} returns the euclidean size of the element \\spad{x}. Error: if \\spad{x} is zero."))
 (|sizeLess?|
  (((|Boolean|) $ $)
   "\\spad{sizeLess?(x,{} y)} tests whether \\spad{x} is strictly smaller than \\spad{y} with respect to the \\spadfunFrom{euclideanSize}{EuclideanDomain}."))) 
NIL 
(|Evalable&| S R) 
((|constructor|
  (NIL
   "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\\spad{''} substitutions."))
 (|eval|
  (($ $ (|List| (|Equation| |#2|)))
   "\\spad{eval(f,{} [x1 = v1,{} ...,{} xn = vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f}.")
  (($ $ (|Equation| |#2|))
   "\\spad{eval(f,{} x = v)} replaces \\spad{x} by \\spad{v} in \\spad{f}."))) 
NIL 
(|Evalable| R) 
((|constructor|
  (NIL
   "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\\spad{''} substitutions."))
 (|eval|
  (($ $ (|List| (|Equation| |#1|)))
   "\\spad{eval(f,{} [x1 = v1,{} ...,{} xn = vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f}.")
  (($ $ (|Equation| |#1|))
   "\\spad{eval(f,{} x = v)} replaces \\spad{x} by \\spad{v} in \\spad{f}."))) 
NIL 
(|EvaluateCycleIndicators| F) 
((|constructor|
  (NIL
   "This package is to be used in conjuction with \\indented{12}{the CycleIndicators package. It provides an evaluation} \\indented{12}{function for SymmetricPolynomials.}"))
 (|eval|
  ((|#1| (|Mapping| |#1| (|Integer|))
    (|SymmetricPolynomial| (|Fraction| (|Integer|))))
   "\\spad{eval(f,{} s)} evaluates the cycle index \\spad{s} by applying \\indented{1}{the function \\spad{f} to each integer in a monomial partition,{}} \\indented{1}{forms their product and sums the results over all monomials.}"))) 
NIL 
(|Exit|) 
((|constructor|
  (NIL
   "A function which does not return directly to its caller should have Exit as its return type. \\blankline Note: It is convenient to have a formal \\spad{coerce} into each type from type Exit. This allows,{} for example,{} errors to be raised in one half of a type-balanced \\spad{if}."))) 
NIL 
(|Export3D|) 
((|constructor|
  (NIL
   "This package provides support for exporting SubSpace and ThreeSpace structures to files."))
 (|writeObj|
  (((|Void|) (|SubSpace| 3 (|DoubleFloat|)) (|String|))
   "writes 3D SubSpace to a file in Wavefront (.OBJ) format"))) 
NIL 
(|ExponentialExpansion| R FE |var| |cen|) 
((|constructor|
  (NIL
   "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent essential singularities of functions. Objects in this domain are quotients of sums,{} where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series."))
 (|coerce|
  (($ (|UnivariatePuiseuxSeries| |#2| |#3| |#4|))
   "\\spad{coerce(f)} converts a \\spadtype{UnivariatePuiseuxSeries} to an \\spadtype{ExponentialExpansion}."))
 (|limitPlus|
  (((|Union| (|OrderedCompletion| |#2|) "failed") $)
   "\\spad{limitPlus(f(var))} returns \\spad{limit(var -> a+,{} f(var))}."))) 
((|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|PolynomialFactorizationExplicit|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|CharacteristicNonZero|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|CharacteristicZero|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|RealConstant|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|OrderedIntegralDomain|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|OrderedSet|))
 (OR
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|OrderedIntegralDomain|))
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|OrderedSet|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|StepThrough|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|InnerEvalable| '(|Symbol|)
        (LIST '|UnivariatePuiseuxSeriesWithExponentialSingularity|
              (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)
              (|devaluate| |#4|))))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|Evalable|
        (LIST '|UnivariatePuiseuxSeriesWithExponentialSingularity|
              (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)
              (|devaluate| |#4|))))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|Eltable|
        (LIST '|UnivariatePuiseuxSeriesWithExponentialSingularity|
              (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)
              (|devaluate| |#4|))
        (LIST '|UnivariatePuiseuxSeriesWithExponentialSingularity|
              (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)
              (|devaluate| |#4|))))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|DifferentialRing|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|EuclideanDomain|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|IntegerNumberSystem|))
 (|HasCategory|
  (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
  '(|Comparable|))
 (OR
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|Comparable|))
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|OrderedIntegralDomain|))
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory|
       (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3|
                                                            |#4|)
       '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory|
        (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3|
                                                             |#4|)
        '(|PolynomialFactorizationExplicit|)))
  (|HasCategory|
   (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|)
   '(|CharacteristicNonZero|)))) 
(|Expression| R) 
((|constructor| (NIL "Expressions involving symbolic functions."))
 (|getSimplifyDenomsFlag|
  (((|Boolean|))
   "\\spad{getSimplifyDenomsFlag()} gets values of flag affecting simplification of denominators. See setSimplifyDenomsFlag."))
 (|setSimplifyDenomsFlag|
  (((|Boolean|) (|Boolean|))
   "\\spad{setSimplifyDenomsFlag(x)} sets flag affecting simplification of denominators. If \\spad{true} irrational algebraics are removed from denominators. If \\spad{false} they are kept."))
 (|number?|
  (((|Boolean|) $) "\\spad{number?(f)} tests if \\spad{f} is rational"))
 (|reduce|
  (($ $)
   "\\spad{reduce(f)} simplifies all the unreduced algebraic quantities present in \\spad{f} by applying their defining relations."))) 
((|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|Group|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiGroup|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|SemiGroup|)))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#1| '(|IntegralDomain|))))
 (OR (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|)))
 (OR (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|SemiGroup|)))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| $ '(|Ring|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))) 
(|ExpressionFunctions2| R S) 
((|constructor|
  (NIL "Lifting of maps to Expressions. Date Created: 16 Jan 1989"))
 (|map|
  (((|Expression| |#2|) (|Mapping| |#2| |#1|) (|Expression| |#1|))
   "\\spad{map(f,{} e)} applies \\spad{f} to all the constants appearing in \\spad{e}."))) 
NIL 
(|ExpressionToUnivariatePowerSeries| R FE) 
((|constructor|
  (NIL
   "This package provides functions to convert functional expressions to power series."))
 (|series|
  (((|Any|) |#2| (|Equation| |#2|) (|Fraction| (|Integer|)))
   "\\spad{series(f,{} x = a,{} n)} expands the expression \\spad{f} as a series in powers of (\\spad{x} - a); terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2| (|Equation| |#2|))
   "\\spad{series(f,{} x = a)} expands the expression \\spad{f} as a series in powers of (\\spad{x} - a).")
  (((|Any|) |#2| (|Fraction| (|Integer|)))
   "\\spad{series(f,{} n)} returns a series expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2|)
   "\\spad{series(f)} returns a series expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable.")
  (((|Any|) (|Symbol|))
   "\\spad{series(x)} returns \\spad{x} viewed as a series."))
 (|puiseux|
  (((|Any|) |#2| (|Equation| |#2|) (|Fraction| (|Integer|)))
   "\\spad{puiseux(f,{} x = a,{} n)} expands the expression \\spad{f} as a Puiseux series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2| (|Equation| |#2|))
   "\\spad{puiseux(f,{} x = a)} expands the expression \\spad{f} as a Puiseux series in powers of \\spad{(x - a)}.")
  (((|Any|) |#2| (|Fraction| (|Integer|)))
   "\\spad{puiseux(f,{} n)} returns a Puiseux expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2|)
   "\\spad{puiseux(f)} returns a Puiseux expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable.")
  (((|Any|) (|Symbol|))
   "\\spad{puiseux(x)} returns \\spad{x} viewed as a Puiseux series."))
 (|laurent|
  (((|Any|) |#2| (|Equation| |#2|) (|Integer|))
   "\\spad{laurent(f,{} x = a,{} n)} expands the expression \\spad{f} as a Laurent series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2| (|Equation| |#2|))
   "\\spad{laurent(f,{} x = a)} expands the expression \\spad{f} as a Laurent series in powers of \\spad{(x - a)}.")
  (((|Any|) |#2| (|Integer|))
   "\\spad{laurent(f,{} n)} returns a Laurent expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2|)
   "\\spad{laurent(f)} returns a Laurent expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable.")
  (((|Any|) (|Symbol|))
   "\\spad{laurent(x)} returns \\spad{x} viewed as a Laurent series."))
 (|taylor|
  (((|Any|) |#2| (|Equation| |#2|) (|NonNegativeInteger|))
   "\\spad{taylor(f,{} x = a)} expands the expression \\spad{f} as a Taylor series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2| (|Equation| |#2|))
   "\\spad{taylor(f,{} x = a)} expands the expression \\spad{f} as a Taylor series in powers of \\spad{(x - a)}.")
  (((|Any|) |#2| (|NonNegativeInteger|))
   "\\spad{taylor(f,{} n)} returns a Taylor expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n}.")
  (((|Any|) |#2|)
   "\\spad{taylor(f)} returns a Taylor expansion of the expression \\spad{f}. Note: \\spad{f} should have only one variable; the series will be expanded in powers of that variable.")
  (((|Any|) (|Symbol|))
   "\\spad{taylor(x)} returns \\spad{x} viewed as a Taylor series."))) 
NIL 
(|ExpressionSpaceODESolver| R F) 
((|constructor| (NIL "Taylor series solutions of explicit ODE\\spad{'s}."))
 (|seriesSolve|
  (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) (|List| |#2|))
   "\\spad{seriesSolve(eq,{} y,{} x = a,{} [b0,{} ...,{} bn])} is equivalent to \\spad{seriesSolve(eq = 0,{} y,{} x = a,{} [b0,{} ...,{} b(n-1)])}.")
  (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) (|Equation| |#2|))
   "\\spad{seriesSolve(eq,{} y,{} x = a,{} y a = b)} is equivalent to \\spad{seriesSolve(eq=0,{} y,{} x=a,{} y a = b)}.")
  (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) |#2|)
   "\\spad{seriesSolve(eq,{} y,{} x = a,{} b)} is equivalent to \\spad{seriesSolve(eq = 0,{} y,{} x = a,{} y a = b)}.")
  (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|) |#2|)
   "\\spad{seriesSolve(eq,{} y,{} x=a,{} b)} is equivalent to \\spad{seriesSolve(eq,{} y,{} x=a,{} y a = b)}.")
  (((|Any|) (|List| |#2|) (|List| (|BasicOperator|)) (|Equation| |#2|)
    (|List| (|Equation| |#2|)))
   "\\spad{seriesSolve([eq1,{} ...,{} eqn],{} [y1,{} ...,{} yn],{} x = a,{} [y1 a = b1,{} ...,{} yn a = bn])} is equivalent to \\spad{seriesSolve([eq1=0,{} ...,{} eqn=0],{} [y1,{} ...,{} yn],{} x = a,{} [y1 a = b1,{} ...,{} yn a = bn])}.")
  (((|Any|) (|List| |#2|) (|List| (|BasicOperator|)) (|Equation| |#2|)
    (|List| |#2|))
   "\\spad{seriesSolve([eq1,{} ...,{} eqn],{} [y1,{} ...,{} yn],{} x=a,{} [b1,{} ...,{} bn])} is equivalent to \\spad{seriesSolve([eq1=0,{} ...,{} eqn=0],{} [y1,{} ...,{} yn],{} x=a,{} [b1,{} ...,{} bn])}.")
  (((|Any|) (|List| (|Equation| |#2|)) (|List| (|BasicOperator|))
    (|Equation| |#2|) (|List| |#2|))
   "\\spad{seriesSolve([eq1,{} ...,{} eqn],{} [y1,{} ...,{} yn],{} x=a,{} [b1,{} ...,{} bn])} is equivalent to \\spad{seriesSolve([eq1,{} ...,{} eqn],{} [y1,{} ...,{} yn],{} x = a,{} [y1 a = b1,{} ...,{} yn a = bn])}.")
  (((|Any|) (|List| (|Equation| |#2|)) (|List| (|BasicOperator|))
    (|Equation| |#2|) (|List| (|Equation| |#2|)))
   "\\spad{seriesSolve([eq1,{} ...,{} eqn],{} [y1,{} ...,{} yn],{} x = a,{} [y1 a = b1,{} ...,{} yn a = bn])} returns a taylor series solution of \\spad{[eq1,{} ...,{} eqn]} around \\spad{x = a} with initial conditions \\spad{\\spad{yi}(a) = \\spad{bi}}. Note: eqi must be of the form \\spad{\\spad{fi}(x,{} y1 x,{} y2 x,{} ...,{} yn x) y1'(x) + \\spad{gi}(x,{} y1 x,{} y2 x,{} ...,{} yn x) = h(x,{} y1 x,{} y2 x,{} ...,{} yn x)}.")
  (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|)
    (|List| |#2|))
   "\\spad{seriesSolve(eq,{} y,{} x=a,{} [b0,{} ...,{} b(n-1)])} returns a Taylor series solution of \\spad{eq} around \\spad{x = a} with initial conditions \\spad{y(a) = b0},{} \\spad{y'(a) = b1},{} \\spad{y''(a) = b2},{} ...,{} \\spad{y(n-1)(a) = b(n-1)} \\spad{eq} must be of the form \\spad{f(x,{} y x,{} y'(x),{} ...,{} y(n-1)(x)) y(n)(x) + g(x,{} y x,{} y'(x),{} ...,{} y(n-1)(x)) = h(x,{} y x,{} y'(x),{} ...,{} y(n-1)(x))}.")
  (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|)
    (|Equation| |#2|))
   "\\spad{seriesSolve(eq,{} y,{} x=a,{} y a = b)} returns a Taylor series solution of \\spad{eq} around \\spad{x} = a with initial condition \\spad{y(a) = b}. Note: \\spad{eq} must be of the form \\spad{f(x,{} y x) y'(x) + g(x,{} y x) = h(x,{} y x)}."))) 
NIL 
(|ExpressionSolve| R F UTSF UTSSMPF) 
NIL 
NIL 
(|ExpressionTubePlot|) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Clifton \\spad{J}. Williamson} Date Created: Bastille Day 1989 Keywords: Examples: Package for constructing tubes around 3-dimensional parametric curves."))
 (|tubePlot|
  (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|))
    (|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|DoubleFloat|) (|Integer|) (|String|))
   "\\spad{tubePlot(f,{} g,{} h,{} colorFcn,{} a..b,{} r,{} n,{} s)} puts a tube of radius \\spad{r} with \\spad{n} points on each circle about the curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} for \\spad{t} in \\spad{[a,{} b]}. If \\spad{s} = \"closed\",{} the tube is considered to be closed; if \\spad{s} = \"open\",{} the tube is considered to be open.")
  (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|))
    (|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|DoubleFloat|) (|Integer|))
   "\\spad{tubePlot(f,{} g,{} h,{} colorFcn,{} a..b,{} r,{} n)} puts a tube of radius \\spad{r} with \\spad{n} points on each circle about the curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} for \\spad{t} in \\spad{[a,{} b]}. The tube is considered to be open.")
  (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|))
    (|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Integer|) (|String|))
   "\\spad{tubePlot(f,{} g,{} h,{} colorFcn,{} a..b,{} r,{} n,{} s)} puts a tube of radius \\spad{r(t)} with \\spad{n} points on each circle about the curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} for \\spad{t} in \\spad{[a,{}b]}. If \\spad{s} = \"closed\",{} the tube is considered to be closed; if \\spad{s} = \"open\",{} the tube is considered to be open.")
  (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|))
    (|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Integer|))
   "\\spad{tubePlot(f,{} g,{} h,{} colorFcn,{} a..b,{} r,{} n)} puts a tube of radius \\spad{r}(\\spad{t}) with \\spad{n} points on each circle about the curve \\spad{x = f(t)},{} \\spad{y = g(t)},{} \\spad{z = h(t)} for \\spad{t} in \\spad{[a,{} b]}. The tube is considered to be open."))
 (|constantToUnaryFunction|
  (((|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|DoubleFloat|))
   "\\spad{constantToUnaryFunction(s)} is a local function which takes the value of \\spad{s},{} which may be a function of a constant,{} and returns a function which always returns the value \\spadtype{DoubleFloat} \\spad{s}."))) 
NIL 
(|ExponentialOfUnivariatePuiseuxSeries| FE |var| |cen|) 
((|constructor|
  (NIL
   "ExponentialOfUnivariatePuiseuxSeries is a domain used to represent essential singularities of functions. An object in this domain is a function of the form \\spad{exp(f(x))},{} where \\spad{f(x)} is a Puiseux series with no terms of non-negative degree. Objects are ordered according to order of singularity,{} with functions which tend more rapidly to zero or infinity considered to be larger. Thus,{} if \\spad{order(f(x)) < order(g(x))},{} \\spadignore{i.e.} the first non-zero term of \\spad{f(x)} has lower degree than the first non-zero term of \\spad{g(x)},{} then \\spad{exp(f(x)) > exp(g(x))}. If \\spad{order(f(x)) = order(g(x))},{} then the ordering is essentially random. This domain is used in computing limits involving functions with essential singularities."))
 (|exponentialOrder|
  (((|Fraction| (|Integer|)) $)
   "\\spad{exponentialOrder(exp(c * x ^(-n) + ...))} returns \\spad{-n}. exponentialOrder(0) returns \\spad{0}."))
 (|exponent|
  (((|UnivariatePuiseuxSeries| |#1| |#2| |#3|) $)
   "\\spad{exponent(exp(f(x)))} returns \\spad{f(x)}"))
 (|exponential|
  (($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))
   "\\spad{exponential(f(x))} returns \\spad{exp(f(x))}. Note: the function does NOT check that \\spad{f(x)} has no non-negative terms."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (LIST '|Fraction| '(|Integer|))
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|)
                                  (LIST '|Fraction| '(|Integer|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Fraction| (|Integer|)) '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (LIST '|Fraction| '(|Integer|)))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|)))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))) 
(|ExtendedPolynomialReduction| C E R) 
((|constructor|
  (NIL
   "\\indented{1}{ExtendedPolynomialReduction(\\spad{C},{} \\spad{E},{} \\spad{R}) is a package that allows} denominatorFree reductions of a polynomial \\spad{r} from \\spad{R} \\spad{wrt} a list of polynomials from \\spad{R} (usually such a list is a Groebner basis \\spad{wrt} the order given via \\spad{E}). Additionally,{} the reduction steps are recorded and provided in the output."))
 (|reduce|
  (((|Record| (|:| |poly| |#3|) (|:| |repr| (|Vector| |#3|)) (|:| |mult| |#1|))
    |#3| (|List| |#3|))
   "\\spad{reduce(r,{} bas)} returns a triple (\\spad{p},{} \\spad{v},{} \\spad{m}) such that \\spad{m*r} = sum(bas.\\spad{i} * \\spad{v}.\\spad{i},{} \\spad{i=1}..\\#bas) + \\spad{p}"))) 
NIL 
(|FacetCategory&| S) 
((|constructor|
  (NIL
   "This is a category to represent different types of facet,{} such as,{} (1) A single simplex (2) A single cubical simplex (3) The product of two facets \\blankline"))
 (|empty?|
  (((|Boolean|) $)
   "is empty if it contains no vertices or if multiplier is zero"))
 (|order| (((|NonNegativeInteger|) $) "number of vertices"))
 (|getMult| (((|Integer|) $) "returns multiplier of face"))) 
NIL 
(|FacetCategory|) 
((|constructor|
  (NIL
   "This is a category to represent different types of facet,{} such as,{} (1) A single simplex (2) A single cubical simplex (3) The product of two facets \\blankline"))
 (|empty?|
  (((|Boolean|) $)
   "is empty if it contains no vertices or if multiplier is zero"))
 (|order| (((|NonNegativeInteger|) $) "number of vertices"))
 (|getMult| (((|Integer|) $) "returns multiplier of face"))) 
NIL 
(|FactoredFunctions| M) 
((|constructor| (NIL "computes various functions on factored arguments."))
 (|log|
  (((|List| (|Record| (|:| |coef| (|NonNegativeInteger|)) (|:| |logand| |#1|)))
    (|Factored| |#1|))
   "\\spad{log(f)} returns \\spad{[(a1,{} b1),{} ...,{} (am,{} bm)]} such that the logarithm of \\spad{f} is equal to \\spad{a1*log(b1) + ... + am*log(bm)}."))
 (|nthRoot|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#1|)
              (|:| |radicand| (|List| |#1|)))
    (|Factored| |#1|) (|NonNegativeInteger|))
   "\\spad{nthRoot(f,{} n)} returns \\spad{(p,{} r,{} [r1,{} ...,{} rm])} such that the \\spad{n}th-root of \\spad{f} is equal to \\spad{r * \\spad{p}th-root(r1 * ... * rm)},{} where \\spad{r1},{} ...,{} \\spad{rm} are distinct factors of \\spad{f},{} each of which has an exponent smaller than \\spad{p} in \\spad{f}."))) 
NIL 
(|FactoringUtilities| E OV R P) 
((|constructor|
  (NIL
   "This package provides utilities used by the factorizers which operate on polynomials represented as univariate polynomials with multivariate coefficients."))
 (|ran|
  ((|#3| (|Integer|))
   "\\spad{ran(k)} computes a random integer between \\spad{-k} and \\spad{k} as a member of \\spad{R}."))
 (|normalDeriv|
  (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)
    (|Integer|))
   "\\spad{normalDeriv(poly,{} i)} computes the \\spad{i}th derivative of \\spad{poly} divided by i!."))
 (|raisePolynomial|
  (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|))
   "\\spad{raisePolynomial(rpoly)} converts \\spad{rpoly} from a univariate polynomial over \\spad{r} to be a univariate polynomial with polynomial coefficients."))
 (|lowerPolynomial|
  (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#4|))
   "\\spad{lowerPolynomial(upoly)} converts \\spad{upoly} to be a univariate polynomial over \\spad{R}. An error if the coefficients contain variables."))
 (|variables|
  (((|List| |#2|) (|SparseUnivariatePolynomial| |#4|))
   "\\spad{variables(upoly)} returns the list of variables for the coefficients of \\spad{upoly}."))
 (|degree|
  (((|List| (|NonNegativeInteger|)) (|SparseUnivariatePolynomial| |#4|)
    (|List| |#2|))
   "\\spad{degree(upoly,{} lvar)} returns a list containing the maximum degree for each variable in lvar."))
 (|completeEval|
  (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#4|)
    (|List| |#2|) (|List| |#3|))
   "\\spad{completeEval(upoly,{} lvar,{} lval)} evaluates the polynomial \\spad{upoly} with each variable in \\spad{lvar} replaced by the corresponding value in lval. Substitutions are done for all variables in \\spad{upoly} producing a univariate polynomial over \\spad{R}."))) 
NIL 
(|FakePolynomial|) 
((|constructor|
  (NIL
   "FakePolynomial is a domain of univariate polynomials \\indented{1}{with coefficients being fractions of multivariate integer} \\indented{1}{polynomials.\\space{2}Coefficients are kept in unsimplified form.} \\indented{1}{This domain exists to avoid cost of recursive \\spad{GCD} calls} \\indented{1}{during polynomial evaluation.}"))) 
NIL 
(|FiniteAbelianMonoidRing&| S R E) 
((|constructor|
  (NIL
   "This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general."))
 (|primitivePart|
  (($ $)
   "\\spad{primitivePart(p)} returns the unit normalized form of polynomial \\spad{p} divided by the content of \\spad{p}."))
 (|content|
  ((|#2| $)
   "\\spad{content(p)} gives the \\spad{gcd} of the coefficients of polynomial \\spad{p}."))
 (|exquo|
  (((|Union| $ "failed") $ |#2|)
   "\\spad{exquo(p,{}r)} returns the exact quotient of polynomial \\spad{p} by \\spad{r},{} or \"failed\" if none exists."))
 (|binomThmExpt|
  (($ $ $ (|NonNegativeInteger|))
   "\\spad{binomThmExpt(p,{} q,{} n)} returns \\spad{(p+q)^n} by means of the binomial theorem trick."))
 (|fmecg|
  (($ $ |#3| |#2| $)
   "\\spad{fmecg(p1,{} e,{} r,{} p2)} returns \\spad{p1 - monomial(r,{} e) * p2}."))
 (|pomopo!|
  (($ $ |#2| |#3| $)
   "\\spad{pomopo!(p1,{} r,{} e,{} p2)} returns \\spad{p1 + monomial(r,{} e) * p2} and may use \\spad{p1} as workspace. The constant \\spad{r} is assumed to be nonzero."))
 (|mapExponents|
  (($ (|Mapping| |#3| |#3|) $)
   "\\spad{mapExponents(fn,{} u)} maps function \\spad{fn} onto the exponents of the non-zero monomials of polynomial \\spad{u}."))
 (|minimumDegree|
  ((|#3| $)
   "\\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \\spad{p}. Error: if applied to 0."))
 (|ground|
  ((|#2| $)
   "\\spad{ground(p)} retracts polynomial \\spad{p} to the coefficient ring."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground?(p)} tests if polynomial \\spad{p} is a member of the coefficient ring."))) 
((|HasCategory| |#2| '(|GcdDomain|)) (|HasCategory| |#2| '(|EntireRing|))
 (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#2| '(|Ring|))) 
(|FiniteAbelianMonoidRing| R E) 
((|constructor|
  (NIL
   "This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general."))
 (|primitivePart|
  (($ $)
   "\\spad{primitivePart(p)} returns the unit normalized form of polynomial \\spad{p} divided by the content of \\spad{p}."))
 (|content|
  ((|#1| $)
   "\\spad{content(p)} gives the \\spad{gcd} of the coefficients of polynomial \\spad{p}."))
 (|exquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{exquo(p,{}r)} returns the exact quotient of polynomial \\spad{p} by \\spad{r},{} or \"failed\" if none exists."))
 (|binomThmExpt|
  (($ $ $ (|NonNegativeInteger|))
   "\\spad{binomThmExpt(p,{} q,{} n)} returns \\spad{(p+q)^n} by means of the binomial theorem trick."))
 (|fmecg|
  (($ $ |#2| |#1| $)
   "\\spad{fmecg(p1,{} e,{} r,{} p2)} returns \\spad{p1 - monomial(r,{} e) * p2}."))
 (|pomopo!|
  (($ $ |#1| |#2| $)
   "\\spad{pomopo!(p1,{} r,{} e,{} p2)} returns \\spad{p1 + monomial(r,{} e) * p2} and may use \\spad{p1} as workspace. The constant \\spad{r} is assumed to be nonzero."))
 (|mapExponents|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{mapExponents(fn,{} u)} maps function \\spad{fn} onto the exponents of the non-zero monomials of polynomial \\spad{u}."))
 (|minimumDegree|
  ((|#2| $)
   "\\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \\spad{p}. Error: if applied to 0."))
 (|ground|
  ((|#1| $)
   "\\spad{ground(p)} retracts polynomial \\spad{p} to the coefficient ring."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground?(p)} tests if polynomial \\spad{p} is a member of the coefficient ring."))) 
NIL 
(|FiniteAbelianMonoidRingFunctions2| E R1 A1 R2 A2) 
((|constructor|
  (NIL
   "This package provides a mapping function for \\spadtype{FiniteAbelianMonoidRing}"))
 (|map|
  ((|#5| (|Mapping| |#4| |#2|) |#3|)
   "\\spad{map}(\\spad{f},{} a) applies the map \\spad{f} to each coefficient in a. It is assumed that \\spad{f} maps 0 to 0"))) 
NIL 
(|FlexibleArray| S) 
((|constructor|
  (NIL
   "\\indented{1}{A FlexibleArray is the notion of an array intended to allow for growth} at the end only. Hence the following efficient operations \\indented{2}{\\spad{concat!(a,{} x)} meaning append item \\spad{x} at the end of the array \\spad{a}} \\indented{2}{\\spad{delete!(a,{} n)} meaning delete the last item from the array \\spad{a}} Flexible arrays support the other operations inherited from \\spadtype{ExtensibleLinearAggregate}. However,{} these are not efficient. Flexible arrays combine the \\spad{O(1)} access time property of arrays with growing and shrinking at the end in \\spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50\\% larger) array. Conversely,{} when the array becomes less than 1/2 full,{} it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps,{} stacks and sets."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|FiniteAlgebraicExtensionField&| S F) 
((|constructor|
  (NIL
   "FiniteAlgebraicExtensionField {\\em F} is the category of fields which are finite algebraic extensions of the field {\\em F}. If {\\em F} is finite then any finite algebraic extension of {\\em F} is finite,{} too. Let {\\em K} be a finite algebraic extension of the finite field {\\em F}. The exponentiation of elements of {\\em K} defines a \\spad{Z}-module structure on the multiplicative group of {\\em K}. The additive group of {\\em K} becomes a module over the ring of polynomials over {\\em F} via the operation \\spadfun{linearAssociatedExp}(a: \\spad{K},{} \\spad{f:} SparseUnivariatePolynomial \\spad{F}) which is linear over {\\em F},{} \\spadignore{i.e.} for elements {\\em a} from {\\em K},{} {\\em c,{} d} from {\\em F} and {\\em f,{} g} univariate polynomials over {\\em F} we have \\spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\\em c} times \\spadfun{linearAssociatedExp}(a,{} \\spad{f}) plus {\\em d} times \\spadfun{linearAssociatedExp}(a,{} \\spad{g}). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\\em F[X]}: \\spadfun{linearAssociatedExp}(a,{} monomial(1,{} \\spad{k})\\spad{\\$}SUP(\\spad{F})) is defined to be \\spadfun{Frobenius}(a,{} \\spad{k}) which is {\\em a^(q^k)} where {\\em q=size()\\$F}. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog},{} respectively."))
 (|linearAssociatedLog|
  (((|Union| (|SparseUnivariatePolynomial| |#2|) "failed") $ $)
   "\\spad{linearAssociatedLog(b,{} a)} returns a polynomial {\\em g},{} such that the \\spadfun{linearAssociatedExp}(\\spad{b},{} \\spad{g}) equals {\\em a}. If there is no such polynomial {\\em g},{} then \\spadfun{linearAssociatedLog} fails.")
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{linearAssociatedLog(a)} returns a polynomial {\\em g},{} such that \\spadfun{linearAssociatedExp}(normalElement(),{} \\spad{g}) equals {\\em a}."))
 (|linearAssociatedOrder|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{linearAssociatedOrder(a)} retruns the monic polynomial {\\em g} of least degree,{} such that \\spadfun{linearAssociatedExp}(a,{} \\spad{g}) is 0."))
 (|linearAssociatedExp|
  (($ $ (|SparseUnivariatePolynomial| |#2|))
   "\\spad{linearAssociatedExp(a,{} f)} is linear over {\\em F},{} \\spadignore{i.e.} for elements {\\em a} from {\\em \\$},{} {\\em c,{} d} form {\\em F} and {\\em f,{} g} univariate polynomials over {\\em F} we have \\spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\\em c} times \\spadfun{linearAssociatedExp}(a,{} \\spad{f}) plus {\\em d} times \\spadfun{linearAssociatedExp}(a,{} \\spad{g}). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\\em F[X]}: \\spadfun{linearAssociatedExp}(a,{} monomial(1,{} \\spad{k})\\spad{\\$}SUP(\\spad{F})) is defined to be \\spadfun{Frobenius}(a,{} \\spad{k}) which is {\\em a^(q^k)},{} where {\\em q=size()\\$F}."))
 (|generator|
  (($)
   "\\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field."))
 (|normal?|
  (((|Boolean|) $)
   "\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F},{} \\spadignore{i.e.} \\spad{a^(q^i),{} 0 <= i <= extensionDegree()-1} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39."))
 (|normalElement|
  (($)
   "\\spad{normalElement()} returns a element,{} normal over the ground field \\spad{F},{} \\spadignore{i.e.} \\spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. At the first call,{} the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls,{} the element is retrieved by referencing the global variable."))
 (|createNormalElement|
  (($)
   "\\spad{createNormalElement()} computes a normal element over the ground field \\spad{F},{} that is,{} \\spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35."))
 (|trace|
  (($ $ (|PositiveInteger|))
   "\\spad{trace(a,{} d)} computes the trace of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size \\spad{q}. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note: \\spad{trace(a,{} d) = reduce(+,{} [a^(q^(d*i)) for i in 0..n/d])}."))
 (|norm|
  (($ $ (|PositiveInteger|))
   "\\spad{norm(a,{} d)} computes the norm of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note: norm(a,{} \\spad{d}) = reduce(*,{} [a^(\\spad{q^}(d*i)) for \\spad{i} in 0..\\spad{n/d}])"))
 (|minimalPolynomial|
  (((|SparseUnivariatePolynomial| $) $ (|PositiveInteger|))
   "\\spad{minimalPolynomial(x,{} n)} computes the minimal polynomial of \\spad{x} over the field of extension degree \\spad{n} over the ground field \\spad{F}."))
 (|basis|
  (((|Vector| $) (|PositiveInteger|))
   "\\spad{basis(n)} returns a fixed basis of a subfield of \\% as \\spad{F}-vector space."))
 (|degree|
  (((|PositiveInteger|) $)
   "\\spad{degree(a)} returns the degree of the minimal polynomial of an element \\spad{a} over the ground field \\spad{F}."))
 (|extensionDegree|
  (((|PositiveInteger|))
   "\\spad{extensionDegree()} returns the degree of field extension."))
 (|definingPolynomial|
  (((|SparseUnivariatePolynomial| |#2|))
   "\\spad{definingPolynomial()} returns the polynomial used to define the field extension."))) 
((|HasCategory| |#2| '(|Finite|))) 
(|FiniteAlgebraicExtensionField| F) 
((|constructor|
  (NIL
   "FiniteAlgebraicExtensionField {\\em F} is the category of fields which are finite algebraic extensions of the field {\\em F}. If {\\em F} is finite then any finite algebraic extension of {\\em F} is finite,{} too. Let {\\em K} be a finite algebraic extension of the finite field {\\em F}. The exponentiation of elements of {\\em K} defines a \\spad{Z}-module structure on the multiplicative group of {\\em K}. The additive group of {\\em K} becomes a module over the ring of polynomials over {\\em F} via the operation \\spadfun{linearAssociatedExp}(a: \\spad{K},{} \\spad{f:} SparseUnivariatePolynomial \\spad{F}) which is linear over {\\em F},{} \\spadignore{i.e.} for elements {\\em a} from {\\em K},{} {\\em c,{} d} from {\\em F} and {\\em f,{} g} univariate polynomials over {\\em F} we have \\spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\\em c} times \\spadfun{linearAssociatedExp}(a,{} \\spad{f}) plus {\\em d} times \\spadfun{linearAssociatedExp}(a,{} \\spad{g}). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\\em F[X]}: \\spadfun{linearAssociatedExp}(a,{} monomial(1,{} \\spad{k})\\spad{\\$}SUP(\\spad{F})) is defined to be \\spadfun{Frobenius}(a,{} \\spad{k}) which is {\\em a^(q^k)} where {\\em q=size()\\$F}. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog},{} respectively."))
 (|linearAssociatedLog|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") $ $)
   "\\spad{linearAssociatedLog(b,{} a)} returns a polynomial {\\em g},{} such that the \\spadfun{linearAssociatedExp}(\\spad{b},{} \\spad{g}) equals {\\em a}. If there is no such polynomial {\\em g},{} then \\spadfun{linearAssociatedLog} fails.")
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{linearAssociatedLog(a)} returns a polynomial {\\em g},{} such that \\spadfun{linearAssociatedExp}(normalElement(),{} \\spad{g}) equals {\\em a}."))
 (|linearAssociatedOrder|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{linearAssociatedOrder(a)} retruns the monic polynomial {\\em g} of least degree,{} such that \\spadfun{linearAssociatedExp}(a,{} \\spad{g}) is 0."))
 (|linearAssociatedExp|
  (($ $ (|SparseUnivariatePolynomial| |#1|))
   "\\spad{linearAssociatedExp(a,{} f)} is linear over {\\em F},{} \\spadignore{i.e.} for elements {\\em a} from {\\em \\$},{} {\\em c,{} d} form {\\em F} and {\\em f,{} g} univariate polynomials over {\\em F} we have \\spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\\em c} times \\spadfun{linearAssociatedExp}(a,{} \\spad{f}) plus {\\em d} times \\spadfun{linearAssociatedExp}(a,{} \\spad{g}). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\\em F[X]}: \\spadfun{linearAssociatedExp}(a,{} monomial(1,{} \\spad{k})\\spad{\\$}SUP(\\spad{F})) is defined to be \\spadfun{Frobenius}(a,{} \\spad{k}) which is {\\em a^(q^k)},{} where {\\em q=size()\\$F}."))
 (|generator|
  (($)
   "\\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field."))
 (|normal?|
  (((|Boolean|) $)
   "\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F},{} \\spadignore{i.e.} \\spad{a^(q^i),{} 0 <= i <= extensionDegree()-1} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39."))
 (|normalElement|
  (($)
   "\\spad{normalElement()} returns a element,{} normal over the ground field \\spad{F},{} \\spadignore{i.e.} \\spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. At the first call,{} the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls,{} the element is retrieved by referencing the global variable."))
 (|createNormalElement|
  (($)
   "\\spad{createNormalElement()} computes a normal element over the ground field \\spad{F},{} that is,{} \\spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \\spad{F}-basis,{} where \\spad{q = size()\\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35."))
 (|trace|
  (($ $ (|PositiveInteger|))
   "\\spad{trace(a,{} d)} computes the trace of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size \\spad{q}. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note: \\spad{trace(a,{} d) = reduce(+,{} [a^(q^(d*i)) for i in 0..n/d])}."))
 (|norm|
  (($ $ (|PositiveInteger|))
   "\\spad{norm(a,{} d)} computes the norm of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note: norm(a,{} \\spad{d}) = reduce(*,{} [a^(\\spad{q^}(d*i)) for \\spad{i} in 0..\\spad{n/d}])"))
 (|minimalPolynomial|
  (((|SparseUnivariatePolynomial| $) $ (|PositiveInteger|))
   "\\spad{minimalPolynomial(x,{} n)} computes the minimal polynomial of \\spad{x} over the field of extension degree \\spad{n} over the ground field \\spad{F}."))
 (|basis|
  (((|Vector| $) (|PositiveInteger|))
   "\\spad{basis(n)} returns a fixed basis of a subfield of \\% as \\spad{F}-vector space."))
 (|degree|
  (((|PositiveInteger|) $)
   "\\spad{degree(a)} returns the degree of the minimal polynomial of an element \\spad{a} over the ground field \\spad{F}."))
 (|extensionDegree|
  (((|PositiveInteger|))
   "\\spad{extensionDegree()} returns the degree of field extension."))
 (|definingPolynomial|
  (((|SparseUnivariatePolynomial| |#1|))
   "\\spad{definingPolynomial()} returns the polynomial used to define the field extension."))) 
NIL 
(|FiniteBiCPO| S) 
((|constructor|
  (NIL
   "Holds a complete set together with a structure to codify the partial order. For more documentation see: \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))) 
NIL 
(|FortranCode|) 
((|constructor|
  (NIL
   "This domain builds representations of program code segments for use with the FortranProgram domain."))
 (|setLabelValue|
  (((|SingleInteger|) (|SingleInteger|))
   "\\spad{setLabelValue(i)} resets the counter which produces labels to \\spad{i}"))
 (|getCode|
  (((|List| (|String|)) $)
   "\\spad{getCode(f)} returns a list of strings representing \\spad{f} in Fortran notation. This is used by the FortranProgram domain."))
 (|printCode|
  (((|Void|) $)
   "\\spad{printCode(f)} prints out \\spad{f} in FORTRAN notation."))
 (|code|
  (((|Union| (|:| |nullBranch| "null")
             (|:| |assignmentBranch|
                  (|Record| (|:| |var| (|Symbol|))
                            (|:| |arrayIndex|
                                 (|List| (|Polynomial| (|Integer|))))
                            (|:| |rand|
                                 (|Record| (|:| |ints2Floats?| (|Boolean|))
                                           (|:| |expr| (|OutputForm|))))))
             (|:| |arrayAssignmentBranch|
                  (|Record| (|:| |var| (|Symbol|)) (|:| |rand| (|OutputForm|))
                            (|:| |ints2Floats?| (|Boolean|))))
             (|:| |conditionalBranch|
                  (|Record| (|:| |switch| (|Switch|)) (|:| |thenClause| $)
                            (|:| |elseClause| $)))
             (|:| |returnBranch|
                  (|Record| (|:| |empty?| (|Boolean|))
                            (|:| |value|
                                 (|Record| (|:| |ints2Floats?| (|Boolean|))
                                           (|:| |expr| (|OutputForm|))))))
             (|:| |blockBranch| (|List| $))
             (|:| |commentBranch| (|List| (|String|)))
             (|:| |callBranch| (|String|))
             (|:| |forBranch|
                  (|Record|
                   (|:| |range| (|SegmentBinding| (|Polynomial| (|Integer|))))
                   (|:| |span| (|Polynomial| (|Integer|))) (|:| |body| $)))
             (|:| |labelBranch| (|SingleInteger|))
             (|:| |loopBranch|
                  (|Record| (|:| |switch| (|Switch|)) (|:| |body| $)))
             (|:| |commonBranch|
                  (|Record| (|:| |name| (|Symbol|))
                            (|:| |contents| (|List| (|Symbol|)))))
             (|:| |printBranch| (|List| (|OutputForm|))))
    $)
   "\\spad{code(f)} returns the internal representation of the object represented by \\spad{f}."))
 (|operation|
  (((|Union| (|:| |Null| "null") (|:| |Assignment| "assignment")
             (|:| |Conditional| "conditional") (|:| |Return| "return")
             (|:| |Block| "block") (|:| |Comment| "comment")
             (|:| |Call| "call") (|:| |For| "for") (|:| |While| "while")
             (|:| |Repeat| "repeat") (|:| |Goto| "goto")
             (|:| |Continue| "continue")
             (|:| |ArrayAssignment| "arrayAssignment") (|:| |Save| "save")
             (|:| |Stop| "stop") (|:| |Common| "common") (|:| |Print| "print"))
    $)
   "\\spad{operation(f)} returns the name of the operation represented by \\spad{f}."))
 (|common|
  (($ (|Symbol|) (|List| (|Symbol|)))
   "\\spad{common(name,{} contents)} creates a representation a named common block."))
 (|printStatement|
  (($ (|List| (|OutputForm|)))
   "\\spad{printStatement(l)} creates a representation of a PRINT statement."))
 (|save| (($) "\\spad{save()} creates a representation of a SAVE statement."))
 (|stop| (($) "\\spad{stop()} creates a representation of a STOP statement."))
 (|block|
  (($ (|List| $))
   "\\spad{block(l)} creates a representation of the statements in \\spad{l} as a block."))
 (|assign|
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|)))
    (|Expression| (|Complex| (|Float|))))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|Float|)))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|)))
    (|Expression| (|Integer|)))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|Vector| (|Expression| (|Complex| (|Float|)))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|Expression| (|Float|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|Expression| (|Integer|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|Complex| (|Float|)))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|Float|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|Integer|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|Complex| (|Float|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|Float|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|Integer|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|)))
    (|Expression| (|MachineComplex|)))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|)))
    (|Expression| (|MachineFloat|)))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|List| (|Polynomial| (|Integer|)))
    (|Expression| (|MachineInteger|)))
   "\\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}\\spad{'}th element of array \\spad{x} (\\spad{l} is a list of indices).")
  (($ (|Symbol|) (|Vector| (|Expression| (|MachineComplex|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|Expression| (|MachineFloat|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|Expression| (|MachineInteger|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|MachineComplex|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|MachineFloat|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|Expression| (|MachineInteger|))))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|MachineComplex|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|MachineFloat|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Vector| (|MachineInteger|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|MachineComplex|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|MachineFloat|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Matrix| (|MachineInteger|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|MachineComplex|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|MachineFloat|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|Expression| (|MachineInteger|)))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.")
  (($ (|Symbol|) (|String|))
   "\\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y."))
 (|cond|
  (($ (|Switch|) $ $)
   "\\spad{cond(s,{} e,{} f)} creates a representation of the FORTRAN expression IF (\\spad{s}) THEN \\spad{e} ELSE \\spad{f}.")
  (($ (|Switch|) $)
   "\\spad{cond(s,{} e)} creates a representation of the FORTRAN expression IF (\\spad{s}) THEN \\spad{e}."))
 (|returns|
  (($ (|Expression| (|Complex| (|Float|))))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($ (|Expression| (|Integer|)))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($ (|Expression| (|Float|)))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($ (|Expression| (|MachineComplex|)))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($ (|Expression| (|MachineInteger|)))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($ (|Expression| (|MachineFloat|)))
   "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.")
  (($)
   "\\spad{returns()} creates a representation of a FORTRAN RETURN statement."))
 (|call|
  (($ (|String|))
   "\\spad{call(s)} creates a representation of a FORTRAN CALL statement"))
 (|comment|
  (($ (|List| (|String|)))
   "\\spad{comment(s)} creates a representation of the Strings \\spad{s} as a multi-line FORTRAN comment.")
  (($ (|String|))
   "\\spad{comment(s)} creates a representation of the String \\spad{s} as a single FORTRAN comment."))
 (|continue|
  (($ (|SingleInteger|))
   "\\spad{continue(l)} creates a representation of a FORTRAN CONTINUE labelled with \\spad{l}"))
 (|gotoJump|
  (($ (|SingleInteger|))
   "\\spad{gotoJump(l)} creates a representation of a FORTRAN GOTO statement"))
 (|repeatUntilLoop|
  (($ (|Switch|) $)
   "\\spad{repeatUntilLoop(s,{} c)} creates a repeat ... until loop in FORTRAN."))
 (|whileLoop|
  (($ (|Switch|) $)
   "\\spad{whileLoop(s,{} c)} creates a while loop in FORTRAN."))
 (|forLoop|
  (($ (|SegmentBinding| (|Polynomial| (|Integer|))) (|Polynomial| (|Integer|))
    $)
   "\\spad{forLoop(i=1..10,{} n,{} c)} creates a representation of a FORTRAN DO loop with \\spad{i} ranging over the values 1 to 10 by \\spad{n}.")
  (($ (|SegmentBinding| (|Polynomial| (|Integer|))) $)
   "\\spad{forLoop(i=1..10,{} c)} creates a representation of a FORTRAN DO loop with \\spad{i} ranging over the values 1 to 10."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(f)} returns an object of type OutputForm."))) 
NIL 
(|FiniteCoDcpo| S) 
((|constructor|
  (NIL
   "holds a complete set together with a structure to codify \\indented{2}{the partial order.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))) 
NIL 
(|FourierComponent| E) 
((|constructor|
  (NIL
   "\\indented{1}{Author: James Davenport} Date Created: 17 April 1992 Basic Functions: Related Constructors: Also See: AMS Classifications: Keywords: References: Description:"))
 (|argument|
  ((|#1| $)
   "\\spad{argument(x)} returns the argument of a given sin/cos expressions"))
 (|sin?|
  (((|Boolean|) $)
   "\\spad{sin?(x)} returns \\spad{true} if term is a sin,{} otherwise \\spad{false}"))
 (|cos|
  (($ |#1|) "\\spad{cos(x)} makes a cos kernel for use in Fourier series"))
 (|sin|
  (($ |#1|) "\\spad{sin(x)} makes a sin kernel for use in Fourier series"))) 
NIL 
(|FortranCodePackage1|) 
((|constructor|
  (NIL
   "\\spadtype{FortranCodePackage1} provides some utilities for producing useful objects in FortranCode domain. The Package may be used with the FortranCode domain and its \\spad{printCode} or possibly via an outputAsFortran. (The package provides items of use in connection with ASPs in the AXIOM-NAG link and,{} where appropriate,{} naming accords with that in IRENA.) The easy-to-use functions use Fortran loop variables \\spad{I1},{} \\spad{I2},{} and it is users' responsibility to check that this is sensible. The advanced functions use SegmentBinding to allow users control over Fortran loop variable names."))
 (|identitySquareMatrix|
  (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|)))
   "\\spad{identitySquareMatrix(s,{} p)} \\undocumented{}"))
 (|zeroSquareMatrix|
  (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|)))
   "\\spad{zeroSquareMatrix(s,{} p)} \\undocumented{}"))
 (|zeroMatrix|
  (((|FortranCode|) (|Symbol|) (|SegmentBinding| (|Polynomial| (|Integer|)))
    (|SegmentBinding| (|Polynomial| (|Integer|))))
   "\\spad{zeroMatrix(s,{} b,{} d)} in this version gives the user control over names of Fortran variables used in loops.")
  (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|))
    (|Polynomial| (|Integer|)))
   "\\spad{zeroMatrix(s,{} p,{} q)} uses loop variables in the Fortran,{} \\spad{I1} and \\spad{I2}"))
 (|zeroVector|
  (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|)))
   "\\spad{zeroVector(s,{} p)} \\undocumented{}"))) 
NIL 
(|FortranCodeTools|) 
((|get_fort_indent|
  (((|Integer|))
   "\\spad{get_fort_indent()} gets current amount of Frotran indentation"))
 (|get_used_intrinsics|
  (((|List| (|String|)))
   "\\spad{get_used_intrinsics()} gets list of used intrinsics"))
 (|clear_used_intrinsics|
  (((|Void|)) "\\spad{clear_used_intrinsics()} clear list of used intrinsics"))
 (|newFortranTempVar|
  (((|Symbol|))
   "\\spad{newFortranTempVar()} creates new name for temporary variable and puts it in TheSymbolTable"))
 (|checkType| (((|String|) (|String|)) "\\spad{checkType(t)}"))
 (|indentFortLevel| (((|Void|) (|Integer|)) "\\spad{indentFortLevel(i)}"))
 (|fort_format_types|
  (((|Void|) (|String|) (|List| (|OutputForm|)))
   "\\spad{fort_format_types(typeName,{} names)}"))
 (|fortFormatTypeLines|
  (((|Void|) (|String|) (|List| (|String|)))
   "\\spad{fortFormatTypeLines(typeName,{} l)}"))
 (|fortFormatHead|
  (((|Void|) (|Symbol|)
    (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void"))
    (|List| (|Symbol|)))
   "\\spad{fortFormatHead(name,{} returnType,{} args)}"))
 (|dispStatement| (((|Void|) (|OutputForm|)) "\\spad{dispStatement(of)}"))
 (|displayLines| (((|Void|) (|List| (|String|))) "\\spad{displayLines(l)}"))
 (|changeExprLength|
  (((|Void|) (|Integer|))
   "\\spad{changeExprLength(i)} changes limit on expression length by \\spad{i}."))
 (|getStatement|
  (((|List| (|String|)) (|OutputForm|) (|Boolean|))
   "\\spad{getStatement(of,{} int_to_floats?)}"))
 (|expression2Fortran|
  (((|List| (|String|)) (|OutputForm|)) "\\spad{expression2Fortran(of)}"))
 (|statement2Fortran|
  (((|List| (|String|)) (|OutputForm|)) "\\spad{statement2Fortran(of)}"))
 (|expression2Fortran1|
  (((|List| (|String|)) (|Mapping| (|Symbol|)) (|OutputForm|) (|Boolean|))
   "\\spad{expression2Fortran1(nf,{} of,{} int_to_floats?)}"))
 (|do_with_error_env1|
  (((|List| (|String|)) (|Mapping| (|List| (|String|))))
   "\\spad{do_with_error_env1(f)}"))
 (|do_with_error_env2|
  (((|List| (|String|)) (|Boolean|) (|Mapping| (|List| (|String|))))
   "\\spad{do_with_error_env2(int_to_floats?,{} f)}"))
 (|do_with_error_env3|
  (((|List| (|String|)) (|Boolean|) (|Mapping| (|List| (|String|))))
   "\\spad{do_with_error_env3(int_to_floats?,{} f)}"))) 
NIL 
(|FreeDivisionAlgebra| VAR F) 
((|constructor|
  (NIL
   "The elements of the Free Field are represented by Admissible Linear Systems (ALS) in standard form ..."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(f)} returns the rank of the element \\spad{f},{} that is,{} the dimension of a minimal admissible linear system (for \\spad{f})."))
 (|refinementSolve|
  (((|List| (|List| (|Equation| (|Polynomial| |#2|)))) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|Boolean|) (|Boolean|))
   "\\spad{refinementSolve(f,{}i_min,{}i_max,{}k_rows,{}flg_u,{}flg_r)} Computes a list of solutions (for the entries in transformation matrices) to create a lower left block of zeros with \\spad{k} rows in the pivot block \\spad{i_min}..\\spad{i_max}."))
 (|refinementGroebner|
  (((|List| (|Polynomial| |#2|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|Boolean|) (|Boolean|))
   "\\spad{refinementGroebner(f,{}i_min,{}i_max,{}k_rows,{}flg_u,{}flg_r)} computes a Groebner basis for the ideal generated by the equations for creating a zero block with \\spad{k} rows within the pivot block \\spad{i_min}..\\spad{i_max} and conditions to guarantee invertible transformations."))
 (|refinementEquations|
  (((|List| (|Polynomial| |#2|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|Boolean|) (|Boolean|))
   "\\spad{refinementEquations(f,{}i_min,{}i_max,{}k_rows,{}flg_u,{}flg_r)} for debugging purposes (interface LINPEN)"))
 (|refinementTransformations|
  (((|List| (|Matrix| |#2|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| (|Equation| (|Polynomial| |#2|))))
   "\\spad{refinementTransformations(f,{}i_min,{}i_max,{}sol)} for debugging purposes (interface LINPEN)"))
 (|refine!|
  (($ $) "\\spad{refine!(f)} refines \\spad{f} using non-linear techniques.")
  (($ $ (|Boolean|))
   "\\spad{refine!(f,{} flg)} refines the underlying admissible admissible linear system using simple and linear techniques and if flg=true also non-linear techniques (Groebner basis)."))
 (|setRefined!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{setRefined!(f,{}max_sze)} sets the internal flag if the system is refined (over the ground field) up to the specified block size."))
 (^ (($ $ (|Integer|)) "\\spad{f^n} returns \\spad{f^n}.")
  (($ $ (|PositiveInteger|)) "\\spad{f^n} returns \\spad{f^n}."))
 (/
  (($ $ $)
   "\\spad{f / g} computes \\spad{f} * \\spad{g^}-1 for nonzero element \\spad{g}.")
  (($ |#2| $)
   "\\spad{alpha / f} computes alpha / \\spad{f} for nonzero \\spad{f}.")
  (($ $ |#2|)
   "\\spad{f / alpha} computes \\spad{f} / alpha for nonzero alpha."))
 (- (($ |#2| $) "\\spad{alpha - f} adds the scalar alpha to \\spad{-f}.")
    (($ $ |#2|)
     "\\spad{f - alpha} subtracts the scalar alpha from \\spad{f}."))
 (+ (($ |#2| $) "\\spad{alpha + f} adds the scalar alpha to \\spad{f}.")
    (($ $ |#2|) "\\spad{f + alpha} adds the scalar alpha to \\spad{f}."))
 (|inverse| (($ $) "\\spad{inverse(f)} \\spad{f^}-1 using invertMIN."))
 (|invertMIN|
  (($ $)
   "\\spad{invertMIN(f)} uses invertSTD(\\spad{f}) and minimization to construct a minimal system for \\spad{f^}-1. Linear techniques are used to get a fine pivot block structure."))
 (|multiplyMIN|
  (($ $ $)
   "\\spad{multiplyMIN(f,{}g)} uses multiplyALS(\\spad{f},{}\\spad{g}) with minimization."))
 (|addMIN|
  (($ $ $)
   "\\spad{addMIN(f,{}g)} uses addALS(\\spad{f},{}\\spad{g}) with minimization."))
 (|minimize|
  (($ $)
   "\\spad{minimize(f)} minimizes the unterlying ALS by applying left and right block minimization steps. Minimality is only guaranteed if the remaining blocks are refined."))
 (|rightMinimization|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{rightMinimization(f,{} i_min,{} i_max)} tries to apply a right minimization step with respect to the pivot block with the rows/columns (\\spad{i_min},{} ...,{} i_max)."))
 (|leftMinimization|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{leftMinimization(f,{} i_min,{} i_max)} tries to apply a left minimization step with respect to the pivot block with the rows/columns (\\spad{i_min},{} ...,{} i_max)."))
 (|normalALS|
  (($ $)
   "\\spad{normalALS(f)} removes a scalar first row of an (extended) ALS."))
 (|extendedALS|
  (($ $)
   "\\spad{extendedALS(f)} returns an extended ALS for \\spad{f},{} that is,{} 1*f (with a scalar first row)."))
 (|refineUR!|
  (($ $)
   "\\spad{refineUR!(f)} uses linear techniques to create upper right blocks of zeros in staircase form (as far as possible).")
  (($ $ (|NonNegativeInteger|))
   "\\spad{refineUR!(f,{}k)} uses linear techniques to create an upper right block of zeros with \\spad{k} rows (if possible)."))
 (|factorizationSolve|
  (((|List| (|List| (|Equation| (|Polynomial| |#2|)))) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{factorizationSolve(f,{}k_rows,{}k_cols)} returns a (possible empty) list of solutions for an admissible transformation to create an upper right block of zeros of size \\spad{k_rows} times \\spad{k_cols}."))
 (|factorizationGroebner|
  (((|List| (|Polynomial| |#2|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{factorizationGroebner(f,{}k_rows,{}k_cols)} for debugging purposes (interface LINPEN)"))
 (|factorizationEquations|
  (((|List| (|Polynomial| |#2|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{factorizationEquations(f,{}k_rows,{}k_cols)} for debugging purposes (interface LINPEN)"))
 (|factorizationTransformations|
  (((|List| (|Matrix| |#2|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| (|Equation| (|Polynomial| |#2|))))
   "\\spad{factorizationTransformations(f,{}k_rows,{}k_cols,{}sol)} for debugging purposes (interface LINPEN)"))
 (|factor|
  (((|List| $) $)
   "\\spad{factor(f)} factorizes \\spad{f} in f=f_1*f_2*...*f_k with atoms (irreducible elements) f_i. Notice that this factorization is unique only with respect to similiarity."))
 (|factorize|
  (((|List| $) $ (|NonNegativeInteger|))
   "\\spad{factorize(f,{}k)} factorizes \\spad{f} in f=g*h with rank(\\spad{g})\\spad{=k} if possible (if necessary by using non-linear techniques)."))
 (|rightFactor|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rightFactor(f,{}k)} returns the right factor of rank \\spad{k} of a polynomial \\spad{f} or 1 if it\\spad{'s} not possible by linear techniques."))
 (|leftFactor|
  (($ $ (|NonNegativeInteger|))
   "\\spad{leftFactor(f,{}k)} returns the left factor of rank \\spad{k} of a polynomial \\spad{f} or 1 if it\\spad{'s} not possible by linear techniques."))
 (|ratexpr|
  (((|OutputForm|) $)
   "\\spad{ratexpr(f)} analysis the block structure of the admissible linear system to write \\spad{f} as rational expression."))
 (|ratexprInverse|
  (((|OutputForm|) $ (|Boolean|))
   "\\spad{ratexprInverse(f,{} flg)} returns \\spad{f} in output form if it is a polynomial,{} (\\spad{f})^-1 if \\spad{f^}-1 is a polynomial,{} \"r<rank>\" if the system is minimal and \"d<dim>\" in general."))
 (|rightFamily|
  (((|List| (|OutputForm|)) $)
   "\\spad{rightFamily(f)} prints the right family t=u*A^-1."))
 (|leftFamily|
  (((|List| (|OutputForm|)) $)
   "\\spad{leftFamily(f)} prints the left family s=A^-1*v."))
 (|summands|
  (((|List| $) $)
   "\\spad{summands(f)} analysis the block structure of the system matrix of the ALS of \\spad{f} to split \\spad{f} into summands."))
 (|factors|
  (((|List| $) $)
   "\\spad{factors(f)} analysis the block structure of the system matrix of the ALS of \\spad{f} to split \\spad{f} into factors."))
 (|invertSTD|
  (($ $)
   "\\spad{invertSTD(f)} computes the standard inverse of \\spad{f} in terems of the admissible linear system There is no check if \\spad{f} is invertible!"))
 (|invertALS|
  (($ $)
   "\\spad{invertALS(f)} computes \\spad{f^}-1 in terms of the ALS for \\spad{f}. There is no check if \\spad{f} is invertible!"))
 (|multiplyALS|
  (($ $ $)
   "\\spad{multiplyALS(f,{}g)} computes \\spad{f*g} in terms of the admissible linear systems for \\spad{f} and \\spad{g} (without minimization)."))
 (|addALS|
  (($ $ $)
   "\\spad{addALS(f,{}g)} computes \\spad{f+g} in terms of the admissible linear systems for \\spad{f} and \\spad{g} (without minimization)."))
 (|scaleALS|
  (($ $ |#2|)
   "\\spad{scaleALS(f,{} alpha)} computes alpha*f by scaling the right hand side of the ALS for \\spad{f}."))
 (|rowSpan|
  (((|Stream| (|Matrix| (|XDistributedPolynomial| |#1| |#2|))) $)
   "\\spad{rowSpan(f)} computes the row span for a regular element,{} that is (\\spad{u}; uM; \\spad{uM^2}; ...) where PAs=Pv with PA = \\spad{I}-\\spad{M}."))
 (|columnSpan|
  (((|Stream| (|Matrix| (|XDistributedPolynomial| |#1| |#2|))) $)
   "\\spad{columnSpan(f)} computes the column span for a regular element,{} that is (\\spad{v'},{} \\spad{Mv'},{} M^2v',{} ...) where PAs=Pv=v' with PA = \\spad{I}-\\spad{M}."))
 (|solutionVector|
  (((|Matrix| (|XDistributedPolynomial| |#1| |#2|)) $ (|NonNegativeInteger|))
   "\\spad{solutionVector(f,{} k)} computes the approximated solution vector up to powers \\spad{M^k} \\spad{v'} where PAs=Pv=v' with PA = \\spad{I}-\\spad{M}.")
  (((|Matrix| (|XDistributedPolynomial| |#1| |#2|)) $)
   "\\spad{solutionVector(f)} computes the solution vector \\spad{s} of As=v if \\spad{f} is polynomial."))
 (|polynomial|
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{polynomial(f)} returns \\spad{f} as XDPOLY (if possible)"))
 (|normalize!|
  (($ $)
   "\\spad{normalize!(f)} rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one. The right hand side is normalized by normalizeRHS! and the non-zero entry is in the last row of the corresponding block."))
 (|normalizeDIAG!|
  (($ $)
   "\\spad{normalizeDIAG!(f)} rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one."))
 (|normalizePLS!|
  (($ $)
   "\\spad{normalizePLS!(f)} scales and rearranges rows and columns of the system matrix such that the constant part of the system matrix is the identity matrix (possibly of smaller size)."))
 (|normalizeRHS!|
  (($ $)
   "\\spad{normalizeRHS!(f)} eliminates non-zero entries in the right hand side of ALS with respect of the non-zero entry with the highest index."))
 (|transformColumns!|
  (($ $ (|Matrix| |#2|))
   "\\spad{transformColumns!(f,{} U)} transforms the ALS of \\spad{f} from the right."))
 (|transformRows!|
  (($ $ (|Matrix| |#2|))
   "\\spad{transformRows!(f,{} T)} transforms the ALS of \\spad{f} from the left."))
 (|transformationMatrix|
  (((|Matrix| |#2|) $)
   "\\spad{transformationMatrix(f)} returns the identity matrix to be modified and used within transformRows! or transformColumns!"))
 (* (($ (|Matrix| |#2|) $) "\\spad{T * f} row transformation")
    (($ $ (|Matrix| |#2|)) "\\spad{f * U} column transformation"))
 (|representation|
  (((|List| (|Matrix| (|XDistributedPolynomial| |#1| |#2|))) $)
   "\\spad{representation(f)} returns the element \\spad{f} as linear representation (\\spad{u},{}A,{}\\spad{v})."))
 (|linearization|
  (((|Matrix| $) $)
   "\\spad{linearization(f)} returns the element \\spad{f} as linearization with entries represented by admissible linear systems in minimal refined form.")
  (((|Matrix| (|XDistributedPolynomial| |#1| |#2|)) $)
   "\\spad{linearization(f)} returns the element \\spad{f} as linearization."))
 (|admissibleLinearSystem|
  (((|OutputForm|) $) "\\spad{admissibleLinearSystem(f)} output as ALS."))
 (|display|
  (((|OutputForm|) $ (|List| (|Symbol|)))
   "\\spad{display(f,{}[s])} prints the element \\spad{f} as A*(\\spad{s_1},{}\\spad{s_2},{}...,{}\\spad{s_n})' = \\spad{v}.")
  (((|OutputForm|) $ (|OutputForm|))
   "\\spad{display(f,{}sol)} prints the element \\spad{f} as A*sol = \\spad{v}."))
 (|blockElimination|
  (((|List| (|Matrix| |#2|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{blockElimination(f,{} rsrc,{} rdst,{} csrc,{} cdst)} flg_u = \\spad{true},{} flg_v = \\spad{true}")
  (((|List| (|Matrix| |#2|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|Boolean|) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|Boolean|))
   "\\spad{blockElimination(f,{} rsrc,{} rdst,{} flg_u,{} csrc,{} cdst,{} flg_v)} returns transformation matrices if it is possible to eliminate all entries in \\spad{rdst} \\spad{x} \\spad{cdst} (including columns in \\spad{u} if \\spad{flg_u} = \\spad{true},{} including rows in \\spad{v} if flg_v = \\spad{true}) by using rows in \\spad{rsrc} and columns in \\spad{csrc}. Otherwise an empty list."))
 (|refined?|
  (((|Boolean|) $)
   "\\spad{refined?(f)} is \\spad{f} represented by a refined ALS?"))
 (|blockStructure|
  (((|Matrix| (|NonNegativeInteger|)) $)
   "\\spad{blockStructure(f)} analyzes the structure of the ALS of \\spad{f} and detects blocks with respect to an upper triangular structure. Entry (\\spad{i},{}1) contains the first row,{} (\\spad{i},{}2) the last row,{} (\\spad{i},{}3) the size and (\\spad{i},{}4) if block \\spad{i} is refined."))
 (|qzero?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|FreeMonoid| |#1|))
   "\\spad{qzero?(f,{} i_min,{} i_max,{} j_min,{} j_max,{} m)} is the spezified block zero in the (system) matrix corresponding to the monomial \\spad{m?}")
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qzero?(f,{} i_min,{} i_max,{} j_min,{} j_max,{} l)} is the spezified block zero in matrix \\spad{l?}")
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qzero?(f,{} i_min,{} i_max,{} j_min,{} j_max)} is the spezified block zero (in the system matrix)?"))
 (|insertRowsColumns|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{insertRowsColumns(f,{} lst_row,{} lst_col)} returns a new system with rows and columns inserted. An index \\spad{k} means a new row/column between \\spad{k} and \\spad{k+1}. The number of rows and columns have to be the same!"))
 (|removeRowsColumns|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{removeRowsColumns(f,{} lst_row,{} lst_col)} returns a new system with the specified rows and columns removed. The number of rows and columns have to be the same!"))
 (|addColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addColumns!(f,{} i,{} j,{} alpha)} adds alpha*column(\\spad{i}) to column(\\spad{j}) in A and subtracts row(\\spad{j}) from row(\\spad{i}) in \\spad{s} (in the ALS of \\spad{f}),{} \\spadignore{i.e.} (A*U)(U^-1*s) = \\spad{v}."))
 (|qaddColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addColumns!(f,{} i,{} j,{} alpha)} adds alpha*column(\\spad{i}) to column(\\spad{j}) in A and subtracts row(\\spad{j}) from row(\\spad{i}) in \\spad{s} (in the ALS of \\spad{f}),{} \\spadignore{i.e.} (A*U)(U^-1*s) = \\spad{v}."))
 (|swapColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapColumns!(f,{} i,{} j)} exchanges columns \\spad{i} and \\spad{j} in the ALS of \\spad{f}."))
 (|qswapColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapColumns!(f,{} i,{} j)} exchanges columns \\spad{i} and \\spad{j} in the ALS of \\spad{f}."))
 (|multiplyColumn!|
  (($ $ (|NonNegativeInteger|) |#2|)
   "\\spad{multiplyColumn!(f,{} i,{} alpha)} multiplies column(\\spad{i}) by alpha in the ALS of \\spad{f}."))
 (|multiplyRow!|
  (($ $ (|NonNegativeInteger|) |#2|)
   "\\spad{multiplyRow!(f,{} i,{} alpha)} multiplies row(\\spad{i}) by alpha in the ALS of \\spad{f}."))
 (|qaddRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addRows!(f,{} i,{} j,{} alpha)} adds alpha*row(\\spad{i}) to row(\\spad{j}) in the ALS of \\spad{f}."))
 (|addRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addRows!(f,{} i,{} j,{} alpha)} adds alpha*row(\\spad{i}) to row(\\spad{j}) in the ALS of \\spad{f}."))
 (|addColumnsRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addColumnsRows!(f,{} i,{} j,{} alpha)} adds alpha*column(\\spad{i}) to column(\\spad{j}) and subtracts alpha*row(\\spad{j}) from row(\\spad{i}) in the ALS of \\spad{f}."))
 (|addRowsColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addRowsColumns!(f,{} i,{} j,{} alpha)} adds alpha*row(\\spad{i}) to row(\\spad{j}) and subtracts alpha*column(\\spad{j}) from column(\\spad{i}) in the ALS of \\spad{f}."))
 (|qswapRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapRows!(f,{} i,{} j)} exchanges rows \\spad{i} and \\spad{j} in the ALS of \\spad{f}."))
 (|swapRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapRows!(f,{} i,{} j)} exchanges rows \\spad{i} and \\spad{j} in the ALS of \\spad{f}."))
 (|swapRowsColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapRowsColumns!(f,{} i,{} j)} exchanges rows \\spad{i} and \\spad{j} and columns \\spad{j} and \\spad{i} in the ALS of \\spad{f}."))
 (|pencil|
  (((|LinearMultivariateMatrixPencil| |#2|) $)
   "\\spad{pencil(f)} returns a pointer to the underlying pencil."))
 (|appendSupport!|
  (($ $ (|List| (|FreeMonoid| |#1|)))
   "\\spad{appendSupport! (f,{} lst)} appends variables not in the support."))
 (|matrix|
  (((|Matrix| (|XDistributedPolynomial| |#1| |#2|)) $)
   "\\spad{matrix(f)} returns the matrix of the ALS of \\spad{f}.")
  (((|Matrix| |#2|) $ (|FreeMonoid| |#1|))
   "\\spad{matrix(f,{}m)} returns the coefficient matrix for the monomial \\spad{m} of the ALS of \\spad{f}."))
 (|vector|
  (((|Matrix| (|XDistributedPolynomial| |#1| |#2|)) $)
   "\\spad{vector(f)} returns \\spad{v} from the ALS of \\spad{f}.")
  (((|Matrix| |#2|) $)
   "\\spad{vector(f)} returns \\spad{v} from the ALS of \\spad{f}."))
 (|setelt!|
  (((|XDistributedPolynomial| |#1| |#2|) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{setelt!(f,{} i,{} j,{} p)} sets A(\\spad{i},{}\\spad{j}) = \\spad{p} in the ALS of \\spad{f} (where \\spad{p} has degree less equal one) if the system is in polynomial form and j>i.")
  ((|#2| $ (|NonNegativeInteger|) |#2|)
   "\\spad{setelt!(f,{} i,{} alpha)} sets \\spad{v}(\\spad{i}) = alpha in the ALS of \\spad{f}."))
 (|qelt|
  (((|XDistributedPolynomial| |#1| |#2|) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qelt(f,{} i,{} j)} returns A(\\spad{i},{}\\spad{j}) from the ALS of \\spad{f}."))
 (|elt|
  (((|XDistributedPolynomial| |#1| |#2|) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{elt(f,{} i,{} j)} returns A(\\spad{i},{}\\spad{j}) from the ALS of \\spad{f}.")
  ((|#2| $ (|NonNegativeInteger|))
   "\\spad{elt(f,{} i)} returns \\spad{v}(\\spad{i}) from the ALS of \\spad{f}."))
 (|variables|
  (((|List| (|FreeMonoid| |#1|)) $)
   "\\spad{variables(f)} returns a list of the variables."))
 (|dimension|
  (((|NonNegativeInteger|) $)
   "\\spad{dimension(f)} returns the dimension of the ALS."))
 (|polynomial?|
  (((|Boolean|) $) "\\spad{polynomial?(f)} is the ALS in polynomial form?"))
 (|regular?|
  (((|Boolean|) $) "\\spad{regular?(f)} is \\spad{f} a regular element?"))
 (|zero?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{zero?(f,{} i,{} j)} is A(\\spad{i},{}\\spad{j}) zero?"))
 (|scalar?| (((|Boolean|) $) "\\spad{scalar?(f)} is \\spad{f} scalar?")
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{scalar?(f,{} i,{} j)} is A(\\spad{i},{}\\spad{j}) scalar?"))
 (|qregular?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qregular?(f,{} i_min,{} i_max)} does the specified diagonal block define a regular element?"))
 (|mutable?|
  (((|Boolean|) $)
   "\\spad{mutable?(f)} is the underlying ALS of \\spad{f} mutable?"))
 (|minimal?|
  (((|Boolean|) $)
   "\\spad{minimal?(f)} is \\spad{f} represented by a minimal ALS?"))
 (|toggleAlternativeOutput|
  (($ $)
   "\\spad{toggleAlternativeOutput(f)} enable/disable output as rational expression."))
 (|disableAlternativeOutput|
  (($ $)
   "\\spad{disableAlternativeOutput(f)} disable output as rational expression."))
 (|enableAlternativeOutput|
  (($ $)
   "\\spad{enableAlternativeOutput(f)} enable output as rational expression."))
 (|toggleDebugOutput|
  (($ $) "\\spad{toggleDebugOutput(f)} enable/disable ALS."))
 (|disableDebugOutput|
  (($ $) "\\spad{disableDebugOutput(f)} disable displaying the ALS."))
 (|enableDebugOutput|
  (($ $) "\\spad{enableDebugOutput(f)} enable displaying the ALS."))
 (|coerce|
  (($ (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{coerce(p)} converts the polynomial \\spad{p} to an element in the free field represented by an minimal admissible linear system.")
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{coerce(f)} converts the element to XDPOLY (if possible).")
  (((|OutputForm|) $)
   "\\spad{coerce(f)} prints the ALS of \\spad{f} if the debug flag is set and a rational expression if the alternative output flag is set.")
  (($ |#2|)
   "\\spad{coerce(c)} converts the constant \\spad{c} into an element of the free field represented by an ALS in minimal refined form.")
  (($ (|FreeMonoid| |#1|))
   "\\spad{coerce(m)} converts the monoid \\spad{m} into an element of the free field represented by an ALS in minimal refined form."))
 (|copy|
  (($ $ |#2|)
   "\\spad{copy(f,{} alpha)} gives a copy of element \\spad{f} multiplied by alpha.")
  (($ $) "\\spad{copy(f)} gives a copy of the element \\spad{f}."))
 (|new|
  (($ (|FreeMonoid| |#1|) |#2|)
   "\\spad{new(m,{}c)} creates a monomial element with coefficient \\spad{c}.")
  (($ |#2|) "\\spad{new(c)} creates a constant element.")
  (($ (|LinearMultivariateMatrixPencil| |#2|) (|List| (|FreeMonoid| |#1|)))
   "\\spad{new(lp,{} lst)} creates an element by the linear multivariate matrix pencil \\spad{lp} and the list of monomials \\spad{lst}."))
 (|qnew|
  (($ (|NonNegativeInteger|) (|List| (|FreeMonoid| |#1|)))
   "\\spad{qnew(n,{} lst)} creates an empty ALS of dimension \\spad{n}.")
  (($ (|NonNegativeInteger|))
   "\\spad{qnew(n)} creates an empty ALS of dimension \\spad{n}."))
 (|interval|
  (((|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{interval(i,{} j)} creates list [\\spad{i},{} \\spad{i+1},{} ...,{} \\spad{j}]"))) 
NIL 
(|FiniteDcpo| S) 
((|constructor|
  (NIL
   "holds a complete set together with a structure to codify \\indented{2}{the partial order.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))) 
NIL 
(|FiniteDivisor| F UP UPUP R) 
((|constructor|
  (NIL
   "This domains implements finite rational divisors on a curve,{} that is finite formal sums SUM(\\spad{n} * \\spad{P}) where the \\spad{n}\\spad{'s} are integers and the \\spad{P}\\spad{'s} are finite rational points on the curve."))
 (|lSpaceBasis|
  (((|Vector| |#4|) $)
   "\\spad{lSpaceBasis(d)} returns a basis for \\spad{L(d) = {f | (f) >= -d}} as a module over \\spad{K[x]}."))
 (|finiteBasis|
  (((|Vector| |#4|) $)
   "\\spad{finiteBasis(d)} returns a basis for \\spad{d} as a module over {\\em K[x]}."))) 
NIL 
(|FiniteDivisorFunctions2| R1 UP1 UPUP1 F1 R2 UP2 UPUP2 F2) 
((|constructor|
  (NIL
   "\\indented{1}{Lift a map to finite divisors.} Author: Manuel Bronstein Date Created: 1988"))
 (|map|
  (((|FiniteDivisor| |#5| |#6| |#7| |#8|) (|Mapping| |#5| |#1|)
    (|FiniteDivisor| |#1| |#2| |#3| |#4|))
   "\\spad{map(f,{} d)} \\undocumented{}"))) 
NIL 
(|FiniteDivisorCategory&| S F UP UPUP R) 
((|constructor|
  (NIL
   "This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\\spad{n} * \\spad{P}) where the \\spad{n}\\spad{'s} are integers and the \\spad{P}\\spad{'s} are finite rational points on the curve."))
 (|generator|
  (((|Union| |#5| "failed") $ (|Integer|) (|List| |#3|))
   "\\spad{generator(d,{} k,{} lp)} returns \\spad{f} if \\spad{(f) = d},{} \"failed\" if \\spad{d} is not principal. \\spad{k} is sum of orders of \\spad{d} at special places. Special places are places over infinity and over zeros of polynomials in \\spad{lp}. Elements of \\spad{lp} are assumed to be relatively prime.")
  (((|Union| |#5| "failed") $)
   "\\spad{generator(d)} returns \\spad{f} if \\spad{(f) = d},{} \"failed\" if \\spad{d} is not principal. \\spad{d} is assumed to be of degree 0."))
 (|principal?|
  (((|Boolean|) $)
   "\\spad{principal?(D)} tests if the argument is the divisor of a function."))
 (|reduce|
  (($ $)
   "\\spad{reduce(D)} converts \\spad{D} to some reduced form (the reduced forms can be different in different implementations)."))
 (|decompose|
  (((|Record| (|:| |id| (|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|))
              (|:| |principalPart| |#5|))
    $)
   "\\spad{decompose(d)} returns \\spad{[id,{} f]} where \\spad{d = (id) + div(f)}."))
 (|divisor|
  (($ |#5| |#3| |#3| |#3| |#2|)
   "\\spad{divisor(h,{} d,{} d',{} g,{} r)} returns the sum of all the finite points where \\spad{h/d} has residue \\spad{r}. \\spad{h} must be integral. \\spad{d} must be squarefree. \\spad{d'} is some derivative of \\spad{d} (not necessarily dd/dx). \\spad{g = gcd(d,{} discriminant)} contains the ramified zeros of \\spad{d}")
  (($ |#5| |#3| |#3|)
   "\\spad{divisor(h,{} d,{} g)} returns \\spad{gcd} of divisor of zeros of \\spad{h} and divisor of zeros of \\spad{d}. \\spad{d} must be squarefree. All ramified zeros of \\spad{d} must be contained in zeros of \\spad{g}.")
  (($ |#2| |#2| (|Integer|))
   "\\spad{divisor(a,{} b,{} n)} makes the divisor \\spad{nP} where \\spad{P:} \\spad{(x = a,{} y = b)}. \\spad{P} is allowed to be singular if \\spad{n} is a multiple of the rank.")
  (($ |#2| |#2|)
   "\\spad{divisor(a,{} b)} makes the divisor \\spad{P:} \\spad{(x = a,{} y = b)}. Error: if \\spad{P} is singular.")
  (($ |#5|)
   "\\spad{divisor(g)} returns the divisor of the function \\spad{g}.")
  (($ (|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|))
   "\\spad{divisor(I)} makes a divisor \\spad{D} from an ideal \\spad{I}."))
 (|ideal|
  (((|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|) $)
   "\\spad{ideal(D)} returns the ideal corresponding to a divisor \\spad{D}."))) 
NIL 
(|FiniteDivisorCategory| F UP UPUP R) 
((|constructor|
  (NIL
   "This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\\spad{n} * \\spad{P}) where the \\spad{n}\\spad{'s} are integers and the \\spad{P}\\spad{'s} are finite rational points on the curve."))
 (|generator|
  (((|Union| |#4| "failed") $ (|Integer|) (|List| |#2|))
   "\\spad{generator(d,{} k,{} lp)} returns \\spad{f} if \\spad{(f) = d},{} \"failed\" if \\spad{d} is not principal. \\spad{k} is sum of orders of \\spad{d} at special places. Special places are places over infinity and over zeros of polynomials in \\spad{lp}. Elements of \\spad{lp} are assumed to be relatively prime.")
  (((|Union| |#4| "failed") $)
   "\\spad{generator(d)} returns \\spad{f} if \\spad{(f) = d},{} \"failed\" if \\spad{d} is not principal. \\spad{d} is assumed to be of degree 0."))
 (|principal?|
  (((|Boolean|) $)
   "\\spad{principal?(D)} tests if the argument is the divisor of a function."))
 (|reduce|
  (($ $)
   "\\spad{reduce(D)} converts \\spad{D} to some reduced form (the reduced forms can be different in different implementations)."))
 (|decompose|
  (((|Record| (|:| |id| (|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|))
              (|:| |principalPart| |#4|))
    $)
   "\\spad{decompose(d)} returns \\spad{[id,{} f]} where \\spad{d = (id) + div(f)}."))
 (|divisor|
  (($ |#4| |#2| |#2| |#2| |#1|)
   "\\spad{divisor(h,{} d,{} d',{} g,{} r)} returns the sum of all the finite points where \\spad{h/d} has residue \\spad{r}. \\spad{h} must be integral. \\spad{d} must be squarefree. \\spad{d'} is some derivative of \\spad{d} (not necessarily dd/dx). \\spad{g = gcd(d,{} discriminant)} contains the ramified zeros of \\spad{d}")
  (($ |#4| |#2| |#2|)
   "\\spad{divisor(h,{} d,{} g)} returns \\spad{gcd} of divisor of zeros of \\spad{h} and divisor of zeros of \\spad{d}. \\spad{d} must be squarefree. All ramified zeros of \\spad{d} must be contained in zeros of \\spad{g}.")
  (($ |#1| |#1| (|Integer|))
   "\\spad{divisor(a,{} b,{} n)} makes the divisor \\spad{nP} where \\spad{P:} \\spad{(x = a,{} y = b)}. \\spad{P} is allowed to be singular if \\spad{n} is a multiple of the rank.")
  (($ |#1| |#1|)
   "\\spad{divisor(a,{} b)} makes the divisor \\spad{P:} \\spad{(x = a,{} y = b)}. Error: if \\spad{P} is singular.")
  (($ |#4|)
   "\\spad{divisor(g)} returns the divisor of the function \\spad{g}.")
  (($ (|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|))
   "\\spad{divisor(I)} makes a divisor \\spad{D} from an ideal \\spad{I}."))
 (|ideal|
  (((|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|) $)
   "\\spad{ideal(D)} returns the ideal corresponding to a divisor \\spad{D}."))) 
NIL 
(|FloatEllipticFunctions|) 
((|constructor|
  (NIL
   "This package implements arbitrary precision numerical elliptic functions. The method is based on descending Landen transform."))
 (|sn2|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|List| (|Complex| (|Float|))))
   "Undocumented.")
  (((|Float|) (|Float|) (|List| (|Float|))) "Undocumented."))
 (|kprod|
  (((|Complex| (|Float|)) (|List| (|Complex| (|Float|)))) "Undocumented.")
  (((|Float|) (|List| (|Float|))) "Undocumented."))
 (|landen|
  (((|List| (|Complex| (|Float|))) (|Complex| (|Float|)) (|Float|))
   "Undocumented.")
  (((|List| (|Float|)) (|Float|) (|Float|)) "Undocumented."))
 (|landen2|
  (((|List| (|Complex| (|Float|))) (|Complex| (|Float|))
    (|List| (|Complex| (|Float|))) (|Float|))
   "Undocumented.")
  (((|List| (|Float|)) (|Float|) (|List| (|Float|)) (|Float|))
   "Undocumented."))
 (|landen1|
  (((|List| (|Complex| (|Float|))) (|Complex| (|Float|))
    (|List| (|Complex| (|Float|))))
   "Undocumented.")
  (((|List| (|Float|)) (|Float|) (|List| (|Float|))) "Undocumented."))
 (|rabs| (((|Float|) (|Complex| (|Float|))) "Undocumented.")
  (((|Float|) (|Float|)) "Undocumented."))
 (|ellipticPi|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|))
    (|Complex| (|Float|)))
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.")
  (((|Float|) (|Float|) (|Float|) (|Float|))
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind."))
 (|ellipticF|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind."))
 (|ellipticE|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.")
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind.")
  (((|Float|) (|Float|))
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind."))
 (|ellipticK|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{ellipticK(m)} is the complete elliptic integral of the first kind.")
  (((|Float|) (|Float|))
   "\\spad{ellipticK(m)} is the complete elliptic integral of the first kind."))
 (|modularInvariantJ|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{modularInvariantJ(tau)} computes modular invariant \\spad{j},{} that is \\spad{1728*g2^3/(g2^3 - 27*g3^2)} where \\spad{g2},{} \\spad{g3} are invariants corresponding to half periods \\spad{w1},{} \\spad{w2} such that \\spad{tau = w1/w2}."))
 (|weierstrassInvariants|
  (((|List| (|Complex| (|Float|))) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{weierstrassInvariants(w1,{} w2)} computes invariants \\spad{g2},{} \\spad{g3} of Weierstrass elliptic functions from half periods \\spad{w1},{} \\spad{w2}."))
 (|weierstrassHalfPeriods|
  (((|List| (|Complex| (|Float|))) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{weierstrassHalfPeriods(g2,{} g3)} computes half periods of Weierstrass elliptic functions from invariants \\spad{g2},{} \\spad{g3}."))
 (|weierstrassPPrime|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|))
    (|Complex| (|Float|)))
   "\\spad{weierstrassPPrime(g2,{} g3,{} x)} is the derivative of the Weierstrass \\spad{P} function")
  (((|Float|) (|Float|) (|Float|) (|Float|))
   "\\spad{weierstrassPPrime(g2,{} g3,{} x)} is the derivative of the Weierstrass \\spad{P} function"))
 (|weierstrassP|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|))
    (|Complex| (|Float|)))
   "\\spad{weierstrassP(g2,{} g3,{} x)} is the Weierstrass \\spad{P} function")
  (((|Float|) (|Float|) (|Float|) (|Float|))
   "\\spad{weierstrassP(g2,{} g3,{} x)} is the Weierstrass \\spad{P} function"))
 (|jacobiZeta|
  (((|Float|) (|Float|) (|Float|))
   "\\spad{jacobiZeta(z,{} m)} is the Jacobi zeta function"))
 (|jacobiDn|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{jacobiDn(z,{} m)} is the Jacobi \\spad{dn} function")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{jacobiDn(z,{} m)} is the Jacobi \\spad{dn} function"))
 (|jacobiCn|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{jacobiCn(z,{} m)} is the Jacobi \\spad{cn} function")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{jacobiCn(z,{} m)} is the Jacobi \\spad{cn} function"))
 (|jacobiSn|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{jacobiSn(z,{} m)} is the Jacobi \\spad{sn} function")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{jacobiSn(z,{} m)} is the Jacobi \\spad{sn} function"))) 
NIL 
(|FullyEvalableOver&| S R) 
((|constructor|
  (NIL
   "This category provides a selection of evaluation operations depending on what the argument type \\spad{R} provides."))
 (|map|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map(f,{} ex)} evaluates ex,{} applying \\spad{f} to values of type \\spad{R} in ex."))) 
((|HasCategory| |#2| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#2|)))
 (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
 (|HasCategory| |#2| (LIST '|Eltable| (|devaluate| |#2|) (|devaluate| |#2|)))) 
(|FullyEvalableOver| R) 
((|constructor|
  (NIL
   "This category provides a selection of evaluation operations depending on what the argument type \\spad{R} provides."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} ex)} evaluates ex,{} applying \\spad{f} to values of type \\spad{R} in ex."))) 
NIL 
(|FortranExpression| |basicSymbols| |subscriptedSymbols| R) 
((|constructor|
  (NIL
   "A domain of expressions involving functions which can be translated into standard Fortran-77,{} with some extra extensions from the NAG Fortran Library."))
 (|useNagFunctions|
  (((|Boolean|) (|Boolean|))
   "\\spad{useNagFunctions(v)} sets the flag which controls whether NAG functions \\indented{1}{are being used for mathematical and machine constants.\\space{2}The previous} \\indented{1}{value is returned.}")
  (((|Boolean|))
   "\\spad{useNagFunctions()} indicates whether NAG functions are being used \\indented{1}{for mathematical and machine constants.}"))
 (|variables|
  (((|List| (|Symbol|)) $)
   "\\spad{variables(e)} return a list of all the variables in \\spad{e}."))
 (|pi|
  (($)
   "\\spad{\\spad{pi}(x)} represents the NAG Library function X01AAF which returns \\indented{1}{an approximation to the value of \\spad{pi}}"))
 (|tanh|
  (($ $) "\\spad{tanh(x)} represents the Fortran intrinsic function TANH"))
 (|cosh|
  (($ $) "\\spad{cosh(x)} represents the Fortran intrinsic function COSH"))
 (|sinh|
  (($ $) "\\spad{sinh(x)} represents the Fortran intrinsic function SINH"))
 (|atan|
  (($ $) "\\spad{atan(x)} represents the Fortran intrinsic function ATAN"))
 (|acos|
  (($ $) "\\spad{acos(x)} represents the Fortran intrinsic function ACOS"))
 (|asin|
  (($ $) "\\spad{asin(x)} represents the Fortran intrinsic function ASIN"))
 (|tan| (($ $) "\\spad{tan(x)} represents the Fortran intrinsic function TAN"))
 (|cos| (($ $) "\\spad{cos(x)} represents the Fortran intrinsic function COS"))
 (|sin| (($ $) "\\spad{sin(x)} represents the Fortran intrinsic function SIN"))
 (|log10|
  (($ $)
   "\\spad{log10(x)} represents the Fortran intrinsic function \\spad{LOG10}"))
 (|log| (($ $) "\\spad{log(x)} represents the Fortran intrinsic function LOG"))
 (|exp| (($ $) "\\spad{exp(x)} represents the Fortran intrinsic function EXP"))
 (|sqrt|
  (($ $) "\\spad{sqrt(x)} represents the Fortran intrinsic function SQRT"))
 (|abs| (($ $) "\\spad{abs(x)} represents the Fortran intrinsic function ABS"))
 (|coerce| (((|Expression| |#3|) $) "\\spad{coerce(x)} \\undocumented{}"))
 (|retractIfCan|
  (((|Union| $ "failed") (|Polynomial| (|Float|)))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|))))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Expression| (|Float|)))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Polynomial| (|Integer|)))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|))))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Expression| (|Integer|)))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Symbol|))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression \\indented{1}{checking that it is one of the given basic symbols} \\indented{1}{or subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (((|Union| $ "failed") (|Expression| |#3|))
   "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}"))
 (|retract|
  (($ (|Polynomial| (|Float|)))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Fraction| (|Polynomial| (|Float|))))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Expression| (|Float|)))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Fraction| (|Polynomial| (|Integer|))))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Expression| (|Integer|)))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Symbol|))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression \\indented{1}{checking that it is one of the given basic symbols} \\indented{1}{or subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}")
  (($ (|Expression| |#3|))
   "\\spad{retract(e)} takes \\spad{e} and transforms it into a \\indented{1}{FortranExpression checking that it contains no non-Fortran} \\indented{1}{functions,{} and that it only contains the given basic symbols} \\indented{1}{and subscripted symbols which correspond to scalar and array} \\indented{1}{parameters respectively.}"))) 
((|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#3| (LIST '|RetractableTo| '(|Float|)))
 (|HasCategory| $ '(|Ring|))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))) 
(|FiniteField| |p| |n|) 
((|constructor|
  (NIL
   "FiniteField(\\spad{p},{} \\spad{n}) implements finite fields with \\spad{p^n} elements. This packages checks that \\spad{p} is prime. For a non-checking version,{} see \\spadtype{InnerFiniteField}."))) 
((|HasCategory| (|PrimeField| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|PrimeField| |#1|) '(|Finite|))
 (OR (|HasCategory| (|PrimeField| |#1|) '(|CharacteristicNonZero|))
     (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))
 (|HasCategory| (|PrimeField| |#1|) '(|Field|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))) 
(|FunctionFieldCategory&| S F UP UPUP) 
((|constructor|
  (NIL
   "This category is a model for the function field of a plane algebraic curve."))
 (|rationalPoints|
  (((|List| (|List| |#2|)))
   "\\spad{rationalPoints()} returns the list of all the affine rational points."))
 (|nonSingularModel|
  (((|List| (|Polynomial| |#2|)) (|Symbol|))
   "\\spad{nonSingularModel(u)} returns the equations in \\spad{u1},{} ...,{} un of an affine non-singular model for the curve."))
 (|algSplitSimple|
  (((|Record| (|:| |num| $) (|:| |den| |#3|) (|:| |derivden| |#3|)
              (|:| |gd| |#3|))
    $ (|Mapping| |#3| |#3|))
   "\\spad{algSplitSimple(f,{} D)} returns \\spad{[h,{} d,{} d',{} g]} such that \\spad{f=h/d},{} \\spad{h} is integral at all the normal places \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} \\spad{d' = Dd},{} \\spad{g = gcd(d,{} discriminant())} and \\spad{D} is the derivation to use. \\spad{f} must have at most simple finite poles."))
 (|hyperelliptic|
  (((|Union| |#3| "failed"))
   "\\spad{hyperelliptic()} returns \\spad{p(x)} if the curve is the hyperelliptic defined by \\spad{y^2 = p(x)},{} \"failed\" otherwise."))
 (|elliptic|
  (((|Union| |#3| "failed"))
   "\\spad{elliptic()} returns \\spad{p(x)} if the curve is the elliptic defined by \\spad{y^2 = p(x)},{} \"failed\" otherwise."))
 (|elt|
  ((|#2| $ |#2| |#2|)
   "\\spad{elt(f,{} a,{} b)} or \\spad{f}(a,{} \\spad{b}) returns the value of \\spad{f} at the point \\spad{(x = a,{} y = b)} if it is not singular."))
 (|primitivePart|
  (($ $)
   "\\spad{primitivePart(f)} removes the content of the denominator and the common content of the numerator of \\spad{f}."))
 (|represents|
  (($ (|Vector| |#3|) |#3|)
   "\\spad{represents([A0,{} ...,{} A(n-1)],{} D)} returns \\spad{(A0 + A1 y +...+ A(n-1)*y^(n-1))/D}."))
 (|differentiate|
  (($ $ (|Mapping| |#3| |#3|))
   "\\spad{differentiate(x,{} d)} extends the derivation \\spad{d} from UP to \\$ and applies it to \\spad{x}."))
 (|integralDerivationMatrix|
  (((|Record| (|:| |num| (|Matrix| |#3|)) (|:| |den| |#3|))
    (|Mapping| |#3| |#3|))
   "\\spad{integralDerivationMatrix(d)} extends the derivation \\spad{d} from UP to \\$ and returns (\\spad{M},{} \\spad{Q}) such that the i^th row of \\spad{M} divided by \\spad{Q} form the coordinates of \\spad{d(\\spad{wi})} with respect to \\spad{(w1,{} ...,{} wn)} where \\spad{(w1,{} ...,{} wn)} is the integral basis returned by integralBasis()."))
 (|integralRepresents|
  (($ (|Vector| |#3|) |#3|)
   "\\spad{integralRepresents([A1,{} ...,{} An],{} D)} returns \\spad{(A1 w1+...+An wn)/D} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spad{integralBasis()}."))
 (|integralCoordinates|
  (((|Record| (|:| |num| (|Vector| |#3|)) (|:| |den| |#3|)) $)
   "\\spad{integralCoordinates(f)} returns \\spad{[[A1,{} ...,{} An],{} D]} such that \\spad{f = (A1 w1 +...+ An wn) / D} where \\spad{(w1,{} ...,{} wn)} is the integral basis returned by \\spad{integralBasis()}."))
 (|yCoordinates|
  (((|Record| (|:| |num| (|Vector| |#3|)) (|:| |den| |#3|)) $)
   "\\spad{yCoordinates(f)} returns \\spad{[[A1,{} ...,{} An],{} D]} such that \\spad{f = (A1 + A2 y +...+ An y^(n-1)) / D}."))
 (|inverseIntegralMatrixAtInfinity|
  (((|Matrix| (|Fraction| |#3|)))
   "\\spad{inverseIntegralMatrixAtInfinity()} returns \\spad{M} such that \\spad{M (v1,{} ...,{} vn) = (1,{} y,{} ...,{} y^(n-1))} where \\spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \\spad{infIntBasis()}."))
 (|integralMatrixAtInfinity|
  (((|Matrix| (|Fraction| |#3|)))
   "\\spad{integralMatrixAtInfinity()} returns \\spad{M} such that \\spad{(v1,{} ...,{} vn) = M (1,{} y,{} ...,{} y^(n-1))} where \\spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \\spad{infIntBasis()}."))
 (|inverseIntegralMatrix|
  (((|Matrix| (|Fraction| |#3|)))
   "\\spad{inverseIntegralMatrix()} returns \\spad{M} such that \\spad{M (w1,{} ...,{} wn) = (1,{} y,{} ...,{} y^(n-1))} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spadfunFrom{integralBasis}{FunctionFieldCategory}."))
 (|integralMatrix|
  (((|Matrix| (|Fraction| |#3|)))
   "\\spad{integralMatrix()} returns \\spad{M} such that \\spad{(w1,{} ...,{} wn) = M (1,{} y,{} ...,{} y^(n-1))},{} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spadfunFrom{integralBasis}{FunctionFieldCategory}."))
 (|reduceBasisAtInfinity|
  (((|Vector| $) (|Vector| $))
   "\\spad{reduceBasisAtInfinity(b1,{} ...,{} bn)} returns \\spad{(x^i * bj)} for all \\spad{i},{} \\spad{j} such that \\spad{x^i*bj} is locally integral at infinity."))
 (|normalizeAtInfinity|
  (((|Vector| $) (|Vector| $))
   "\\spad{normalizeAtInfinity(v)} makes \\spad{v} normal at infinity."))
 (|complementaryBasis|
  (((|Vector| $) (|Vector| $))
   "\\spad{complementaryBasis(b1,{} ...,{} bn)} returns the complementary basis \\spad{(b1',{} ...,{} bn')} of \\spad{(b1,{} ...,{} bn)}."))
 (|integral?|
  (((|Boolean|) $ |#3|)
   "\\spad{integral?(f,{} p)} tests whether \\spad{f} is locally integral at \\spad{p(x) = 0}.")
  (((|Boolean|) $ |#2|)
   "\\spad{integral?(f,{} a)} tests whether \\spad{f} is locally integral at \\spad{x = a}.")
  (((|Boolean|) $)
   "\\spad{integral?(f)} tests if \\spad{f} is integral over \\spad{k[x]}."))
 (|special_order|
  (((|Integer|) $ (|List| |#3|))
   "\\spad{special_order(f,{} lp)} computes sum of orders at special places,{} that is at infinite places and at places over zeros in polynomials in \\spad{lp}. Elements of \\spad{lp} must be relatively prime."))
 (|integralAtInfinity?|
  (((|Boolean|) $)
   "\\spad{integralAtInfinity?(f)} tests if \\spad{f} is locally integral at infinity."))
 (|integralBasisAtInfinity|
  (((|Vector| $))
   "\\spad{integralBasisAtInfinity()} returns the local integral basis at infinity."))
 (|integralBasis|
  (((|Vector| $))
   "\\spad{integralBasis()} returns the integral basis for the curve."))
 (|ramified?|
  (((|Boolean|) |#3|)
   "\\spad{ramified?(p)} tests whether \\spad{p(x) = 0} is ramified.")
  (((|Boolean|) |#2|)
   "\\spad{ramified?(a)} tests whether \\spad{x = a} is ramified."))
 (|ramifiedAtInfinity?|
  (((|Boolean|))
   "\\spad{ramifiedAtInfinity?()} tests if infinity is ramified."))
 (|singular?|
  (((|Boolean|) |#3|)
   "\\spad{singular?(p)} tests whether \\spad{p(x) = 0} is singular.")
  (((|Boolean|) |#2|)
   "\\spad{singular?(a)} tests whether \\spad{x = a} is singular."))
 (|singularAtInfinity?|
  (((|Boolean|))
   "\\spad{singularAtInfinity?()} tests if there is a singularity at infinity."))
 (|branchPoint?|
  (((|Boolean|) |#3|)
   "\\spad{branchPoint?(p)} tests whether \\spad{p(x) = 0} is a branch point.")
  (((|Boolean|) |#2|)
   "\\spad{branchPoint?(a)} tests whether \\spad{x = a} is a branch point."))
 (|branchPointAtInfinity?|
  (((|Boolean|))
   "\\spad{branchPointAtInfinity?()} tests if there is a branch point at infinity."))
 (|rationalPoint?|
  (((|Boolean|) |#2| |#2|)
   "\\spad{rationalPoint?(a,{} b)} tests if \\spad{(x=a,{} y=b)} is on the curve."))
 (|absolutelyIrreducible?|
  (((|Boolean|))
   "\\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?"))
 (|genus|
  (((|NonNegativeInteger|))
   "\\spad{genus()} returns the genus of one absolutely irreducible component"))
 (|numberOfComponents|
  (((|NonNegativeInteger|))
   "\\spad{numberOfComponents()} returns the number of absolutely irreducible components."))) 
((|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Field|))) 
(|FunctionFieldCategory| F UP UPUP) 
((|constructor|
  (NIL
   "This category is a model for the function field of a plane algebraic curve."))
 (|rationalPoints|
  (((|List| (|List| |#1|)))
   "\\spad{rationalPoints()} returns the list of all the affine rational points."))
 (|nonSingularModel|
  (((|List| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{nonSingularModel(u)} returns the equations in \\spad{u1},{} ...,{} un of an affine non-singular model for the curve."))
 (|algSplitSimple|
  (((|Record| (|:| |num| $) (|:| |den| |#2|) (|:| |derivden| |#2|)
              (|:| |gd| |#2|))
    $ (|Mapping| |#2| |#2|))
   "\\spad{algSplitSimple(f,{} D)} returns \\spad{[h,{} d,{} d',{} g]} such that \\spad{f=h/d},{} \\spad{h} is integral at all the normal places \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} \\spad{d' = Dd},{} \\spad{g = gcd(d,{} discriminant())} and \\spad{D} is the derivation to use. \\spad{f} must have at most simple finite poles."))
 (|hyperelliptic|
  (((|Union| |#2| "failed"))
   "\\spad{hyperelliptic()} returns \\spad{p(x)} if the curve is the hyperelliptic defined by \\spad{y^2 = p(x)},{} \"failed\" otherwise."))
 (|elliptic|
  (((|Union| |#2| "failed"))
   "\\spad{elliptic()} returns \\spad{p(x)} if the curve is the elliptic defined by \\spad{y^2 = p(x)},{} \"failed\" otherwise."))
 (|elt|
  ((|#1| $ |#1| |#1|)
   "\\spad{elt(f,{} a,{} b)} or \\spad{f}(a,{} \\spad{b}) returns the value of \\spad{f} at the point \\spad{(x = a,{} y = b)} if it is not singular."))
 (|primitivePart|
  (($ $)
   "\\spad{primitivePart(f)} removes the content of the denominator and the common content of the numerator of \\spad{f}."))
 (|represents|
  (($ (|Vector| |#2|) |#2|)
   "\\spad{represents([A0,{} ...,{} A(n-1)],{} D)} returns \\spad{(A0 + A1 y +...+ A(n-1)*y^(n-1))/D}."))
 (|differentiate|
  (($ $ (|Mapping| |#2| |#2|))
   "\\spad{differentiate(x,{} d)} extends the derivation \\spad{d} from UP to \\$ and applies it to \\spad{x}."))
 (|integralDerivationMatrix|
  (((|Record| (|:| |num| (|Matrix| |#2|)) (|:| |den| |#2|))
    (|Mapping| |#2| |#2|))
   "\\spad{integralDerivationMatrix(d)} extends the derivation \\spad{d} from UP to \\$ and returns (\\spad{M},{} \\spad{Q}) such that the i^th row of \\spad{M} divided by \\spad{Q} form the coordinates of \\spad{d(\\spad{wi})} with respect to \\spad{(w1,{} ...,{} wn)} where \\spad{(w1,{} ...,{} wn)} is the integral basis returned by integralBasis()."))
 (|integralRepresents|
  (($ (|Vector| |#2|) |#2|)
   "\\spad{integralRepresents([A1,{} ...,{} An],{} D)} returns \\spad{(A1 w1+...+An wn)/D} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spad{integralBasis()}."))
 (|integralCoordinates|
  (((|Record| (|:| |num| (|Vector| |#2|)) (|:| |den| |#2|)) $)
   "\\spad{integralCoordinates(f)} returns \\spad{[[A1,{} ...,{} An],{} D]} such that \\spad{f = (A1 w1 +...+ An wn) / D} where \\spad{(w1,{} ...,{} wn)} is the integral basis returned by \\spad{integralBasis()}."))
 (|yCoordinates|
  (((|Record| (|:| |num| (|Vector| |#2|)) (|:| |den| |#2|)) $)
   "\\spad{yCoordinates(f)} returns \\spad{[[A1,{} ...,{} An],{} D]} such that \\spad{f = (A1 + A2 y +...+ An y^(n-1)) / D}."))
 (|inverseIntegralMatrixAtInfinity|
  (((|Matrix| (|Fraction| |#2|)))
   "\\spad{inverseIntegralMatrixAtInfinity()} returns \\spad{M} such that \\spad{M (v1,{} ...,{} vn) = (1,{} y,{} ...,{} y^(n-1))} where \\spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \\spad{infIntBasis()}."))
 (|integralMatrixAtInfinity|
  (((|Matrix| (|Fraction| |#2|)))
   "\\spad{integralMatrixAtInfinity()} returns \\spad{M} such that \\spad{(v1,{} ...,{} vn) = M (1,{} y,{} ...,{} y^(n-1))} where \\spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \\spad{infIntBasis()}."))
 (|inverseIntegralMatrix|
  (((|Matrix| (|Fraction| |#2|)))
   "\\spad{inverseIntegralMatrix()} returns \\spad{M} such that \\spad{M (w1,{} ...,{} wn) = (1,{} y,{} ...,{} y^(n-1))} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spadfunFrom{integralBasis}{FunctionFieldCategory}."))
 (|integralMatrix|
  (((|Matrix| (|Fraction| |#2|)))
   "\\spad{integralMatrix()} returns \\spad{M} such that \\spad{(w1,{} ...,{} wn) = M (1,{} y,{} ...,{} y^(n-1))},{} where \\spad{(w1,{} ...,{} wn)} is the integral basis of \\spadfunFrom{integralBasis}{FunctionFieldCategory}."))
 (|reduceBasisAtInfinity|
  (((|Vector| $) (|Vector| $))
   "\\spad{reduceBasisAtInfinity(b1,{} ...,{} bn)} returns \\spad{(x^i * bj)} for all \\spad{i},{} \\spad{j} such that \\spad{x^i*bj} is locally integral at infinity."))
 (|normalizeAtInfinity|
  (((|Vector| $) (|Vector| $))
   "\\spad{normalizeAtInfinity(v)} makes \\spad{v} normal at infinity."))
 (|complementaryBasis|
  (((|Vector| $) (|Vector| $))
   "\\spad{complementaryBasis(b1,{} ...,{} bn)} returns the complementary basis \\spad{(b1',{} ...,{} bn')} of \\spad{(b1,{} ...,{} bn)}."))
 (|integral?|
  (((|Boolean|) $ |#2|)
   "\\spad{integral?(f,{} p)} tests whether \\spad{f} is locally integral at \\spad{p(x) = 0}.")
  (((|Boolean|) $ |#1|)
   "\\spad{integral?(f,{} a)} tests whether \\spad{f} is locally integral at \\spad{x = a}.")
  (((|Boolean|) $)
   "\\spad{integral?(f)} tests if \\spad{f} is integral over \\spad{k[x]}."))
 (|special_order|
  (((|Integer|) $ (|List| |#2|))
   "\\spad{special_order(f,{} lp)} computes sum of orders at special places,{} that is at infinite places and at places over zeros in polynomials in \\spad{lp}. Elements of \\spad{lp} must be relatively prime."))
 (|integralAtInfinity?|
  (((|Boolean|) $)
   "\\spad{integralAtInfinity?(f)} tests if \\spad{f} is locally integral at infinity."))
 (|integralBasisAtInfinity|
  (((|Vector| $))
   "\\spad{integralBasisAtInfinity()} returns the local integral basis at infinity."))
 (|integralBasis|
  (((|Vector| $))
   "\\spad{integralBasis()} returns the integral basis for the curve."))
 (|ramified?|
  (((|Boolean|) |#2|)
   "\\spad{ramified?(p)} tests whether \\spad{p(x) = 0} is ramified.")
  (((|Boolean|) |#1|)
   "\\spad{ramified?(a)} tests whether \\spad{x = a} is ramified."))
 (|ramifiedAtInfinity?|
  (((|Boolean|))
   "\\spad{ramifiedAtInfinity?()} tests if infinity is ramified."))
 (|singular?|
  (((|Boolean|) |#2|)
   "\\spad{singular?(p)} tests whether \\spad{p(x) = 0} is singular.")
  (((|Boolean|) |#1|)
   "\\spad{singular?(a)} tests whether \\spad{x = a} is singular."))
 (|singularAtInfinity?|
  (((|Boolean|))
   "\\spad{singularAtInfinity?()} tests if there is a singularity at infinity."))
 (|branchPoint?|
  (((|Boolean|) |#2|)
   "\\spad{branchPoint?(p)} tests whether \\spad{p(x) = 0} is a branch point.")
  (((|Boolean|) |#1|)
   "\\spad{branchPoint?(a)} tests whether \\spad{x = a} is a branch point."))
 (|branchPointAtInfinity?|
  (((|Boolean|))
   "\\spad{branchPointAtInfinity?()} tests if there is a branch point at infinity."))
 (|rationalPoint?|
  (((|Boolean|) |#1| |#1|)
   "\\spad{rationalPoint?(a,{} b)} tests if \\spad{(x=a,{} y=b)} is on the curve."))
 (|absolutelyIrreducible?|
  (((|Boolean|))
   "\\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?"))
 (|genus|
  (((|NonNegativeInteger|))
   "\\spad{genus()} returns the genus of one absolutely irreducible component"))
 (|numberOfComponents|
  (((|NonNegativeInteger|))
   "\\spad{numberOfComponents()} returns the number of absolutely irreducible components."))) 
NIL 
(|FunctionFieldCategoryFunctions2| R1 UP1 UPUP1 F1 R2 UP2 UPUP2 F2) 
((|constructor| (NIL "Lifts a map from rings to function fields over them."))
 (|map|
  ((|#8| (|Mapping| |#5| |#1|) |#4|)
   "\\spad{map(f,{} p)} lifts \\spad{f} to \\spad{F1} and applies it to \\spad{p}."))) 
NIL 
(|FiniteFieldCyclicGroup| |p| |extdeg|) 
((|constructor|
  (NIL
   "FiniteFieldCyclicGroup(\\spad{p},{} \\spad{n}) implements a finite field extension of degee \\spad{n} over the prime field with \\spad{p} elements. Its elements are represented by powers of a primitive element,{} \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by {\\em createPrimitivePoly} from \\spadtype{FiniteFieldPolynomialPackage}. The Zech logarithms are stored in a table of size half of the field size,{} and use \\spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field."))
 (|getZechTable|
  (((|PrimitiveArray| (|SingleInteger|)))
   "\\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly."))) 
((|HasCategory| (|PrimeField| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|PrimeField| |#1|) '(|Finite|))
 (OR (|HasCategory| (|PrimeField| |#1|) '(|CharacteristicNonZero|))
     (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))
 (|HasCategory| (|PrimeField| |#1|) '(|Field|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))) 
(|FiniteFieldCyclicGroupExtensionByPolynomial| GF |defpol|) 
((|constructor|
  (NIL
   "FiniteFieldCyclicGroupExtensionByPolynomial(\\spad{GF},{} defpol) implements a finite extension field of the ground field {\\em GF}. Its elements are represented by powers of a primitive element,{} \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial {\\em defpol},{} which MUST be primitive (user responsibility). Zech logarithms are stored in a table of size half of the field size,{} and use \\spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field."))
 (|getZechTable|
  (((|PrimitiveArray| (|SingleInteger|)))
   "\\spad{getZechTable()} returns the zech logarithm table of the field it is used to perform additions in the field quickly."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FiniteFieldCyclicGroupExtension| GF |extdeg|) 
((|constructor|
  (NIL
   "FiniteFieldCyclicGroupExtension(\\spad{GF},{} \\spad{n}) implements a extension of degree \\spad{n} over the ground field {\\em GF}. Its elements are represented by powers of a primitive element,{} \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by {\\em createPrimitivePoly} from \\spadtype{FiniteFieldPolynomialPackage}. Zech logarithms are stored in a table of size half of the field size,{} and use \\spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field."))
 (|getZechTable|
  (((|PrimitiveArray| (|SingleInteger|)))
   "\\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FiniteFieldFunctions| GF) 
((|constructor|
  (NIL
   "FiniteFieldFunctions(\\spad{GF}) is a package with functions concerning finite extension fields of the finite ground field {\\em GF},{} \\spadignore{e.g.} Zech logarithms."))
 (|createLowComplexityNormalBasis|
  (((|Union| (|SparseUnivariatePolynomial| |#1|)
             (|Vector|
              (|List|
               (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))))
    (|PositiveInteger|))
   "\\spad{createLowComplexityNormalBasis(n)} tries to find a a low complexity normal basis of degree {\\em n} over {\\em GF} and returns its multiplication matrix If no low complexity basis is found it calls \\spadfunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}(\\spad{n}) to produce a normal polynomial of degree {\\em n} over {\\em GF}"))
 (|createLowComplexityTable|
  (((|Union|
     (|Vector|
      (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))
     "failed")
    (|PositiveInteger|))
   "\\spad{createLowComplexityTable(n)} tries to find a low complexity normal basis of degree {\\em n} over {\\em GF} and returns its multiplication matrix Fails,{} if it does not find a low complexity basis"))
 (|sizeMultiplication|
  (((|NonNegativeInteger|)
    (|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))))
   "\\spad{sizeMultiplication(m)} returns the number of entries of the multiplication table {\\em m}."))
 (|createMultiplicationMatrix|
  (((|Matrix| |#1|)
    (|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))))
   "\\spad{createMultiplicationMatrix(m)} forms the multiplication table {\\em m} into a matrix over the ground field."))
 (|createMultiplicationTable|
  (((|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{createMultiplicationTable(f)} generates a multiplication table for the normal basis of the field extension determined by {\\em f}. This is needed to perform multiplications between elements represented as coordinate vectors to this basis. See \\spadtype{FFNBP},{} \\spadtype{FFNBX}."))
 (|createZechTable|
  (((|PrimitiveArray| (|SingleInteger|)) (|SparseUnivariatePolynomial| |#1|))
   "\\spad{createZechTable(f)} generates a Zech logarithm table for the cyclic group representation of a extension of the ground field by the primitive polynomial {\\em f(x)},{} \\spadignore{i.e.} \\spad{Z(i)},{} defined by {\\em x^Z(i) = 1+x^i} is stored at index \\spad{i}. This is needed in particular to perform addition of field elements in finite fields represented in this way. See \\spadtype{FFCGP},{} \\spadtype{FFCGX}."))) 
NIL 
(|FractionFreeFastGaussian| D V) 
((|constructor|
  (NIL
   "This package implements the interpolation algorithm proposed in Beckermann,{} Bernhard and Labahn,{} George,{} Fraction-free computation of matrix rational interpolants and matrix GCDs,{} SIAM Journal on Matrix Analysis and Applications 22."))
 (|genVectorStream2|
  (((|Stream| (|List| (|NonNegativeInteger|))) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "like genVectorStream,{} but skips every second vector."))
 (|genVectorStream|
  (((|Stream| (|List| (|NonNegativeInteger|))) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{genVectorStream(sumEta,{} maxEta,{} k)} generates stream of all possible non-increasing lists \\spad{eta} with maximal entry \\spad{maxEta} and sum of entries at most \\spad{sumEta}."))
 (|qShiftC|
  (((|List| |#1|) |#1| (|NonNegativeInteger|))
   "\\spad{qShiftC} gives the coefficients \\spad{c_}{\\spad{k},{} \\spad{k}} in the expansion <x^k> \\spad{z} \\spad{g}(\\spad{x}) = sum_{\\spad{i=0}}\\spad{^k} \\spad{c_}{\\spad{k},{} \\spad{i}} <x^i> \\spad{g}(\\spad{x}),{} where \\spad{z} acts on \\spad{g}(\\spad{x}) by shifting. In fact,{} the result is [1,{} \\spad{q},{} \\spad{q^2},{} ...]"))
 (|qShiftAction|
  ((|#1| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{qShiftAction(q,{} k,{} l,{} g)} gives the coefficient of \\spad{x^k} in \\spad{z^l} \\spad{g}(\\spad{x}),{} where \\spad{z*}(a+b*x+c*x^2+d*x^3+...) = (a+q*b*x+q^2*c*x^2+q^3*d*x^3+...). In terms of sequences,{} z*u(\\spad{n})=q^n*u(\\spad{n})."))
 (|DiffC|
  (((|List| |#1|) (|NonNegativeInteger|))
   "\\spad{DiffC} gives the coefficients \\spad{c_}{\\spad{k},{} \\spad{k}} in the expansion <x^k> \\spad{z} \\spad{g}(\\spad{x}) = sum_{\\spad{i=0}}\\spad{^k} \\spad{c_}{\\spad{k},{} \\spad{i}} <x^i> \\spad{g}(\\spad{x}),{} where \\spad{z} acts on \\spad{g}(\\spad{x}) by shifting. In fact,{} the result is [0,{} 0,{} 0,{} ...]"))
 (|DiffAction|
  ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{DiffAction(k,{} l,{} g)} gives the coefficient of \\spad{x^k} in \\spad{z^l} \\spad{g}(\\spad{x}),{} where \\spad{z*}(a+b*x+c*x^2+d*x^3+...) = (a*x+b*x^2+c*x^3+...),{} \\spadignore{i.e.} multiplication with \\spad{x}."))
 (|ShiftC|
  (((|List| |#1|) (|NonNegativeInteger|))
   "\\spad{ShiftC} gives the coefficients \\spad{c_}{\\spad{k},{} \\spad{k}} in the expansion <x^k> \\spad{z} \\spad{g}(\\spad{x}) = sum_{\\spad{i=0}}\\spad{^k} \\spad{c_}{\\spad{k},{} \\spad{i}} <x^i> \\spad{g}(\\spad{x}),{} where \\spad{z} acts on \\spad{g}(\\spad{x}) by shifting. In fact,{} the result is [0,{} 1,{} 2,{} ...]"))
 (|ShiftAction|
  ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{ShiftAction(k,{} l,{} g)} gives the coefficient of \\spad{x^k} in \\spad{z^l} \\spad{g}(\\spad{x}),{} where \\spad{z*(a+b*x+c*x^2+d*x^3+...) = (b*x+2*c*x^2+3*d*x^3+...)}. In terms of sequences,{} z*u(\\spad{n})=n*u(\\spad{n})."))
 (|generalCoefficient|
  ((|#1| (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
    (|Vector| |#2|) (|NonNegativeInteger|)
    (|Vector| (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{generalCoefficient(action,{} f,{} k,{} p)} gives the coefficient of \\spad{x^k} in \\spad{p}(\\spad{z})\\dot \\spad{f}(\\spad{x}),{} where the \\spad{action} of \\spad{z^l} on a polynomial in \\spad{x} is given by \\spad{action},{} \\spadignore{i.e.} \\spad{action}(\\spad{k},{} \\spad{l},{} \\spad{f}) should return the coefficient of \\spad{x^k} in \\spad{z^l} \\spad{f}(\\spad{x})."))
 (|generalInterpolation|
  (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
    (|Vector| |#2|) (|Vector| (|Integer|)) (|NonNegativeInteger|))
   "\\spad{generalInterpolation(C,{} CA,{} f,{} vd,{} K)} is like \\spad{generalInterpolation(C,{} CA,{} f,{} eta)} but solves up to order \\spad{K} and modifies \\spad{vd} to return defects of solutions")
  (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
    (|Vector| |#2|) (|List| (|NonNegativeInteger|)))
   "\\spad{generalInterpolation(C,{} CA,{} f,{} eta)} performs Hermite-Pade approximation using the given action \\spad{CA} of polynomials on the elements of \\spad{f}. The result is guaranteed to be correct up to order |eta|-1. Given that eta is a \"normal\" point,{} the degrees on the diagonal are given by eta. The degrees of column \\spad{i} are in this case eta + \\spad{e}.\\spad{i} - [1,{} 1,{} ...,{} 1],{} where the degree of zero is \\spad{-1}. \\blankline The first argument \\spad{C} is the list of coefficients \\spad{c_}{\\spad{k},{} \\spad{k}} in the expansion <x^k> \\spad{z} \\spad{g}(\\spad{x}) = sum_{\\spad{i=0}}\\spad{^k} \\spad{c_}{\\spad{k},{} \\spad{i}} <x^i> \\spad{g}(\\spad{x}). \\blankline The second argument,{} \\spad{CA}(\\spad{k},{} \\spad{l},{} \\spad{f}),{} should return the coefficient of \\spad{x^k} in \\spad{z^l} \\spad{f}(\\spad{x})."))
 (|interpolate|
  (((|Fraction| (|SparseUnivariatePolynomial| |#1|)) (|List| (|Fraction| |#1|))
    (|List| (|Fraction| |#1|)) (|NonNegativeInteger|))
   "\\spad{interpolate(xlist,{} ylist,{} deg)} returns the rational function with numerator degree \\spad{deg} that interpolates the given points using fraction free arithmetic.")
  (((|Fraction| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|List| |#1|) (|NonNegativeInteger|))
   "\\spad{interpolate(xlist,{} ylist,{} deg)} returns the rational function with numerator degree at most \\spad{deg} and denominator degree at most \\spad{\\#xlist-deg-1} that interpolates the given points using fraction free arithmetic. Note that rational interpolation does not guarantee that all given points are interpolated correctly: unattainable points may make this impossible."))
 (|fffg|
  (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|)
               (|Vector| (|SparseUnivariatePolynomial| |#1|)))
    (|List| (|NonNegativeInteger|)))
   "\\spad{fffg(C,{} c,{} eta)} is version of fffg which uses sum of eta as order")
  (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|)
               (|Vector| (|SparseUnivariatePolynomial| |#1|)))
    (|Vector| (|Integer|)) (|NonNegativeInteger|))
   "\\spad{fffg(C,{} c,{} vd,{} K)} is the general algorithm as proposed by Beckermann and Labahn. \\blankline The first argument is the list of \\spad{c_}{\\spad{i},{} \\spad{i}}. These are the only values of \\spad{C} explicitly needed in \\spad{fffg}. \\blankline The second argument \\spad{c},{} computes \\spad{c_k}(\\spad{M}),{} \\spadignore{i.e.} \\spad{c_k}(.) is the dual basis of the vector space \\spad{V},{} but also knows about the special multiplication rule as described in Equation (2). Note that the information about \\spad{f} is therefore encoded in \\spad{c}. \\blankline \\spad{vd} is modified by the routine,{} on input it is the vector of degree bounds \\spad{n},{} as introduced in Definition 2.1. On output it is vector of defects (degree bound minus degree of solution). \\blankline \\spad{K} is requested order of solution."))) 
NIL 
(|FractionFreeFastGaussianFractions| D V VF) 
((|constructor|
  (NIL
   "This package lifts the interpolation functions from \\spadtype{FractionFreeFastGaussian} to fractions."))
 (|generalInterpolation|
  (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
    (|Vector| |#3|) (|List| (|NonNegativeInteger|)))
   "\\spad{generalInterpolation(l,{} CA,{} f,{} eta)} performs Hermite-Pade approximation using the given action \\spad{CA} of polynomials on the elements of \\spad{f}. The result is guaranteed to be correct up to order |eta|-1. Given that eta is a \"normal\" point,{} the degrees on the diagonal are given by eta. The degrees of column \\spad{i} are in this case eta + \\spad{e}.\\spad{i} - [1,{} 1,{} ...,{} 1],{} where the degree of zero is \\spad{-1}."))) 
NIL 
(|FiniteFieldHomomorphisms| F1 GF F2) 
((|constructor|
  (NIL
   "FiniteFieldHomomorphisms(\\spad{F1},{} \\spad{GF},{} \\spad{F2}) exports coercion functions of elements between the fields {\\em F1} and {\\em F2},{} which both must be finite simple algebraic extensions of the finite ground field {\\em GF}."))
 (|coerce|
  ((|#1| |#3|)
   "\\spad{coerce(x)} is the homomorphic image of \\spad{x} from {\\em F2} in {\\em F1},{} where {\\em coerce} is a field homomorphism between the fields extensions {\\em F2} and {\\em F1} both over ground field {\\em GF} (the second argument to the package). Error: if the extension degree of {\\em F2} doesn\\spad{'t} divide the extension degree of {\\em F1}. Note that the other coercion function in the \\spadtype{FiniteFieldHomomorphisms} is a left inverse.")
  ((|#3| |#1|)
   "\\spad{coerce(x)} is the homomorphic image of \\spad{x} from {\\em F1} in {\\em F2}. Thus {\\em coerce} is a field homomorphism between the fields extensions {\\em F1} and {\\em F2} both over ground field {\\em GF} (the second argument to the package). Error: if the extension degree of {\\em F1} doesn\\spad{'t} divide the extension degree of {\\em F2}. Note that the other coercion function in the \\spadtype{FiniteFieldHomomorphisms} is a left inverse."))) 
NIL 
(|FiniteFieldCategory&| S) 
((|constructor| (NIL "FiniteFieldCategory is the category of finite fields"))
 (|representationType|
  (((|Union| "prime" "polynomial" "normal" "cyclic"))
   "\\spad{representationType()} returns the type of the representation,{} one of: \\spad{prime},{} \\spad{polynomial},{} \\spad{normal},{} or \\spad{cyclic}."))
 (|order|
  (((|PositiveInteger|) $)
   "\\spad{order(b)} computes the order of an element \\spad{b} in the multiplicative group of the field. Error: if \\spad{b} equals 0."))
 (|discreteLog|
  (((|NonNegativeInteger|) $)
   "\\spad{discreteLog(a)} computes the discrete logarithm of \\spad{a} with respect to \\spad{primitiveElement()} of the field."))
 (|primitive?|
  (((|Boolean|) $)
   "\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field,{} \\spadignore{i.e.} is a primitive element. Implementation Note: see \\spad{ch}.IX.1.3,{} th.2 in \\spad{D}. Lipson."))
 (|primitiveElement|
  (($)
   "\\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call,{} the primitive element is computed by calling \\spadfun{createPrimitiveElement}."))
 (|createPrimitiveElement|
  (($)
   "\\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field."))
 (|tableForDiscreteLogarithm|
  (((|Table| (|PositiveInteger|) (|NonNegativeInteger|)) (|Integer|))
   "\\spad{tableForDiscreteLogarithm(a,{} n)} returns a table of the discrete logarithms of \\spad{a^0} up to \\spad{a^(n-1)} which,{} called with key \\spad{lookup(a^i)} returns \\spad{i} for \\spad{i} in \\spad{0..n-1}. Error: if not called for prime divisors of order of \\indented{7}{multiplicative group.}"))
 (|factorsOfCyclicGroupSize|
  (((|List|
     (|Record| (|:| |factor| (|Integer|))
               (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{factorsOfCyclicGroupSize()} returns the factorization of size()\\spad{-1}"))
 (|charthRoot|
  (($ $)
   "\\spad{charthRoot(a)} takes the characteristic'th root of {\\em a}. Note: such a root is alway defined in finite fields."))) 
NIL 
(|FiniteFieldCategory|) 
((|constructor| (NIL "FiniteFieldCategory is the category of finite fields"))
 (|representationType|
  (((|Union| "prime" "polynomial" "normal" "cyclic"))
   "\\spad{representationType()} returns the type of the representation,{} one of: \\spad{prime},{} \\spad{polynomial},{} \\spad{normal},{} or \\spad{cyclic}."))
 (|order|
  (((|PositiveInteger|) $)
   "\\spad{order(b)} computes the order of an element \\spad{b} in the multiplicative group of the field. Error: if \\spad{b} equals 0."))
 (|discreteLog|
  (((|NonNegativeInteger|) $)
   "\\spad{discreteLog(a)} computes the discrete logarithm of \\spad{a} with respect to \\spad{primitiveElement()} of the field."))
 (|primitive?|
  (((|Boolean|) $)
   "\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field,{} \\spadignore{i.e.} is a primitive element. Implementation Note: see \\spad{ch}.IX.1.3,{} th.2 in \\spad{D}. Lipson."))
 (|primitiveElement|
  (($)
   "\\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call,{} the primitive element is computed by calling \\spadfun{createPrimitiveElement}."))
 (|createPrimitiveElement|
  (($)
   "\\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field."))
 (|tableForDiscreteLogarithm|
  (((|Table| (|PositiveInteger|) (|NonNegativeInteger|)) (|Integer|))
   "\\spad{tableForDiscreteLogarithm(a,{} n)} returns a table of the discrete logarithms of \\spad{a^0} up to \\spad{a^(n-1)} which,{} called with key \\spad{lookup(a^i)} returns \\spad{i} for \\spad{i} in \\spad{0..n-1}. Error: if not called for prime divisors of order of \\indented{7}{multiplicative group.}"))
 (|factorsOfCyclicGroupSize|
  (((|List|
     (|Record| (|:| |factor| (|Integer|))
               (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{factorsOfCyclicGroupSize()} returns the factorization of size()\\spad{-1}"))
 (|charthRoot|
  (($ $)
   "\\spad{charthRoot(a)} takes the characteristic'th root of {\\em a}. Note: such a root is alway defined in finite fields."))) 
NIL 
(|FunctionFieldIntegralBasis| R UP F) 
((|constructor|
  (NIL
   "In this package \\spad{R} is a Euclidean domain and \\spad{F} is a framed algebra over \\spad{R}. The package provides functions to compute the integral closure of \\spad{R} in the quotient field of \\spad{F}. It is assumed that \\spad{char(R/P) = char(R)} for any prime \\spad{P} of \\spad{R}. A typical instance of this is when \\spad{R = K[x]} and \\spad{F} is a function field over \\spad{R}."))
 (|localIntegralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|)
              (|:| |basisInv| (|Matrix| |#1|)))
    |#1|)
   "\\spad{integralBasis(p)} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the local integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|integralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|)
              (|:| |basisInv| (|Matrix| |#1|))))
   "\\spad{integralBasis()} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(x)} returns a square-free factorisation of \\spad{x}"))) 
NIL 
(|FiniteFieldNormalBasis| |p| |extdeg|) 
((|constructor|
  (NIL
   "FiniteFieldNormalBasis(\\spad{p},{} \\spad{n}) implements a finite extension field of degree \\spad{n} over the prime field with \\spad{p} elements. The elements are represented by coordinate vectors with respect to a normal basis,{} \\spadignore{i.e.} a basis consisting of the conjugates (\\spad{q}-powers) of an element,{} in this case called normal element. This is chosen as a root of the extension polynomial created by \\spadfunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}."))
 (|sizeMultiplication|
  (((|NonNegativeInteger|))
   "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: The time of multiplication of field elements depends on this size."))
 (|getMultiplicationMatrix|
  (((|Matrix| (|PrimeField| |#1|)))
   "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix."))
 (|getMultiplicationTable|
  (((|Vector|
     (|List|
      (|Record| (|:| |value| (|PrimeField| |#1|))
                (|:| |index| (|SingleInteger|))))))
   "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|HasCategory| (|PrimeField| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|PrimeField| |#1|) '(|Finite|))
 (OR (|HasCategory| (|PrimeField| |#1|) '(|CharacteristicNonZero|))
     (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))
 (|HasCategory| (|PrimeField| |#1|) '(|Field|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|PrimeField| |#1|) '(|Finite|)))) 
(|FiniteFieldNormalBasisExtensionByPolynomial| GF |uni|) 
((|constructor|
  (NIL
   "FiniteFieldNormalBasisExtensionByPolynomial(\\spad{GF},{} uni) implements a finite extension of the ground field {\\em GF}. The elements are represented by coordinate vectors with respect to. a normal basis,{} \\spadignore{i.e.} a basis consisting of the conjugates (\\spad{q}-powers) of an element,{} in this case called normal element,{} where \\spad{q} is the size of {\\em GF}. The normal element is chosen as a root of the extension polynomial,{} which MUST be normal over {\\em GF} (user responsibility)"))
 (|sizeMultiplication|
  (((|NonNegativeInteger|))
   "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size."))
 (|getMultiplicationMatrix|
  (((|Matrix| |#1|))
   "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix."))
 (|getMultiplicationTable|
  (((|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))))
   "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FiniteFieldNormalBasisExtension| GF |extdeg|) 
((|constructor|
  (NIL
   "FiniteFieldNormalBasisExtensionByPolynomial(\\spad{GF},{} \\spad{n}) implements a finite extension field of degree \\spad{n} over the ground field {\\em GF}. The elements are represented by coordinate vectors with respect to a normal basis,{} \\spadignore{i.e.} a basis consisting of the conjugates (\\spad{q}-powers) of an element,{} in this case called normal element. This is chosen as a root of the extension polynomial,{} created by {\\em createNormalPoly} from \\spadtype{FiniteFieldPolynomialPackage}"))
 (|sizeMultiplication|
  (((|NonNegativeInteger|))
   "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size."))
 (|getMultiplicationMatrix|
  (((|Matrix| |#1|))
   "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix."))
 (|getMultiplicationTable|
  (((|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))))
   "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FiniteFieldExtensionByPolynomial| GF |defpol|) 
((|constructor|
  (NIL
   "FiniteFieldExtensionByPolynomial(\\spad{GF},{} defpol) implements the extension of the finite field {\\em GF} generated by the extension polynomial {\\em defpol} which MUST be irreducible. Note: the user has the responsibility to ensure that {\\em defpol} is irreducible."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FiniteFieldPolynomialPackage| GF) 
((|constructor|
  (NIL
   "This package provides a number of functions for generating,{} counting and testing irreducible,{} normal,{} primitive,{} random polynomials over finite fields."))
 (|reducedQPowers|
  (((|PrimitiveArray| (|SparseUnivariatePolynomial| |#1|))
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{reducedQPowers(f)} generates \\spad{[x,{} x^q,{} x^(q^2),{} ...,{} x^(q^(n-1))]} reduced modulo \\spad{f} where \\spad{q = size()\\$GF} and \\spad{n = degree f}."))
 (|leastAffineMultiple|
  (((|SparseUnivariatePolynomial| |#1|) (|SparseUnivariatePolynomial| |#1|))
   "\\spad{leastAffineMultiple(f)} computes the least affine polynomial which is divisible by the polynomial \\spad{f} over the finite field {\\em GF},{} \\spadignore{i.e.} a polynomial whose exponents are 0 or a power of \\spad{q},{} the size of {\\em GF}."))
 (|random|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)
    (|PositiveInteger|))
   "\\spad{random(m,{} n)}\\$FFPOLY(\\spad{GF}) generates a random monic polynomial of degree \\spad{d} over the finite field {\\em GF},{} \\spad{d} between \\spad{m} and \\spad{n}.")
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{random(n)}\\$FFPOLY(\\spad{GF}) generates a random monic polynomial of degree \\spad{n} over the finite field {\\em GF}."))
 (|nextPrimitiveNormalPoly|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed")
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nextPrimitiveNormalPoly(f)} yields the next primitive normal polynomial over a finite field {\\em GF} of the same degree as \\spad{f} in the following order,{} or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note: the input polynomial \\spad{f} is made monic. \\spad{cnlexSmaller?} is used as ordering predicate. This operation is equivalent to nextNormalPrimitivePoly(\\spad{f})."))
 (|nextNormalPrimitivePoly|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed")
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nextNormalPrimitivePoly(f)} yields the next normal primitive polynomial over a finite field {\\em GF} of the same degree as \\spad{f} in the following order,{} or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note: the input polynomial \\spad{f} is made monic. \\spad{cnlexSmaller?} is used as ordering predicate. This operation is equivalent to nextPrimitiveNormalPoly(\\spad{f})."))
 (|nextNormalPoly|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed")
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nextNormalPoly(f)} yields the next normal polynomial over a finite field {\\em GF} of the same degree as \\spad{f} in the following order,{} or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note: the input polynomial \\spad{f} is made monic. \\spad{nlexSmaller?} is used as ordering predicate."))
 (|nextPrimitivePoly|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed")
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nextPrimitivePoly(f)} yields the next primitive polynomial over a finite field {\\em GF} of the same degree as \\spad{f} in the following order,{} or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note: the input polynomial \\spad{f} is made monic. \\spad{clexSmaller?} is used as ordering predicate."))
 (|nextIrreduciblePoly|
  (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed")
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nextIrreduciblePoly(f)} yields the next monic irreducible polynomial over a finite field {\\em GF} of the same degree as \\spad{f} in the following order,{} or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note: the input polynomial \\spad{f} is made monic. \\spad{lexSmaller?} is used as ordering predicate."))
 (|cnlexSmaller?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{cnlexSmaller?(f,{} g)} compares monic \\spad{f} and \\spad{g} of the same degree \\pdad{\\spad{n}} in the following order. Error: if \\spad{f} or \\spad{g} is not monic or if \\spad{f} and \\spad{g} have different degrees or if common degree is 0. \\spad{f < g} if the constant term of \\spad{f} is zero and constant term of \\spad{g} is nonzero. If both constant term of \\spad{f} and \\spad{g} are nonzero then \\spad{f < g} if the {\\em lookup} of the constant term of \\spad{f} is less than this number for \\spad{g}. If constant terms are equal then \\spad{nlexSmaller?} is used as ordering predicate."))
 (|nlexSmaller?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{nlexSmaller?(f,{} g)} compares monic \\spad{f} and \\spad{g} of the same degree \\pdad{\\spad{n}} in the following order. Error: if \\spad{f} or \\spad{g} is not monic or if \\spad{f} and \\spad{g} have different degrees or if common degree is 0. \\spad{f < g} if the coefficient of the term of degree {\\em n-1} of \\spad{f} is zero and than that for \\spad{g} is nonzero. Also,{} \\spad{f < g} if both coefficients are nonzero and {\\em lookup} of the coefficient of \\spad{f} is less than that for \\spad{g}. In case those coefficients are equal,{} then \\spad{lexSmaller?} is used as ordering predicate."))
 (|clexSmaller?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{clexSmaller?(f,{} g)} compares monic \\spad{f} and \\spad{g} of the same degree in the following order. Error: if \\spad{f} or \\spad{g} is not monic or if \\spad{f} and \\spad{g} have different degrees or if common degree is 0. \\spad{f < g} if the constant term of \\spad{f} is zero and constant term of \\spad{g} is nonzero. If both constant term of \\spad{f} and \\spad{g} are nonzero then \\spad{f < g} if the {\\em lookup} of the constant term of \\spad{f} is less than this number for \\spad{g}. If these values are equal,{} then \\spad{lexSmaller?} is used as ordering predicate."))
 (|lexSmaller?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{lexSmaller?(f,{} g)} compares monic \\spad{f} and \\spad{g} of the same degree in the following order. Error: if \\spad{f} or \\spad{g} is not monic or if \\spad{f} and \\spad{g} have different degrees or if common degree is 0. \\spad{f < g} if the number of monomials of \\spad{f} is less than this number for \\spad{g}. If \\spad{f} and \\spad{g} have the same number of monomials,{} the lists of exponents are compared lexicographically. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of {\\em GF} given by {\\em lookup}."))
 (|createPrimitiveNormalPoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{createPrimitiveNormalPoly(n)}\\$FFPOLY(\\spad{GF}) generates a normal and primitive polynomial of degree \\spad{n} over the field {\\em GF}."))
 (|createNormalPrimitivePoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{createNormalPrimitivePoly(n)}\\$FFPOLY(\\spad{GF}) generates a normal and primitive polynomial of degree \\spad{n} over the field {\\em GF}. Note: this function is equivalent to createPrimitiveNormalPoly(\\spad{n})"))
 (|createNormalPoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{createNormalPoly(n)}\\$FFPOLY(\\spad{GF}) generates a normal polynomial of degree \\spad{n} over the finite field {\\em GF}."))
 (|createPrimitivePoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{createPrimitivePoly(n)}\\$FFPOLY(\\spad{GF}) generates a primitive polynomial of degree \\spad{n} over the finite field {\\em GF}."))
 (|createIrreduciblePoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{createIrreduciblePoly(n)}\\$FFPOLY(\\spad{GF}) generates a monic irreducible univariate polynomial of degree \\spad{n} over the finite field {\\em GF}."))
 (|numberOfNormalPoly|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{numberOfNormalPoly(n)}\\$FFPOLY(\\spad{GF}) yields the number of normal polynomials of degree \\spad{n} over the finite field {\\em GF}."))
 (|numberOfPrimitivePoly|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{numberOfPrimitivePoly(n)}\\$FFPOLY(\\spad{GF}) yields the number of primitive polynomials of degree \\spad{n} over the finite field {\\em GF}."))
 (|numberOfIrreduciblePoly|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{numberOfIrreduciblePoly(n)}\\$FFPOLY(\\spad{GF}) yields the number of monic irreducible univariate polynomials of degree \\spad{n} over the finite field {\\em GF}."))
 (|normal?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|))
   "\\spad{normal?(f)} tests whether the polynomial \\spad{f} over a finite field is normal,{} \\spadignore{i.e.} its roots are linearly independent over the field."))
 (|primitive?|
  (((|Boolean|) (|SparseUnivariatePolynomial| |#1|))
   "\\spad{primitive?(f)} tests whether the polynomial \\spad{f} over a finite field is primitive,{} \\spadignore{i.e.} all its roots are primitive."))) 
NIL 
(|FiniteFieldPolynomialPackage2| F GF) 
((|constructor|
  (NIL
   "\\spad{FiniteFieldPolynomialPackage2}(\\spad{F},{} \\spad{GF}) exports some functions concerning finite fields,{} which depend on a finite field {\\em GF} and an algebraic extension \\spad{F} of {\\em GF},{} \\spadignore{e.g.} a zero of a polynomial over {\\em GF} in \\spad{F}."))
 (|rootOfIrreduciblePoly|
  ((|#1| (|SparseUnivariatePolynomial| |#2|))
   "\\spad{rootOfIrreduciblePoly(f)} computes one root of the monic,{} irreducible polynomial \\spad{f},{} which degree must divide the extension degree of {\\em F} over {\\em GF},{} \\spadignore{i.e.} \\spad{f} splits into linear factors over {\\em F}."))
 (|Frobenius| (($ $) "\\spad{Frobenius(x)} \\undocumented{}"))
 (|basis|
  (((|Vector| $) (|PositiveInteger|)) "\\spad{basis(n)} \\undocumented{}"))
 (|lookup| (((|PositiveInteger|) $) "\\spad{lookup(x)} \\undocumented{}"))
 (|coerce| (($ |#2|) "\\spad{coerce(x)} \\undocumented{}"))) 
NIL 
(|FiniteFieldSolveLinearPolynomialEquation| F FP FPP) 
((|constructor|
  (NIL
   "This package solves linear diophantine equations for Bivariate polynomials over finite fields"))
 (|solveLinearPolynomialEquation|
  (((|Union| (|List| |#3|) "failed") (|List| |#3|) |#3|)
   "\\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of \\spad{ai}\\spad{'s} exists."))) 
NIL 
(|FiniteFieldExtension| GF |n|) 
((|constructor|
  (NIL
   "FiniteFieldExtensionByPolynomial(\\spad{GF},{} \\spad{n}) implements an extension of the finite field {\\em GF} of degree \\spad{n} generated by the extension polynomial constructed by \\spadfunFrom{createIrreduciblePoly}{FiniteFieldPolynomialPackage} from \\spadtype{FiniteFieldPolynomialPackage}."))) 
((|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))) 
(|FGLMIfCanPackage| R |ls|) 
((|constructor|
  (NIL
   "This is just an interface between several packages and domains. The goal is to compute lexicographical Groebner bases of sets of polynomial with type \\spadtype{Polynomial R} by the {\\em FGLM} algorithm if this is possible (\\spadignore{i.e.} if the input system generates a zero-dimensional ideal)."))
 (|groebner|
  (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|)))
   "\\spad{groebner(lq1)} returns the lexicographical Groebner basis of \\spad{lq1}. If \\spad{lq1} generates a zero-dimensional ideal then the {\\em FGLM} strategy is used,{} otherwise the {\\em Sugar} strategy is used."))
 (|fglmIfCan|
  (((|Union| (|List| (|Polynomial| |#1|)) "failed")
    (|List| (|Polynomial| |#1|)))
   "\\spad{fglmIfCan(lq1)} returns the lexicographical Groebner basis of \\spad{lq1} by using the {\\em FGLM} strategy,{} if \\spad{zeroDimensional?(lq1)} holds."))
 (|zeroDimensional?|
  (((|Boolean|) (|List| (|Polynomial| |#1|)))
   "\\spad{zeroDimensional?(lq1)} returns \\spad{true} iff \\spad{lq1} generates a zero-dimensional ideal \\spad{w}.\\spad{r}.\\spad{t}. the variables of \\spad{ls}."))) 
NIL 
(|FreeGroup| S) 
((|constructor|
  (NIL
   "The free group on a set \\spad{S} is the group of finite products of the form \\spad{reduce(*,{} [\\spad{si} ^ \\spad{ni}])} where the \\spad{si}\\spad{'s} are in \\spad{S},{} and the \\spad{ni}\\spad{'s} are integers. The multiplication is not commutative."))
 (|factors|
  (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|Integer|)))) $)
   "\\spad{factors(a1\\^e1,{} ...,{} an\\^en)} returns \\spad{[[a1,{} e1],{} ...,{} [an,{} en]]}."))
 (|mapGen|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{mapGen(f,{} a1\\^e1 ... an\\^en)} returns \\spad{f(a1)\\^e1 ... f(an)\\^en}."))
 (|mapExpon|
  (($ (|Mapping| (|Integer|) (|Integer|)) $)
   "\\spad{mapExpon(f,{} a1\\^e1 ... an\\^en)} returns \\spad{a1\\^f(e1) ... an\\^f(en)}."))
 (|nthFactor|
  ((|#1| $ (|Integer|))
   "\\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \\spad{x}."))
 (|nthExpon|
  (((|Integer|) $ (|Integer|))
   "\\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \\spad{x}."))
 (|size|
  (((|NonNegativeInteger|) $)
   "\\spad{size(x)} returns the number of monomials in \\spad{x}."))
 (^
  (($ |#1| (|Integer|))
   "\\spad{s ^ n} returns the product of \\spad{s} by itself \\spad{n} times."))
 (*
  (($ $ |#1|)
   "\\spad{x * s} returns the product of \\spad{x} by \\spad{s} on the right.")
  (($ |#1| $)
   "\\spad{s * x} returns the product of \\spad{x} by \\spad{s} on the left."))) 
((|HasCategory| |#1| '(|Comparable|))) 
(|FiniteGraph&| A S) 
((|constructor|
  (NIL
   "Category of finite graphs,{} allows us to model graph theory \\blankline"))
 (|mapContra|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| |#2|) (|Integer|) (|Integer|))
   "\\spad{mapContra(s,{} m,{} newOb,{} offsetX,{} offsetY)} is similar to map function but reverses the directions of the arrows"))
 (|map|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| |#2|) (|Integer|) (|Integer|))
   "\\spad{map(s,{} m,{} newOb,{} offsetX,{} offsetY)} creates a new graph by mapping from this one \\spad{newOb} should contain the new list of vertices. \\spad{m} should contain a NNI value for each vertex,{} this is the new index into \\spad{newOb}. It is allowed that \\spad{newOb} may contain less objects than \\spad{s} (for surjective mapping) or more objects than \\spad{s} (for injective mapping)"))
 (|looseEquals|
  (((|Boolean|) $ $)
   "\\spad{looseEquals(x,{} y)} is \\spad{true} if \\spad{x} 'equals' \\spad{y} this is a looser version of equality test but is not as general as isomorphism. it only requires the same number of vertices but does not require the objects themselves being equal. the arrows must be the same,{} that is it may return \\spad{false} if the order of vertices is changed so this is not isomorphism test."))
 (|createY|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \\spad{y} coordinate for objects in a graph"))
 (|createX|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \\spad{x} coordinate for objects in a graph"))
 (|createWidth|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph"))
 (|diagramHeight|
  (((|NonNegativeInteger|) $)
   "\\spad{diagramHeight(s)} returns the height of the diagram that will be generated by diagramSvg. This is the maximum posY of all vertices in graph \\spad{s}"))
 (|diagramWidth|
  (((|NonNegativeInteger|) $)
   "\\spad{diagramWidth(s)} returns the width of the diagram that will be generated by diagramSvg. This is the maximum posX of all vertices in graph \\spad{s}"))
 (|diagramsSvg|
  (((|Void|) (|String|) (|List| $) (|Boolean|))
   "creates \\spad{SVG} diagram containing multiple graphs fileName: String is the name of the \\spad{SVG} file that will be created \\spad{ln:} List \\% is list of graphs that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|diagramSvg|
  (((|Void|) (|String|) $ (|Boolean|))
   "\\spad{diagramSvg(fileName,{} n,{} dispArrowName)} creates an \\spad{SVG} diagram fileName: String is the name of the \\spad{SVG} file that will be created \\spad{n:} \\% is the graph that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|subdiagramSvg|
  (((|Void|) (|Scene| (|SCartesian| 2)) $ (|Boolean|) (|Boolean|))
   "\\spad{subdiagramSvg(sc,{} n,{} dispArrowName,{} deep)} creates a branch of an \\spad{SVG} diagram diagram under an already existing scene node \\spad{sc}. \\spad{n:} \\% is the graph that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|isDirected?|
  (((|Boolean|))
   "isDirected? is \\spad{true} iff \\% is domain consisting of directed graphs,{} \\spad{false} for undirected graphs."))
 (|isFunctional?|
  (((|Boolean|) $)
   "\\spad{isFunctional?(s)} returns \\spad{true} if \\spad{s} is a functional graph,{} that is a directed graph in which each vertex has a single outgoing arrow."))
 (|distanceMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{distanceMatrix(s)} gives matrix of distances between vertices. Element a_{\\spad{i},{} \\spad{j}} is the distance from \\spad{i} to \\spad{j}. Distance matrices are related to adjacency matrices,{} with the differences that: a. the latter only provides the information which vertices are connected \\indented{3}{but does not tell about costs or distances between the vertices} \\spad{b}. adjacency matrix only tells us about directly connected \\indented{3}{vertices while distance matrix also considers indirect connections.}"))
 (|laplacianMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{laplacianMatrix(s)} returns matrix also known as \"Kirchhoff matrix\" or \"Admittance matrix\" where: entry [\\spad{i},{} \\spad{j}] = inDegree(\\spad{vi}) if \\spad{i} = \\spad{j} (number of incoming links) \\spad{-1} if \\spad{i} not = \\spad{j} and \\spad{vi} is adjacent to \\spad{vj} 0 otherwise Alternatively this is defined as \\spad{D} - A,{} where \\spad{D} is the diagonal degree matrix. It contains both adjacency information and degree information. There are other,{} similar matrices,{} that are also called \"Laplacian matrices\" of a graph."))
 (|adjacencyMatrix|
  (((|Matrix| (|NonNegativeInteger|)) $)
   "\\spad{adjacencyMatrix(s)} returns an \\spad{n} by \\spad{n} matrix A,{} where \\spad{n} is the number of vertices in the graph. If there is an edge from a vertex \\spad{x} to a vertex \\spad{y},{} then the element ax,{} \\spad{y} is 1 (or in general the number of xy edges),{} otherwise it is 0. In computing,{} this matrix makes it easy to find subgraphs,{} and to reverse a directed graph."))
 (|incidenceMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{incidenceMatrix(s)} represents graph \\spad{s} by a matrix of size \\spad{|V|} by |E| where: V=number of vertices E=number of edges entry [vertex,{} arrow] = arrow endpoint data (undirected case case: 1 - incident,{} 0 - not incident,{} directed case: \\spad{-1} - start,{} 1 - end,{} 0 - not incident)."))
 (|isAcyclic?|
  (((|Boolean|) $)
   "\\spad{isAcyclic?(s)} returns \\spad{true} if there are no loops"))
 (|loopsArrows|
  (((|List| (|Loop|)) $)
   "\\spad{loopsArrows(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through. to-do: it would be better to use a more efficient algorithm,{} currently the code calls spanningForestArrow and traverses the result for loops,{} it might be more efficient to use Floyds algorithm."))
 (|loopsAtNode|
  (((|List| (|Loop|)) $ (|NonNegativeInteger|))
   "\\spad{loopsAtNode(s,{} a)} returns a list of loops for this graph that pass through vertex index 'a'"))
 (|loopsNodes|
  (((|List| (|Loop|)) $)
   "\\spad{loopsNodes(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through."))
 (|spanningForestNode|
  (((|List| (|Tree| (|Integer|))) $)
   "\\spad{spanningForestNode(s)} constructs a spanning tree for every vertex."))
 (|spanningTreeNode|
  (((|Tree| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{spanningTreeNode(s,{} i)} constructs a spanning tree for graph \\spad{'s'} rooted at the node indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a vertex that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a vertex and a negative Integer represents a repeated vertex."))
 (|spanningForestArrow|
  (((|List| (|Tree| (|Integer|))) $)
   "\\spad{spanningForestArrow(s)} constructs a spanning tree for every arrow."))
 (|spanningTreeArrow|
  (((|Tree| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{spanningTreeArrow(s,{} i)} constructs a spanning tree for graph \\spad{'s'} rooted at the arrow indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a arrow that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a arrow and a negative Integer represents a repeated arrow. note: it is possible that nodes may be visited many times,{} only arrows must not be re-visited."))
 (|merge|
  (($ $ $)
   "\\spad{merge(a,{} b)} returns sum : union (not necessarily disjoint) of nodes with arrows merged in from appropriate input,{} if arrow exists from both inputs then it will be duplicated."))
 (+
  (($ $ $) "sum : disjoint union of nodes with arrows from appropriate input"))
 (|distance|
  (((|Integer|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{distance(s,{} a,{} b)} gives the shortest distance between nodes 'a' and \\spad{'b'} as a number of hops. 0 if 'a' = \\spad{'b'},{} \\spad{-1} if it is not possible to go from 'a' to \\spad{'b'}"))
 (|routeArrows|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{routeArrows(s,{} a,{} b)} gives the shortest route between nodes 'a' and \\spad{'b'} as a sequence of arrow indexes. [] if 'a' = \\spad{'b'} [0] if it is not possible to go from 'a' to \\spad{'b'}"))
 (|routeNodes|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{routeNodes(s,{} a,{} b)} gives the shortest route between nodes 'a' and \\spad{'b'} as a sequence of node indexes. [a] if 'a' = \\spad{'b'} [] if it is not possible to go from 'a' to \\spad{'b'}"))
 (|arrowsToArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "arrowsToArrow: (\\spad{s:} \\%,{} a: NNI) returns index of all arrows leading from a given arrow"))
 (|arrowsFromArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "index of all arrows leading to a given arrow"))
 (|nodeToArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeToArrow(s,{} a)} returns index of all nodes with a direct arrow leading out of arrow 'a' in graph \\spad{'s'}"))
 (|nodeFromArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeFromArrow(s,{} a)} returns index of all nodes with a direct arrow leading in to arrow 'a' in graph \\spad{'s'}"))
 (|arrowsToNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{arrowsToNode(s,{} a)} gives list of all arrows leading from a given node"))
 (|arrowsFromNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{arrowsFromNode(s,{} a)} gives list of all arrows leading to a given node"))
 (|nodeToNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeToNode(s,{} a)} gives list of all nodes with a direct arrow leading out of node 'a' in graph \\spad{'s'}"))
 (|nodeFromNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeFromNode(s,{} a)} gives list of all nodes with a direct arrow leading in to node 'a' in graph \\spad{'s'}"))
 (|outDegree|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{outDegree(s,{} a)} gives the number of arrows leading out of node 'a' in graph \\spad{'s'}"))
 (|inDegree|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{inDegree(s,{} a)} gives the number of arrows leading in to node 'a' in graph \\spad{'s'}"))
 (|getArrowIndex|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{getArrowIndex(s,{} a,{} b)} retrieves arrow index of the arrow form a to \\spad{b}"))
 (|arrowName|
  (((|String|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{arrowName(s,{} a,{} b)} retrieves the name of arrow a-\\spad{>b} if it does not exist then return \\spad{\"?\"}"))
 (|isFixPoint?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{isFixPoint?(s,{} a)} is \\spad{true} if 'a' has an arrow to itself"))
 (|min|
  (((|NonNegativeInteger|) $ (|List| (|NonNegativeInteger|)))
   "\\spad{min(s,{} sub)} returns index of the vertex which can reach to a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.")
  (((|NonNegativeInteger|) $)
   "\\spad{min(s)} returns index of the vertex which can reach to all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance."))
 (|max|
  (((|NonNegativeInteger|) $ (|List| (|NonNegativeInteger|)))
   "\\spad{max(s,{} sub)} returns index of the vertex which can be reached from a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.")
  (((|NonNegativeInteger|) $)
   "\\spad{max(s)} returns index of the vertex which can be reached from all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance."))
 (|isGreaterThan?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{isGreaterThan?(s,{} a,{} b)} is \\spad{true} if we can get from vertex 'a' to \\spad{'b'} through a sequence of arrows but we can\\spad{'t} go in the opposite direction from \\spad{'b'} to 'a'"))
 (|isDirectSuccessor?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{isDirectSuccessor?(s,{} a,{} b)} is \\spad{true} if \\spad{'b'} is a direct successor of 'a' that is,{} if there is a direct arrow from 'a' to \\spad{'b'}"))
 (|kgraph|
  (($ (|List| |#2|) (|String|))
   "\\spad{kgraph(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) and fully connected arrows,{} that is,{} each object has an arrow to every other object except itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|unit|
  (($ (|List| |#2|) (|String|))
   "\\spad{unit(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) and arrows from each object to itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|cycleClosed|
  (($ (|List| |#2|) (|String|))
   "cycleClosed: (objs: List \\spad{S},{} arrowName: String) constructs a graph with vertices (from objs) connected in a cycle. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|cycleOpen|
  (($ (|List| |#2|) (|String|))
   "\\spad{cycleOpen(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) connected in a cycle but with one gap. The last vertex in the sequence loops back to itself so all vertices have one outgoing arrow. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|terminal|
  (($ |#2|)
   "\\spad{terminal(a)} constructs a graph over a with a single vertex and a single loop"))
 (|initial|
  (($) "\\spad{initial constructs} a graph without vertices or edges"))
 (|flatten|
  (($ (|DirectedGraph| $))
   "\\spad{flatten(n)} takes a second order graph,{} that is a graph whose elements are themselves graphs and create a first order graph whose vertices are the vertices of the inner graphs."))
 (|getArrows|
  (((|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|)))))
    $)
   "\\spad{getArrows(s)} returns a list of all the arrows (or edges)"))
 (|getVertexIndex|
  (((|NonNegativeInteger|) $ |#2|)
   "\\spad{getVertexIndex(s,{} o)} gives index of object \\spad{o}. returns 0 if not found"))
 (|getVertices|
  (((|List|
     (|Record| (|:| |value| |#2|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    $)
   "\\spad{getVertices(s)} returns a list of all the vertices (or objects) of the graph \\spad{s}."))
 (|addArrow!|
  (($ $ (|String|) |#2| |#2|)
   "\\spad{addArrow!(s,{} nm,{} o1,{} o2)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{o1} is the start object \\spad{o2} is the end object")
  (($ $ (|String|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2,{} mp)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object \\spad{mp} is a map represented by this arrow")
  (($ $ (|String|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object")
  (($ $
    (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
              (|:| |fromOb| (|NonNegativeInteger|))
              (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
              (|:| |yOffset| (|Integer|))
              (|:| |map| (|List| (|NonNegativeInteger|)))))
   "\\spad{addArrow!(s,{} ar)} adds an arrow ar to the graph \\spad{s}"))
 (|addObject!|
  (($ $
    (|Record| (|:| |value| |#2|) (|:| |posX| (|NonNegativeInteger|))
              (|:| |posY| (|NonNegativeInteger|))))
   "\\spad{addObject!(s,{} n)} adds object with coordinates \\spad{n} to the graph \\spad{s}.")
  (($ $ |#2|)
   "\\spad{addObject!(s,{} n)} adds object \\spad{n} to the graph \\spad{s}. Use this version if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates."))) 
NIL 
(|FiniteGraph| S) 
((|constructor|
  (NIL
   "Category of finite graphs,{} allows us to model graph theory \\blankline"))
 (|mapContra|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| |#1|) (|Integer|) (|Integer|))
   "\\spad{mapContra(s,{} m,{} newOb,{} offsetX,{} offsetY)} is similar to map function but reverses the directions of the arrows"))
 (|map|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| |#1|) (|Integer|) (|Integer|))
   "\\spad{map(s,{} m,{} newOb,{} offsetX,{} offsetY)} creates a new graph by mapping from this one \\spad{newOb} should contain the new list of vertices. \\spad{m} should contain a NNI value for each vertex,{} this is the new index into \\spad{newOb}. It is allowed that \\spad{newOb} may contain less objects than \\spad{s} (for surjective mapping) or more objects than \\spad{s} (for injective mapping)"))
 (|looseEquals|
  (((|Boolean|) $ $)
   "\\spad{looseEquals(x,{} y)} is \\spad{true} if \\spad{x} 'equals' \\spad{y} this is a looser version of equality test but is not as general as isomorphism. it only requires the same number of vertices but does not require the objects themselves being equal. the arrows must be the same,{} that is it may return \\spad{false} if the order of vertices is changed so this is not isomorphism test."))
 (|createY|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \\spad{y} coordinate for objects in a graph"))
 (|createX|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \\spad{x} coordinate for objects in a graph"))
 (|createWidth|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph"))
 (|diagramHeight|
  (((|NonNegativeInteger|) $)
   "\\spad{diagramHeight(s)} returns the height of the diagram that will be generated by diagramSvg. This is the maximum posY of all vertices in graph \\spad{s}"))
 (|diagramWidth|
  (((|NonNegativeInteger|) $)
   "\\spad{diagramWidth(s)} returns the width of the diagram that will be generated by diagramSvg. This is the maximum posX of all vertices in graph \\spad{s}"))
 (|diagramsSvg|
  (((|Void|) (|String|) (|List| $) (|Boolean|))
   "creates \\spad{SVG} diagram containing multiple graphs fileName: String is the name of the \\spad{SVG} file that will be created \\spad{ln:} List \\% is list of graphs that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|diagramSvg|
  (((|Void|) (|String|) $ (|Boolean|))
   "\\spad{diagramSvg(fileName,{} n,{} dispArrowName)} creates an \\spad{SVG} diagram fileName: String is the name of the \\spad{SVG} file that will be created \\spad{n:} \\% is the graph that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|subdiagramSvg|
  (((|Void|) (|Scene| (|SCartesian| 2)) $ (|Boolean|) (|Boolean|))
   "\\spad{subdiagramSvg(sc,{} n,{} dispArrowName,{} deep)} creates a branch of an \\spad{SVG} diagram diagram under an already existing scene node \\spad{sc}. \\spad{n:} \\% is the graph that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|isDirected?|
  (((|Boolean|))
   "isDirected? is \\spad{true} iff \\% is domain consisting of directed graphs,{} \\spad{false} for undirected graphs."))
 (|isFunctional?|
  (((|Boolean|) $)
   "\\spad{isFunctional?(s)} returns \\spad{true} if \\spad{s} is a functional graph,{} that is a directed graph in which each vertex has a single outgoing arrow."))
 (|distanceMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{distanceMatrix(s)} gives matrix of distances between vertices. Element a_{\\spad{i},{} \\spad{j}} is the distance from \\spad{i} to \\spad{j}. Distance matrices are related to adjacency matrices,{} with the differences that: a. the latter only provides the information which vertices are connected \\indented{3}{but does not tell about costs or distances between the vertices} \\spad{b}. adjacency matrix only tells us about directly connected \\indented{3}{vertices while distance matrix also considers indirect connections.}"))
 (|laplacianMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{laplacianMatrix(s)} returns matrix also known as \"Kirchhoff matrix\" or \"Admittance matrix\" where: entry [\\spad{i},{} \\spad{j}] = inDegree(\\spad{vi}) if \\spad{i} = \\spad{j} (number of incoming links) \\spad{-1} if \\spad{i} not = \\spad{j} and \\spad{vi} is adjacent to \\spad{vj} 0 otherwise Alternatively this is defined as \\spad{D} - A,{} where \\spad{D} is the diagonal degree matrix. It contains both adjacency information and degree information. There are other,{} similar matrices,{} that are also called \"Laplacian matrices\" of a graph."))
 (|adjacencyMatrix|
  (((|Matrix| (|NonNegativeInteger|)) $)
   "\\spad{adjacencyMatrix(s)} returns an \\spad{n} by \\spad{n} matrix A,{} where \\spad{n} is the number of vertices in the graph. If there is an edge from a vertex \\spad{x} to a vertex \\spad{y},{} then the element ax,{} \\spad{y} is 1 (or in general the number of xy edges),{} otherwise it is 0. In computing,{} this matrix makes it easy to find subgraphs,{} and to reverse a directed graph."))
 (|incidenceMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{incidenceMatrix(s)} represents graph \\spad{s} by a matrix of size \\spad{|V|} by |E| where: V=number of vertices E=number of edges entry [vertex,{} arrow] = arrow endpoint data (undirected case case: 1 - incident,{} 0 - not incident,{} directed case: \\spad{-1} - start,{} 1 - end,{} 0 - not incident)."))
 (|isAcyclic?|
  (((|Boolean|) $)
   "\\spad{isAcyclic?(s)} returns \\spad{true} if there are no loops"))
 (|loopsArrows|
  (((|List| (|Loop|)) $)
   "\\spad{loopsArrows(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through. to-do: it would be better to use a more efficient algorithm,{} currently the code calls spanningForestArrow and traverses the result for loops,{} it might be more efficient to use Floyds algorithm."))
 (|loopsAtNode|
  (((|List| (|Loop|)) $ (|NonNegativeInteger|))
   "\\spad{loopsAtNode(s,{} a)} returns a list of loops for this graph that pass through vertex index 'a'"))
 (|loopsNodes|
  (((|List| (|Loop|)) $)
   "\\spad{loopsNodes(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through."))
 (|spanningForestNode|
  (((|List| (|Tree| (|Integer|))) $)
   "\\spad{spanningForestNode(s)} constructs a spanning tree for every vertex."))
 (|spanningTreeNode|
  (((|Tree| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{spanningTreeNode(s,{} i)} constructs a spanning tree for graph \\spad{'s'} rooted at the node indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a vertex that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a vertex and a negative Integer represents a repeated vertex."))
 (|spanningForestArrow|
  (((|List| (|Tree| (|Integer|))) $)
   "\\spad{spanningForestArrow(s)} constructs a spanning tree for every arrow."))
 (|spanningTreeArrow|
  (((|Tree| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{spanningTreeArrow(s,{} i)} constructs a spanning tree for graph \\spad{'s'} rooted at the arrow indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a arrow that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a arrow and a negative Integer represents a repeated arrow. note: it is possible that nodes may be visited many times,{} only arrows must not be re-visited."))
 (|merge|
  (($ $ $)
   "\\spad{merge(a,{} b)} returns sum : union (not necessarily disjoint) of nodes with arrows merged in from appropriate input,{} if arrow exists from both inputs then it will be duplicated."))
 (+
  (($ $ $) "sum : disjoint union of nodes with arrows from appropriate input"))
 (|distance|
  (((|Integer|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{distance(s,{} a,{} b)} gives the shortest distance between nodes 'a' and \\spad{'b'} as a number of hops. 0 if 'a' = \\spad{'b'},{} \\spad{-1} if it is not possible to go from 'a' to \\spad{'b'}"))
 (|routeArrows|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{routeArrows(s,{} a,{} b)} gives the shortest route between nodes 'a' and \\spad{'b'} as a sequence of arrow indexes. [] if 'a' = \\spad{'b'} [0] if it is not possible to go from 'a' to \\spad{'b'}"))
 (|routeNodes|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{routeNodes(s,{} a,{} b)} gives the shortest route between nodes 'a' and \\spad{'b'} as a sequence of node indexes. [a] if 'a' = \\spad{'b'} [] if it is not possible to go from 'a' to \\spad{'b'}"))
 (|arrowsToArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "arrowsToArrow: (\\spad{s:} \\%,{} a: NNI) returns index of all arrows leading from a given arrow"))
 (|arrowsFromArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "index of all arrows leading to a given arrow"))
 (|nodeToArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeToArrow(s,{} a)} returns index of all nodes with a direct arrow leading out of arrow 'a' in graph \\spad{'s'}"))
 (|nodeFromArrow|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeFromArrow(s,{} a)} returns index of all nodes with a direct arrow leading in to arrow 'a' in graph \\spad{'s'}"))
 (|arrowsToNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{arrowsToNode(s,{} a)} gives list of all arrows leading from a given node"))
 (|arrowsFromNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{arrowsFromNode(s,{} a)} gives list of all arrows leading to a given node"))
 (|nodeToNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeToNode(s,{} a)} gives list of all nodes with a direct arrow leading out of node 'a' in graph \\spad{'s'}"))
 (|nodeFromNode|
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|))
   "\\spad{nodeFromNode(s,{} a)} gives list of all nodes with a direct arrow leading in to node 'a' in graph \\spad{'s'}"))
 (|outDegree|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{outDegree(s,{} a)} gives the number of arrows leading out of node 'a' in graph \\spad{'s'}"))
 (|inDegree|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{inDegree(s,{} a)} gives the number of arrows leading in to node 'a' in graph \\spad{'s'}"))
 (|getArrowIndex|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{getArrowIndex(s,{} a,{} b)} retrieves arrow index of the arrow form a to \\spad{b}"))
 (|arrowName|
  (((|String|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{arrowName(s,{} a,{} b)} retrieves the name of arrow a-\\spad{>b} if it does not exist then return \\spad{\"?\"}"))
 (|isFixPoint?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{isFixPoint?(s,{} a)} is \\spad{true} if 'a' has an arrow to itself"))
 (|min|
  (((|NonNegativeInteger|) $ (|List| (|NonNegativeInteger|)))
   "\\spad{min(s,{} sub)} returns index of the vertex which can reach to a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.")
  (((|NonNegativeInteger|) $)
   "\\spad{min(s)} returns index of the vertex which can reach to all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance."))
 (|max|
  (((|NonNegativeInteger|) $ (|List| (|NonNegativeInteger|)))
   "\\spad{max(s,{} sub)} returns index of the vertex which can be reached from a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.")
  (((|NonNegativeInteger|) $)
   "\\spad{max(s)} returns index of the vertex which can be reached from all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance."))
 (|isGreaterThan?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{isGreaterThan?(s,{} a,{} b)} is \\spad{true} if we can get from vertex 'a' to \\spad{'b'} through a sequence of arrows but we can\\spad{'t} go in the opposite direction from \\spad{'b'} to 'a'"))
 (|isDirectSuccessor?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{isDirectSuccessor?(s,{} a,{} b)} is \\spad{true} if \\spad{'b'} is a direct successor of 'a' that is,{} if there is a direct arrow from 'a' to \\spad{'b'}"))
 (|kgraph|
  (($ (|List| |#1|) (|String|))
   "\\spad{kgraph(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) and fully connected arrows,{} that is,{} each object has an arrow to every other object except itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|unit|
  (($ (|List| |#1|) (|String|))
   "\\spad{unit(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) and arrows from each object to itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|cycleClosed|
  (($ (|List| |#1|) (|String|))
   "cycleClosed: (objs: List \\spad{S},{} arrowName: String) constructs a graph with vertices (from objs) connected in a cycle. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|cycleOpen|
  (($ (|List| |#1|) (|String|))
   "\\spad{cycleOpen(objs,{} arrowName)} constructs a graph with vertices (from \\spad{objs}) connected in a cycle but with one gap. The last vertex in the sequence loops back to itself so all vertices have one outgoing arrow. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow"))
 (|terminal|
  (($ |#1|)
   "\\spad{terminal(a)} constructs a graph over a with a single vertex and a single loop"))
 (|initial|
  (($) "\\spad{initial constructs} a graph without vertices or edges"))
 (|flatten|
  (($ (|DirectedGraph| $))
   "\\spad{flatten(n)} takes a second order graph,{} that is a graph whose elements are themselves graphs and create a first order graph whose vertices are the vertices of the inner graphs."))
 (|getArrows|
  (((|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|)))))
    $)
   "\\spad{getArrows(s)} returns a list of all the arrows (or edges)"))
 (|getVertexIndex|
  (((|NonNegativeInteger|) $ |#1|)
   "\\spad{getVertexIndex(s,{} o)} gives index of object \\spad{o}. returns 0 if not found"))
 (|getVertices|
  (((|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    $)
   "\\spad{getVertices(s)} returns a list of all the vertices (or objects) of the graph \\spad{s}."))
 (|addArrow!|
  (($ $ (|String|) |#1| |#1|)
   "\\spad{addArrow!(s,{} nm,{} o1,{} o2)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{o1} is the start object \\spad{o2} is the end object")
  (($ $ (|String|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2,{} mp)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object \\spad{mp} is a map represented by this arrow")
  (($ $ (|String|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \\spad{s},{} where: \\spad{nm} is the name of the arrow \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object")
  (($ $
    (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
              (|:| |fromOb| (|NonNegativeInteger|))
              (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
              (|:| |yOffset| (|Integer|))
              (|:| |map| (|List| (|NonNegativeInteger|)))))
   "\\spad{addArrow!(s,{} ar)} adds an arrow ar to the graph \\spad{s}"))
 (|addObject!|
  (($ $
    (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
              (|:| |posY| (|NonNegativeInteger|))))
   "\\spad{addObject!(s,{} n)} adds object with coordinates \\spad{n} to the graph \\spad{s}.")
  (($ $ |#1|)
   "\\spad{addObject!(s,{} n)} adds object \\spad{n} to the graph \\spad{s}. Use this version if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates."))) 
NIL 
(|Field&| S) 
((|constructor|
  (NIL
   "The category of commutative fields,{} \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline"))
 (/
  (($ $ $)
   "\\spad{x/y} divides the element \\spad{x} by the element \\spad{y}. Error: if \\spad{y} is 0."))) 
NIL 
(|Field|) 
((|constructor|
  (NIL
   "The category of commutative fields,{} \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline"))
 (/
  (($ $ $)
   "\\spad{x/y} divides the element \\spad{x} by the element \\spad{y}. Error: if \\spad{y} is 0."))) 
NIL 
(|File| S) 
((|constructor|
  (NIL
   "This domain provides a basic model of files to save arbitrary values. The operations provide sequential access to the contents."))
 (|readIfCan!|
  (((|Union| |#1| "failed") $)
   "\\spad{readIfCan!(f)} returns a value from the file \\spad{f},{} if possible. If \\spad{f} is not open for reading,{} or if \\spad{f} is at the end of file then \\spad{\"failed\"} is the result."))) 
NIL 
(|FileCategory| |Name| S) 
((|constructor|
  (NIL
   "This category provides an interface to operate on files in the computer\\spad{'s} file system. The precise method of naming files is determined by the Name parameter. The type of the contents of the file is determined by \\spad{S}."))
 (|flush|
  (((|Void|) $)
   "\\spad{flush(f)} make sure that buffered data in written out to the operating system."))
 (|write!|
  ((|#2| $ |#2|)
   "\\spad{write!(f,{} s)} puts the value \\spad{s} into the file \\spad{f}. The state of \\spad{f} is modified so subsequents call to \\spad{write!} will append one after another."))
 (|read!|
  ((|#2| $)
   "\\spad{read!(f)} extracts a value from file \\spad{f}. The state of \\spad{f} is modified so a subsequent call to \\spadfun{read!} will return the next element."))
 (|iomode|
  (((|String|) $)
   "\\spad{iomode(f)} returns the status of the file \\spad{f}. The input/output status of \\spad{f} may be \"input\",{} \"output\" or \"closed\" mode."))
 (|name|
  ((|#1| $)
   "\\spad{name(f)} returns the external name of the file \\spad{f}."))
 (|close!|
  (($ $)
   "\\spad{close!(f)} returns the file \\spad{f} closed to input and output."))
 (|reopen!|
  (($ $ (|String|))
   "\\spad{reopen!(f,{} mode)} returns a file \\spad{f} reopened for operation in the indicated mode: \"input\" or \"output\". \\spad{reopen!(f,{}\"input\")} will reopen the file \\spad{f} for input."))
 (|open|
  (($ |#1| (|String|))
   "\\spad{open(s,{} mode)} returns a file \\spad{s} open for operation in the indicated mode: \"input\" or \"output\".")
  (($ |#1|) "\\spad{open(s)} returns the file \\spad{s} open for input."))) 
NIL 
(|FiniteRankNonAssociativeAlgebra&| S R) 
((|constructor|
  (NIL
   "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|unit|
  (((|Union| $ "failed"))
   "\\spad{unit()} returns a unit of the algebra (necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnit|
  (((|Union| $ "failed"))
   "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|leftUnit|
  (((|Union| $ "failed"))
   "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|rightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|leftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|associatorDependence|
  (((|List| (|Vector| |#2|)))
   "\\spad{associatorDependence()} looks for the associator identities,{} \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,{} b,{} c)} which yield 0,{} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|lieAlgebra?|
  (((|Boolean|))
   "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Lie algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := a@b-b@a}."))
 (|jordanAlgebra?|
  (((|Boolean|))
   "\\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \\spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Jordan algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := (a@b+b@a)/2}."))
 (|noncommutativeJordanAlgebra?|
  (((|Boolean|))
   "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible."))
 (|jordanAdmissible?|
  (((|Boolean|))
   "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadtype{CommutativeStar} follows from by definition."))
 (|lieAdmissible?|
  (((|Boolean|))
   "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."))
 (|jacobiIdentity?|
  (((|Boolean|))
   "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors."))
 (|powerAssociative?|
  (((|Boolean|))
   "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative."))
 (|alternative?|
  (((|Boolean|))
   "\\spad{alternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|flexible?|
  (((|Boolean|))
   "\\spad{flexible?()} tests if \\spad{2*associator(a,{} b,{} a) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|rightAlternative?|
  (((|Boolean|))
   "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,{} b,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|leftAlternative?|
  (((|Boolean|))
   "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|antiAssociative?|
  (((|Boolean|))
   "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra."))
 (|associative?|
  (((|Boolean|))
   "\\spad{associative?()} tests if multiplication in algebra is associative."))
 (|antiCommutative?|
  (((|Boolean|))
   "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note: this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}."))
 (|commutative?|
  (((|Boolean|))
   "\\spad{commutative?()} tests if multiplication in the algebra is commutative."))
 (|rightCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis."))
 (|leftCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{rightTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}."))
 (|leftTraceMatrix|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{leftTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}."))
 (|rightDiscriminant|
  ((|#2| (|Vector| $))
   "\\spad{rightDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(rightTraceMatrix([v1,{} ...,{} vn]))}."))
 (|leftDiscriminant|
  ((|#2| (|Vector| $))
   "\\spad{leftDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(leftTraceMatrix([v1,{} ...,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#2|) (|Vector| $))
   "\\spad{represents([a1,{} ...,{} am],{} [v1,{} ...,{} vm])} returns the linear combination \\spad{a1*vm + ... + an*vm}."))
 (|coordinates|
  (((|Matrix| |#2|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([a1,{} ...,{} am],{} [v1,{} ...,{} vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{\\spad{ai}} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}.")
  (((|Vector| |#2|) $ (|Vector| $))
   "\\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rightNorm|
  ((|#2| $)
   "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}."))
 (|leftNorm|
  ((|#2| $)
   "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}."))
 (|rightTrace|
  ((|#2| $)
   "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}."))
 (|leftTrace|
  ((|#2| $)
   "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}."))
 (|rightRegularRepresentation|
  (((|Matrix| |#2|) $ (|Vector| $))
   "\\spad{rightRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(x*a,{} b) = m*coordinates(x,{} b)}."))
 (|leftRegularRepresentation|
  (((|Matrix| |#2|) $ (|Vector| $))
   "\\spad{leftRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(a*x,{} b) = m*coordinates(x,{} b)}."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#2|)) (|Vector| $))
   "\\spad{structuralConstants([v1,{} v2,{} ...,{} vm])} calculates the structural constants \\spad{[(gammaijk) for k in 1..m]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijm * vm},{} where \\spad{[v1,{} ...,{} vm]} is an \\spad{R}-module basis of a subalgebra."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#2|)) (|Vector| $))
   "\\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rank|
  (((|PositiveInteger|))
   "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module."))
 (|someBasis|
  (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))
 (|unitsKnown|
  ((|attribute|)
   "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit,{} similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left,{} respectively right,{} minimal polynomials to decide this question."))) 
((|HasCategory| |#2| '(|IntegralDomain|))) 
(|FiniteRankNonAssociativeAlgebra| R) 
((|constructor|
  (NIL
   "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|unit|
  (((|Union| $ "failed"))
   "\\spad{unit()} returns a unit of the algebra (necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnit|
  (((|Union| $ "failed"))
   "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|leftUnit|
  (((|Union| $ "failed"))
   "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|rightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|leftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|associatorDependence|
  (((|List| (|Vector| |#1|)))
   "\\spad{associatorDependence()} looks for the associator identities,{} \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,{} b,{} c)} which yield 0,{} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|lieAlgebra?|
  (((|Boolean|))
   "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Lie algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := a@b-b@a}."))
 (|jordanAlgebra?|
  (((|Boolean|))
   "\\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \\spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Jordan algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := (a@b+b@a)/2}."))
 (|noncommutativeJordanAlgebra?|
  (((|Boolean|))
   "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible."))
 (|jordanAdmissible?|
  (((|Boolean|))
   "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadtype{CommutativeStar} follows from by definition."))
 (|lieAdmissible?|
  (((|Boolean|))
   "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."))
 (|jacobiIdentity?|
  (((|Boolean|))
   "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors."))
 (|powerAssociative?|
  (((|Boolean|))
   "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative."))
 (|alternative?|
  (((|Boolean|))
   "\\spad{alternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|flexible?|
  (((|Boolean|))
   "\\spad{flexible?()} tests if \\spad{2*associator(a,{} b,{} a) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|rightAlternative?|
  (((|Boolean|))
   "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,{} b,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|leftAlternative?|
  (((|Boolean|))
   "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|antiAssociative?|
  (((|Boolean|))
   "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra."))
 (|associative?|
  (((|Boolean|))
   "\\spad{associative?()} tests if multiplication in algebra is associative."))
 (|antiCommutative?|
  (((|Boolean|))
   "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note: this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}."))
 (|commutative?|
  (((|Boolean|))
   "\\spad{commutative?()} tests if multiplication in the algebra is commutative."))
 (|rightCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis."))
 (|leftCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{rightTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}."))
 (|leftTraceMatrix|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{leftTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}."))
 (|rightDiscriminant|
  ((|#1| (|Vector| $))
   "\\spad{rightDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(rightTraceMatrix([v1,{} ...,{} vn]))}."))
 (|leftDiscriminant|
  ((|#1| (|Vector| $))
   "\\spad{leftDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(leftTraceMatrix([v1,{} ...,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#1|) (|Vector| $))
   "\\spad{represents([a1,{} ...,{} am],{} [v1,{} ...,{} vm])} returns the linear combination \\spad{a1*vm + ... + an*vm}."))
 (|coordinates|
  (((|Matrix| |#1|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([a1,{} ...,{} am],{} [v1,{} ...,{} vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{\\spad{ai}} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}.")
  (((|Vector| |#1|) $ (|Vector| $))
   "\\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rightNorm|
  ((|#1| $)
   "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}."))
 (|leftNorm|
  ((|#1| $)
   "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}."))
 (|rightTrace|
  ((|#1| $)
   "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}."))
 (|leftTrace|
  ((|#1| $)
   "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}."))
 (|rightRegularRepresentation|
  (((|Matrix| |#1|) $ (|Vector| $))
   "\\spad{rightRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(x*a,{} b) = m*coordinates(x,{} b)}."))
 (|leftRegularRepresentation|
  (((|Matrix| |#1|) $ (|Vector| $))
   "\\spad{leftRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(a*x,{} b) = m*coordinates(x,{} b)}."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#1|)) (|Vector| $))
   "\\spad{structuralConstants([v1,{} v2,{} ...,{} vm])} calculates the structural constants \\spad{[(gammaijk) for k in 1..m]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijm * vm},{} where \\spad{[v1,{} ...,{} vm]} is an \\spad{R}-module basis of a subalgebra."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#1|)) (|Vector| $))
   "\\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rank|
  (((|PositiveInteger|))
   "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module."))
 (|someBasis|
  (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))
 (|unitsKnown|
  ((|attribute|)
   "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit,{} similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left,{} respectively right,{} minimal polynomials to decide this question."))) 
NIL 
(|FinitelyGenerated|) 
((|constructor|
  (NIL
   "A category for finitely generated structures. Exports a list of generators."))
 (|generators|
  (((|List| $)) "\\spad{generators()} returns the list of generators."))) 
NIL 
(|FiniteGroupPackage| G) 
((|constructor|
  (NIL "A package for permutation representations of finite groups."))
 (|regularRepresentation|
  (((|Matrix| (|Integer|)) |#1|)
   "\\spad{regularRepresentation(x)} returns the matrix representation of the permutation \\spad{permutationRep(x)}"))
 (|permutationRepresentation|
  (((|Permutation| (|Integer|)) |#1|)
   "\\spad{permutationRepresentation(x)} returns the permutation induced by \\spad{x} on \\spad{enumerate()\\$G}"))) 
NIL 
(|FiniteGroup&| S) 
((|constructor| (NIL "The category of finite groups."))
 (|order|
  (((|Integer|) $)
   "\\spad{order(x)} computes the order of the element \\$\\spad{x}\\$."))) 
NIL 
(|FiniteGroup|) 
((|constructor| (NIL "The category of finite groups."))
 (|order|
  (((|Integer|) $)
   "\\spad{order(x)} computes the order of the element \\$\\spad{x}\\$."))) 
NIL 
(|Finite&| S) 
((|constructor|
  (NIL
   "The category of domains composed of a finite set of elements. We include the functions \\spadfun{lookup} and \\spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \\blankline"))
 (|enumerate|
  (((|List| $)) "\\spad{enumerate()} returns list of elements of the set."))
 (|random| (($) "\\spad{random()} returns a random element from the set."))
 (|lookup|
  (((|PositiveInteger|) $)
   "\\spad{lookup(x)} returns a positive integer such that \\spad{x = index lookup x}."))
 (|index|
  (($ (|PositiveInteger|))
   "\\spad{index(i)} takes a positive integer \\spad{i} less than or equal to \\spad{size()} and returns the \\spad{i}\\spad{-}th element of the set. This operation establishes a bijection between the elements of the finite set and \\spad{1..size()}."))
 (|size|
  (((|NonNegativeInteger|))
   "\\spad{size()} returns the number of elements in the set."))) 
NIL 
(|Finite|) 
((|constructor|
  (NIL
   "The category of domains composed of a finite set of elements. We include the functions \\spadfun{lookup} and \\spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \\blankline"))
 (|enumerate|
  (((|List| $)) "\\spad{enumerate()} returns list of elements of the set."))
 (|random| (($) "\\spad{random()} returns a random element from the set."))
 (|lookup|
  (((|PositiveInteger|) $)
   "\\spad{lookup(x)} returns a positive integer such that \\spad{x = index lookup x}."))
 (|index|
  (($ (|PositiveInteger|))
   "\\spad{index(i)} takes a positive integer \\spad{i} less than or equal to \\spad{size()} and returns the \\spad{i}\\spad{-}th element of the set. This operation establishes a bijection between the elements of the finite set and \\spad{1..size()}."))
 (|size|
  (((|NonNegativeInteger|))
   "\\spad{size()} returns the number of elements in the set."))) 
NIL 
(|FiniteLattice| S |p|) 
((|constructor|
  (NIL
   "This is the algebration of poset. A big difference between \\indented{3}{this lattice domain and the poset domain is that,{} in this domain,{} the} \\indented{3}{REP holds a single node whereas in poset REP holds the whole poset.} Date Created: Aug 2015"))
 (|finiteLattice| (($ |#1|) "construct finite lattice element from object")
  (($ (|NonNegativeInteger|)) "construct finite lattice element from index"))) 
NIL 
(|FiniteRankAlgebra&| S R UP) 
((|constructor|
  (NIL
   "A FiniteRankAlgebra is an algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|minimalPolynomial|
  ((|#3| $)
   "\\spad{minimalPolynomial(a)} returns the minimal polynomial of \\spad{a}."))
 (|characteristicPolynomial|
  ((|#3| $)
   "\\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \\spad{a} with respect to any basis."))
 (|traceMatrix|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{traceMatrix([v1,{} ..,{} vn])} is the \\spad{n}-by-\\spad{n} matrix ( \\spad{Tr}(\\spad{vi} * \\spad{vj}) )"))
 (|discriminant|
  ((|#2| (|Vector| $))
   "\\spad{discriminant([v1,{} ..,{} vn])} returns \\spad{determinant(traceMatrix([v1,{} ..,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#2|) (|Vector| $))
   "\\spad{represents([a1,{} ..,{} an],{} [v1,{} ..,{} vn])} returns \\spad{a1*v1 + ... + an*vn}."))
 (|coordinates|
  (((|Matrix| |#2|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([v1,{} ...,{} vm],{} basis)} returns the coordinates of the \\spad{vi}\\spad{'s} with to the basis \\spad{basis}. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.")
  (((|Vector| |#2|) $ (|Vector| $))
   "\\spad{coordinates(a,{} basis)} returns the coordinates of \\spad{a} with respect to the basis \\spad{basis}."))
 (|norm|
  ((|#2| $)
   "\\spad{norm(a)} returns the determinant of the regular representation of \\spad{a} with respect to any basis."))
 (|trace|
  ((|#2| $)
   "\\spad{trace(a)} returns the trace of the regular representation of \\spad{a} with respect to any basis."))
 (|regularRepresentation|
  (((|Matrix| |#2|) $ (|Vector| $))
   "\\spad{regularRepresentation(a,{} basis)} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the basis \\spad{basis}. That is for all \\spad{x} we have \\spad{coordinates(a*x,{} basis) = m*coordinates(x,{} basis)}."))
 (|rank|
  (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra."))) 
((|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Field|))) 
(|FiniteRankAlgebra| R UP) 
((|constructor|
  (NIL
   "A FiniteRankAlgebra is an algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|minimalPolynomial|
  ((|#2| $)
   "\\spad{minimalPolynomial(a)} returns the minimal polynomial of \\spad{a}."))
 (|characteristicPolynomial|
  ((|#2| $)
   "\\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \\spad{a} with respect to any basis."))
 (|traceMatrix|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{traceMatrix([v1,{} ..,{} vn])} is the \\spad{n}-by-\\spad{n} matrix ( \\spad{Tr}(\\spad{vi} * \\spad{vj}) )"))
 (|discriminant|
  ((|#1| (|Vector| $))
   "\\spad{discriminant([v1,{} ..,{} vn])} returns \\spad{determinant(traceMatrix([v1,{} ..,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#1|) (|Vector| $))
   "\\spad{represents([a1,{} ..,{} an],{} [v1,{} ..,{} vn])} returns \\spad{a1*v1 + ... + an*vn}."))
 (|coordinates|
  (((|Matrix| |#1|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([v1,{} ...,{} vm],{} basis)} returns the coordinates of the \\spad{vi}\\spad{'s} with to the basis \\spad{basis}. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.")
  (((|Vector| |#1|) $ (|Vector| $))
   "\\spad{coordinates(a,{} basis)} returns the coordinates of \\spad{a} with respect to the basis \\spad{basis}."))
 (|norm|
  ((|#1| $)
   "\\spad{norm(a)} returns the determinant of the regular representation of \\spad{a} with respect to any basis."))
 (|trace|
  ((|#1| $)
   "\\spad{trace(a)} returns the trace of the regular representation of \\spad{a} with respect to any basis."))
 (|regularRepresentation|
  (((|Matrix| |#1|) $ (|Vector| $))
   "\\spad{regularRepresentation(a,{} basis)} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the basis \\spad{basis}. That is for all \\spad{x} we have \\spad{coordinates(a*x,{} basis) = m*coordinates(x,{} basis)}."))
 (|rank|
  (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra."))) 
NIL 
(|FiniteLinearAggregate| S) 
((|constructor|
  (NIL "A finite linear aggregate is a linear aggregate of finite length."))) 
NIL 
(|FiniteLinearAggregateFunctions2| S A R B) 
((|constructor|
  (NIL
   "\\spad{FiniteLinearAggregateFunctions2} provides functions involving two FiniteLinearAggregates where the underlying domains might be different. An example of this might be creating a list of rational numbers by mapping a function across a list of integers where the function divides each integer by 1000."))
 (|scan|
  ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-aggregates \\spad{x} of aggregrate \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad{[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))
 (|reduce|
  ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialized to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as the identity element for the function \\spad{f}."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of aggregate \\spad{a} resulting in a new aggregate over a possibly different underlying domain."))) 
NIL 
(|FreeLieAlgebra| |VarSet| R) 
((|constructor|
  (NIL
   "The category of free Lie algebras. It is used by domains of non-commutative algebra: \\spadtype{LiePolynomial} and \\spadtype{XPBWPolynomial}. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})"))
 (|eval|
  (($ $ (|List| |#1|) (|List| $))
   "\\spad{eval(p,{} [x1,{} ...,{} xn],{} [v1,{} ...,{} vn])} replaces \\spad{\\spad{xi}} by \\spad{\\spad{vi}} in \\spad{p}.") 
  (($ $ |#1| $)
   "\\spad{eval(p,{} x,{} v)} replaces \\spad{x} by \\spad{v} in \\spad{p}."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of distinct entries of \\spad{x}."))
 (|trunc|
  (($ $ (|NonNegativeInteger|))
   "\\spad{trunc(p,{} n)} returns the polynomial \\spad{p} truncated at order \\spad{n}."))
 (|mirror|
  (($ $)
   "\\spad{mirror(x)} returns \\spad{Sum(r_i mirror(w_i))} if \\spad{x} is \\spad{Sum(r_i w_i)}."))
 (|LiePoly|
  (($ (|LyndonWord| |#1|))
   "\\spad{LiePoly(l)} returns the bracketed form of \\spad{l} as a Lie polynomial."))
 (|rquo|
  (((|XRecursivePolynomial| |#1| |#2|) (|XRecursivePolynomial| |#1| |#2|) $)
   "\\spad{rquo(x,{} y)} returns the right simplification of \\spad{x} by \\spad{y}."))
 (|lquo|
  (((|XRecursivePolynomial| |#1| |#2|) (|XRecursivePolynomial| |#1| |#2|) $)
   "\\spad{lquo(x,{} y)} returns the left simplification of \\spad{x} by \\spad{y}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(x)} returns the greatest length of a word in the support of \\spad{x}."))
 (|coerce|
  (((|XRecursivePolynomial| |#1| |#2|) $)
   "\\spad{coerce(x)} returns \\spad{x} as a recursive polynomial.")
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{coerce(x)} returns \\spad{x} as distributed polynomial.")
  (($ |#1|) "\\spad{coerce(x)} returns \\spad{x} as a Lie polynomial."))
 (|coef|
  ((|#2| (|XRecursivePolynomial| |#1| |#2|) $)
   "\\spad{coef(x,{} y)} returns the scalar product of \\spad{x} by \\spad{y},{} the set of words being regarded as an orthogonal basis."))) 
NIL 
(|FiniteLinearAggregateSort| S V) 
((|constructor|
  (NIL
   "This package exports 3 sorting algorithms which work over FiniteLinearAggregates."))
 (|shellSort|
  ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|)
   "\\spad{shellSort(f,{} agg)} sorts the aggregate agg with the ordering function \\spad{f} using the shellSort algorithm."))
 (|heapSort|
  ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|)
   "\\spad{heapSort(f,{} agg)} sorts the aggregate agg with the ordering function \\spad{f} using the heapsort algorithm."))
 (|quickSort|
  ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|)
   "\\spad{quickSort(f,{} agg)} sorts the aggregate agg with the ordering function \\spad{f} using the quicksort algorithm."))) 
NIL 
(|FullyLinearlyExplicitOver&| S R) 
((|constructor|
  (NIL
   "\\spad{S} is \\spadtype{FullyLinearlyExplicitOver R} means that \\spad{S} is a \\spadtype{LinearlyExplicitOver R} and,{} in addition,{} if \\spad{R} is a \\spadtype{LinearlyExplicitOver Integer},{} then so is \\spad{S}"))) 
((|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))) 
(|FullyLinearlyExplicitOver| R) 
((|constructor|
  (NIL
   "\\spad{S} is \\spadtype{FullyLinearlyExplicitOver R} means that \\spad{S} is a \\spadtype{LinearlyExplicitOver R} and,{} in addition,{} if \\spad{R} is a \\spadtype{LinearlyExplicitOver Integer},{} then so is \\spad{S}"))) 
NIL 
(|FloatLiouvilianFunctions|) 
((|Shi|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{Shi(f)} denotes the hyperbolic sine integral")
  (((|Float|) (|Float|))
   "\\spad{Shi(f)} denotes the hyperbolic sine integral"))
 (|Chi|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{Chi(f)} denotes the hyperbolic cosine integral")
  (((|Float|) (|Float|))
   "\\spad{Chi(f)} denotes the hyperbolic cosine integral"))
 (|Si|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{\\spad{Si}(f)} denotes the sine integral")
  (((|Float|) (|Float|)) "\\spad{\\spad{Si}(f)} denotes the sine integral"))
 (|Ci|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{\\spad{Ci}(f)} denotes the cosine integral")
  (((|Float|) (|Float|)) "\\spad{\\spad{Ci}(f)} denotes the cosine integral"))
 (|li|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{\\spad{li}(f)} denotes the logarithmic integral")
  (((|Float|) (|Float|))
   "\\spad{\\spad{li}(f)} denotes the logarithmic integral"))
 (|Ei|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{\\spad{Ei}(f)} denotes the exponential integral")
  (((|Float|) (|Float|))
   "\\spad{\\spad{Ei}(f)} denotes the exponential integral"))
 (|fresnelS|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{fresnelS(f)} denotes the Fresnel integral \\spad{S}")
  (((|Float|) (|Float|))
   "\\spad{fresnelS(f)} denotes the Fresnel integral \\spad{S}"))
 (|fresnelC|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{fresnelC(f)} denotes the Fresnel integral \\spad{C}")
  (((|Float|) (|Float|))
   "\\spad{fresnelC(f)} denotes the Fresnel integral \\spad{C}"))
 (|erfi|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{erfi(f)} denotes \\spad{-\\%i*erf(\\%i*f)}")
  (((|Float|) (|Float|)) "\\spad{erfi(f)} denotes \\spad{-\\%i*erf(\\%i*f)}"))
 (|erf|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{erf(f)} denotes the error function")
  (((|Float|) (|Float|)) "\\spad{erf(f)} denotes the error function"))
 (|gamma| (((|Complex| (|Float|))) "\\spad{gamma()} is the Euler constant"))) 
NIL 
(|Float|) 
((|constructor|
  (NIL
   "\\spadtype{Float} implements arbitrary precision floating point arithmetic. The number of significant digits of each operation can be set to an arbitrary value (the default is 20 decimal digits). The operation \\spadfunFrom{float}{FloatingPointSystem}(mantissa,{} exponent,{} \\spadfunFrom{base}{FloatingPointSystem}) for integer \\spad{mantissa},{} \\spad{exponent} specifies the number \\spad{mantissa} * \\spadfunFrom{base}{FloatingPointSystem} ^ \\spad{exponent} The underlying representation for floats is binary not decimal. The implications of this are described below. \\blankline The model adopted is that arithmetic operations are rounded to to nearest unit in the last place,{} that is,{} accurate to within 2^(-\\spadfunFrom{bits}{FloatingPointSystem}). Also,{} the elementary functions and constants are accurate to one unit in the last place. A float is represented as a record of two integers,{} the mantissa and the exponent. The \\spadfunFrom{base}{FloatingPointSystem} of the representation is binary,{} hence a \\spad{Record(m: mantissa,{} e: exponent)} represents the number \\spad{m * 2 ^ e}. Though it is not assumed that the underlying integers are represented with a binary \\spadfunFrom{base}{FloatingPointSystem},{} the code will be most efficient when this is the the case (this is \\spad{true} in most implementations of Lisp). The decision to choose the \\spadfunFrom{base}{FloatingPointSystem} to be binary has some unfortunate consequences. First,{} decimal numbers like 0.3 cannot be represented exactly. Second,{} there is a further loss of accuracy during conversion to decimal for output. To compensate for this,{} if \\spad{d} digits of precision are specified,{} \\spad{1 + ceiling(log2(10^d))} bits are used. Two numbers that are displayed identically may therefore be not equal. On the other hand,{} a significant efficiency loss would be incurred if we chose to use a decimal \\spadfunFrom{base}{FloatingPointSystem} when the underlying integer base is binary. \\blankline Algorithms used: For the elementary functions,{} the general approach is to apply identities so that the taylor series can be used,{} and,{} so that it will converge within \\spad{O( sqrt n )} steps. For example,{} using the identity \\spad{exp(x) = exp(x/2)^2},{} we can compute \\spad{exp(1/3)} to \\spad{n} digits of precision as follows. We have \\spad{exp(1/3) = exp(2 ^ (-sqrt s) / 3) ^ (2 ^ sqrt s)}. The taylor series will converge in less than sqrt \\spad{n} steps and the exponentiation requires sqrt \\spad{n} multiplications for a total of \\spad{2 sqrt n} multiplications. Assuming integer multiplication costs \\spad{O( n^2 )} the overall running time is \\spad{O( sqrt(n) n^2 )}. This approach is the best known approach for precisions up to about 10,{} 000 digits at which point the methods of Brent which are \\spad{O( log(n) n^2 )} become competitive. Note also that summing the terms of the taylor series for the elementary functions is done using integer operations. This avoids the overhead of floating point operations and results in efficient code at low precisions. This implementation makes no attempt to reuse storage,{} relying on the underlying system to do \\spadgloss{garbage collection}. \\spad{I} estimate that the efficiency of this package at low precisions could be improved by a factor of 2 if in-place operations were available. \\blankline Running times: in the following,{} \\spad{n} is the number of bits of precision \\indented{5}{\\spad{*},{} \\spad{/},{} \\spad{sqrt},{} \\spad{\\spad{pi}},{} \\spad{exp1},{} \\spad{log2},{} \\spad{log10}: \\spad{ O( n^2 )}} \\indented{5}{\\spad{exp},{} \\spad{log},{} \\spad{sin},{} \\spad{atan}:\\space{2}\\spad{ O( sqrt(n) n^2 )}} The other elementary functions are coded in terms of the ones above."))
 (|outputSpacing|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputSpacing(n)} inserts a space after \\spad{n} (default 10) digits on output; outputSpacing(0) means no spaces are inserted."))
 (|outputGeneral|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputGeneral(n)} sets the output mode to general notation with \\spad{n} significant digits displayed.")
  (((|Void|))
   "\\spad{outputGeneral()} sets the output mode (default mode) to general notation; numbers will be displayed in either fixed or floating (scientific) notation depending on the magnitude."))
 (|outputFixed|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputFixed(n)} sets the output mode to fixed point notation,{} with \\spad{n} digits displayed after the decimal point.")
  (((|Void|))
   "\\spad{outputFixed()} sets the output mode to fixed point notation; the output will contain a decimal point."))
 (|outputFloating|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputFloating(n)} sets the output mode to floating (scientific) notation with \\spad{n} significant digits displayed after the decimal point.")
  (((|Void|))
   "\\spad{outputFloating()} sets the output mode to floating (scientific) notation,{} \\spadignore{i.e.} \\spad{mantissa * 10 exponent} is displayed as \\spad{0.mantissa E exponent}."))
 (|convert|
  (($ (|DoubleFloat|))
   "\\spad{convert(x)} converts a \\spadtype{DoubleFloat} \\spad{x} to a \\spadtype{Float}."))
 (|atan|
  (($ $ $)
   "\\spad{atan(x,{} y)} computes the arc tangent from \\spad{x} with phase \\spad{y}."))
 (|exp1| (($) "\\spad{exp1()} returns exp 1: \\spad{2.7182818284...}."))
 (|log10|
  (($ $) "\\spad{log10(x)} computes the logarithm for \\spad{x} to base 10.")
  (($) "\\spad{log10()} returns \\spad{ln 10}: \\spad{2.3025809299...}."))
 (|log2|
  (($ $) "\\spad{log2(x)} computes the logarithm for \\spad{x} to base 2.")
  (($)
   "\\spad{log2()} returns \\spad{ln 2},{} \\spadignore{i.e.} \\spad{0.6931471805...}."))
 (|rationalApproximation|
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n,{} b)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< b^(-n)},{} that is \\spad{|(r-f)/f| < b^(-n)}.")
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< 10^(-n)}."))
 (|shift|
  (($ $ (|Integer|))
   "\\spad{shift(x,{} n)} adds \\spad{n} to the exponent of float \\spad{x}."))
 (|relerror|
  (($ $ $)
   "\\spad{relerror(x,{} y)} computes the absolute value of \\spad{(x - y)/y},{} when \\spad{y \\~= 0}."))
 (|normalize|
  (($ $) "\\spad{normalize(x)} normalizes \\spad{x} at current precision."))) 
((|HasCategory| $ '(|arbitraryPrecision|))
 (AND (|not| (|HasCategory| $ '(|arbitraryExponent|)))
      (|not| (|HasCategory| $ '(|arbitraryPrecision|))))) 
(|FloatingComplexPackage| |Par|) 
((|constructor|
  (NIL
   "\\indented{3}{This is a package for the approximation of complex solutions for} systems of equations of rational functions with complex rational coefficients. The results are expressed as either complex rational numbers or complex floats depending on the type of the precision parameter which can be either a rational number or a floating point number."))
 (|complexRoots|
  (((|List| (|List| (|Complex| |#1|)))
    (|List| (|Fraction| (|Polynomial| (|Complex| (|Integer|)))))
    (|List| (|Symbol|)) |#1|)
   "\\spad{complexRoots(lrf,{} lv,{} eps)} finds all the complex solutions of a list of rational functions with rational number coefficients with respect the variables appearing in \\spad{lv}. Each solution is computed to precision eps and returned as list corresponding to the order of variables in \\spad{lv}.")
  (((|List| (|Complex| |#1|))
    (|Fraction| (|Polynomial| (|Complex| (|Integer|)))) |#1|)
   "\\spad{complexRoots(rf,{} eps)} finds all the complex solutions of a univariate rational function with rational number coefficients. The solutions are computed to precision eps."))
 (|complexSolve|
  (((|List| (|Equation| (|Polynomial| (|Complex| |#1|))))
    (|Equation| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))) |#1|)
   "\\spad{complexSolve(eq,{} eps)} finds all the complex solutions of the equation \\spad{eq} of rational functions with rational rational coefficients with respect to all the variables appearing in \\spad{eq},{} with precision eps.")
  (((|List| (|Equation| (|Polynomial| (|Complex| |#1|))))
    (|Fraction| (|Polynomial| (|Complex| (|Integer|)))) |#1|)
   "\\spad{complexSolve(p,{} eps)} find all the complex solutions of the rational function \\spad{p} with complex rational coefficients with respect to all the variables appearing in \\spad{p},{} with precision eps.")
  (((|List| (|List| (|Equation| (|Polynomial| (|Complex| |#1|)))))
    (|List| (|Equation| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))))
    |#1|)
   "\\spad{complexSolve(leq,{} eps)} finds all the complex solutions to precision eps of the system \\spad{leq} of equations of rational functions over complex rationals with respect to all the variables appearing in \\spad{lp}.")
  (((|List| (|List| (|Equation| (|Polynomial| (|Complex| |#1|)))))
    (|List| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))) |#1|)
   "\\spad{complexSolve(lp,{} eps)} finds all the complex solutions to precision eps of the system \\spad{lp} of rational functions over the complex rationals with respect to all the variables appearing in \\spad{lp}."))) 
NIL 
(|FloatingRealPackage| |Par|) 
((|constructor|
  (NIL
   "\\indented{3}{This is a package for the approximation of real solutions for} systems of polynomial equations over the rational numbers. The results are expressed as either rational numbers or floats depending on the type of the precision parameter which can be either a rational number or a floating point number."))
 (|realRoots|
  (((|List| |#1|) (|Fraction| (|Polynomial| (|Integer|))) |#1|)
   "\\spad{realRoots(rf,{} eps)} finds the real zeros of a univariate rational function with precision given by eps.")
  (((|List| (|List| |#1|)) (|List| (|Fraction| (|Polynomial| (|Integer|))))
    (|List| (|Symbol|)) |#1|)
   "\\spad{realRoots(lp,{} lv,{} eps)} computes the list of the real solutions of the list \\spad{lp} of rational functions with rational coefficients with respect to the variables in \\spad{lv},{} with precision eps. Each solution is expressed as a list of numbers in order corresponding to the variables in \\spad{lv}."))
 (|solve|
  (((|List| (|Equation| (|Polynomial| |#1|)))
    (|Equation| (|Fraction| (|Polynomial| (|Integer|)))) |#1|)
   "\\spad{solve(eq,{} eps)} finds all of the real solutions of the univariate equation \\spad{eq} of rational functions with respect to the unique variables appearing in \\spad{eq},{} with precision eps.")
  (((|List| (|Equation| (|Polynomial| |#1|)))
    (|Fraction| (|Polynomial| (|Integer|))) |#1|)
   "\\spad{solve(p,{} eps)} finds all of the real solutions of the univariate rational function \\spad{p} with rational coefficients with respect to the unique variable appearing in \\spad{p},{} with precision eps.")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|))))
    (|List| (|Equation| (|Fraction| (|Polynomial| (|Integer|))))) |#1|)
   "\\spad{solve(leq,{} eps)} finds all of the real solutions of the system \\spad{leq} of equationas of rational functions with respect to all the variables appearing in \\spad{lp},{} with precision eps.")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|))))
    (|List| (|Fraction| (|Polynomial| (|Integer|)))) |#1|)
   "\\spad{solve(lp,{} eps)} finds all of the real solutions of the system \\spad{lp} of rational functions over the rational numbers with respect to all the variables appearing in \\spad{lp},{} with precision eps."))) 
NIL 
(|FreeModule| R S) 
((|constructor|
  (NIL
   "A \\spad{bi}-module is a free module over a ring with generators indexed by an ordered set. Each element can be expressed as a finite linear combination of generators. Only non-zero terms are stored. old domain \\spad{FreeModule1} was merged to it in May 2009 The description of the latter: \\indented{2}{This domain implements linear combinations} \\indented{2}{of elements from the domain \\spad{S} with coefficients} \\indented{2}{in the domain \\spad{R} where \\spad{S} is an ordered set} \\indented{2}{and \\spad{R} is a ring (which may be non-commutative).} \\indented{2}{This domain is used by domains of non-commutative algebra such as:} \\indented{6}{\\spadtype{XDistributedPolynomial},{}} \\indented{6}{\\spadtype{XRecursivePolynomial}.} \\indented{2}{Author: Michel Petitot (petitot@lifl.\\spad{fr})}"))
 (*
  (($ |#2| |#1|)
   "\\spad{s*r} returns the product \\spad{r*s} used by \\spadtype{XRecursivePolynomial}")
  (($ |#1| |#2|) "\\spad{r*b} returns the product of \\spad{r} by \\spad{b}."))) 
((|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
      (|HasCategory| |#2| '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#2| '(|Comparable|))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
          (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))) 
(|FreeModuleFunctions2| R S M1 M2) 
((|constructor| (NIL "linear extensions of maps on the basis"))
 (|linearExtend|
  ((|#4| (|Mapping| |#4| |#2|) |#3|)
   "\\spad{linearExtend: (f,{} x)} returns the linear extension of a map defined on the basis of \\spad{M2} applied to a linear combination"))) 
NIL 
(|FreeMagma| |VarSet|) 
((|constructor|
  (NIL
   "This type is the basic representation of parenthesized words (binary trees over arbitrary symbols) useful in \\spadtype{LiePolynomial}. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of distinct entries of \\spad{x}."))
 (|right|
  (($ $)
   "\\spad{right(x)} returns right subtree of \\spad{x} or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(x)} tests if \\spad{x} is a tree with only one entry."))
 (|rest|
  (($ $)
   "\\spad{rest(x)} return \\spad{x} without the first entry or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|mirror|
  (($ $)
   "\\spad{mirror(x)} returns the reversed word of \\spad{x}. That is \\spad{x} itself if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true} and \\spad{mirror(z) * mirror(y)} if \\spad{x} is \\spad{y*z}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{VarSet}. \\spad{N}.\\spad{B}. This operation does not take into account the tree structure of its arguments. Thus this is not a total ordering."))
 (|length|
  (((|PositiveInteger|) $)
   "\\spad{length(x)} returns the number of entries in \\spad{x}."))
 (|left|
  (($ $)
   "\\spad{left(x)} returns left subtree of \\spad{x} or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|first|
  ((|#1| $) "\\spad{first(x)} returns the first entry of the tree \\spad{x}."))
 (|coerce|
  (((|FreeMonoid| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMonoid}(VarSet) corresponding to \\spad{x} by removing parentheses."))
 (* (($ $ $) "\\spad{x*y} returns the tree \\spad{[x,{} y]}."))) 
NIL 
(|FortranMatrixCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranMatrixCategory} provides support for producing Functions and Subroutines when the input to these is a FriCAS object of type \\spadtype{Matrix} or in domains involving \\spadtype{FortranCode}."))
 (|coerce|
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \\spadtype{SymbolTable} component.")
  (($ (|FortranCode|))
   "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|List| (|FortranCode|)))
   "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|Matrix| (|MachineFloat|)))
   "\\spad{coerce(v)} produces an ASP which returns the value of \\spad{v}."))) 
NIL 
(|FreeModuleCategory&| A R S) 
((|constructor|
  (NIL
   "A domain of this category implements formal linear combinations of elements from a domain \\spad{Basis} with coefficients in a domain \\spad{R}. The domain \\spad{Basis} needs only to belong to the category \\spadtype{SetCategory} and \\spad{R} to the category \\spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \\spadtype{XDistributedPolynomial} constructor for examples of domains built with the \\spadtype{FreeModuleCategory} category constructor. Author: Michel Petitot (petitot@lifl.\\spad{fr}) \\blankline Note (Franz Lehner,{} June 2009): \\spad{FreeModule} originally was not of FreeModuleCategory. Some functions (like \\spad{support},{} \\spad{coefficients},{} \\spad{monomials},{} ...) from here could be moved to \\spad{IndexedDirectProductCategory} but at the moment there is no need for this."))
 (|linearExtend|
  ((|#2| (|Mapping| |#2| |#3|) $)
   "\\spad{linearExtend: (f,{} x)} returns the linear extension of a map defined on the basis applied to a linear combination"))
 (|coefficient|
  ((|#2| $ |#3|)
   "\\spad{coefficient(x,{} s)} returns the coefficient of the basis element \\spad{s}"))
 (|monomials|
  (((|List| $) $)
   "\\spad{monomials(x)} returns the list of \\spad{r_i*b_i} whose sum is \\spad{x}."))
 (|support|
  (((|List| |#3|) $)
   "\\spad{support(x)} returns the list of basis elements with nonzero coefficients."))
 (|coefficients|
  (((|List| |#2|) $)
   "\\spad{coefficients(x)} returns the list of coefficients of \\spad{x}."))) 
((|HasCategory| |#2| '(|CommutativeRing|))) 
(|FreeModuleCategory| R S) 
((|constructor|
  (NIL
   "A domain of this category implements formal linear combinations of elements from a domain \\spad{Basis} with coefficients in a domain \\spad{R}. The domain \\spad{Basis} needs only to belong to the category \\spadtype{SetCategory} and \\spad{R} to the category \\spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \\spadtype{XDistributedPolynomial} constructor for examples of domains built with the \\spadtype{FreeModuleCategory} category constructor. Author: Michel Petitot (petitot@lifl.\\spad{fr}) \\blankline Note (Franz Lehner,{} June 2009): \\spad{FreeModule} originally was not of FreeModuleCategory. Some functions (like \\spad{support},{} \\spad{coefficients},{} \\spad{monomials},{} ...) from here could be moved to \\spad{IndexedDirectProductCategory} but at the moment there is no need for this."))
 (|linearExtend|
  ((|#1| (|Mapping| |#1| |#2|) $)
   "\\spad{linearExtend: (f,{} x)} returns the linear extension of a map defined on the basis applied to a linear combination"))
 (|coefficient|
  ((|#1| $ |#2|)
   "\\spad{coefficient(x,{} s)} returns the coefficient of the basis element \\spad{s}"))
 (|monomials|
  (((|List| $) $)
   "\\spad{monomials(x)} returns the list of \\spad{r_i*b_i} whose sum is \\spad{x}."))
 (|support|
  (((|List| |#2|) $)
   "\\spad{support(x)} returns the list of basis elements with nonzero coefficients."))
 (|coefficients|
  (((|List| |#1|) $)
   "\\spad{coefficients(x)} returns the list of coefficients of \\spad{x}."))) 
NIL 
(|FreeModuleCoefficientFunctions2| R1 R2 S M1 M2) 
((|constructor|
  (NIL
   "A package for mappings between coefficients of free modules over the same base set."))
 (|map|
  ((|#5| (|Mapping| |#2| |#1|) |#4|)
   "\\spad{map(f,{} x)} applies the function \\spad{f} to every coefficient of \\spad{x}"))) 
NIL 
(|FortranMatrixFunctionCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranMatrixFunctionCategory} provides support for producing Functions and Subroutines representing matrices of expressions."))
 (|retractIfCan|
  (((|Union| $ "failed") (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Matrix| (|Fraction| (|Polynomial| (|Float|)))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Matrix| (|Polynomial| (|Integer|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Matrix| (|Polynomial| (|Float|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Matrix| (|Expression| (|Integer|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Matrix| (|Expression| (|Float|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|retract|
  (($ (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Matrix| (|Fraction| (|Polynomial| (|Float|)))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Matrix| (|Polynomial| (|Integer|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Matrix| (|Polynomial| (|Float|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Matrix| (|Expression| (|Integer|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Matrix| (|Expression| (|Float|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|coerce|
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \\spadtype{SymbolTable} component.")
  (($ (|FortranCode|))
   "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|List| (|FortranCode|)))
   "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
NIL 
(|FiniteMoebiusFunction| P) 
((|constructor|
  (NIL
   "A domain for Moebius functions of explicit subposets of infinite posets."))
 (|moebiusMatrix|
  (((|Matrix| (|Integer|)) $)
   "\\spad{moebiusMatrix(P)} returns the Moebius matrix"))
 (|members|
  (((|List| |#1|) $)
   "\\spad{members(mf)} returns the elements of the subposet"))
 (|apply|
  (((|Integer|) $ |#1| |#1|)
   "\\spad{mf(\\spad{pi},{} \\spad{si})} evaluates the Moebius function \\spad{mf} at \\spad{pi} and \\spad{si}"))
 (|moebiusMu|
  (((|Integer|) $ |#1| |#1|)
   "\\spad{moebiusMu(mf,{} \\spad{pi},{} \\spad{si})} evaluates the Moebius function"))
 (|moebiusFunction|
  (($ (|List| |#1|))
   "\\spad{moebiusFunction(pp)} creates the canonical zeta matrix and inverts it."))) 
NIL 
(|FreeMonoid| S) 
((|constructor|
  (NIL
   "The free monoid on a set \\spad{S} is the monoid of finite products of the form \\spad{reduce(*,{} [\\spad{si} ^ \\spad{ni}])} where the \\spad{si}\\spad{'s} are in \\spad{S},{} and the \\spad{ni}\\spad{'s} are nonnegative integers. The multiplication is not commutative. When \\spad{S} is an OrderedSet,{} then FreeMonoid(\\spad{S}) has order: for two elements \\spad{x} and \\spad{y} the relation \\spad{x < y} holds if either \\spad{length(x) < length(y)} holds or if these lengths are equal and if \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{S}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the pure lexicographical ordering induced by \\spad{S}."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of variables of \\spad{x}."))
 (|mapGen|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{mapGen(f,{} a1\\^e1 ... an\\^en)} returns \\spad{f(a1)\\^e1 ... f(an)\\^en}."))
 (|mapExpon|
  (($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $)
   "\\spad{mapExpon(f,{} a1\\^e1 ... an\\^en)} returns \\spad{a1\\^f(e1) ... an\\^f(en)}."))
 (|nthFactor|
  ((|#1| $ (|Integer|))
   "\\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \\spad{x}."))
 (|nthExpon|
  (((|NonNegativeInteger|) $ (|Integer|))
   "\\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \\spad{x}."))
 (|factors|
  (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $)
   "\\spad{factors(a1\\^e1,{} ...,{} an\\^en)} returns \\spad{[[a1,{} e1],{} ...,{} [an,{} en]]}."))
 (|length|
  (((|NonNegativeInteger|) $)
   "\\spad{length(x)} returns the length of \\spad{x}."))
 (|size|
  (((|NonNegativeInteger|) $)
   "\\spad{size(x)} returns the number of monomials in \\spad{x}."))
 (|overlap|
  (((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $)
   "\\spad{overlap(x,{} y)} returns \\spad{[l,{} m,{} r]} such that \\spad{x = l * m},{} \\spad{y = m * r} and \\spad{l} and \\spad{r} have no overlap,{} \\spadignore{i.e.} \\spad{overlap(l,{} r) = [l,{} 1,{} r]}."))
 (|divide|
  (((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $)
   "\\spad{divide(x,{} y)} returns the left and right exact quotients of \\spad{x} by \\spad{y},{} \\spadignore{i.e.} \\spad{[l,{} r]} such that \\spad{x = l * y * r},{} \"failed\" if \\spad{x} is not of the form \\spad{l * y * r}."))
 (|rquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{rquo(x,{} s)} returns the exact right quotient of \\spad{x} by \\spad{s}.")
  (((|Union| $ "failed") $ $)
   "\\spad{rquo(x,{} y)} returns the exact right quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = q * y},{} \"failed\" if \\spad{x} is not of the form \\spad{q * y}."))
 (|lquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{lquo(x,{} s)} returns the exact left quotient of \\spad{x} by \\spad{s}.")
  (((|Union| $ "failed") $ $)
   "\\spad{lquo(x,{} y)} returns the exact left quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = y * q},{} \"failed\" if \\spad{x} is not of the form \\spad{y * q}."))
 (|hcrf|
  (($ $ $)
   "\\spad{hcrf(x,{} y)} returns the highest common right factor of \\spad{x} and \\spad{y},{} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = a d} and \\spad{y = b d}."))
 (|hclf|
  (($ $ $)
   "\\spad{hclf(x,{} y)} returns the highest common left factor of \\spad{x} and \\spad{y},{} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = d a} and \\spad{y = d b}."))
 (|mirror| (($ $) "\\spad{mirror(x)} returns the reversed word of \\spad{x}."))
 (|rest| (($ $) "\\spad{rest(x)} returns \\spad{x} except the first letter."))
 (|first| ((|#1| $) "\\spad{first(x)} returns the first letter of \\spad{x}."))
 (^
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{s ^ n} returns the product of \\spad{s} by itself \\spad{n} times."))
 (*
  (($ $ |#1|)
   "\\spad{x * s} returns the product of \\spad{x} by \\spad{s} on the right.")
  (($ |#1| $)
   "\\spad{s * x} returns the product of \\spad{x} by \\spad{s} on the left."))) 
((|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|BasicType|))) 
(|Format1D|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{Format1D} provides a coercion from \\spadtype{OutputForm}} to a one-dimensional format such that the output can be pasted back as input,{}"))) 
NIL 
(|Format2D|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{Format2D} provides a coercion from} \\spadtype{OutputForm} to two-dimensional format."))) 
NIL 
(|FortranMachineTypeCategory|) 
((|constructor|
  (NIL
   "A category of domains which model machine arithmetic used by machines in the AXIOM-NAG link."))) 
NIL 
(|FormatterCategory&| S) 
((|matrix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|))
   "\\spad{matrix(left,{} right)} returns a handler that typesets a matrix with parentheses given by \\spad{left} and right where rows are formatted using \\spad{h}."))
 (|pile|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{pile()} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then puts them on top of each other left adjusted. The baseline corresponds to the baseline of the first argument."))
 (|vconcat|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{vconcat(hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then puts them on top of each other where the lines are centered. The baseline corresponds to the baseline of the first argument."))
 (|zag|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{zag} is a handler such that \\spad{zag(prec,{} args)} formats one part of a continued fraction."))
 (|binomial|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{binomial} is a handler such that \\spad{binomial(prec,{}args)} formats a binomial expresssion of the first two arguments."))
 (|slash|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format a fraction linearly. \\spad{slash(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1} and the second argument by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|fraction|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format a fraction. \\spad{fraction(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument by \\spad{h1} and the second argument by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|power|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{power(op,{} p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats \\spad{args.1} and \\spad{args.2} according to \\spad{h1} and \\spad{h2},{} respectively. Outer parentheses are added if \\spad{p < prec}."))
 (|prime|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{prime(p)} returns a handler that treats the typesetting of primes. Note that differentiate(a,{} 3) gives the following \\spad{s}-expression in OutputForm: (PRIME a \",{},{},{}\") whereas differentiate(a+b,{} 4) gives: (PRIME (+ a \\spad{b}) (PAREN \"iv\")). the precedence \\spad{p1}. Outer parentheses are added if \\spad{p < prec}. See also the auxiliary function \\spad{numberOfPrimes}."))
 (|numberOfPrimes|
  (((|Integer|) (|OutputForm|))
   "\\spad{numberOfPrimes(e)} counts the number of commas in \\spad{e} and returns it. If \\spad{s} does not only contain commas,{} but has a parenthesis at the beginning and the end of the string,{} then the part between the parentheses is interpreted as a roman numeral and translated into an integer. For any other format the function returns \\spad{-1}."))
 (|altsupersub|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{altsupersub(p)} returns a handler such that \\spad{altsupersub(p)(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The remaining arguments are formatted without parentheses and interpreted as subscript,{} superscript,{} subscript,{} superscript,{} etc. where the subscripts and superscripts are pairwise aligned. Outer parentheses are added if \\spad{p < prec}."))
 (|subscript|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{subscript(p)} returns a handler such that \\spad{subscript(p)(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The other arguments are formatted without parentheses and interpreted as subscripts separated by commas. Outer parentheses are added if \\spad{p < prec}."))
 (|scripts|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "Formats super- and subscripts also presuper and presub. \\spad{scripts(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The other arguments are interpreted as subscript,{} superscript,{} presuperscript,{} and presubscript (in this order). Outer parentheses are added if \\spad{p < prec}."))
 (|nthRoot|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format square roots and \\spad{n}th roots. \\spad{nthRoot(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1}. If there is no second argument,{} then the \\spad{n}th root is a square root and formatted accordingly. Otherwise the second argument is formatted by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|box|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{box(hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the arguments via \\spad{hh(prec,{} args)} and then draws a box frame around the resulting box."))
 (|overbar|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{overbar(p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats arguments via \\spad{hh(p,{} args)} and then draws a bar over the resulting box. Outer parentheses are added if \\spad{p < prec}."))
 (|theMap|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{theMap} is a special handler to format a function."))
 (|product|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{product(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats a product with product sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|sum|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{sum(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats a sum expresssion with summation sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|integral|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{integral(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the expression as an integral with integral sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|naryPlus|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nary(plus,{} minus,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats each argument according to \\spad{hh}. All resulting boxes will be horizontally concatenated with \\spad{box minus} or \\spad{box plus} inbetween depending on whether the respective argument starts with a unary \\spad{minus} or not. Outer parentheses are added if \\spad{p < prec}. This is a special handler that treats the case that a sum is represented as a nary expression that contains unary subexpressions that are unary \\spad{minus} expressions. This handler transforms something like (+ a (- \\spad{b})) into a - \\spad{b}."))
 (|nary|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nary(s,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats each argument according to \\spad{hh}. All resulting boxes will be horizontally concatenated with \\spad{box s} inbetween. Outer parentheses are added if \\spad{p < prec}."))
 (|infix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{infix(op,{} p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument by \\spad{h1} and the second argument by \\spad{h2}. Both boxes will be horizontally concatenated with \\spad{box op} in the middle. Outer parentheses are added if \\spad{p < prec}."))
 (|binary|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{binary(h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1} and the second argument by \\spad{h2}. Both boxes will be horizontally concatenated. binary(\\spad{h1},{} \\spad{h2}) is equal to infix(\\spad{\"\"},{} maxPrecedence(),{} \\spad{h1},{} \\spad{h2})"))
 (|prefix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{prefix(s,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then prefixes this box by \\spad{box s}. Outer parentheses are added if \\spad{p < prec}."))
 (|bracket|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{bracket(lb,{} rb,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats its first argument according to \\spad{hh} and then put left and right brackets given by \\spad{lb} and \\spad{rb} around the resulting box."))
 (|precedence|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{precedence(p,{} hh)} returns a handler \\spad{h} that \\spad{h(prec,{} args)} returns \\spad{hh(p,{} args)}. This handler can be used to change the context in which an expression is formatted."))
 (|formatConstant|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|))
   "\\spad{formatConstant(op)} is a handler to format constant operators."))
 (|nothing|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nothing()} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} returns an empty box. This corresponds to NOTHING in \\spad{OutputForm}."))
 (|parenthesizeIf|
  (((|OutputBox|) (|Boolean|) (|OutputBox|))
   "\\spad{parenthesizeIf(paren?,{} bx)} returns parentheses (of appropriate size if \\spad{paren?} is \\spad{true}. Otherwise,{} \\spad{bx} is returned."))
 (|parenthesize|
  (((|OutputBox|) (|String|) (|String|) (|OutputBox|))
   "\\spad{parenthesize(lb,{} rb,{} bx)} returns the box \\spad{bx} with left and right brackets (\\spad{lb} and \\spad{rb}) around it."))
 (|operatorHandlers|
  (((|OperatorHandlers|
     (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))))
   "\\spad{operatorHandlers()} returns an internal data structure that is used for the selection of respective handlers."))
 (|formatFunctionSymbol|
  (((|OutputBox|) (|String|))
   "\\spad{formatFunctionSymbol(s)} formats an otherwise unknown function symbol."))
 (|formatSymbol|
  (((|OutputBox|) (|String|)) "\\spad{formatSymbol(s)} formats a symbol."))
 (|formatString|
  (((|OutputBox|) (|String|)) "\\spad{formatString(s)} formats a string."))
 (|formatFloat|
  (((|OutputBox|) (|String|))
   "\\spad{formatFloat(s)} formats a floating point number from it string representation in \\spadtype{OutputForm}."))
 (|formatInteger|
  (((|OutputBox|) (|Integer|)) "\\spad{formatInteger(n)} formats an integer."))
 (|formatExpression|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{formatExpression(p)} returns a handler \\spad{h} that \\spad{h(prec,{} args)} returns \\spad{formatExpression(first args,{} p)}. This handler is used to change the precedence context in which the argument is formatted.")
  (((|OutputBox|) (|OutputForm|))
   "\\spad{formatExpression(o)} returns \\spad{formatExpression(o,{} minPrecedence())}.")
  (((|OutputBox|) (|OutputForm|) (|Integer|))
   "\\spad{formatExpression(o,{} p)} returns an \\spadtype{OutputBox} that represent the expression \\spad{o} in the respective format when considered in a context with outer precedence \\spad{p}. This function is the main dispatcher function. It first checks whether \\spad{o} is an integer or a string and treats these cases. Then,{} if the number \\spad{n} of arguments is less than 3,{} it tries to find a handler for the top-level operator of \\spad{o}. If none is found,{} it checks for a handler of an \\spad{n}-ary operator. If no handler is found,{} the operator is treated as a function symbol and formatted as such."))
 (|maxPrecedence|
  (((|Integer|))
   "\\spad{maxPrecedence()} returns the maximal precedence value,{}"))
 (|minPrecedence|
  (((|Integer|))
   "\\spad{minPrecedence()} returns the minimal precedence value."))
 (|defaultEpilogue|
  (((|OutputBox|) (|String|))
   "\\spad{defaultEpilogue(label)} returns a box that is used at the end of every format."))
 (|defaultPrologue|
  (((|OutputBox|) (|String|))
   "\\spad{defaultPrologue(label)} returns a box that is used at the beginning of every format."))) 
NIL 
(|FormatterCategory|) 
((|matrix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|))
   "\\spad{matrix(left,{} right)} returns a handler that typesets a matrix with parentheses given by \\spad{left} and right where rows are formatted using \\spad{h}."))
 (|pile|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{pile()} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then puts them on top of each other left adjusted. The baseline corresponds to the baseline of the first argument."))
 (|vconcat|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{vconcat(hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then puts them on top of each other where the lines are centered. The baseline corresponds to the baseline of the first argument."))
 (|zag|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{zag} is a handler such that \\spad{zag(prec,{} args)} formats one part of a continued fraction."))
 (|binomial|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{binomial} is a handler such that \\spad{binomial(prec,{}args)} formats a binomial expresssion of the first two arguments."))
 (|slash|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format a fraction linearly. \\spad{slash(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1} and the second argument by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|fraction|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format a fraction. \\spad{fraction(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument by \\spad{h1} and the second argument by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|power|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{power(op,{} p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats \\spad{args.1} and \\spad{args.2} according to \\spad{h1} and \\spad{h2},{} respectively. Outer parentheses are added if \\spad{p < prec}."))
 (|prime|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{prime(p)} returns a handler that treats the typesetting of primes. Note that differentiate(a,{} 3) gives the following \\spad{s}-expression in OutputForm: (PRIME a \",{},{},{}\") whereas differentiate(a+b,{} 4) gives: (PRIME (+ a \\spad{b}) (PAREN \"iv\")). the precedence \\spad{p1}. Outer parentheses are added if \\spad{p < prec}. See also the auxiliary function \\spad{numberOfPrimes}."))
 (|numberOfPrimes|
  (((|Integer|) (|OutputForm|))
   "\\spad{numberOfPrimes(e)} counts the number of commas in \\spad{e} and returns it. If \\spad{s} does not only contain commas,{} but has a parenthesis at the beginning and the end of the string,{} then the part between the parentheses is interpreted as a roman numeral and translated into an integer. For any other format the function returns \\spad{-1}."))
 (|altsupersub|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{altsupersub(p)} returns a handler such that \\spad{altsupersub(p)(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The remaining arguments are formatted without parentheses and interpreted as subscript,{} superscript,{} subscript,{} superscript,{} etc. where the subscripts and superscripts are pairwise aligned. Outer parentheses are added if \\spad{p < prec}."))
 (|subscript|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{subscript(p)} returns a handler such that \\spad{subscript(p)(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The other arguments are formatted without parentheses and interpreted as subscripts separated by commas. Outer parentheses are added if \\spad{p < prec}."))
 (|scripts|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "Formats super- and subscripts also presuper and presub. \\spad{scripts(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument with respect to the precedence \\spad{p}. The other arguments are interpreted as subscript,{} superscript,{} presuperscript,{} and presubscript (in this order). Outer parentheses are added if \\spad{p < prec}."))
 (|nthRoot|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "Format square roots and \\spad{n}th roots. \\spad{nthRoot(p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1}. If there is no second argument,{} then the \\spad{n}th root is a square root and formatted accordingly. Otherwise the second argument is formatted by \\spad{h2}. Outer parentheses are added if \\spad{p < prec}."))
 (|box|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{box(hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the arguments via \\spad{hh(prec,{} args)} and then draws a box frame around the resulting box."))
 (|overbar|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{overbar(p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats arguments via \\spad{hh(p,{} args)} and then draws a bar over the resulting box. Outer parentheses are added if \\spad{p < prec}."))
 (|theMap|
  (((|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
   "\\spad{theMap} is a special handler to format a function."))
 (|product|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{product(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats a product with product sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|sum|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{sum(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats a sum expresssion with summation sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|integral|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{integral(p)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the expression as an integral with integral sign and respective limits. Outer parentheses are added if \\spad{p < prec}."))
 (|naryPlus|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nary(plus,{} minus,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats each argument according to \\spad{hh}. All resulting boxes will be horizontally concatenated with \\spad{box minus} or \\spad{box plus} inbetween depending on whether the respective argument starts with a unary \\spad{minus} or not. Outer parentheses are added if \\spad{p < prec}. This is a special handler that treats the case that a sum is represented as a nary expression that contains unary subexpressions that are unary \\spad{minus} expressions. This handler transforms something like (+ a (- \\spad{b})) into a - \\spad{b}."))
 (|nary|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nary(s,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats each argument according to \\spad{hh}. All resulting boxes will be horizontally concatenated with \\spad{box s} inbetween. Outer parentheses are added if \\spad{p < prec}."))
 (|infix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{infix(op,{} p,{} h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument by \\spad{h1} and the second argument by \\spad{h2}. Both boxes will be horizontally concatenated with \\spad{box op} in the middle. Outer parentheses are added if \\spad{p < prec}."))
 (|binary|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{binary(h1,{} h2)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats the first argument according to \\spad{h1} and the second argument by \\spad{h2}. Both boxes will be horizontally concatenated. binary(\\spad{h1},{} \\spad{h2}) is equal to infix(\\spad{\"\"},{} maxPrecedence(),{} \\spad{h1},{} \\spad{h2})"))
 (|prefix|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|Integer|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{prefix(s,{} p,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats args according to \\spad{hh} and then prefixes this box by \\spad{box s}. Outer parentheses are added if \\spad{p < prec}."))
 (|bracket|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{bracket(lb,{} rb,{} hh)} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} formats its first argument according to \\spad{hh} and then put left and right brackets given by \\spad{lb} and \\spad{rb} around the resulting box."))
 (|precedence|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{precedence(p,{} hh)} returns a handler \\spad{h} that \\spad{h(prec,{} args)} returns \\spad{hh(p,{} args)}. This handler can be used to change the context in which an expression is formatted."))
 (|formatConstant|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|))
   "\\spad{formatConstant(op)} is a handler to format constant operators."))
 (|nothing|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{nothing()} returns a handler \\spad{h} such that \\spad{h(prec,{} args)} returns an empty box. This corresponds to NOTHING in \\spad{OutputForm}."))
 (|parenthesizeIf|
  (((|OutputBox|) (|Boolean|) (|OutputBox|))
   "\\spad{parenthesizeIf(paren?,{} bx)} returns parentheses (of appropriate size if \\spad{paren?} is \\spad{true}. Otherwise,{} \\spad{bx} is returned."))
 (|parenthesize|
  (((|OutputBox|) (|String|) (|String|) (|OutputBox|))
   "\\spad{parenthesize(lb,{} rb,{} bx)} returns the box \\spad{bx} with left and right brackets (\\spad{lb} and \\spad{rb}) around it."))
 (|operatorHandlers|
  (((|OperatorHandlers|
     (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))))
   "\\spad{operatorHandlers()} returns an internal data structure that is used for the selection of respective handlers."))
 (|formatFunctionSymbol|
  (((|OutputBox|) (|String|))
   "\\spad{formatFunctionSymbol(s)} formats an otherwise unknown function symbol."))
 (|formatSymbol|
  (((|OutputBox|) (|String|)) "\\spad{formatSymbol(s)} formats a symbol."))
 (|formatString|
  (((|OutputBox|) (|String|)) "\\spad{formatString(s)} formats a string."))
 (|formatFloat|
  (((|OutputBox|) (|String|))
   "\\spad{formatFloat(s)} formats a floating point number from it string representation in \\spadtype{OutputForm}."))
 (|formatInteger|
  (((|OutputBox|) (|Integer|)) "\\spad{formatInteger(n)} formats an integer."))
 (|formatExpression|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|Integer|))
   "\\spad{formatExpression(p)} returns a handler \\spad{h} that \\spad{h(prec,{} args)} returns \\spad{formatExpression(first args,{} p)}. This handler is used to change the precedence context in which the argument is formatted.")
  (((|OutputBox|) (|OutputForm|))
   "\\spad{formatExpression(o)} returns \\spad{formatExpression(o,{} minPrecedence())}.")
  (((|OutputBox|) (|OutputForm|) (|Integer|))
   "\\spad{formatExpression(o,{} p)} returns an \\spadtype{OutputBox} that represent the expression \\spad{o} in the respective format when considered in a context with outer precedence \\spad{p}. This function is the main dispatcher function. It first checks whether \\spad{o} is an integer or a string and treats these cases. Then,{} if the number \\spad{n} of arguments is less than 3,{} it tries to find a handler for the top-level operator of \\spad{o}. If none is found,{} it checks for a handler of an \\spad{n}-ary operator. If no handler is found,{} the operator is treated as a function symbol and formatted as such."))
 (|maxPrecedence|
  (((|Integer|))
   "\\spad{maxPrecedence()} returns the maximal precedence value,{}"))
 (|minPrecedence|
  (((|Integer|))
   "\\spad{minPrecedence()} returns the minimal precedence value."))
 (|defaultEpilogue|
  (((|OutputBox|) (|String|))
   "\\spad{defaultEpilogue(label)} returns a box that is used at the end of every format."))
 (|defaultPrologue|
  (((|OutputBox|) (|String|))
   "\\spad{defaultPrologue(label)} returns a box that is used at the beginning of every format."))) 
NIL 
(|FormatLaTeX|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{FormatLaTeX} provides a coercion from} \\spadtype{OutputForm} to \\LaTeX{} format. The particular dialect of \\TeX{} used is \\LaTeX{},{} but for flexibility reasons \\spadtype{FormatLaTeX} outputs everything into a fricasmath environment in which certain additional commands are available. These commands are defined in a .sty file that is distributed with the source code of FriCAS."))
 (|environment|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|String|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{environmnt(env,{} x,{} sep)} returns a handler that typesets its arguments (without parentheses) in a \\LaTeX{} environment with name \\spad{env}. The string \\spad{x} is put right after the start of the environment. The arguments are separated by the string \\spad{sep}."))) 
NIL 
(|FormatMathJax|) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{FormatMathJax} provides a coercion from} \\spadtype{OutputForm} to a \\LaTeX{} format in a variant that can be understood by MahtJax (https://www.mathjax.org)."))
 (|environment|
  (((|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))) (|String|)
    (|String|) (|String|)
    (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|))))
   "\\spad{environmnt(env,{} x,{} sep)} returns a handler that typesets its arguments (without parentheses) in a \\LaTeX{} environment with name \\spad{env}. The string \\spad{x} is put right after the start of the environment. The arguments are separated by the string \\spad{sep}."))) 
NIL 
(|FormattedOutput|) 
((|constructor|
  (NIL
   "\\indented{1}{The domain \\spad{FormattedOutput} is used when} \")set output formatted on\" is issued on the command line. Then for each formatter that is stored in the internal data structure of \\spad{FormattedOutput}"))
 (|setFormats!|
  (((|Void|) (|List| (|OutputFormatterCategory|)))
   "\\spad{setFormats!(l)} takes a list \\spad{l} of formatters and sets this for future output in a session."))) 
NIL 
(|FileName|) 
((|constructor|
  (NIL "This domain provides an interface to names in the file system."))) 
NIL 
(|FileNameCategory|) 
((|constructor|
  (NIL "This category provides an interface to names in the file system."))
 (|new|
  (($ (|String|) (|String|) (|String|))
   "\\spad{new(d,{} pref,{} e)} constructs the name of a new writable file with \\spad{d} as its directory,{} \\spad{pref} as a prefix of its name and \\spad{e} as its extension. When \\spad{d} or \\spad{t} is the empty string,{} a default is used. An error occurs if a new file cannot be written in the given directory."))
 (|writable?|
  (((|Boolean|) $)
   "\\spad{writable?(f)} tests if the named file be opened for writing. The named file need not already exist."))
 (|readable?|
  (((|Boolean|) $)
   "\\spad{readable?(f)} tests if the named file exist and can it be opened for reading."))
 (|exists?|
  (((|Boolean|) $)
   "\\spad{exists?(f)} tests if the file exists in the file system."))
 (|extension|
  (((|String|) $)
   "\\spad{extension(f)} returns the type part of the file name."))
 (|name|
  (((|String|) $) "\\spad{name(f)} returns the name part of the file name."))
 (|directory|
  (((|String|) $)
   "\\spad{directory(f)} returns the directory part of the file name."))
 (|filename|
  (($ (|String|) (|String|) (|String|))
   "\\spad{filename(d,{} n,{} e)} creates a file name with \\spad{d} as its directory,{} \\spad{n} as its name and \\spad{e} as its extension. This is a portable way to create file names. When \\spad{d} or \\spad{t} is the empty string,{} a default is used."))
 (|coerce|
  (((|String|) $)
   "\\spad{coerce(fn)} produces a string for a file name according to operating system-dependent conventions.")
  (($ (|String|))
   "\\spad{coerce(s)} converts a string to a file name according to operating system-dependent conventions."))) 
NIL 
(|FunctionGraph| S) 
((|constructor| (NIL "allows us to model graph theory \\blankline"))
 (|limit|
  (((|Loop|) $ (|NonNegativeInteger|))
   "apply 'function' represented by this graph to 'a' repeatedly until we reach a loop which is returned as a sequence of vertex indexes."))
 (|apply|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{apply '}function' represented by this graph to vertex index 'a'"))
 (|contraAdjoint|
  (((|Union| (|List| (|NonNegativeInteger|)) #1="failed") $
    (|List| (|NonNegativeInteger|)))
   "given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph"))
 (|coAdjoint|
  (((|Union| (|List| (|NonNegativeInteger|)) #1#) $
    (|List| (|NonNegativeInteger|)))
   "given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph"))
 (|closedTensor|
  (($ $ $ (|Mapping| |#1| |#1| |#1|))
   "as tensor product but returns \\%. Cartesian product does apply to function graph produces two arrows out of every node"))
 (*
  (((|FunctionGraph| (|Product| |#1| |#1|)) $ $)
   "tensor product : the tensor product \\spad{G*H} of graphs \\spad{G} and \\spad{H} is a graph such that the vertex set of \\spad{G*H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}); and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) are adjacent in \\spad{G} \\times \\spad{H} if and only if u' is adjacent with \\spad{v'} and \\spad{u} is adjacent with \\spad{v}. Cartesian product does apply to function graph produces two arrows out of every node"))
 (|functionGraph|
  (($ (|List| (|Permutation| |#1|)))
   "construct graph from a list of permutations.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "constructor for graph with given objects and arrows more objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))
               (|:| |next| (|NonNegativeInteger|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "constructor for graph with given objects more objects and arrows can be added later if required.")
  (($ (|List| |#1|))
   "constructor for graph with given list of object names. Use this version of the constructor if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates. more objects and arrows can be added later if required."))) 
NIL 
(|FreeNilpotentLie| |n| |class| R) 
((|constructor|
  (NIL
   "Generate the Free Lie Algebra over a ring \\spad{R} with identity; A \\spad{P}. Hall basis is generated by a package call to HallBasis."))
 (|generator|
  (($ (|NonNegativeInteger|))
   "\\spad{generator(i)} is the \\spad{i}th Hall Basis element"))
 (|shallowExpand|
  (((|OutputForm|) $)
   "\\spad{shallowExpand(x)} replaces elements of basis by commutators of other basis elements if possible."))
 (|deepExpand|
  (((|OutputForm|) $)
   "\\spad{deepExpand(x)} rewrites all terms of \\spad{x} as commutators of generators."))
 (|dimension|
  (((|NonNegativeInteger|))
   "\\spad{dimension()} is the rank of this Lie algebra"))) 
NIL 
(|FortranOutputStackPackage|) 
((|constructor| (NIL "Code to manipulate Fortran Output Stack"))
 (|topFortranOutputStack|
  (((|String|))
   "\\spad{topFortranOutputStack()} returns the top element of the Fortran output stack"))
 (|pushFortranOutputStack|
  (((|Void|) (|String|))
   "\\spad{pushFortranOutputStack(f)} pushes \\spad{f} onto the Fortran output stack")
  (((|Void|) (|FileName|))
   "\\spad{pushFortranOutputStack(f)} pushes \\spad{f} onto the Fortran output stack"))
 (|popFortranOutputStack|
  (((|Void|)) "\\spad{popFortranOutputStack()} pops the Fortran output stack"))
 (|showFortranOutputStack|
  (((|Stack| (|String|)))
   "\\spad{showFortranOutputStack()} returns the Fortran output stack"))
 (|clearFortranOutputStack|
  (((|Stack| (|String|)))
   "\\spad{clearFortranOutputStack()} clears the Fortran output stack"))) 
NIL 
(|FindOrderFinite| F UP UPUP R) 
((|constructor|
  (NIL
   "\\indented{1}{Finds the order of a divisor over a finite field} Author: Manuel Bronstein Date Created: 1988"))
 (|order|
  (((|NonNegativeInteger|) (|FiniteDivisor| |#1| |#2| |#3| |#4|))
   "\\spad{order(x)} \\undocumented"))) 
NIL 
(|Formatter| F) 
((|formatStep|
  (($ (|OutputForm|) (|Integer|))
   "\\spad{format(o,{} n)} creates a formatted form of the \\spad{OutputForm} \\spad{o} with step number \\spad{n}."))
 (|operatorHandlers|
  (((|OperatorHandlers|
     (|Mapping| (|OutputBox|) (|Integer|) (|List| (|OutputForm|)))))
   "\\spad{operatorHandlers()} returns an internal data structure that is used for the selection of respective handlers."))
 (|setFormat!|
  (((|OutputBox|) $ (|OutputBox|))
   "\\spad{setFormat!(t,{} box)} sets the \\spad{fmt} section of a form \\spad{t} and returns the previous box."))
 (|setEpilogue!|
  (((|OutputBox|) $ (|OutputBox|))
   "\\spad{setEpilogue!(t,{} epi)} sets the epilogue section of the form \\spad{t} to epi and returns the previous epilogue."))
 (|setPrologue!|
  (((|OutputBox|) $ (|OutputBox|))
   "\\spad{setPrologue!(t,{} pro)} sets the prologue section of the form \\spad{t} to pro and returns the previous prologue."))
 (|setDefault!|
  (((|Record| (|:| |prolog| (|Mapping| (|OutputBox|) (|String|)))
              (|:| |epilog| (|Mapping| (|OutputBox|) (|String|))))
    (|Mapping| (|OutputBox|) (|String|)) (|Mapping| (|OutputBox|) (|String|)))
   "Set the prologue and epilogue that is used by default. Between the elements of the list the stepnumber will be inserted. The old values are returned."))
 (|format|
  (($ (|OutputForm|))
   "\\spad{format(o)} creates a formatted form of the \\spad{OutputForm} \\spad{o}.")
  (((|OutputBox|) $)
   "\\spad{format(t)} extracts the \\spad{fmt} section of a 2D-form \\spad{t}."))
 (|epilogue|
  (((|OutputBox|) $)
   "\\spad{epilogue(t)} extracts the epilogue section of the form \\spad{t}. This is a function \\spad{f} such that \\spad{f}(\\spad{l}) returns a box with label \\spad{l}."))
 (|prologue|
  (((|OutputBox|) $)
   "\\spad{prologue(t)} extracts the prologue section of the form \\spad{t}."))
 (|new|
  (($)
   "\\spad{new()} create a new,{} empty object with defaultPrologue(\\spad{\"\"}) and defaultEpilogue(\\spad{\"\"}). Use \\spadfun{setPrologue!},{} \\spadfun{setFormat!} and \\spadfun{setEpilogue!} to set the various components of this object."))) 
NIL 
(|OutputFormatterCategory|) 
((|display| (((|Void|) $) "\\spad{display(t)} outputs the formatted code"))
 (|convert|
  (($ (|OutputForm|) (|Integer|))
   "\\spad{convert(o,{} step)} changes \\spad{o} in standard output format to given format and also adds the given step number."))) 
NIL 
(|FortranProgramCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranProgramCategory} provides various models of FORTRAN subprograms. These can be transformed into actual FORTRAN code."))
 (|outputAsFortran|
  (((|Void|) $)
   "\\spad{outputAsFortran(u)} translates \\spad{u} into a legal FORTRAN subprogram."))) 
NIL 
(|FortranFunctionCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranFunctionCategory} is the category of arguments to NAG Library routines which return (sets of) function values."))
 (|retractIfCan|
  (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Polynomial| (|Integer|)))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Polynomial| (|Float|)))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Expression| (|Integer|)))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Expression| (|Float|)))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|retract|
  (($ (|Fraction| (|Polynomial| (|Integer|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Fraction| (|Polynomial| (|Float|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Polynomial| (|Float|)))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Expression| (|Integer|)))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Expression| (|Float|)))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|coerce|
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \\spadtype{SymbolTable} component.")
  (($ (|FortranCode|))
   "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|List| (|FortranCode|)))
   "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
NIL 
(|FortranFormat|) 
NIL 
NIL 
(|FortranProgram| |name| |returnType| |arguments| |symbols|) 
((|constructor|
  (NIL
   "\\spadtype{FortranProgram} allows the user to build and manipulate simple models of FORTRAN subprograms. These can then be transformed into actual FORTRAN notation."))
 (|coerce|
  (($ (|Equation| (|Expression| (|Complex| (|Float|)))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Equation| (|Expression| (|Float|))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Equation| (|Expression| (|Integer|))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Expression| (|Complex| (|Float|))))
   "\\spad{coerce(e)} \\undocumented{}")
  (($ (|Expression| (|Float|))) "\\spad{coerce(e)} \\undocumented{}")
  (($ (|Expression| (|Integer|))) "\\spad{coerce(e)} \\undocumented{}")
  (($ (|Equation| (|Expression| (|MachineComplex|))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Equation| (|Expression| (|MachineFloat|))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Equation| (|Expression| (|MachineInteger|))))
   "\\spad{coerce(eq)} \\undocumented{}")
  (($ (|Expression| (|MachineComplex|))) "\\spad{coerce(e)} \\undocumented{}")
  (($ (|Expression| (|MachineFloat|))) "\\spad{coerce(e)} \\undocumented{}")
  (($ (|Expression| (|MachineInteger|))) "\\spad{coerce(e)} \\undocumented{}")
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(r)} \\undocumented{}")
  (($ (|List| (|FortranCode|))) "\\spad{coerce(lfc)} \\undocumented{}")
  (($ (|FortranCode|)) "\\spad{coerce(fc)} \\undocumented{}"))) 
NIL 
(|FullPartialFractionExpansion| F UP) 
((|constructor|
  (NIL
   "\\indented{1}{Full partial fraction expansion of rational functions} Author: Manuel Bronstein Date Created: 9 December 1992 References: \\spad{M}.Bronstein & \\spad{B}.Salvy,{} \\indented{12}{Full Partial Fraction Decomposition of Rational Functions,{}} \\indented{12}{in Proceedings of \\spad{ISSAC'93},{} Kiev,{} ACM Press.}"))
 (D
  (($ $ (|NonNegativeInteger|))
   "\\spad{D(f,{} n)} returns the \\spad{n}-th derivative of \\spad{f}.")
  (($ $) "\\spad{D(f)} returns the derivative of \\spad{f}."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(f,{} n)} returns the \\spad{n}-th derivative of \\spad{f}.")
  (($ $) "\\spad{differentiate(f)} returns the derivative of \\spad{f}."))
 (|construct|
  (($
    (|List|
     (|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |center| |#2|)
               (|:| |num| |#2|))))
   "\\spad{construct(l)} is the inverse of fracPart."))
 (|fracPart|
  (((|List|
     (|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |center| |#2|)
               (|:| |num| |#2|)))
    $)
   "\\spad{fracPart(f)} returns the list of summands of the fractional part of \\spad{f}."))
 (|polyPart|
  ((|#2| $) "\\spad{polyPart(f)} returns the polynomial part of \\spad{f}."))
 (|fullPartialFraction|
  (($ (|Fraction| |#2|))
   "\\spad{fullPartialFraction(f)} returns \\spad{[p,{} [[j,{} Dj,{} Hj]...]]} such that \\spad{f = p(x) + \\sum_{[j,{} Dj,{} Hj] in l} \\sum_{Dj(a)=0} Hj(a)/(x - a)\\^j}."))
 (+ (($ |#2| $) "\\spad{p + x} returns the sum of \\spad{p} and \\spad{x}"))) 
NIL 
(|FullyPatternMatchable| R) 
((|constructor|
  (NIL
   "A set \\spad{S} is PatternMatchable over \\spad{R} if \\spad{S} can lift the pattern-matching functions of \\spad{S} over the integers and float to itself (necessary for matching in towers)."))) 
NIL 
(|FieldOfPrimeCharacteristic&| S) 
((|constructor|
  (NIL
   "FieldOfPrimeCharacteristic is the category of fields of prime characteristic,{} \\spadignore{e.g.} finite fields,{} algebraic closures of fields of prime characteristic,{} transcendental extensions of of fields of prime characteristic."))
 (|primeFrobenius|
  (($ $ (|NonNegativeInteger|))
   "\\spad{primeFrobenius(a,{} s)} returns \\spad{a^(p^s)} where \\spad{p} is the characteristic.")
  (($ $)
   "\\spad{primeFrobenius(a)} returns \\spad{a ^ p} where \\spad{p} is the characteristic."))
 (|discreteLog|
  (((|Union| (|NonNegativeInteger|) "failed") $ $)
   "\\spad{discreteLog(b,{} a)} computes \\spad{s} with \\spad{b^s = a} if such an \\spad{s} exists."))
 (|order|
  (((|OnePointCompletion| (|PositiveInteger|)) $)
   "\\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \\spad{a} is 0."))) 
NIL 
(|FieldOfPrimeCharacteristic|) 
((|constructor|
  (NIL
   "FieldOfPrimeCharacteristic is the category of fields of prime characteristic,{} \\spadignore{e.g.} finite fields,{} algebraic closures of fields of prime characteristic,{} transcendental extensions of of fields of prime characteristic."))
 (|primeFrobenius|
  (($ $ (|NonNegativeInteger|))
   "\\spad{primeFrobenius(a,{} s)} returns \\spad{a^(p^s)} where \\spad{p} is the characteristic.")
  (($ $)
   "\\spad{primeFrobenius(a)} returns \\spad{a ^ p} where \\spad{p} is the characteristic."))
 (|discreteLog|
  (((|Union| (|NonNegativeInteger|) "failed") $ $)
   "\\spad{discreteLog(b,{} a)} computes \\spad{s} with \\spad{b^s = a} if such an \\spad{s} exists."))
 (|order|
  (((|OnePointCompletion| (|PositiveInteger|)) $)
   "\\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \\spad{a} is 0."))) 
NIL 
(|FinitePoset| S) 
((|constructor|
  (NIL
   "holds a complete set together with a structure to codify \\indented{2}{the partial order.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))) 
NIL 
(|FloatingPointSystem&| S) 
((|constructor|
  (NIL
   "This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact,{} it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \\blankline \\indented{2}{1: \\spadfunFrom{base}{FloatingPointSystem} of the \\spadfunFrom{exponent}{FloatingPointSystem}.} \\indented{9}{(actual implementations are usually binary or decimal)} \\indented{2}{2: \\spadfunFrom{precision}{FloatingPointSystem} of the \\spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)} \\indented{2}{3: rounding error for operations} \\blankline Because a Float is an approximation to the real numbers,{} even though it is defined to be a join of a Field and OrderedRing,{} some of the attributes do not hold. In particular associative(\\spad{\"+\"}) does not hold. Algorithms defined over a field need special considerations when the field is a floating point system."))
 (|max| (($) "\\spad{max()} returns the maximum floating point number."))
 (|min| (($) "\\spad{min()} returns the minimum floating point number."))
 (|decreasePrecision|
  (((|PositiveInteger|) (|Integer|))
   "\\spad{decreasePrecision(n)} decreases the current \\spadfunFrom{precision}{FloatingPointSystem} precision by \\spad{n} decimal digits."))
 (|increasePrecision|
  (((|PositiveInteger|) (|Integer|))
   "\\spad{increasePrecision(n)} increases the current \\spadfunFrom{precision}{FloatingPointSystem} by \\spad{n} decimal digits."))
 (|precision|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{precision(n)} set the precision in the base to \\spad{n} decimal digits.")
  (((|PositiveInteger|))
   "\\spad{precision()} returns the precision in digits base."))
 (|digits|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{digits(d)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{d} digits.")
  (((|PositiveInteger|))
   "\\spad{digits()} returns ceiling\\spad{'s} precision in decimal digits."))
 (|bits|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{bits(n)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{n} bits.")
  (((|PositiveInteger|))
   "\\spad{bits()} returns ceiling\\spad{'s} precision in bits."))
 (|toString|
  (((|String|) $ (|NonNegativeInteger|))
   "\\spad{toString(x,{} n)} returns a string representation of \\spad{x} truncated to \\spad{n} decimal digits.")
  (((|String|) $)
   "\\spad{toString(x)} returns the string representation of \\spad{x}."))
 (|mantissa|
  (((|Integer|) $)
   "\\spad{mantissa(x)} returns the mantissa part of \\spad{x}."))
 (|exponent|
  (((|Integer|) $)
   "\\spad{exponent(x)} returns the \\spadfunFrom{exponent}{FloatingPointSystem} part of \\spad{x}."))
 (|base|
  (((|PositiveInteger|))
   "\\spad{base()} returns the base of the \\spadfunFrom{exponent}{FloatingPointSystem}."))
 (|order|
  (((|Integer|) $)
   "\\spad{order x} is the order of magnitude of \\spad{x}. Note: \\spad{base ^ order x <= |x| < base ^ (1 + order x)}."))
 (|float|
  (($ (|Integer|) (|Integer|) (|PositiveInteger|))
   "\\spad{float(a,{} e,{} b)} returns \\spad{a * b ^ e}.")
  (($ (|Integer|) (|Integer|))
   "\\spad{float(a,{} e)} returns \\spad{a * base() ^ e}."))
 (/
  (($ $ (|Integer|))
   "\\spad{x / i} computes the division from \\spad{x} by an integer \\spad{i}."))) 
((|HasCategory| |#1| '(|arbitraryExponent|))
 (|HasCategory| |#1| '(|arbitraryPrecision|))) 
(|FloatingPointSystem|) 
((|constructor|
  (NIL
   "This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact,{} it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \\blankline \\indented{2}{1: \\spadfunFrom{base}{FloatingPointSystem} of the \\spadfunFrom{exponent}{FloatingPointSystem}.} \\indented{9}{(actual implementations are usually binary or decimal)} \\indented{2}{2: \\spadfunFrom{precision}{FloatingPointSystem} of the \\spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)} \\indented{2}{3: rounding error for operations} \\blankline Because a Float is an approximation to the real numbers,{} even though it is defined to be a join of a Field and OrderedRing,{} some of the attributes do not hold. In particular associative(\\spad{\"+\"}) does not hold. Algorithms defined over a field need special considerations when the field is a floating point system."))
 (|max| (($) "\\spad{max()} returns the maximum floating point number."))
 (|min| (($) "\\spad{min()} returns the minimum floating point number."))
 (|decreasePrecision|
  (((|PositiveInteger|) (|Integer|))
   "\\spad{decreasePrecision(n)} decreases the current \\spadfunFrom{precision}{FloatingPointSystem} precision by \\spad{n} decimal digits."))
 (|increasePrecision|
  (((|PositiveInteger|) (|Integer|))
   "\\spad{increasePrecision(n)} increases the current \\spadfunFrom{precision}{FloatingPointSystem} by \\spad{n} decimal digits."))
 (|precision|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{precision(n)} set the precision in the base to \\spad{n} decimal digits.")
  (((|PositiveInteger|))
   "\\spad{precision()} returns the precision in digits base."))
 (|digits|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{digits(d)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{d} digits.")
  (((|PositiveInteger|))
   "\\spad{digits()} returns ceiling\\spad{'s} precision in decimal digits."))
 (|bits|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{bits(n)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{n} bits.")
  (((|PositiveInteger|))
   "\\spad{bits()} returns ceiling\\spad{'s} precision in bits."))
 (|toString|
  (((|String|) $ (|NonNegativeInteger|))
   "\\spad{toString(x,{} n)} returns a string representation of \\spad{x} truncated to \\spad{n} decimal digits.")
  (((|String|) $)
   "\\spad{toString(x)} returns the string representation of \\spad{x}."))
 (|mantissa|
  (((|Integer|) $)
   "\\spad{mantissa(x)} returns the mantissa part of \\spad{x}."))
 (|exponent|
  (((|Integer|) $)
   "\\spad{exponent(x)} returns the \\spadfunFrom{exponent}{FloatingPointSystem} part of \\spad{x}."))
 (|base|
  (((|PositiveInteger|))
   "\\spad{base()} returns the base of the \\spadfunFrom{exponent}{FloatingPointSystem}."))
 (|order|
  (((|Integer|) $)
   "\\spad{order x} is the order of magnitude of \\spad{x}. Note: \\spad{base ^ order x <= |x| < base ^ (1 + order x)}."))
 (|float|
  (($ (|Integer|) (|Integer|) (|PositiveInteger|))
   "\\spad{float(a,{} e,{} b)} returns \\spad{a * b ^ e}.")
  (($ (|Integer|) (|Integer|))
   "\\spad{float(a,{} e)} returns \\spad{a * base() ^ e}."))
 (/
  (($ $ (|Integer|))
   "\\spad{x / i} computes the division from \\spad{x} by an integer \\spad{i}."))) 
NIL 
(|Factored| R) 
((|constructor|
  (NIL
   "\\spadtype{Factored} creates a domain whose objects are kept in factored form as long as possible. Thus certain operations like multiplication and \\spad{gcd} are relatively easy to do. Others,{} like addition require somewhat more work,{} and unless the argument domain provides a factor function,{} the result may not be completely factored. Each object consists of a unit and a list of factors,{} where a factor has a member of \\spad{R} (the \"base\"),{} and exponent and a flag indicating what is known about the base. A flag may be one of \"nil\",{} \"sqfr\",{} \"irred\" or \"prime\",{} which respectively mean that nothing is known about the base,{} it is square-free,{} it is irreducible,{} or it is prime. The current restriction to integral domains allows simplification to be performed without worrying about multiplication order."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(u)} returns a rational number if \\spad{u} really is one,{} and \"failed\" otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(u)} assumes spadvar{\\spad{u}} is actually a rational number and does the conversion to rational number (see \\spadtype{Fraction Integer})."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(u)} tests if \\spadvar{\\spad{u}} is actually a rational number (see \\spadtype{Fraction Integer})."))
 (|mergeFactors|
  (($ $ $)
   "\\spad{mergeFactors(u,{} v)} is used when the factorizations of \\spadvar{\\spad{u}} and \\spadvar{\\spad{v}} are known to be disjoint,{} \\spadignore{e.g.} resulting from a content/primitive part split. Essentially,{} it creates a new factored object by multiplying the units together and appending the lists of factors."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(fn,{} u)} maps the function \\userfun{\\spad{fn}} across the factors of \\spadvar{\\spad{u}} and creates a new factored object. Note: this clears the information flags (sets them to \"nil\") because the effect of \\userfun{\\spad{fn}} is clearly not known in general."))
 (|unitNormalize|
  (($ $)
   "\\spad{unitNormalize(u)} normalizes the unit part of the factorization. For example,{} when working with factored integers,{} this operation will ensure that the bases are all positive integers."))
 (|unit|
  ((|#1| $) "\\spad{unit(u)} extracts the unit part of the factorization."))
 (|flagFactor|
  (($ |#1| (|NonNegativeInteger|)
    (|Union| #1="nil" #2="sqfr" #3="irred" #4="prime"))
   "\\spad{flagFactor(base,{} exponent,{} flag)} creates a factored object with a single factor whose \\spad{base} is asserted to be properly described by the information flag."))
 (|sqfrFactor|
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{sqfrFactor(base,{} exponent)} creates a factored object with a single factor whose \\spad{base} is asserted to be square-free (flag = \"sqfr\")."))
 (|primeFactor|
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{primeFactor(base,{} exponent)} creates a factored object with a single factor whose \\spad{base} is asserted to be prime (flag = \"prime\")."))
 (|numberOfFactors|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfFactors(u)} returns the number of factors in \\spadvar{\\spad{u}}."))
 (|irreducibleFactor|
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{irreducibleFactor(base,{} exponent)} creates a factored object with a single factor whose \\spad{base} is asserted to be irreducible (flag = \"irred\")."))
 (|factors|
  (((|List|
     (|Record| (|:| |factor| |#1|) (|:| |exponent| (|NonNegativeInteger|))))
    $)
   "\\spad{factors(u)} returns a list of the factors in a form suitable for iteration. That is,{} it returns a list where each element is a record containing a base and exponent. The original object is the product of all the factors and the unit (which can be extracted by \\spad{unit(u)})."))
 (|nilFactor|
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{nilFactor(base,{} exponent)} creates a factored object with a single factor with no information about the kind of \\spad{base} (flag = \"nil\")."))
 (|factorList|
  (((|List|
     (|Record| (|:| |flag| (|Union| #1# #2# #3# #4#)) (|:| |factor| |#1|)
               (|:| |exponent| (|NonNegativeInteger|))))
    $)
   "\\spad{factorList(u)} returns the list of factors with flags (for use by factoring code)."))
 (|makeFR|
  (($ |#1|
    (|List|
     (|Record| (|:| |flag| (|Union| #1# #2# #3# #4#)) (|:| |factor| |#1|)
               (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{makeFR(unit,{} listOfFactors)} creates a factored object (for use by factoring code)."))
 (|expand|
  ((|#1| $)
   "\\spad{expand(f)} multiplies the unit and factors together,{} yielding an \"unfactored\" object. Note: this is purposely not called \\spadfun{coerce} which would cause the interpreter to do this automatically."))) 
((|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) '$))
 (|HasCategory| |#1| (LIST '|Evalable| '$))
 (|HasCategory| |#1| (LIST '|Eltable| '$ '$))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|UniqueFactorizationDomain|))
 (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|UniqueFactorizationDomain|)))
 (|HasCategory| |#1| '(|RealConstant|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))) 
(|FactoredFunctions2| R S) 
((|constructor|
  (NIL
   "\\spadtype{FactoredFunctions2} contains functions that involve factored objects whose underlying domains may not be the same. For example,{} \\spadfun{map} might be used to coerce an object of type \\spadtype{Factored(Integer)} to \\spadtype{Factored(Complex(Integer))}."))
 (|map_preserving|
  (((|Factored| |#2|) (|Mapping| |#2| |#1|) (|Factored| |#1|))
   "\\spad{map_preserving(fn,{} u)} is used to apply the function \\userfun{\\spad{fn}} to every factor of \\spadvar{\\spad{u}}. The new factored object will have the same flags as original."))
 (|map|
  (((|Factored| |#2|) (|Mapping| |#2| |#1|) (|Factored| |#1|))
   "\\spad{map(fn,{} u)} is used to apply the function \\userfun{\\spad{fn}} to every factor of \\spadvar{\\spad{u}}. The new factored object will have all its information flags set to \"nil\". This function is used,{} for example,{} to coerce every factor base to another type."))) 
NIL 
(|Fraction| S) 
((|constructor|
  (NIL
   "Fraction takes an IntegralDomain \\spad{S} and produces the domain of Fractions with numerators and denominators from \\spad{S}. If \\spad{S} is also a GcdDomain,{} then \\spad{gcd}\\spad{'s} between numerator and denominator will be cancelled during all operations."))
 (|factorFraction|
  (((|Fraction| (|Factored| |#1|)) $)
   "\\spad{factorFraction(r)} factors the numerator and the denominator of the fraction \\spad{r}."))) 
((|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|RealConstant|))
 (|HasCategory| |#1| '(|OrderedIntegralDomain|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#1| '(|OrderedIntegralDomain|))
     (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|StepThrough|))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
 (AND (|HasCategory| |#1| '(|Canonical|)) (|HasCategory| |#1| '(|GcdDomain|))
      (|HasCategory| |#1| '(|canonicalUnitNormal|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))
 (AND (|HasCategory| |#1| '(|IntegerNumberSystem|))
      (|HasCategory| |#1| '(|OpenMath|)))
 (OR
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (AND (|HasCategory| |#1| '(|IntegerNumberSystem|))
       (|HasCategory| |#1| '(|OpenMath|))))
 (OR (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|IntegerNumberSystem|))
          (|HasCategory| |#1| '(|OpenMath|))))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (OR (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
     (AND (|HasCategory| |#1| '(|IntegerNumberSystem|))
          (|HasCategory| |#1| '(|OpenMath|))))
 (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedIntegralDomain|))
     (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|IntegerNumberSystem|))
          (|HasCategory| |#1| '(|OpenMath|))))
 (|HasCategory| |#1| '(|UniqueFactorizationDomain|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))) 
(|FractionFunctions2| A B) 
((|constructor|
  (NIL
   "This package extends a map between integral domains to a map between Fractions over those domains by applying the map to the numerators and denominators."))
 (|map|
  (((|Fraction| |#2|) (|Mapping| |#2| |#1|) (|Fraction| |#1|))
   "\\spad{map(func,{} frac)} applies the function \\spad{func} to the numerator and denominator of the fraction frac."))) 
NIL 
(|FramedAlgebra&| S R UP) 
((|constructor|
  (NIL
   "A \\spadtype{FramedAlgebra} is a \\spadtype{FiniteRankAlgebra} together with a fixed \\spad{R}-module basis."))
 (|regularRepresentation|
  (((|Matrix| |#2|) $)
   "\\spad{regularRepresentation(a)} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the fixed basis. That is for all \\spad{x} we have \\spad{coordinates(a*x) = m*coordinates(x)}."))
 (|discriminant|
  ((|#2|) "\\spad{discriminant()} = determinant(traceMatrix())."))
 (|traceMatrix|
  (((|Matrix| |#2|))
   "\\spad{traceMatrix()} is the \\spad{n}-by-\\spad{n} matrix ( \\spad{Tr(\\spad{vi} * vj)} ),{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis."))) 
NIL 
(|FramedAlgebra| R UP) 
((|constructor|
  (NIL
   "A \\spadtype{FramedAlgebra} is a \\spadtype{FiniteRankAlgebra} together with a fixed \\spad{R}-module basis."))
 (|regularRepresentation|
  (((|Matrix| |#1|) $)
   "\\spad{regularRepresentation(a)} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the fixed basis. That is for all \\spad{x} we have \\spad{coordinates(a*x) = m*coordinates(x)}."))
 (|discriminant|
  ((|#1|) "\\spad{discriminant()} = determinant(traceMatrix())."))
 (|traceMatrix|
  (((|Matrix| |#1|))
   "\\spad{traceMatrix()} is the \\spad{n}-by-\\spad{n} matrix ( \\spad{Tr(\\spad{vi} * vj)} ),{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis."))) 
NIL 
(|FullyRetractableTo&| A S) 
((|constructor|
  (NIL
   "\\indented{2}{A is fully retractable to \\spad{B} means that A is retractable to \\spad{B},{} and,{}} \\indented{2}{in addition,{} if \\spad{B} is retractable to the integers or rational} \\indented{2}{numbers then so is A.} \\indented{2}{In particular,{} what we are asserting is that there are no integers} \\indented{2}{(rationals) in A which don\\spad{'t} retract into \\spad{B}.} Date Created: March 1990"))) 
((|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))) 
(|FullyRetractableTo| S) 
((|constructor|
  (NIL
   "\\indented{2}{A is fully retractable to \\spad{B} means that A is retractable to \\spad{B},{} and,{}} \\indented{2}{in addition,{} if \\spad{B} is retractable to the integers or rational} \\indented{2}{numbers then so is A.} \\indented{2}{In particular,{} what we are asserting is that there are no integers} \\indented{2}{(rationals) in A which don\\spad{'t} retract into \\spad{B}.} Date Created: March 1990"))) 
NIL 
(|FractionalIdeal| R F UP A) 
((|constructor| (NIL "Fractional ideals in a framed algebra."))
 (|randomLC|
  ((|#4| (|NonNegativeInteger|) (|Vector| |#4|))
   "\\spad{randomLC(n,{} x)} should be local but conditional."))
 (|minimize|
  (($ $)
   "\\spad{minimize(I)} returns a reduced set of generators for \\spad{I}."))
 (|denom|
  ((|#1| $) "\\spad{denom(1/d * (f1,{} ...,{} fn))} returns \\spad{d}."))
 (|numer|
  (((|Vector| |#4|) $)
   "\\spad{numer(1/d * (f1,{} ...,{} fn))} = the vector \\spad{[f1,{} ...,{} fn]}."))
 (|norm| ((|#2| $) "\\spad{norm(I)} returns the norm of the ideal \\spad{I}."))
 (|basis|
  (((|Vector| |#4|) $)
   "\\spad{basis((f1,{} ...,{} fn))} returns the vector \\spad{[f1,{} ...,{} fn]}."))
 (|ideal|
  (($ (|Vector| |#4|))
   "\\spad{ideal([f1,{} ...,{} fn])} returns the ideal \\spad{(f1,{} ...,{} fn)}."))) 
NIL 
(|FractionalIdealFunctions2| R1 F1 U1 A1 R2 F2 U2 A2) 
((|constructor|
  (NIL
   "\\indented{1}{Lifting of morphisms to fractional ideals.} Author: Manuel Bronstein Date Created: 1 Feb 1989 Keywords: ideal,{} algebra,{} module."))
 (|map|
  (((|FractionalIdeal| |#5| |#6| |#7| |#8|) (|Mapping| |#5| |#1|)
    (|FractionalIdeal| |#1| |#2| |#3| |#4|))
   "\\spad{map(f,{} i)} \\undocumented{}"))) 
NIL 
(|FractionalIdealAsModule| R F UP A |ibasis|) 
((|constructor| (NIL "Module representation of fractional ideals."))
 (|module|
  (($ (|FractionalIdeal| |#1| |#2| |#3| |#4|))
   "\\spad{module(I)} returns \\spad{I} viewed has a module over \\spad{R}.")
  (($ (|Vector| |#4|))
   "\\spad{module([f1,{} ...,{} fn])} = the module generated by \\spad{(f1,{} ...,{} fn)} over \\spad{R}."))
 (|norm|
  ((|#2| $) "\\spad{norm(f)} returns the norm of the module \\spad{f}."))
 (|basis|
  (((|Vector| |#4|) $)
   "\\spad{basis((f1,{} ...,{} fn))} = the vector \\spad{[f1,{} ...,{} fn]}."))) 
((|HasCategory| |#4| (LIST '|RetractableTo| (|devaluate| |#2|)))) 
(|FramedModule&| S R) 
((|constructor|
  (NIL
   "A \\spadtype{FramedModule} is a finite rank free module with fixed \\spad{R}-module basis."))
 (|convert|
  (($ (|Vector| |#2|))
   "\\spad{convert([a1,{} ..,{} an])} returns \\spad{a1*v1 + ... + an*vn},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis.")
  (((|Vector| |#2|) $)
   "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|represents|
  (($ (|Vector| |#2|))
   "\\spad{represents([a1,{} ..,{} an])} returns \\spad{a1*v1 + ... + an*vn},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis."))
 (|coordinates|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{coordinates([v1,{} ...,{} vm])} returns the coordinates of the \\spad{vi}\\spad{'s} with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.")
  (((|Vector| |#2|) $)
   "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|rank|
  (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the module"))
 (|basis|
  (((|Vector| $)) "\\spad{basis()} returns the fixed \\spad{R}-module basis."))) 
((|HasCategory| |#2| '(|Finite|))) 
(|FramedModule| R) 
((|constructor|
  (NIL
   "A \\spadtype{FramedModule} is a finite rank free module with fixed \\spad{R}-module basis."))
 (|convert|
  (($ (|Vector| |#1|))
   "\\spad{convert([a1,{} ..,{} an])} returns \\spad{a1*v1 + ... + an*vn},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis.")
  (((|Vector| |#1|) $)
   "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|represents|
  (($ (|Vector| |#1|))
   "\\spad{represents([a1,{} ..,{} an])} returns \\spad{a1*v1 + ... + an*vn},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed basis."))
 (|coordinates|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{coordinates([v1,{} ...,{} vm])} returns the coordinates of the \\spad{vi}\\spad{'s} with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.")
  (((|Vector| |#1|) $)
   "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|rank|
  (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the module"))
 (|basis|
  (((|Vector| $)) "\\spad{basis()} returns the fixed \\spad{R}-module basis."))) 
NIL 
(|FramedNonAssociativeAlgebraFunctions2| AR R AS S) 
((|constructor|
  (NIL
   "\\spad{FramedNonAssociativeAlgebraFunctions2} implements functions between two framed non associative algebra domains defined over different rings. The function map is used to coerce between algebras over different domains having the same structural constants."))
 (|map|
  ((|#3| (|Mapping| |#4| |#2|) |#1|)
   "\\spad{map(f,{} u)} maps \\spad{f} onto the coordinates of \\spad{u} to get an element in \\spad{AS} via identification of the basis of \\spad{AR} as beginning part of the basis of \\spad{AS}."))) 
NIL 
(|FramedNonAssociativeAlgebra&| S R) 
((|constructor|
  (NIL
   "FramedNonAssociativeAlgebra(\\spad{R}) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis."))
 (|apply|
  (($ (|Matrix| |#2|) $)
   "\\spad{apply(m,{} a)} defines a left operation of \\spad{n} by \\spad{n} matrices where \\spad{n} is the rank of the algebra in terms of matrix-vector multiplication,{} this is a substitute for a left module structure. Error: if shape of matrix doesn\\spad{'t} fit."))
 (|rightRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Polynomial| |#2|)))
   "\\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis."))
 (|leftRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Polynomial| |#2|)))
   "\\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis."))
 (|rightRegularRepresentation|
  (((|Matrix| |#2|) $)
   "\\spad{rightRegularRepresentation(a)} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|leftRegularRepresentation|
  (((|Matrix| |#2|) $)
   "\\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#2|))
   "\\spad{rightTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis."))
 (|leftTraceMatrix|
  (((|Matrix| |#2|))
   "\\spad{leftTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by left trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis."))
 (|rightDiscriminant|
  ((|#2|)
   "\\spad{rightDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note: the same as \\spad{determinant(rightTraceMatrix())}."))
 (|leftDiscriminant|
  ((|#2|)
   "\\spad{leftDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note: the same as \\spad{determinant(leftTraceMatrix())}."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#2|)))
   "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#2|)))
   "\\spad{structuralConstants()} calculates the structural constants \\spad{[(gammaijk) for k in 1..rank()]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijn * vn},{} where \\spad{v1},{} ...,{} \\spad{vn} is the fixed \\spad{R}-module basis."))
 (|elt|
  ((|#2| $ (|Integer|))
   "\\spad{elt(a,{} i)} returns the \\spad{i}-th coefficient of \\spad{a} with respect to the fixed \\spad{R}-module basis."))) 
((|HasCategory| |#2| '(|Field|))) 
(|FramedNonAssociativeAlgebra| R) 
((|constructor|
  (NIL
   "FramedNonAssociativeAlgebra(\\spad{R}) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis."))
 (|apply|
  (($ (|Matrix| |#1|) $)
   "\\spad{apply(m,{} a)} defines a left operation of \\spad{n} by \\spad{n} matrices where \\spad{n} is the rank of the algebra in terms of matrix-vector multiplication,{} this is a substitute for a left module structure. Error: if shape of matrix doesn\\spad{'t} fit."))
 (|rightRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Polynomial| |#1|)))
   "\\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis."))
 (|leftRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Polynomial| |#1|)))
   "\\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis."))
 (|rightRegularRepresentation|
  (((|Matrix| |#1|) $)
   "\\spad{rightRegularRepresentation(a)} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|leftRegularRepresentation|
  (((|Matrix| |#1|) $)
   "\\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#1|))
   "\\spad{rightTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis."))
 (|leftTraceMatrix|
  (((|Matrix| |#1|))
   "\\spad{leftTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by left trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis."))
 (|rightDiscriminant|
  ((|#1|)
   "\\spad{rightDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note: the same as \\spad{determinant(rightTraceMatrix())}."))
 (|leftDiscriminant|
  ((|#1|)
   "\\spad{leftDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj},{} where \\spad{v1},{} ...,{} \\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note: the same as \\spad{determinant(leftTraceMatrix())}."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#1|)))
   "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#1|)))
   "\\spad{structuralConstants()} calculates the structural constants \\spad{[(gammaijk) for k in 1..rank()]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijn * vn},{} where \\spad{v1},{} ...,{} \\spad{vn} is the fixed \\spad{R}-module basis."))
 (|elt|
  ((|#1| $ (|Integer|))
   "\\spad{elt(a,{} i)} returns the \\spad{i}-th coefficient of \\spad{a} with respect to the fixed \\spad{R}-module basis."))) 
NIL 
(|FactoredFunctionUtilities| R) 
((|constructor|
  (NIL
   "\\spadtype{FactoredFunctionUtilities} implements some utility functions for manipulating factored objects."))
 (|refine|
  (((|Factored| |#1|) (|Factored| |#1|) (|Mapping| (|Factored| |#1|) |#1|))
   "\\spad{refine(u,{} fn)} is used to apply the function \\userfun{\\spad{fn}} to each factor of \\spadvar{\\spad{u}} and then build a new factored object from the results. For example,{} if \\spadvar{\\spad{u}} were created by calling \\spad{nilFactor(10,{} 2)} then \\spad{refine(u,{} factor)} would create a factored object equal to that created by \\spad{factor(100)} or \\spad{primeFactor(2,{} 2) * primeFactor(5,{} 2)}."))) 
NIL 
(|FunctionSpace&| S R) 
((|constructor|
  (NIL
   "A space of formal functions with arguments in an arbitrary ordered set."))
 (|univariate|
  (((|Fraction| (|SparseUnivariatePolynomial| $)) $ (|Kernel| $))
   "\\spad{univariate(f,{} k)} returns \\spad{f} viewed as a univariate fraction in \\spad{k}."))
 (/
  (($ (|SparseMultivariatePolynomial| |#2| (|Kernel| $))
    (|SparseMultivariatePolynomial| |#2| (|Kernel| $)))
   "\\spad{p1/p2} returns the quotient of \\spad{p1} and \\spad{p2} as an element of \\%."))
 (|denominator|
  (($ $)
   "\\spad{denominator(f)} returns the denominator of \\spad{f} converted to \\%."))
 (|denom|
  (((|SparseMultivariatePolynomial| |#2| (|Kernel| $)) $)
   "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R}."))
 (|convert|
  (($ (|Factored| $))
   "\\spad{convert(f1\\^e1 ... fm\\^em)} returns \\spad{(f1)\\^e1 ... (fm)\\^em} as an element of \\%,{} using formal kernels created using a \\spadfunFrom{paren}{ExpressionSpace}."))
 (|algtower|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{algtower([f1,{} ...,{} fn])} returns list of kernels \\spad{[ak1,{} ...,{} akl]} such that each toplevel algebraic kernel in one of \\spad{f1},{} ...,{} \\spad{fn} or in arguments of \\spad{ak1},{} ...,{} akl is one of \\spad{ak1},{} ...,{} akl.")
  (((|List| (|Kernel| $)) $) "\\spad{algtower(f)} is algtower([\\spad{f}])"))
 (|isPower|
  (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|Integer|))) "failed") $)
   "\\spad{isPower(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0}."))
 (|numerator|
  (($ $)
   "\\spad{numerator(f)} returns the numerator of \\spad{f} converted to \\%."))
 (|numer|
  (((|SparseMultivariatePolynomial| |#2| (|Kernel| $)) $)
   "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R} if \\spad{R} is an integral domain. If not,{} then numer(\\spad{f}) = \\spad{f} viewed as a polynomial in the kernels over \\spad{R}."))
 (|coerce|
  (($ (|Fraction| (|Polynomial| (|Fraction| |#2|))))
   "\\spad{coerce(f)} returns \\spad{f} as an element of \\%.")
  (($ (|Polynomial| (|Fraction| |#2|)))
   "\\spad{coerce(p)} returns \\spad{p} as an element of \\%.")
  (($ (|Fraction| |#2|))
   "\\spad{coerce(q)} returns \\spad{q} as an element of \\%.")
  (($ (|SparseMultivariatePolynomial| |#2| (|Kernel| $)))
   "\\spad{coerce(p)} returns \\spad{p} as an element of \\%."))
 (|isMult|
  (((|Union| (|Record| (|:| |coef| (|Integer|)) (|:| |var| (|Kernel| $)))
             "failed")
    $)
   "\\spad{isMult(p)} returns \\spad{[n,{} x]} if \\spad{p = n * x} and \\spad{n ~= 0}."))
 (|isPlus|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isPlus(p)} returns \\spad{[m1,{} ...,{} mn]} if \\spad{p = m1 +...+ mn} and \\spad{n > 1}."))
 (|isExpt|
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $ (|Symbol|))
   "\\spad{isExpt(p,{} f)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0} and \\spad{x = f(a)}.")
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $ (|BasicOperator|))
   "\\spad{isExpt(p,{} op)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0} and \\spad{x = op(a)}.")
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $)
   "\\spad{isExpt(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0}."))
 (|isTimes|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{p = a1*...*an} and \\spad{n > 1}."))
 (|eval|
  (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} n,{} f)} replaces every \\spad{s(a)^n} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} n,{} f)} replaces every \\spad{s(a1,{} ...,{} am)^n} in \\spad{x} by \\spad{f(a1,{} ...,{} am)} for any \\spad{a1},{} ...,{} am.")
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))
    (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)^ni} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} am.")
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))
    (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)^ni} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}.")
  (($ $ (|List| (|BasicOperator|)) (|List| $) (|Symbol|))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm],{} y)} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.")
  (($ $ (|BasicOperator|) $ (|Symbol|))
   "\\spad{eval(x,{} s,{} f,{} y)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}."))
 (|applyQuote|
  (($ (|Symbol|) (|List| $))
   "\\spad{applyQuote(foo,{} [x1,{} ...,{} xn])} returns \\spad{'foo(x1,{} ...,{} xn)}.")
  (($ (|Symbol|) $ $ $ $)
   "\\spad{applyQuote(foo,{} x,{} y,{} z,{} t)} returns \\spad{'foo(x,{} y,{} z,{} t)}.")
  (($ (|Symbol|) $ $ $)
   "\\spad{applyQuote(foo,{} x,{} y,{} z)} returns \\spad{'foo(x,{} y,{} z)}.")
  (($ (|Symbol|) $ $)
   "\\spad{applyQuote(foo,{} x,{} y)} returns \\spad{'foo(x,{} y)}.")
  (($ (|Symbol|) $) "\\spad{applyQuote(foo,{} x)} returns \\spad{'foo(x)}."))
 (|variables|
  (((|List| (|Symbol|)) (|List| $))
   "\\spad{variables([f1,{} ...,{} fn])} returns the list of all the variables of \\spad{f1},{} ...,{} \\spad{fn}.")
  (((|List| (|Symbol|)) $)
   "\\spad{variables(f)} returns the list of all the variables of \\spad{f}."))
 (|ground|
  ((|#2| $)
   "\\spad{ground(f)} returns \\spad{f} as an element of \\spad{R}. An error occurs if \\spad{f} is not an element of \\spad{R}."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground?(f)} tests if \\spad{f} is an element of \\spad{R}."))) 
((|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|AbelianGroup|))
 (|HasCategory| |#2| '(|AbelianSemiGroup|)) (|HasCategory| |#2| '(|Group|))
 (|HasCategory| |#2| '(|SemiGroup|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))) 
(|FunctionSpace| R) 
((|constructor|
  (NIL
   "A space of formal functions with arguments in an arbitrary ordered set."))
 (|univariate|
  (((|Fraction| (|SparseUnivariatePolynomial| $)) $ (|Kernel| $))
   "\\spad{univariate(f,{} k)} returns \\spad{f} viewed as a univariate fraction in \\spad{k}."))
 (/
  (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $))
    (|SparseMultivariatePolynomial| |#1| (|Kernel| $)))
   "\\spad{p1/p2} returns the quotient of \\spad{p1} and \\spad{p2} as an element of \\%."))
 (|denominator|
  (($ $)
   "\\spad{denominator(f)} returns the denominator of \\spad{f} converted to \\%."))
 (|denom|
  (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $)
   "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R}."))
 (|convert|
  (($ (|Factored| $))
   "\\spad{convert(f1\\^e1 ... fm\\^em)} returns \\spad{(f1)\\^e1 ... (fm)\\^em} as an element of \\%,{} using formal kernels created using a \\spadfunFrom{paren}{ExpressionSpace}."))
 (|algtower|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{algtower([f1,{} ...,{} fn])} returns list of kernels \\spad{[ak1,{} ...,{} akl]} such that each toplevel algebraic kernel in one of \\spad{f1},{} ...,{} \\spad{fn} or in arguments of \\spad{ak1},{} ...,{} akl is one of \\spad{ak1},{} ...,{} akl.")
  (((|List| (|Kernel| $)) $) "\\spad{algtower(f)} is algtower([\\spad{f}])"))
 (|isPower|
  (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|Integer|))) "failed") $)
   "\\spad{isPower(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0}."))
 (|numerator|
  (($ $)
   "\\spad{numerator(f)} returns the numerator of \\spad{f} converted to \\%."))
 (|numer|
  (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $)
   "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R} if \\spad{R} is an integral domain. If not,{} then numer(\\spad{f}) = \\spad{f} viewed as a polynomial in the kernels over \\spad{R}."))
 (|coerce|
  (($ (|Fraction| (|Polynomial| (|Fraction| |#1|))))
   "\\spad{coerce(f)} returns \\spad{f} as an element of \\%.")
  (($ (|Polynomial| (|Fraction| |#1|)))
   "\\spad{coerce(p)} returns \\spad{p} as an element of \\%.")
  (($ (|Fraction| |#1|))
   "\\spad{coerce(q)} returns \\spad{q} as an element of \\%.")
  (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $)))
   "\\spad{coerce(p)} returns \\spad{p} as an element of \\%."))
 (|isMult|
  (((|Union| (|Record| (|:| |coef| (|Integer|)) (|:| |var| (|Kernel| $)))
             "failed")
    $)
   "\\spad{isMult(p)} returns \\spad{[n,{} x]} if \\spad{p = n * x} and \\spad{n ~= 0}."))
 (|isPlus|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isPlus(p)} returns \\spad{[m1,{} ...,{} mn]} if \\spad{p = m1 +...+ mn} and \\spad{n > 1}."))
 (|isExpt|
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $ (|Symbol|))
   "\\spad{isExpt(p,{} f)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0} and \\spad{x = f(a)}.")
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $ (|BasicOperator|))
   "\\spad{isExpt(p,{} op)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0} and \\spad{x = op(a)}.")
  (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|)))
             "failed")
    $)
   "\\spad{isExpt(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0}."))
 (|isTimes|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{p = a1*...*an} and \\spad{n > 1}."))
 (|eval|
  (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} n,{} f)} replaces every \\spad{s(a)^n} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} n,{} f)} replaces every \\spad{s(a1,{} ...,{} am)^n} in \\spad{x} by \\spad{f(a1,{} ...,{} am)} for any \\spad{a1},{} ...,{} am.")
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))
    (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)^ni} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} am.")
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))
    (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)^ni} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}.")
  (($ $ (|List| (|BasicOperator|)) (|List| $) (|Symbol|))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm],{} y)} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.")
  (($ $ (|BasicOperator|) $ (|Symbol|))
   "\\spad{eval(x,{} s,{} f,{} y)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}."))
 (|applyQuote|
  (($ (|Symbol|) (|List| $))
   "\\spad{applyQuote(foo,{} [x1,{} ...,{} xn])} returns \\spad{'foo(x1,{} ...,{} xn)}.")
  (($ (|Symbol|) $ $ $ $)
   "\\spad{applyQuote(foo,{} x,{} y,{} z,{} t)} returns \\spad{'foo(x,{} y,{} z,{} t)}.")
  (($ (|Symbol|) $ $ $)
   "\\spad{applyQuote(foo,{} x,{} y,{} z)} returns \\spad{'foo(x,{} y,{} z)}.")
  (($ (|Symbol|) $ $)
   "\\spad{applyQuote(foo,{} x,{} y)} returns \\spad{'foo(x,{} y)}.")
  (($ (|Symbol|) $) "\\spad{applyQuote(foo,{} x)} returns \\spad{'foo(x)}."))
 (|variables|
  (((|List| (|Symbol|)) (|List| $))
   "\\spad{variables([f1,{} ...,{} fn])} returns the list of all the variables of \\spad{f1},{} ...,{} \\spad{fn}.")
  (((|List| (|Symbol|)) $)
   "\\spad{variables(f)} returns the list of all the variables of \\spad{f}."))
 (|ground|
  ((|#1| $)
   "\\spad{ground(f)} returns \\spad{f} as an element of \\spad{R}. An error occurs if \\spad{f} is not an element of \\spad{R}."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground?(f)} tests if \\spad{f} is an element of \\spad{R}."))) 
NIL 
(|FunctionSpaceFunctions2| R A S B) 
((|constructor|
  (NIL
   "This package allows a mapping \\spad{R} \\spad{->} \\spad{S} to be lifted to a mapping from a function space over \\spad{R} to a function space over \\spad{S}."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} a)} applies \\spad{f} to all the constants in \\spad{R} appearing in \\spad{a}."))) 
NIL 
(|FunctionSpaceToExponentialExpansion| R FE |x| |cen|) 
((|constructor|
  (NIL
   "This package converts expressions in some function space to exponential expansions."))
 (|localAbs|
  ((|#2| |#2|)
   "\\spad{localAbs(fcn)} = \\spad{abs(fcn)} or \\spad{sqrt(fcn^2)} depending on whether or not FE has a function \\spad{abs}. This should be a local function,{} but the compiler won\\spad{'t} allow it."))
 (|exprToXXP|
  (((|Union| (|:| |%expansion| (|ExponentialExpansion| |#1| |#2| |#3| |#4|))
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|))
   "\\spad{exprToXXP(fcn,{} posCheck?)} converts the expression \\spad{fcn} to an exponential expansion. If \\spad{posCheck?} is \\spad{true},{} log\\spad{'s} of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is \\spad{false},{} these are allowed."))) 
NIL 
(|FunctionSpaceToUnivariatePowerSeries| R FE |Expon| UPS TRAN UTS TEXP |x|) 
((|constructor|
  (NIL
   "This package converts expressions in some function space to power series in a variable \\spad{x} with coefficients in that function space. The function \\spadfun{exprToUPS} converts expressions to power series whose coefficients do not contain the variable \\spad{x}. The function \\spadfun{exprToGenUPS} converts functional expressions to power series whose coefficients may involve functions of \\spad{log(x)}."))
 (|exprToPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|)
    (|Union| #1="complex" #2="real: two sides" #3="real: left side"
             #4="real: right side" #5="just do it")
    (|Boolean|) |#2| (|Mapping| (|Boolean|) |#2|) (|Mapping| (|Boolean|) |#2|)
    (|Mapping| (|Boolean|) |#2|))
   "exprToPS(\\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val,{} coef_chk,{} inv_chk,{} zero_chk) is like exprToPS(\\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val),{} but fails if \\spad{coef_chk} is \\spad{false} for some coefficient of \\spad{fcn} or if expansion process needs to invert element of \\spad{FE} for which \\spad{inv_chk} is \\spad{false}")
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#) (|Boolean|) |#2|)
   "\\spad{exprToPS(fcn,{} posCheck?,{} atanFlag,{} log_flag,{} log_val)} is like exprToUPS,{} but if \\spad{log_flag} is \\spad{true} it replaces logarithms of expansion variable by \\spad{log_val}"))
 (|exprToGenUPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#))
   "\\spad{exprToGenUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \\spad{fcn} to a generalized power series. If \\spad{posCheck?} is \\spad{true},{} log\\spad{'s} of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is \\spad{false},{} these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))},{} where \\spad{f(x)} has a pole,{} will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"},{} \\spad{\"real: two sides\"},{} \\spad{\"real: left side\"},{} \\spad{\"real: right side\"},{} and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \\spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"},{} no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \\spad{x -> x + a} before calling this function."))
 (|exprToUPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#))
   "\\spad{exprToUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \\spad{fcn} to a power series. If \\spad{posCheck?} is \\spad{true},{} log\\spad{'s} of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is \\spad{false},{} these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))},{} where \\spad{f(x)} has a pole,{} will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"},{} \\spad{\"real: two sides\"},{} \\spad{\"real: left side\"},{} \\spad{\"real: right side\"},{} and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \\spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"},{} no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \\spad{x -> x + a} before calling this function."))
 (|coerce|
  (($ |#3|)
   "\\spad{coerce(e)} converts an 'exponent' \\spad{e} to an 'expression'"))) 
NIL 
(|FunctionSpaceToUnivariatePowerSeries2| R FE |Expon| UPS TRAN UTS TEXP
                                         |coerce_Ex| |x|) 
((|constructor|
  (NIL
   "This package converts expressions in some function space to power series in a variable \\spad{x} with coefficients in that function space. The function \\spadfun{exprToUPS} converts expressions to power series whose coefficients do not contain the variable \\spad{x}. The function \\spadfun{exprToGenUPS} converts functional expressions to power series whose coefficients may involve functions of \\spad{log(x)}."))
 (|my_digamma|
  ((|#2| |#2|) "\\spad{my_digamma should} be local but conditional"))
 (|powToUPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    (|List| |#2|)
    (|Record| (|:| |pos_Check?| (|Boolean|))
              (|:| |atan_Flag|
                   (|Union| #1="complex" #2="real: two sides"
                            #3="real: left side" #4="real: right side"
                            #5="just do it"))
              (|:| |coeff_check?|
                   (|Union| (|Mapping| (|Boolean|) |#2|) #6="none"))
              (|:| |inv_check?| (|Union| (|Mapping| (|Boolean|) |#2|) #6#))
              (|:| |zero_check?| (|Union| (|Mapping| (|Boolean|) |#2|) #6#))
              (|:| |log_x_replace| (|Boolean|)) (|:| |log_x_val| |#2|)))
   "\\spad{powToUPS should} be local but conditional"))
 (|integ_df|
  ((|#4| |#4| |#4|) "\\spad{integ_df should} be local but conditional"))
 (|integt| ((|#6| |#6|) "\\spad{integt should} be local but conditional"))
 (|integ| ((|#4| |#4|) "\\spad{integ should} be local but conditional"))
 (|atan1| ((|#4| |#4|) "\\spad{atan1 should} be local but conditional"))
 (|localAbs|
  ((|#2| |#2|)
   "\\spad{localAbs(fcn)} = \\spad{abs(fcn)} or \\spad{sqrt(fcn^2)} depending on whether or not FE has a function \\spad{abs}. This should be a local function,{} but the compiler won\\spad{'t} allow it."))
 (|exprToPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#) (|Boolean|) |#2|
    (|Mapping| (|Boolean|) |#2|) (|Mapping| (|Boolean|) |#2|)
    (|Mapping| (|Boolean|) |#2|))
   "exprToPS(\\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val,{} coef_chk,{} inv_chk,{} zero_chk) is like exprToPS(\\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val),{} but fails if \\spad{coef_chk} is \\spad{false} for some coefficient of \\spad{fcn} or if expansion process needs to invert element of \\spad{FE} for which \\spad{inv_chk} is \\spad{false}")
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#) (|Boolean|) |#2|)
   "\\spad{exprToPS(fcn,{} posCheck?,{} atanFlag,{} log_flag,{} log_val)} is like exprToUPS,{} but if \\spad{log_flag} is \\spad{true} it replaces logarithms of expansion variable by \\spad{log_val}"))
 (|exprToGenUPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#))
   "\\spad{exprToGenUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \\spad{fcn} to a generalized power series. If \\spad{posCheck?} is \\spad{true},{} log\\spad{'s} of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is \\spad{false},{} these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))},{} where \\spad{f(x)} has a pole,{} will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"},{} \\spad{\"real: two sides\"},{} \\spad{\"real: left side\"},{} \\spad{\"real: right side\"},{} and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \\spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"},{} no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \\spad{x -> x + a} before calling this function."))
 (|exprToUPS|
  (((|Union| (|:| |%series| |#4|)
             (|:| |%problem|
                  (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|)))))
    |#2| (|Boolean|) (|Union| #1# #2# #3# #4# #5#))
   "\\spad{exprToUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \\spad{fcn} to a power series. If \\spad{posCheck?} is \\spad{true},{} log\\spad{'s} of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is \\spad{false},{} these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))},{} where \\spad{f(x)} has a pole,{} will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"},{} \\spad{\"real: two sides\"},{} \\spad{\"real: left side\"},{} \\spad{\"real: right side\"},{} and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \\spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"},{} no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \\spad{x -> x + a} before calling this function."))) 
NIL 
(|FiniteSetAggregate&| A S) 
((|constructor|
  (NIL
   "A finite-set aggregate models the notion of a finite set,{} that is,{} a collection of elements characterized by membership,{} but not by order or multiplicity. See \\spadtype{Set} for an example."))
 (|universe|
  (($)
   "\\spad{universe()}\\$\\spad{D} returns the universal set for finite set aggregate \\spad{D}."))
 (|complement|
  (($ $)
   "\\spad{complement(u)} returns the complement of the set \\spad{u},{} \\spadignore{i.e.} the set of all values not in \\spad{u}."))
 (|cardinality|
  (((|NonNegativeInteger|) $)
   "\\spad{cardinality(u)} returns the number of elements of \\spad{u}. Note: \\spad{cardinality(u) = \\#u}."))) 
((|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#2| '(|Finite|))) 
(|FiniteSetAggregate| S) 
((|constructor|
  (NIL
   "A finite-set aggregate models the notion of a finite set,{} that is,{} a collection of elements characterized by membership,{} but not by order or multiplicity. See \\spadtype{Set} for an example."))
 (|universe|
  (($)
   "\\spad{universe()}\\$\\spad{D} returns the universal set for finite set aggregate \\spad{D}."))
 (|complement|
  (($ $)
   "\\spad{complement(u)} returns the complement of the set \\spad{u},{} \\spadignore{i.e.} the set of all values not in \\spad{u}."))
 (|cardinality|
  (((|NonNegativeInteger|) $)
   "\\spad{cardinality(u)} returns the number of elements of \\spad{u}. Note: \\spad{cardinality(u) = \\#u}."))) 
NIL 
(|FiniteSetAggregateFunctions2| S A R B) 
((|constructor|
  (NIL
   "\\spad{FiniteSetAggregateFunctions2} provides functions involving two finite set aggregates where the underlying domains might be different. An example of this is to create a set of rational numbers by mapping a function across a set of integers,{} where the function divides each integer by 1000."))
 (|scan|
  ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-aggregates \\spad{x} of aggregate \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad {[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))
 (|reduce|
  ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialised to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does a \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as an identity element for the function."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of aggregate \\spad{a},{} creating a new aggregate with a possibly different underlying domain."))) 
NIL 
(|FunctionSpaceComplexIntegration| R F) 
((|constructor|
  (NIL
   "\\spadtype{FunctionSpaceComplexIntegration} provides functions for the indefinite integration of complex-valued functions."))
 (|complexIntegrate|
  ((|#2| |#2| (|Symbol|))
   "\\spad{complexIntegrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable."))
 (|internalIntegrate0|
  (((|IntegrationResult| |#2|) |#2| (|Symbol|))
   "\\spad{internalIntegrate0 should} be a local function,{} but is conditional."))
 (|internalIntegrate|
  (((|IntegrationResult| |#2|) |#2| (|Symbol|))
   "\\spad{internalIntegrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable."))) 
NIL 
(|FunctionSpaceComplexIntegrationAux| G FG) 
((|constructor|
  (NIL
   "\\spadtype{FunctionSpaceComplexIntegrationAux} provides functions for the indefinite integration of complex-valued functions."))
 (|internalIntegrate|
  (((|IntegrationResult| |#2|) |#2| (|Symbol|))
   "\\spad{internalIntegrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable."))) 
NIL 
(|FourierSeries| R E) 
((|constructor|
  (NIL
   "\\indented{1}{Author: James Davenport} Date Created: 17 April 1992 Basic Functions: Related Constructors: Also See: AMS Classifications: Keywords: References: Description:"))
 (|makeCos|
  (($ |#2| |#1|)
   "\\spad{makeCos(e,{} r)} makes a sin expression with given argument and coefficient"))
 (|makeSin|
  (($ |#2| |#1|)
   "\\spad{makeSin(e,{} r)} makes a sin expression with given argument and coefficient"))
 (|coerce|
  (($ (|FourierComponent| |#2|))
   "\\spad{coerce(c)} converts sin/cos terms into Fourier Series")
  (($ |#1|) "\\spad{coerce(r)} converts coefficients into Fourier Series"))) 
((AND (|HasCategory| |#1| '(|Canonical|)) (|HasCategory| |#2| '(|Canonical|)))) 
(|FloatSpecialFunctions|) 
((|lambert_inverse_series|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)))
   "Undocumented")
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "Undocumented")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "Undocumented")
  (((|Float|) (|Float|) (|Float|)) "Undocumented"))
 (|lambert_via_newton2|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|DoubleFloat|))
   "Undocumented")
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|))
    (|Float|))
   "Undocumented")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "Undocumented")
  (((|Float|) (|Float|) (|Float|) (|Float|)) "Undocumented"))
 (|lambert_via_newton1|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))
    (|Complex| (|DoubleFloat|)) (|DoubleFloat|))
   "Undocumented")
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|))
    (|Float|))
   "Undocumented")
  (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "Undocumented")
  (((|Float|) (|Float|) (|Float|) (|Float|)) "Undocumented"))
 (|rabs| (((|DoubleFloat|) (|Complex| (|DoubleFloat|))) "Undocumented")
  (((|DoubleFloat|) (|DoubleFloat|)) "Undocumented")
  (((|Float|) (|Complex| (|Float|))) "Undocumented")
  (((|Float|) (|Float|)) "Undocumented"))
 (|li2|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{li2(z)} is polylog(2,{} \\spad{z})"))
 (|dilog|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{dilog(z)} is the dilogaritm"))
 (|lambertW|
  (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)))
   "\\spad{lambertW(x)} is the Lambert \\spad{W} function.")
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{lambertW(x)} is the Lambert \\spad{W} function.")
  (((|DoubleFloat|) (|DoubleFloat|))
   "\\spad{lambertW(x)} is the Lambert \\spad{W} function.")
  (((|Float|) (|Float|))
   "\\spad{lambertW(x)} is the Lambert \\spad{W} function."))
 (|Beta|
  (((|Complex| (|Float|)) (|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{Beta(x,{} y)} is the Euler Beta function.")
  (((|Float|) (|Float|) (|Float|))
   "\\spad{Beta(x,{} y)} is the Euler Beta function."))
 (|digamma|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{digamma(z)} is the logarithmic derivative of \\spad{Gamma(x)}.")
  (((|Float|) (|Float|))
   "\\spad{digamma(z)} is the logarithmic derivative of \\spad{Gamma(x)}."))
 (|Gamma|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{Gamma(x)} is the Euler Gamma function.")
  (((|Float|) (|Float|)) "\\spad{Gamma(x)} is the Euler Gamma function."))
 (|logGamma|
  (((|Complex| (|Float|)) (|Complex| (|Float|)))
   "\\spad{logGamma(x)} is the natural log of \\spad{Gamma(x)}.")
  (((|Float|) (|Float|))
   "\\spad{logGamma(x)} is the natural log of \\spad{Gamma(x)}."))) 
NIL 
(|FunctionSpaceIntegration| R F) 
((|constructor|
  (NIL
   "\\spadtype{FunctionSpaceIntegration} provides functions for the indefinite integration of real-valued functions."))
 (|integrate|
  (((|Union| |#2| (|List| |#2|)) |#2| (|Symbol|))
   "\\spad{integrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a real variable."))) 
NIL 
(|FunctionalSpecialFunction| R F) 
((|constructor|
  (NIL "Provides some special functions over an integral domain."))
 (|iLambertW|
  ((|#2| |#2|) "\\spad{iLambertW(x)} should be local but conditional."))
 (|iiPolylog|
  ((|#2| |#2| |#2|)
   "\\spad{iiPolylog(x,{} s)} should be local but conditional."))
 (|iiHypergeometricF|
  ((|#2| (|List| |#2|))
   "\\spad{iiHypergeometricF(l)} should be local but conditional."))
 (|iAiryBiPrime|
  ((|#2| |#2|) "\\spad{iAiryBiPrime(x)} should be local but conditional."))
 (|iAiryBi|
  ((|#2| |#2|) "\\spad{iAiryBi(x)} should be local but conditional."))
 (|iAiryAiPrime|
  ((|#2| |#2|) "\\spad{iAiryAiPrime(x)} should be local but conditional."))
 (|iAiryAi|
  ((|#2| |#2|) "\\spad{iAiryAi(x)} should be local but conditional."))
 (|iiAiryBiPrime|
  ((|#2| |#2|) "\\spad{iiAiryBiPrime(x)} should be local but conditional."))
 (|iiAiryBi|
  ((|#2| |#2|) "\\spad{iiAiryBi(x)} should be local but conditional."))
 (|iiAiryAiPrime|
  ((|#2| |#2|) "\\spad{iiAiryAiPrime(x)} should be local but conditional."))
 (|iiAiryAi|
  ((|#2| |#2|) "\\spad{iiAiryAi(x)} should be local but conditional."))
 (|iiBesselK|
  ((|#2| (|List| |#2|))
   "\\spad{iiBesselK(x)} should be local but conditional."))
 (|iiBesselI|
  ((|#2| (|List| |#2|))
   "\\spad{iiBesselI(x)} should be local but conditional."))
 (|iiBesselY|
  ((|#2| (|List| |#2|))
   "\\spad{iiBesselY(x)} should be local but conditional."))
 (|iiBesselJ|
  ((|#2| (|List| |#2|))
   "\\spad{iiBesselJ(x)} should be local but conditional."))
 (|iipolygamma|
  ((|#2| (|List| |#2|))
   "\\spad{iipolygamma(x)} should be local but conditional."))
 (|iidigamma|
  ((|#2| |#2|) "\\spad{iidigamma(x)} should be local but conditional."))
 (|iiBeta|
  ((|#2| (|List| |#2|)) "\\spad{iiBeta(x)} should be local but conditional."))
 (|iiconjugate|
  ((|#2| |#2|) "\\spad{iiconjugate(x)} should be local but conditional."))
 (|iiabs| ((|#2| |#2|) "\\spad{iiabs(x)} should be local but conditional."))
 (|iiGamma|
  ((|#2| |#2|) "\\spad{iiGamma(x)} should be local but conditional."))
 (|meijerG|
  ((|#2| (|List| |#2|) (|List| |#2|) (|List| |#2|) (|List| |#2|) |#2|)
   "\\spad{meijerG(la,{} lb,{} lc,{} ld,{} z)} is the meijerG function"))
 (|hypergeometricF|
  ((|#2| (|List| |#2|) (|List| |#2|) |#2|)
   "\\spad{hypergeometricF(la,{} lb,{} z)} is the generalized hypergeometric function"))
 (|meixnerM|
  ((|#2| |#2| |#2| |#2| |#2|)
   "\\spad{meixnerM(n,{} b,{} c,{} z)} is the Meixner polynomial"))
 (|laguerreL|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{laguerreL(n,{} a,{} z)} is the Laguerre polynomial"))
 (|jacobiP|
  ((|#2| |#2| |#2| |#2| |#2|)
   "\\spad{jacobiP(n,{} a,{} b,{} z)} is the Jacobi polynomial"))
 (|hermiteH|
  ((|#2| |#2| |#2|) "\\spad{hermiteH(n,{} z)} is the Hermite polynomial"))
 (|charlierC|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{charlierC(n,{} a,{} z)} is the Charlier polynomial"))
 (|riemannZeta|
  ((|#2| |#2|) "\\spad{riemannZeta(z)} is the Riemann Zeta function"))
 (|lerchPhi|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{lerchPhi(z,{} s,{} a)} is the Lerch Phi function"))
 (|jacobiTheta|
  ((|#2| |#2| |#2|)
   "\\spad{jacobiTheta(z,{} m)} is the Jacobi Theta function in Jacobi notation."))
 (|jacobiZeta|
  ((|#2| |#2| |#2|)
   "\\spad{jacobiZeta(z,{} m)} is the Jacobi elliptic zeta function,{} defined by \\spad{D(jacobiZeta(z,{} m),{} z) = jacobiDn(z,{} m)^2 - ellipticE(m)/ellipticK(m)} and \\spad{jacobiZeta(0,{} m) = 0}."))
 (|jacobiDn|
  ((|#2| |#2| |#2|)
   "\\spad{jacobiDn(z,{} m)} is the Jacobi elliptic \\spad{dn} function,{} defined by \\spad{jacobiDn(z,{} m)^2 + m*jacobiSn(z,{} m)^2 = 1} and \\spad{jacobiDn(0,{} m) = 1}"))
 (|jacobiCn|
  ((|#2| |#2| |#2|)
   "\\spad{jacobiCn(z,{} m)} is the Jacobi elliptic \\spad{cn} function,{} defined by \\spad{jacobiCn(z,{} m)^2 + jacobiSn(z,{} m)^2 = 1} and \\spad{jacobiCn(0,{} m) = 1}"))
 (|jacobiSn|
  ((|#2| |#2| |#2|)
   "\\spad{jacobiSn(z,{} m)} is the Jacobi elliptic \\spad{sn} function,{} defined by the formula \\spad{jacobiSn(ellipticF(z,{} m),{} m) = z}"))
 (|ellipticPi|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind: \\spad{ellipticPi(z,{} n,{} m) = integrate(1/((1-n*t^2)*sqrt((1-t^2)*(1-m*t^2))),{} t = 0..z)}"))
 (|ellipticF|
  ((|#2| |#2| |#2|)
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind : \\spad{ellipticF(z,{} m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..z)}"))
 (|ellipticE|
  ((|#2| |#2| |#2|)
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind: \\spad{ellipticE(z,{} m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..z)}")
  ((|#2| |#2|)
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind: \\spad{ellipticE(m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..1)}"))
 (|ellipticK|
  ((|#2| |#2|)
   "\\spad{ellipticK(m)} is the complete elliptic integral of the first kind: \\spad{ellipticK(m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..1)}"))
 (|kelvinKer|
  ((|#2| |#2| |#2|)
   "\\spad{kelvinKer(v,{} z)} is the Kelvin kei function defined by equality \\spad{kelvinKer(v,{} z) = real(exp(-v*\\%pi*\\%i/2)*besselK(v,{} exp(\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real"))
 (|kelvinKei|
  ((|#2| |#2| |#2|)
   "\\spad{kelvinKei(v,{} z)} is the Kelvin kei function defined by equality \\spad{kelvinKei(v,{} z) = imag(exp(-v*\\%pi*\\%i/2)*besselK(v,{} exp(\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real"))
 (|kelvinBer|
  ((|#2| |#2| |#2|)
   "\\spad{kelvinBer(v,{} z)} is the Kelvin ber function defined by equality \\spad{kelvinBer(v,{} z) = real(besselJ(v,{} exp(3*\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real"))
 (|kelvinBei|
  ((|#2| |#2| |#2|)
   "\\spad{kelvinBei(v,{} z)} is the Kelvin bei function defined by equality \\spad{kelvinBei(v,{} z) = imag(besselJ(v,{} exp(3*\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real"))
 (|legendreQ|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{legendreQ(nu,{} mu,{} z)} is the Legendre \\spad{Q} function"))
 (|legendreP|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{legendreP(nu,{} mu,{} z)} is the Legendre \\spad{P} function"))
 (|kummerU|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{kummerU(a,{} b,{} z)} is the Kummer \\spad{U} function"))
 (|kummerM|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{kummerM(a,{} b,{} z)} is the Kummer \\spad{M} function"))
 (|lommelS2|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{lommelS2(mu,{} nu,{} z)} is the Lommel \\spad{S} function"))
 (|lommelS1|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{lommelS1(mu,{} nu,{} z)} is the Lommel \\spad{s} function"))
 (|hankelH2|
  ((|#2| |#2| |#2|)
   "\\spad{hankelH2(v,{} z)} is the second Hankel function (Bessel function of the third kind)"))
 (|hankelH1|
  ((|#2| |#2| |#2|)
   "\\spad{hankelH1(v,{} z)} is first Hankel function (Bessel function of the third kind)"))
 (|struveL|
  ((|#2| |#2| |#2|)
   "\\spad{struveL(v,{} z)} is the Struve \\spad{L} function defined by the formula \\spad{struveL(v,{} z) = -\\%i^exp(-v*\\%pi*\\%i/2)*struveH(v,{} \\%i*z)}"))
 (|struveH|
  ((|#2| |#2| |#2|)
   "\\spad{struveH(v,{} z)} is the Struve \\spad{H} function"))
 (|weberE|
  ((|#2| |#2| |#2|) "\\spad{weberE(v,{} z)} is the Weber \\spad{E} function"))
 (|angerJ|
  ((|#2| |#2| |#2|) "\\spad{angerJ(v,{} z)} is the Anger \\spad{J} function"))
 (|whittakerW|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{whittakerW(k,{} m,{} z)} is the Whittaker \\spad{W} function"))
 (|whittakerM|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{whittakerM(k,{} m,{} z)} is the Whittaker \\spad{M} function"))
 (|weierstrassPInverse|
  ((|#2| |#2| |#2| |#2|)
   "\\spad{weierstrassPInverse(g2,{} g3,{} z)} is the inverse of Weierstrass \\spad{P} function,{} defined by the formula \\spad{weierstrassP(g2,{} g3,{} weierstrassPInverse(g2,{} g3,{} z)) = z}"))
 (|weierstrassZeta|
  ((|#2| |#2| |#2| |#2|) "\\spad{weierstrassZeta(g2,{} g3,{} x)}"))
 (|weierstrassSigma|
  ((|#2| |#2| |#2| |#2|) "\\spad{weierstrassSigma(g2,{} g3,{} x)}"))
 (|weierstrassPPrime|
  ((|#2| |#2| |#2| |#2|) "\\spad{weierstrassPPrime(g2,{} g3,{} x)}"))
 (|weierstrassP| ((|#2| |#2| |#2| |#2|) "\\spad{weierstrassP(g2,{} g3,{} x)}"))
 (|polylog|
  ((|#2| |#2| |#2|)
   "\\spad{polylog(s,{} x)} is the polylogarithm of order \\spad{s} at \\spad{x}"))
 (|lambertW|
  ((|#2| |#2|)
   "\\spad{lambertW(x)} is the Lambert \\spad{W} function at \\spad{x}"))
 (|airyBiPrime|
  ((|#2| |#2|)
   "\\spad{airyBiPrime(x)} returns the derivative of Airy \\spad{Bi} function applied to \\spad{x}"))
 (|airyBi|
  ((|#2| |#2|)
   "\\spad{airyBi(x)} returns the Airy \\spad{Bi} function applied to \\spad{x}"))
 (|airyAiPrime|
  ((|#2| |#2|)
   "\\spad{airyAiPrime(x)} returns the derivative of Airy \\spad{Ai} function applied to \\spad{x}"))
 (|airyAi|
  ((|#2| |#2|)
   "\\spad{airyAi(x)} returns the Airy \\spad{Ai} function applied to \\spad{x}"))
 (|besselK|
  ((|#2| |#2| |#2|)
   "\\spad{besselK(x,{} y)} returns the besselk function applied to \\spad{x} and \\spad{y}"))
 (|besselI|
  ((|#2| |#2| |#2|)
   "\\spad{besselI(x,{} y)} returns the besseli function applied to \\spad{x} and \\spad{y}"))
 (|besselY|
  ((|#2| |#2| |#2|)
   "\\spad{besselY(x,{} y)} returns the bessely function applied to \\spad{x} and \\spad{y}"))
 (|besselJ|
  ((|#2| |#2| |#2|)
   "\\spad{besselJ(x,{} y)} returns the besselj function applied to \\spad{x} and \\spad{y}"))
 (|polygamma|
  ((|#2| |#2| |#2|)
   "\\spad{polygamma(x,{} y)} returns the polygamma function applied to \\spad{x} and \\spad{y}"))
 (|digamma|
  ((|#2| |#2|)
   "\\spad{digamma(x)} returns the digamma function applied to \\spad{x}"))
 (|Beta|
  ((|#2| |#2| |#2|)
   "\\spad{Beta(x,{} y)} returns the beta function applied to \\spad{x} and \\spad{y}"))
 (|Gamma|
  ((|#2| |#2| |#2|)
   "\\spad{Gamma(a,{} x)} returns the incomplete Gamma function applied to a and \\spad{x}")
  ((|#2| |#2|)
   "\\spad{Gamma(f)} returns the formal Gamma function applied to \\spad{f}"))
 (|conjugate|
  ((|#2| |#2|)
   "\\spad{conjugate(f)} returns the conjugate value operator applied to \\spad{f}"))
 (|abs|
  ((|#2| |#2|)
   "\\spad{abs(f)} returns the absolute value operator applied to \\spad{f}"))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F}; error if \\spad{op} is not a special function operator"))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} returns \\spad{true} if \\spad{op} is a special function operator."))) 
((|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))) 
(|FunctionSpacePrimitiveElement| R F) 
((|constructor|
  (NIL
   "FunctionsSpacePrimitiveElement provides functions to compute primitive elements in functions spaces."))
 (|primitiveElement|
  (((|Record| (|:| |primelt| |#2|)
              (|:| |pol1| (|SparseUnivariatePolynomial| |#2|))
              (|:| |pol2| (|SparseUnivariatePolynomial| |#2|))
              (|:| |prim| (|SparseUnivariatePolynomial| |#2|)))
    |#2| |#2|)
   "\\spad{primitiveElement(a1,{} a2)} returns \\spad{[a,{} q1,{} q2,{} q]} such that \\spad{k(a1,{} a2) = k(a)},{} \\spad{\\spad{ai} = \\spad{qi}(a)},{} and \\spad{q(a) = 0}. The minimal polynomial for \\spad{a2} may involve \\spad{a1},{} but the minimal polynomial for \\spad{a1} may not involve \\spad{a2}; This operations uses \\spadfun{resultant}.")
  (((|Record| (|:| |primelt| |#2|)
              (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#2|)))
              (|:| |prim| (|SparseUnivariatePolynomial| |#2|)))
    (|List| |#2|))
   "\\spad{primitiveElement([a1,{} ...,{} an])} returns \\spad{[a,{} [q1,{} ...,{} qn],{} q]} such that then \\spad{k(a1,{} ...,{} an) = k(a)},{} \\spad{\\spad{ai} = \\spad{qi}(a)},{} and \\spad{q(a) = 0}. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}."))) 
((|HasCategory| |#2| '(|AlgebraicallyClosedField|))) 
(|FunctionSpaceReduce| R F) 
((|constructor|
  (NIL
   "This package provides function which replaces transcendental kernels in a function space by random integers. The correspondence between the kernels and the integers is fixed between calls to newReduc()."))
 (|newReduc|
  (((|Void|) (|Integer|))
   "\\spad{newReduc(n)} empties reduction state. \\spad{n} is size of random integers to use during next reduction."))
 (|bringDown|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) |#2|
    (|Kernel| |#2|))
   "\\spad{bringDown(f,{} k)} is like bringDown(\\spad{f}) but \\spad{k} is algebraic kernel and the result is reduced modulo minimal polynomial of \\spad{k}.")
  (((|Fraction| (|Integer|)) |#2|)
   "\\spad{bringDown(f)} replaces transcendental kernels in \\spad{f} by random integers. Error if \\spad{f} contains algebraic kernel."))) 
NIL 
(|FunctionSpaceRationalRoots| R F) 
((|get_rational_roots|
  (((|List| (|Fraction| (|Integer|))) |#2| (|Kernel| |#2|))
   "\\spad{get_rational_roots(f,{} k)} finds rational root of \\spad{f} treated as univariate polynomial in \\spad{k}."))) 
NIL 
(|FortranScalarType|) 
((|constructor|
  (NIL
   "Creates and manipulates objects which correspond to the basic FORTRAN data types: REAL,{} INTEGER,{} COMPLEX,{} LOGICAL and CHARACTER"))
 (= (((|Boolean|) $ $) "\\spad{x=y} tests for equality"))
 (|logical?|
  (((|Boolean|) $)
   "\\spad{logical?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type LOGICAL."))
 (|character?|
  (((|Boolean|) $)
   "\\spad{character?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type CHARACTER."))
 (|doubleComplex?|
  (((|Boolean|) $)
   "\\spad{doubleComplex?(t)} tests whether \\spad{t} is equivalent to the (non-standard) FORTRAN type DOUBLE COMPLEX."))
 (|complex?|
  (((|Boolean|) $)
   "\\spad{complex?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type COMPLEX."))
 (|integer?|
  (((|Boolean|) $)
   "\\spad{integer?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type INTEGER."))
 (|double?|
  (((|Boolean|) $)
   "\\spad{double?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type DOUBLE PRECISION"))
 (|real?|
  (((|Boolean|) $)
   "\\spad{real?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type REAL."))
 (|coerce|
  (((|SExpression|) $)
   "\\spad{coerce(x)} returns the \\spad{s}-expression associated with \\spad{x}")
  (((|Symbol|) $)
   "\\spad{coerce(x)} returns the symbol associated with \\spad{x}")
  (($ (|Symbol|))
   "\\spad{coerce(s)} transforms the symbol \\spad{s} into an element of FortranScalarType provided \\spad{s} is one of real,{} complex,{} double precision,{} logical,{} integer,{} character,{} REAL,{} COMPLEX,{} LOGICAL,{} INTEGER,{} CHARACTER,{} DOUBLE PRECISION")
  (((|String|) $)
   "\\spad{coerce(x)} returns the uppercase string associated with \\spad{x}")
  (($ (|String|))
   "\\spad{coerce(s)} transforms the string \\spad{s} into an element of FortranScalarType provided \\spad{s} is one of \"real\",{} \"double precision\",{} \"complex\",{} \"logical\",{} \"integer\",{} \"character\",{} \"REAL\",{} \"COMPLEX\",{} \"LOGICAL\",{} \"INTEGER\",{} \"CHARACTER\",{} \"DOUBLE PRECISION\""))) 
NIL 
(|FortranType|) 
((|constructor|
  (NIL
   "Creates and manipulates objects which correspond to FORTRAN data types,{} including array dimensions."))
 (|fortranCharacter|
  (($)
   "\\spad{fortranCharacter()} returns CHARACTER,{} an element of FortranType"))
 (|fortranDoubleComplex|
  (($)
   "\\spad{fortranDoubleComplex()} returns DOUBLE COMPLEX,{} an element of FortranType"))
 (|fortranComplex|
  (($)
   "\\spad{fortranComplex()} returns COMPLEX,{} an element of FortranType"))
 (|fortranLogical|
  (($)
   "\\spad{fortranLogical()} returns LOGICAL,{} an element of FortranType"))
 (|fortranInteger|
  (($)
   "\\spad{fortranInteger()} returns INTEGER,{} an element of FortranType"))
 (|fortranDouble|
  (($)
   "\\spad{fortranDouble()} returns DOUBLE PRECISION,{} an element of FortranType"))
 (|fortranReal|
  (($) "\\spad{fortranReal()} returns REAL,{} an element of FortranType"))
 (|construct|
  (($ (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1="void"))
    (|List| (|Polynomial| (|Integer|))) (|Boolean|))
   "\\spad{construct(type,{} dims)} creates an element of FortranType")
  (($ (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1#))
    (|List| (|Symbol|)) (|Boolean|))
   "\\spad{construct(type,{} dims)} creates an element of FortranType"))
 (|external?|
  (((|Boolean|) $)
   "\\spad{external?(u)} returns \\spad{true} if \\spad{u} is declared to be EXTERNAL"))
 (|dimensionsOf|
  (((|List| (|Polynomial| (|Integer|))) $)
   "\\spad{dimensionsOf(t)} returns the dimensions of \\spad{t}"))
 (|scalarTypeOf|
  (((|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1#)) $)
   "\\spad{scalarTypeOf(t)} returns the FORTRAN data type of \\spad{t}"))
 (|coerce|
  (($ (|FortranScalarType|))
   "\\spad{coerce(t)} creates an element from a scalar type")
  (((|OutputForm|) $)
   "\\spad{coerce(x)} provides a printable form for \\spad{x}"))) 
NIL 
(|FortranTemplate|) 
((|constructor| (NIL "Code to manipulate Fortran templates"))
 (|fortranCarriageReturn|
  (((|Void|))
   "\\spad{fortranCarriageReturn()} produces a carriage return on the current Fortran output stream"))
 (|fortranLiteral|
  (((|Void|) (|String|))
   "\\spad{fortranLiteral(s)} writes \\spad{s} to the current Fortran output stream"))
 (|fortranLiteralLine|
  (((|Void|) (|String|))
   "\\spad{fortranLiteralLine(s)} writes \\spad{s} to the current Fortran output stream,{} followed by a carriage return"))
 (|processTemplate|
  (((|FileName|) (|FileName|))
   "\\spad{processTemplate(tp)} processes the template \\spad{tp},{} writing the result to the current FORTRAN output stream.")
  (((|FileName|) (|FileName|) (|FileName|))
   "\\spad{processTemplate(tp,{} fn)} processes the template \\spad{tp},{} writing the result out to \\spad{fn}."))) 
NIL 
(|FunctionCalled| |f|) 
((|constructor| (NIL "This domain implements named functions"))
 (|name| (((|Symbol|) $) "\\spad{name(x)} returns the symbol"))) 
NIL 
(|FortranVectorCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranVectorCategory} provides support for producing Functions and Subroutines when the input to these is a FriCAS object of type \\spadtype{Vector} or in domains involving \\spadtype{FortranCode}."))
 (|coerce|
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \\spadtype{SymbolTable} component.")
  (($ (|FortranCode|))
   "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|List| (|FortranCode|)))
   "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|Vector| (|MachineFloat|)))
   "\\spad{coerce(v)} produces an ASP which returns the value of \\spad{v}."))) 
NIL 
(|FortranVectorFunctionCategory|) 
((|constructor|
  (NIL
   "\\spadtype{FortranVectorFunctionCategory} is the catagory of arguments to NAG Library routines which return the values of vectors of functions."))
 (|retractIfCan|
  (((|Union| $ "failed") (|Vector| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Vector| (|Fraction| (|Polynomial| (|Float|)))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Vector| (|Polynomial| (|Integer|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Vector| (|Polynomial| (|Float|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Vector| (|Expression| (|Integer|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (((|Union| $ "failed") (|Vector| (|Expression| (|Float|))))
   "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|retract|
  (($ (|Vector| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Vector| (|Fraction| (|Polynomial| (|Float|)))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Vector| (|Polynomial| (|Integer|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Vector| (|Polynomial| (|Float|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Vector| (|Expression| (|Integer|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}")
  (($ (|Vector| (|Expression| (|Float|))))
   "\\spad{retract(e)} tries to convert \\spad{e} into an ASP,{} checking that \\indented{1}{legal Fortran-77 is produced.}"))
 (|coerce|
  (($
    (|Record| (|:| |localSymbols| (|SymbolTable|))
              (|:| |code| (|List| (|FortranCode|)))))
   "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \\spadtype{SymbolTable} component.")
  (($ (|FortranCode|))
   "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}")
  (($ (|List| (|FortranCode|)))
   "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
NIL 
(|GaloisGroupFactorizer| UP) 
((|constructor|
  (NIL
   "\\spadtype{GaloisGroupFactorizer} provides functions to factor resolvents."))
 (|btwFact|
  (((|Record| (|:| |contp| (|Integer|))
              (|:| |factors|
                   (|List|
                    (|Record| (|:| |irr| |#1|)
                              (|:| |pow| (|NonNegativeInteger|))))))
    |#1| (|Boolean|) (|Set| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{btwFact(p,{} sqf,{} pd,{} r)} returns the factorization of \\spad{p},{} the result is a Record such that \\spad{contp=}content \\spad{p},{} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors). \\spad{pd} is the \\spadtype{Set} of possible degrees. \\spad{r} is a lower bound for the number of factors of \\spad{p}. Please do not use this function in your code because its design may change."))
 (|henselFact|
  (((|Record| (|:| |contp| (|Integer|))
              (|:| |factors|
                   (|List|
                    (|Record| (|:| |irr| |#1|)
                              (|:| |pow| (|NonNegativeInteger|))))))
    |#1| (|Boolean|))
   "\\spad{henselFact(p,{} sqf)} returns the factorization of \\spad{p},{} the result is a Record such that \\spad{contp=}content \\spad{p},{} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors)."))
 (|factorOfDegree|
  (((|Union| |#1| "failed") (|PositiveInteger|) |#1|
    (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|) (|Boolean|))
   "\\spad{factorOfDegree(d,{} p,{} listOfDegrees,{} r,{} sqf)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees},{} and that \\spad{p} has at least \\spad{r} factors. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors).")
  (((|Union| |#1| "failed") (|PositiveInteger|) |#1|
    (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{factorOfDegree(d,{} p,{} listOfDegrees,{} r)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees},{} and that \\spad{p} has at least \\spad{r} factors.")
  (((|Union| |#1| "failed") (|PositiveInteger|) |#1|
    (|List| (|NonNegativeInteger|)))
   "\\spad{factorOfDegree(d,{} p,{} listOfDegrees)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree listOfDegrees.")
  (((|Union| |#1| "failed") (|PositiveInteger|) |#1| (|NonNegativeInteger|))
   "\\spad{factorOfDegree(d,{} p,{} r)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has at least \\spad{r} factors.")
  (((|Union| |#1| "failed") (|PositiveInteger|) |#1|)
   "\\spad{factorOfDegree(d,{} p)} returns a factor of \\spad{p} of degree \\spad{d}."))
 (|factorSquareFree|
  (((|Factored| |#1|) |#1| (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{factorSquareFree(p,{} d,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm,{} knowing that \\spad{d} divides the degree of all factors of \\spad{p} and that \\spad{p} has at least \\spad{r} factors. \\spad{p} is supposed not having any repeated factor (this is not checked).")
  (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|))
    (|NonNegativeInteger|))
   "\\spad{factorSquareFree(p,{} listOfDegrees,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm,{} knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees} and that \\spad{p} has at least \\spad{r} factors. \\spad{p} is supposed not having any repeated factor (this is not checked).")
  (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|)))
   "\\spad{factorSquareFree(p,{} listOfDegrees)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has for possible splitting of its degree listOfDegrees. \\spad{p} is supposed not having any repeated factor (this is not checked).")
  (((|Factored| |#1|) |#1| (|NonNegativeInteger|))
   "\\spad{factorSquareFree(p,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has at least \\spad{r} factors. \\spad{p} is supposed not having any repeated factor (this is not checked).")
  (((|Factored| |#1|) |#1|)
   "\\spad{factorSquareFree(p)} returns the factorization of \\spad{p} which is supposed not having any repeated factor (this is not checked)."))
 (|factor|
  (((|Factored| |#1|) |#1| (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{factor(p,{} d,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm,{} knowing that \\spad{d} divides the degree of all factors of \\spad{p} and that \\spad{p} has at least \\spad{r} factors.")
  (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|))
    (|NonNegativeInteger|))
   "\\spad{factor(p,{} listOfDegrees,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm,{} knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees} and that \\spad{p} has at least \\spad{r} factors.")
  (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|)))
   "\\spad{factor(p,{} listOfDegrees)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has for possible splitting of its degree listOfDegrees.")
  (((|Factored| |#1|) |#1| (|NonNegativeInteger|))
   "\\spad{factor(p,{} r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has at least \\spad{r} factors.")
  (((|Factored| |#1|) |#1|)
   "\\spad{factor(p)} returns the factorization of \\spad{p} over the integers."))
 (|tryFunctionalDecomposition|
  (((|Boolean|) (|Boolean|))
   "\\spad{tryFunctionalDecomposition(b)} chooses whether factorizers have to look for functional decomposition of polynomials (\\spad{true}) or not (\\spad{false}). Returns the previous value."))
 (|tryFunctionalDecomposition?|
  (((|Boolean|))
   "\\spad{tryFunctionalDecomposition?()} returns \\spad{true} if factorizers try functional decomposition of polynomials before factoring them."))
 (|eisensteinIrreducible?|
  (((|Boolean|) |#1|)
   "\\spad{eisensteinIrreducible?(p)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by Eisenstein\\spad{'s} criterion,{} \\spad{false} is inconclusive."))
 (|useEisensteinCriterion|
  (((|Boolean|) (|Boolean|))
   "\\spad{useEisensteinCriterion(b)} chooses whether factorizers check Eisenstein\\spad{'s} criterion before factoring: \\spad{true} for using it,{} \\spad{false} else. Returns the previous value."))
 (|useEisensteinCriterion?|
  (((|Boolean|))
   "\\spad{useEisensteinCriterion?()} returns \\spad{true} if factorizers check Eisenstein\\spad{'s} criterion before factoring."))
 (|useSingleFactorBound|
  (((|Boolean|) (|Boolean|))
   "\\spad{useSingleFactorBound(b)} chooses the algorithm to be used by the factorizers: \\spad{true} for algorithm with single factor bound,{} \\spad{false} for algorithm with overall bound. Returns the previous value."))
 (|useSingleFactorBound?|
  (((|Boolean|))
   "\\spad{useSingleFactorBound?()} returns \\spad{true} if algorithm with single factor bound is used for factorization,{} \\spad{false} for algorithm with overall bound."))
 (|modularFactor|
  (((|Record| (|:| |prime| (|Integer|)) (|:| |factors| (|List| |#1|))) |#1|
    (|Set| (|NonNegativeInteger|)))
   "\\spad{modularFactor(f,{} d)} chooses a \"good\" prime and returns the factorization of \\spad{f} modulo this prime in a form that may be used by \\spadfunFrom{completeHensel}{GeneralHenselPackage}. If prime is zero it means that \\spad{f} has been proved to be irreducible over the integers or that \\spad{f} is a unit (\\spadignore{i.e.} 1 or \\spad{-1}). \\spad{f} shall be primitive (\\spadignore{i.e.} content(\\spad{p})\\spad{=1}) and square free (\\spadignore{i.e.} without repeated factors). \\spad{d} is set of possible degrees of factors."))
 (|numberOfFactors|
  (((|NonNegativeInteger|)
    (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|)))))
   "\\spad{numberOfFactors(ddfactorization)} returns the number of factors of the polynomial \\spad{f} modulo \\spad{p} where \\spad{ddfactorization} is the distinct degree factorization of \\spad{f} computed by \\spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} for some prime \\spad{p}."))
 (|stopMusserTrials|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{stopMusserTrials(n)} sets to \\spad{n} the bound on the number of factors for which \\spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \\spad{2^n} trials. Returns the previous value.")
  (((|PositiveInteger|))
   "\\spad{stopMusserTrials()} returns the bound on the number of factors for which \\spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \\spad{2^stopMusserTrials()} trials."))
 (|musserTrials|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{musserTrials(n)} sets to \\spad{n} the number of primes to be tried in \\spadfun{modularFactor} and returns the previous value.")
  (((|PositiveInteger|))
   "\\spad{musserTrials()} returns the number of primes that are tried in \\spadfun{modularFactor}."))
 (|degreePartition|
  (((|Multiset| (|NonNegativeInteger|))
    (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|)))))
   "\\spad{degreePartition(ddfactorization)} returns the degree partition of the polynomial \\spad{f} modulo \\spad{p} where \\spad{ddfactorization} is the distinct degree factorization of \\spad{f} computed by \\spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} for some prime \\spad{p}."))
 (|makeFR|
  (((|Factored| |#1|)
    (|Record| (|:| |contp| (|Integer|))
              (|:| |factors|
                   (|List|
                    (|Record| (|:| |irr| |#1|)
                              (|:| |pow| (|NonNegativeInteger|)))))))
   "\\spad{makeFR(flist)} turns the final factorization of henselFact into a \\spadtype{Factored} object."))) 
NIL 
(|GaloisGroupFactorizationUtilities| R UP F) 
((|constructor|
  (NIL
   "\\spadtype{GaloisGroupFactorizationUtilities} provides functions that will be used by the factorizer."))
 (|length|
  ((|#3| |#2|)
   "\\spad{length(p)} returns the sum of the absolute values of the coefficients of the polynomial \\spad{p}."))
 (|height|
  ((|#3| |#2|)
   "\\spad{height(p)} returns the maximal absolute value of the coefficients of the polynomial \\spad{p}."))
 (|infinityNorm|
  ((|#3| |#2|)
   "\\spad{infinityNorm(f)} returns the maximal absolute value of the coefficients of the polynomial \\spad{f}."))
 (|quadraticNorm|
  ((|#3| |#2|)
   "\\spad{quadraticNorm(f)} returns the \\spad{l2} norm of the polynomial \\spad{f}."))
 (|norm|
  ((|#3| |#2| (|PositiveInteger|))
   "\\spad{norm(f,{} p)} returns the \\spad{lp} norm of the polynomial \\spad{f}."))
 (|singleFactorBound|
  (((|Integer|) |#2|)
   "\\spad{singleFactorBound(p)} returns a bound on the infinite norm of the factor of \\spad{p} with smallest Bombieri\\spad{'s} norm. \\spad{p} shall be of degree higher or equal to 2.")
  (((|Integer|) |#2| (|NonNegativeInteger|))
   "\\spad{singleFactorBound(p,{} r)} returns a bound on the infinite norm of the factor of \\spad{p} with smallest Bombieri\\spad{'s} norm. \\spad{r} is a lower bound for the number of factors of \\spad{p}. \\spad{p} shall be of degree higher or equal to 2."))
 (|rootBound|
  (((|Integer|) |#2|)
   "\\spad{rootBound(p)} returns a bound on the largest norm of the complex roots of \\spad{p}."))
 (|bombieriNorm|
  ((|#3| |#2| (|PositiveInteger|))
   "\\spad{bombieriNorm(p,{} n)} returns the \\spad{n}th Bombieri\\spad{'s} norm of \\spad{p}.")
  ((|#3| |#2|)
   "\\spad{bombieriNorm(p)} returns quadratic Bombieri\\spad{'s} norm of \\spad{p}."))
 (|beauzamyBound|
  (((|Integer|) |#2|)
   "\\spad{beauzamyBound(p)} returns a bound on the larger coefficient of any factor of \\spad{p}."))) 
NIL 
(|GaloisGroupPolynomialUtilities| R UP) 
((|constructor|
  (NIL
   "\\spadtype{GaloisGroupPolynomialUtilities} provides useful functions for univariate polynomials which should be added to \\spadtype{UnivariatePolynomialCategory} or to \\spadtype{Factored} (July 1994)."))
 (|factorsOfDegree|
  (((|List| |#2|) (|PositiveInteger|) (|Factored| |#2|))
   "\\spad{factorsOfDegree(d,{} f)} returns the factors of degree \\spad{d} of the factored polynomial \\spad{f}."))
 (|factorOfDegree|
  ((|#2| (|PositiveInteger|) (|Factored| |#2|))
   "\\spad{factorOfDegree(d,{} f)} returns a factor of degree \\spad{d} of the factored polynomial \\spad{f}. Such a factor shall exist."))
 (|degreePartition|
  (((|Multiset| (|NonNegativeInteger|)) (|Factored| |#2|))
   "\\spad{degreePartition(f)} returns the degree partition (\\spadignore{i.e.} the multiset of the degrees of the irreducible factors) of the polynomial \\spad{f}."))
 (|shiftRoots|
  ((|#2| |#2| |#1|)
   "\\spad{shiftRoots(p,{} c)} returns the polynomial which has for roots \\spad{c} added to the roots of \\spad{p}."))
 (|scaleRoots|
  ((|#2| |#2| |#1|)
   "\\spad{scaleRoots(p,{} c)} returns the polynomial which has \\spad{c} times the roots of \\spad{p}."))
 (|reverse|
  ((|#2| |#2|)
   "\\spad{reverse(p)} returns the reverse polynomial of \\spad{p}."))
 (|monic?|
  (((|Boolean|) |#2|)
   "\\spad{monic?(p)} tests if \\spad{p} is monic (\\spadignore{i.e.} leading coefficient equal to 1)."))) 
NIL 
(|GaloisGroupUtilities| R) 
((|constructor|
  (NIL "\\spadtype{GaloisGroupUtilities} provides several useful functions."))
 (|safetyMargin|
  (((|NonNegativeInteger|))
   "\\spad{safetyMargin()} returns the number of low weight digits we do not trust in the floating point representation (used by \\spadfun{safeCeiling}).")
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{safetyMargin(n)} sets to \\spad{n} the number of low weight digits we do not trust in the floating point representation and returns the previous value (for use by \\spadfun{safeCeiling})."))
 (|safeFloor|
  (((|Integer|) |#1|)
   "\\spad{safeFloor(x)} returns the integer which is lower or equal to the largest integer which has the same floating point number representation."))
 (|safeCeiling|
  (((|Integer|) |#1|)
   "\\spad{safeCeiling(x)} returns the integer which is greater than any integer with the same floating point number representation."))
 (|fillPascalTriangle|
  (((|Void|)) "\\spad{fillPascalTriangle()} fills the stored table."))
 (|sizePascalTriangle|
  (((|NonNegativeInteger|))
   "\\spad{sizePascalTriangle()} returns the number of entries currently stored in the table."))
 (|rangePascalTriangle|
  (((|NonNegativeInteger|))
   "\\spad{rangePascalTriangle()} returns the maximal number of lines stored.")
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{rangePascalTriangle(n)} sets the maximal number of lines which are stored and returns the previous value."))
 (|pascalTriangle|
  ((|#1| (|NonNegativeInteger|) (|Integer|))
   "\\spad{pascalTriangle(n,{} r)} returns the binomial coefficient \\spad{C(n,{} r)=n!/(r! (n-r)!)} and stores it in a table to prevent recomputation."))) 
((|HasCategory| |#1| '(|FloatingPointSystem|))) 
(|GaussianFactorizationPackage|) 
((|constructor|
  (NIL "Package for the factorization of complex or gaussian integers."))
 (|prime?|
  (((|Boolean|) (|Complex| (|Integer|)))
   "\\spad{prime?(\\spad{zi})} tests if the complex integer \\spad{zi} is prime."))
 (|sumSquares|
  (((|List| (|Integer|)) (|Integer|))
   "\\spad{sumSquares(p)} construct \\spad{a} and \\spad{b} such that \\spad{a^2+b^2} is equal to the integer prime \\spad{p},{} and otherwise returns an error. It will succeed if the prime number \\spad{p} is 2 or congruent to 1 mod 4."))
 (|factor|
  (((|Factored| (|Complex| (|Integer|))) (|Complex| (|Integer|)))
   "\\spad{factor(\\spad{zi})} produces the complete factorization of the complex integer \\spad{zi}."))) 
NIL 
(|GroebnerPackage| |Dom| |Expon| |Dpol|) 
((|constructor|
  (NIL
   "\\spadtype{GroebnerPackage} computes groebner bases for polynomial ideals. The basic computation provides a distinguished set of generators for polynomial ideals over fields. This basis allows an easy test for membership: the operation \\spadfun{normalForm} returns zero on ideal members. When the provided coefficient domain,{} Dom,{} is not a field,{} the result is equivalent to considering the extended ideal with \\spadtype{Fraction(Dom)} as coefficients,{} but considerably more efficient since all calculations are performed in Dom. Additional argument \"info\" and \"redcrit\" can be given to provide incremental information during computation. Argument \"info\" produces a computational summary for each \\spad{s}-polynomial. Argument \"redcrit\" prints out the reduced critical pairs. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial},{} \\spadtype{HomogeneousDistributedMultivariatePolynomial},{} \\spadtype{GeneralDistributedMultivariatePolynomial}."))
 (|normalForm|
  ((|#3| |#3| (|List| |#3|))
   "\\spad{normalForm(poly,{} gb)} reduces the polynomial \\spad{poly} modulo the precomputed groebner basis \\spad{gb} giving a canonical representative of the residue class."))
 (|groebner|
  (((|List| |#3|) (|List| |#3|) (|String|) (|String|))
   "\\spad{groebner(lp,{} \"info\",{} \"redcrit\")} computes a groebner basis for a polynomial ideal generated by the list of polynomials \\spad{lp},{} displaying both a summary of the critical pairs considered (\\spad{\"info\"}) and the result of reducing each critical pair (\"redcrit\"). If the second or third arguments have any other string value,{} the indicated information is suppressed.")
  (((|List| |#3|) (|List| |#3|) (|String|))
   "\\spad{groebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \\spad{lp}. Argument infoflag is used to get information on the computation. If infoflag is \"info\",{} then summary information is displayed for each \\spad{s}-polynomial generated. If infoflag is \"redcrit\",{} the reduced critical pairs are displayed. If infoflag is any other string,{} no information is printed during computation.")
  (((|List| |#3|) (|List| |#3|))
   "\\spad{groebner(lp)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \\spad{lp}."))) 
((|HasCategory| |#1| '(|Field|))) 
(|EuclideanGroebnerBasisPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor|
  (NIL
   "\\spadtype{EuclideanGroebnerBasisPackage} computes groebner bases for polynomial ideals over euclidean domains. The basic computation provides a distinguished set of generators for these ideals. This basis allows an easy test for membership: the operation \\spadfun{euclideanNormalForm} returns zero on ideal members. The string \"info\" and \"redcrit\" can be given as additional args to provide incremental information during the computation. If \"info\" is given,{} \\indented{1}{a computational summary is given for each \\spad{s}-polynomial. If \"redcrit\"} is given,{} the reduced critical pairs are printed. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial},{} \\spadtype{HomogeneousDistributedMultivariatePolynomial},{} \\spadtype{GeneralDistributedMultivariatePolynomial}."))
 (|euclideanGroebner|
  (((|List| |#4|) (|List| |#4|) (|String|) (|String|))
   "\\spad{euclideanGroebner(lp,{} \"info\",{} \"redcrit\")} computes a groebner basis for a polynomial ideal generated by the list of polynomials \\spad{lp}. If the second argument is \\spad{\"info\"},{} a summary is given of the critical pairs. If the third argument is \"redcrit\",{} critical pairs are printed.")
  (((|List| |#4|) (|List| |#4|) (|String|))
   "\\spad{euclideanGroebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \\spad{lp}. During computation,{} additional information is printed out if infoflag is given as either \"info\" (for summary information) or \"redcrit\" (for reduced critical pairs)")
  (((|List| |#4|) (|List| |#4|))
   "\\spad{euclideanGroebner(lp)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \\spad{lp}."))
 (|euclideanNormalForm|
  ((|#4| |#4| (|List| |#4|))
   "\\spad{euclideanNormalForm(poly,{} gb)} reduces the polynomial \\spad{poly} modulo the precomputed groebner basis \\spad{gb} giving a canonical representative of the residue class."))) 
NIL 
(|GroebnerFactorizationPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor|
  (NIL
   "\\spadtype{GroebnerFactorizationPackage} provides the function groebnerFactor\" which uses the factorization routines of \\Language{} to factor each polynomial under consideration while doing the groebner basis algorithm. Then it writes the ideal as an intersection of ideals determined by the irreducible factors. Note that the whole ring may occur as well as other redundancies. We also use the fact,{} that from the second factor on we can assume that the preceding factors are not equal to 0 and we divide all polynomials under considerations by the elements of this list of \"nonZeroRestrictions\". The result is a list of groebner bases,{} whose union of solutions of the corresponding systems of equations is the solution of the system of equation corresponding to the input list. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial},{} \\spadtype{HomogeneousDistributedMultivariatePolynomial},{} \\spadtype{GeneralDistributedMultivariatePolynomial}."))
 (|groebnerFactorize|
  (((|List| (|List| |#4|)) (|List| |#4|) (|Boolean|))
   "\\spad{groebnerFactorize(listOfPolys,{} info)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\\em listOfPolys}. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next \\spad{S}-polynomial) is factorized. For each irreducible factors of \\spad{p},{} a new {\\em createGroebnerBasis} is started doing the usual updates with the factor in place of \\spad{p}. If {\\em info} is \\spad{true},{} information is printed about partial results.")
  (((|List| (|List| |#4|)) (|List| |#4|))
   "\\spad{groebnerFactorize(listOfPolys)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\\em listOfPolys}. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next \\spad{S}-polynomial) is factorized. For each irreducible factors of \\spad{p},{} a new {\\em createGroebnerBasis} is started doing the usual updates with the factor in place of \\spad{p}.")
  (((|List| (|List| |#4|)) (|List| |#4|) (|List| |#4|) (|Boolean|))
   "\\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions,{} info)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\\em listOfPolys} under the restriction that the polynomials of {\\em nonZeroRestrictions} don\\spad{'t} vanish. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next \\spad{S}-polynomial) is factorized. For each irreducible factors of \\spad{p} a new {\\em createGroebnerBasis} is started doing the usual updates with the factor in place of \\spad{p}. If argument {\\em info} is \\spad{true},{} information is printed about partial results.")
  (((|List| (|List| |#4|)) (|List| |#4|) (|List| |#4|))
   "\\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\\em listOfPolys} under the restriction that the polynomials of {\\em nonZeroRestrictions} don\\spad{'t} vanish. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next \\spad{S}-polynomial) is factorized. For each irreducible factors of \\spad{p},{} a new {\\em createGroebnerBasis} is started doing the usual updates with the factor in place of \\spad{p}."))
 (|factorGroebnerBasis|
  (((|List| (|List| |#4|)) (|List| |#4|) (|Boolean|))
   "\\spad{factorGroebnerBasis(basis,{} info)} checks whether the \\spad{basis} contains reducible polynomials and uses these to split the \\spad{basis}. If argument {\\em info} is \\spad{true},{} information is printed about partial results.")
  (((|List| (|List| |#4|)) (|List| |#4|))
   "\\spad{factorGroebnerBasis(basis)} checks whether the \\spad{basis} contains reducible polynomials and uses these to split the \\spad{basis}."))) 
NIL 
(|GroebnerInternalPackage| |Dom| |Expon| |Dpol|) 
((|constructor|
  (NIL
   "\\indented{1}{Author:} Keywords: References: \\indented{2}{\\spad{R}. Gebauer,{} \\spad{M}. Moeller,{}\\space{2}On an Installation of Buchberger\\spad{'s} Algorithm,{}} \\indented{2}{\\spad{JSC} (1988) 6,{} 275-286.} Description This package provides low level tools for Groebner basis computations"))
 (|virtualDegree|
  (((|NonNegativeInteger|) |#3|) "\\spad{virtualDegree }\\undocumented"))
 (|makeCrit|
  (((|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|))
    (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#3|)) |#3|
    (|NonNegativeInteger|))
   "\\spad{makeCrit }\\undocumented"))
 (|critpOrder|
  (((|Boolean|)
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|))
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|)))
   "\\spad{critpOrder }\\undocumented"))
 (|prinb| (((|Void|) (|Integer|)) "\\spad{prinb }\\undocumented"))
 (|prinpolINFO|
  (((|Void|) (|List| |#3|)) "\\spad{prinpolINFO }\\undocumented"))
 (|fprindINFO|
  (((|Integer|)
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|))
    |#3| |#3| (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{fprindINFO }\\undocumented"))
 (|prindINFO|
  (((|Integer|)
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|))
    |#3| |#3| (|Integer|) (|Integer|) (|Integer|))
   "\\spad{prindINFO }\\undocumented"))
 (|prinshINFO| (((|Void|) |#3|) "\\spad{prinshINFO }\\undocumented"))
 (|lepol| (((|Integer|) |#3|) "\\spad{lepol }\\undocumented"))
 (|minGbasis|
  (((|List| |#3|) (|List| |#3|)) "\\spad{minGbasis }\\undocumented"))
 (|updatD|
  (((|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|)))
    (|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|)))
    (|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|))))
   "\\spad{updatD }\\undocumented"))
 (|sPol|
  ((|#3|
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|)))
   "\\spad{sPol }\\undocumented"))
 (|updatF|
  (((|List| (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#3|)))
    |#3| (|NonNegativeInteger|)
    (|List| (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#3|))))
   "\\spad{updatF }\\undocumented"))
 (|hMonic| ((|#3| |#3|) "\\spad{hMonic }\\undocumented"))
 (|redPo|
  (((|Record| (|:| |poly| |#3|) (|:| |mult| |#1|)) |#3| (|List| |#3|))
   "\\spad{redPo }\\undocumented"))
 (|critMonD1|
  (((|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|)))
    |#2|
    (|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|))))
   "\\spad{critMonD1 }\\undocumented"))
 (|critMTonD1|
  (((|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|)))
    (|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|))))
   "\\spad{critMTonD1 }\\undocumented"))
 (|critBonD|
  (((|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|)))
    |#3|
    (|List|
     (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
               (|:| |poli| |#3|) (|:| |polj| |#3|))))
   "\\spad{critBonD }\\undocumented"))
 (|critB| (((|Boolean|) |#2| |#2| |#2| |#2|) "\\spad{critB }\\undocumented"))
 (|critM| (((|Boolean|) |#2| |#2|) "\\spad{critM }\\undocumented"))
 (|critT|
  (((|Boolean|)
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|)))
   "\\spad{critT }\\undocumented"))
 (|gbasisExtend|
  (((|List| |#3|) (|List| |#3|) (|List| |#3|) (|Integer|) (|Integer|))
   "\\spad{gbasisExtend(pols,{} gb,{} f1,{} f2)} computes a Groebner basis of concat(\\spad{pols},{} \\spad{gb}) where \\spad{gb} is assumed to be already a Groebner basis,{} \\spadignore{i.e.} no \\spad{S}-polynomials among elements of \\spad{gb} will ever be considered."))
 (|gbasis|
  (((|List| |#3|) (|List| |#3|) (|Integer|) (|Integer|))
   "\\spad{gbasis(pols,{} f1,{} f2)} computes a Groebner basis of \\spad{pols}."))
 (|redPol| ((|#3| |#3| (|List| |#3|)) "\\spad{redPol }\\undocumented"))
 (|credPol| ((|#3| |#3| (|List| |#3|)) "\\spad{credPol }\\undocumented"))) 
NIL 
(|GcdBasis| R) 
((|constructor|
  (NIL
   "\\spad{Gcd} basis provides functions to find structure of multiplicative group (and semigroup) generated by elements of \\spad{Gcd} domain."))
 (|gcdDecomposition|
  (((|Record| (|:| |basis| (|Vector| |#1|))
              (|:| |transform| (|Matrix| (|Integer|))))
    (|Vector| (|Fraction| |#1|)))
   "\\spad{gcdDecomposition(v)} returns \\spad{[b,{} t]} such that elements of \\spad{b} are relatively prime and that \\spad{v(i) = product(b(j)^(t(j,{} i)),{} j=1..n)}")
  (((|Record| (|:| |basis| (|Vector| |#1|))
              (|:| |transform| (|Matrix| (|Integer|))))
    (|Vector| |#1|))
   "\\spad{gcdDecomposition(v)} returns \\spad{[b,{} t]} such that elements of \\spad{b} are relatively prime and that \\spad{v(i) = product(b(j)^(t(j,{} i)),{} j=1..n)}"))
 (|gcdBasis|
  (((|Vector| |#1|) (|Vector| |#1|))
   "\\spad{gcdBasis(v)} returns basis part of \\spad{gcdDecomposition(v)}."))) 
NIL 
(|GcdDomain&| S) 
((|constructor|
  (NIL
   "This category describes domains where \\spadfun{\\spad{gcd}} can be computed but where there is no guarantee of the existence of \\spadfun{factor} operation for factorization into irreducibles. However,{} if such a \\spadfun{factor} operation exist,{} factorization will be unique up to order and units."))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   "\\spad{gcdPolynomial(p,{} q)} returns the greatest common divisor (\\spad{gcd}) of univariate polynomials over the domain"))
 (|lcm|
  (($ (|List| $))
   "\\spad{lcm(l)} returns the least common multiple of the elements of the list \\spad{l}.")
  (($ $ $)
   "\\spad{lcm(x,{} y)} returns the least common multiple of \\spad{x} and \\spad{y}."))
 (|gcd|
  (($ (|List| $))
   "\\spad{gcd(l)} returns the common \\spad{gcd} of the elements in the list \\spad{l}.")
  (($ $ $)
   "\\spad{gcd(x,{} y)} returns the greatest common divisor of \\spad{x} and \\spad{y}."))) 
NIL 
(|GcdDomain|) 
((|constructor|
  (NIL
   "This category describes domains where \\spadfun{\\spad{gcd}} can be computed but where there is no guarantee of the existence of \\spadfun{factor} operation for factorization into irreducibles. However,{} if such a \\spadfun{factor} operation exist,{} factorization will be unique up to order and units."))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   "\\spad{gcdPolynomial(p,{} q)} returns the greatest common divisor (\\spad{gcd}) of univariate polynomials over the domain"))
 (|lcm|
  (($ (|List| $))
   "\\spad{lcm(l)} returns the least common multiple of the elements of the list \\spad{l}.")
  (($ $ $)
   "\\spad{lcm(x,{} y)} returns the least common multiple of \\spad{x} and \\spad{y}."))
 (|gcd|
  (($ (|List| $))
   "\\spad{gcd(l)} returns the common \\spad{gcd} of the elements in the list \\spad{l}.")
  (($ $ $)
   "\\spad{gcd(x,{} y)} returns the greatest common divisor of \\spad{x} and \\spad{y}."))) 
NIL 
(|GenericNonAssociativeAlgebra| R |n| |ls| |gamma|) 
((|constructor|
  (NIL
   "AlgebraGenericElementPackage allows you to create generic elements of an algebra,{} \\spadignore{i.e.} the scalars are extended to include symbolic coefficients"))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#1|)))
   "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis")
  (((|List| (|Polynomial| |#1|)) (|Vector| $))
   "\\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}"))
 (|genericRightDiscriminant|
  (((|Fraction| (|Polynomial| |#1|)))
   "\\spad{genericRightDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable"))
 (|genericRightTraceForm|
  (((|Fraction| (|Polynomial| |#1|)) $ $)
   "\\spad{genericRightTraceForm (a,{} b)} is defined to be \\spadfun{genericRightTrace (a*b)},{} this defines a symmetric bilinear form on the algebra"))
 (|genericLeftDiscriminant|
  (((|Fraction| (|Polynomial| |#1|)))
   "\\spad{genericLeftDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable"))
 (|genericLeftTraceForm|
  (((|Fraction| (|Polynomial| |#1|)) $ $)
   "\\spad{genericLeftTraceForm (a,{} b)} is defined to be \\spad{genericLeftTrace (a*b)},{} this defines a symmetric bilinear form on the algebra"))
 (|genericRightNorm|
  (((|Fraction| (|Polynomial| |#1|)) $)
   "\\spad{genericRightNorm(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the constant term in \\spadfun{rightRankPolynomial} and changes the sign if the degree of this polynomial is odd"))
 (|genericRightTrace|
  (((|Fraction| (|Polynomial| |#1|)) $)
   "\\spad{genericRightTrace(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the second highest term in \\spadfun{rightRankPolynomial} and changes the sign"))
 (|genericRightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))) $)
   "\\spad{genericRightMinimalPolynomial(a)} substitutes the coefficients of \\spad{a} for the generic coefficients in \\spadfun{rightRankPolynomial}"))
 (|rightRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{rightRankPolynomial()} returns the right minimimal polynomial of the generic element"))
 (|genericLeftNorm|
  (((|Fraction| (|Polynomial| |#1|)) $)
   "\\spad{genericLeftNorm(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the constant term in \\spadfun{leftRankPolynomial} and changes the sign if the degree of this polynomial is odd. This is a form of degree \\spad{k}"))
 (|genericLeftTrace|
  (((|Fraction| (|Polynomial| |#1|)) $)
   "\\spad{genericLeftTrace(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the second highest term in \\spadfun{leftRankPolynomial} and changes the sign. \\indented{1}{This is a linear form}"))
 (|genericLeftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))) $)
   "\\spad{genericLeftMinimalPolynomial(a)} substitutes the coefficients of {em a} for the generic coefficients in \\spad{leftRankPolynomial()}"))
 (|leftRankPolynomial|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{leftRankPolynomial()} returns the left minimimal polynomial of the generic element"))
 (|generic|
  (($ (|Vector| (|Symbol|)) (|Vector| $))
   "\\spad{generic(vs,{} ve)} returns a generic element,{} \\spadignore{i.e.} the linear combination of \\spad{ve} with the symbolic coefficients \\spad{vs} error,{} if the vector of symbols is shorter than the vector of elements")
  (($ (|Symbol|) (|Vector| $))
   "\\spad{generic(s,{} v)} returns a generic element,{} \\spadignore{i.e.} the linear combination of \\spad{v} with the symbolic coefficients \\spad{s1,{} s2,{} ..}")
  (($ (|Vector| $))
   "\\spad{generic(ve)} returns a generic element,{} \\spadignore{i.e.} the linear combination of \\spad{ve} basis with the symbolic coefficients \\spad{\\%x1,{} \\%x2,{} ..}")
  (($ (|Vector| (|Symbol|)))
   "\\spad{generic(vs)} returns a generic element,{} \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{vs}; error,{} if the vector of symbols is too short")
  (($ (|Symbol|))
   "\\spad{generic(s)} returns a generic element,{} \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{s1,{} s2,{} ..}")
  (($)
   "\\spad{generic()} returns a generic element,{} \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{\\%x1,{} \\%x2,{} ..}"))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \\spad{\"failed\"} if there is none"))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \\spad{\"failed\"} if there is none"))
 (|coerce|
  (($ (|Vector| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{coerce(v)} assumes that it is called with a vector of length equal to the dimension of the algebra,{} then a linear combination with the basis element is formed"))) 
((|HasCategory| (|Fraction| (|Polynomial| |#1|)) '(|IntegralDomain|))
 (|HasCategory| (|Fraction| (|Polynomial| |#1|)) '(|Finite|))
 (|HasCategory| (|Fraction| (|Polynomial| |#1|)) '(|Field|))
 (|HasCategory| |#1| '(|IntegralDomain|))) 
(|GeneralDistributedMultivariatePolynomial| |vl| R E) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is specified by its third parameter. Suggested types which define term orderings include: \\spadtype{DirectProduct},{} \\spadtype{HomogeneousDirectProduct},{} \\spadtype{SplitHomogeneousDirectProduct} and finally \\spadtype{OrderedDirectProduct} which accepts an arbitrary user function to define a term ordering."))
 (|reorder|
  (($ $ (|List| (|Integer|)))
   "\\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|)))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#3| '(|Comparable|)) (|HasCategory| |#2| '(|Field|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#2| '(|Ring|))
  (|HasCategory| (|OrderedVariableList| |#1|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|GcdDomain|))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|GnuDraw|) 
((|constructor|
  (NIL
   "This package provides support for gnuplot. These routines generate output files contain gnuplot scripts that may be processed directly by gnuplot. This is especially convenient in the fricas-wiki environment where gnuplot is called from LaTeX via gnuplottex."))
 (|gnuDraw|
  (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)) (|String|))
   "\\spad{gnuDraw} provides 3d surface plotting,{} default options")
  (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|))
    (|SegmentBinding| (|Float|)) (|String|) (|List| (|DrawOption|)))
   "\\spad{gnuDraw} provides 3d surface plotting with options")
  (((|Void|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|String|))
   "\\spad{gnuDraw} provides 2d plotting from list of values,{} default options")
  (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|String|))
   "\\spad{gnuDraw} provides 2d plotting,{} default options")
  (((|Void|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|String|)
    (|List| (|DrawOption|)))
   "\\spad{gnuDraw} provides 2d plotting from list of values with options")
  (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|String|)
    (|List| (|DrawOption|)))
   "\\spad{gnuDraw} provides 2d plotting with options"))) 
NIL 
(|GenExEuclid| R BP) 
((|constructor|
  (NIL
   "\\indented{1}{Author : \\spad{P}.Gianni.} January 1990 The equation \\spad{Af+Bg=h} and its generalization to \\spad{n} polynomials is solved for solutions over the \\spad{R},{} euclidean domain. A table containing the solutions of \\spad{Af+Bg=x^k} is used. The operations are performed modulus a prime which are in principle big enough,{} but the solutions are tested and,{} in case of failure,{} a hensel lifting process is used to get to the right solutions. It will be used in the factorization of multivariate polynomials over finite field,{} with \\spad{R=F[x]}."))
 (|testModulus|
  (((|Boolean|) |#1| (|List| |#2|))
   "\\spad{testModulus(p,{} lp)} returns \\spad{true} if the prime \\spad{p} is valid for the list of polynomials \\spad{lp},{} \\spadignore{i.e.} preserves the degree and they remain relatively prime."))
 (|solveid|
  (((|Union| (|List| |#2|) "failed") |#2| |#1| (|Vector| (|List| |#2|)))
   "\\spad{solveid(h,{} prime,{} table)} computes the coefficients of the extended euclidean algorithm for a list of polynomials whose tablePow is table and with right side \\spad{h}."))
 (|tablePow|
  (((|Union| (|Vector| (|List| |#2|)) "failed") (|NonNegativeInteger|) |#1|
    (|List| |#2|))
   "\\spad{tablePow(maxdeg,{} prime,{} lpol)} constructs the table with the coefficients of the Extended Euclidean Algorithm for lpol. Here the right side is \\spad{x^k},{} for \\spad{k} less to \\spad{maxdeg}. The operation returns \"failed\" when the elements are not coprime modulo \\spad{prime}."))
 (|compBound|
  (((|NonNegativeInteger|) |#2| (|List| |#2|))
   "\\spad{compBound(p,{} lp)} computes a bound for the coefficients of the solution polynomials. Given a polynomial right hand side \\spad{p},{} and a list \\spad{lp} of left hand side polynomials. Exported because it depends on the valuation."))
 (|reduction|
  ((|#2| |#2| |#1|)
   "\\spad{reduction(p,{} prime)} reduces the polynomial \\spad{p} modulo prime of \\spad{R}. Note: this function is exported only because it\\spad{'s} conditional."))) 
NIL 
(|GeneralizedMultivariateFactorize| OV E S R P) 
((|constructor|
  (NIL
   "\\indented{2}{This is the top level package for doing multivariate factorization} over basic domains like \\spadtype{Integer} or \\spadtype{Fraction Integer}."))
 (|factor|
  (((|Factored| |#5|) |#5|)
   "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain"))
 (|convert|
  (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
(|GeneralizedFiniteMoebiusFunction| P R) 
((|constructor|
  (NIL "A domain for generalized Moebius functions of explicit subposets."))
 (|moebiusMatrix|
  (((|Matrix| |#2|) $) "\\spad{moebiusMatrix()} returns the Moebius matrix"))
 (|members|
  (((|List| |#1|) $)
   "\\spad{members(mf)} returns the elements of the subposet"))
 (|apply|
  ((|#2| $ |#1| |#1|)
   "\\spad{mf(\\spad{pi},{} \\spad{si})} evaluates the Moebius function \\spad{mf} at \\spad{pi} and \\spad{si}"))
 (|canonicalMoebiusFunction|
  (($ (|List| |#1|))
   "\\spad{canonicalMoebiusFunction(pp)} inverts the canonical zeta function"))
 (|generalizedMoebiusFunction|
  (($ (|List| |#1|) (|Mapping| |#2| |#1| |#1|))
   "\\spad{generalizedMoebiusFunction(pp,{} zeta)} inverts the given zeta function"))) 
NIL 
(|GeneralPolynomialGcdPackage| E OV R P) 
((|constructor|
  (NIL
   "This package provides operations for \\spad{GCD} computations on polynomials"))
 (|randomR| ((|#3|) "\\spad{randomR()} should be local but conditional"))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{gcdPolynomial(p,{} q)} returns the \\spad{GCD} of \\spad{p} and \\spad{q}"))) 
NIL 
(|GenerateUnivariatePowerSeries| R FE) 
((|constructor|
  (NIL
   "This package is to restrict interpreter choice of signatures,{} and force Expression when no types are declared"))) 
((AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))) 
(|GenerateUnivariatePowerSeries1| R) 
((|constructor|
  (NIL
   "\\spadtype{GenerateUnivariatePowerSeries} provides functions that create power series from explicit formulas for their \\spad{n}th coefficient."))
 (|puiseux|
  (((|Any|) (|Mapping| |#1| (|Fraction| (|Integer|))) (|Symbol|) |#1|
    (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{puiseux(n +-> a(n),{} x,{} a,{} r0..,{} r)} returns \\spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \\spad{puiseux(n +-> a(n),{} x = a,{} r0..r1,{} r)} returns \\spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}."))
 (|laurent|
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Symbol|) |#1|
    (|UniversalSegment| (|Integer|)))
   "\\spad{laurent(n +-> a(n),{} x,{} a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \\spad{laurent(n +-> a(n),{} x,{} a,{} n0..n1)} returns \\spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}."))
 (|taylor|
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Symbol|) |#1|
    (|UniversalSegment| (|NonNegativeInteger|)))
   "\\spad{taylor(n +-> a(n),{} x,{} a,{} n0..)} returns \\spad{sum(n=n0..,{} a(n)*(x-a)^n)}; \\spad{taylor(n +-> a(n),{} x,{} a,{} n0..n1)} returns \\spad{sum(n = n0..,{} a(n)*(x-a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Symbol|) |#1|)
   "\\spad{taylor(n +-> a(n),{} x,{} a)} returns \\spad{sum(n = 0..,{} a(n)*(x-a)^n)}."))) 
NIL 
(|GenerateUnivariatePowerSeries2| FE) 
((|constructor|
  (NIL
   "\\spadtype{GenerateUnivariatePowerSeries} provides functions that create power series from explicit formulas for their \\spad{n}th coefficient."))
 (|series|
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|)
    (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{series(a(n),{} n,{} x = a,{} r0..,{} r)} returns \\spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \\spad{series(a(n),{} n,{} x = a,{} r0..r1,{} r)} returns \\spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.")
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|) (|UniversalSegment| (|Integer|)))
   "\\spad{series(a(n),{} n,{} x=a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \\spad{series(a(n),{} n,{} x=a,{} n0..n1)} returns \\spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.")
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|))
   "\\spad{series(a(n),{} n,{} x = a)} returns \\spad{sum(n = 0..,{} a(n)*(x-a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Fraction| (|Integer|))) (|Equation| |#1|)
    (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{series(n +-> a(n),{} x = a,{} r0..,{} r)} returns \\spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \\spad{series(n +-> a(n),{} x = a,{} r0..r1,{} r)} returns \\spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Equation| |#1|)
    (|UniversalSegment| (|Integer|)))
   "\\spad{series(n +-> a(n),{} x = a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \\spad{series(n +-> a(n),{} x = a,{} n0..n1)} returns \\spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Equation| |#1|))
   "\\spad{series(n +-> a(n),{} x = a)} returns \\spad{sum(n = 0..,{} a(n)*(x-a)^n)}."))
 (|puiseux|
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|)
    (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{puiseux(a(n),{} n,{} x = a,{} r0..,{} r)} returns \\spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \\spad{puiseux(a(n),{} n,{} x = a,{} r0..r1,{} r)} returns \\spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Fraction| (|Integer|))) (|Equation| |#1|)
    (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{puiseux(n +-> a(n),{} x = a,{} r0..,{} r)} returns \\spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \\spad{puiseux(n +-> a(n),{} x = a,{} r0..r1,{} r)} returns \\spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}."))
 (|laurent|
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|) (|UniversalSegment| (|Integer|)))
   "\\spad{laurent(a(n),{} n,{} x=a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \\spad{laurent(a(n),{} n,{} x=a,{} n0..n1)} returns \\spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Equation| |#1|)
    (|UniversalSegment| (|Integer|)))
   "\\spad{laurent(n +-> a(n),{} x = a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \\spad{laurent(n +-> a(n),{} x = a,{} n0..n1)} returns \\spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}."))
 (|taylor|
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|)
    (|UniversalSegment| (|NonNegativeInteger|)))
   "\\spad{taylor(a(n),{} n,{} x = a,{} n0..)} returns \\spad{sum(n = n0..,{} a(n)*(x-a)^n)}; \\spad{taylor(a(n),{} n,{} x = a,{} n0..n1)} returns \\spad{sum(n = n0..,{} a(n)*(x-a)^n)}.")
  (((|Any|) |#1| (|Symbol|) (|Equation| |#1|))
   "\\spad{taylor(a(n),{} n,{} x = a)} returns \\spad{sum(n = 0..,{} a(n)*(x-a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Equation| |#1|)
    (|UniversalSegment| (|NonNegativeInteger|)))
   "\\spad{taylor(n +-> a(n),{} x = a,{} n0..)} returns \\spad{sum(n=n0..,{} a(n)*(x-a)^n)}; \\spad{taylor(n +-> a(n),{} x = a,{} n0..n1)} returns \\spad{sum(n = n0..,{} a(n)*(x-a)^n)}.")
  (((|Any|) (|Mapping| |#1| (|Integer|)) (|Equation| |#1|))
   "\\spad{taylor(n +-> a(n),{} x = a)} returns \\spad{sum(n = 0..,{} a(n)*(x-a)^n)}."))) 
((AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|))))) 
(|GeneralizedUnivariatePowerSeries| |Coef| |Expon| |var| |cen|) 
((|constructor| (NIL "Author: Waldek Hebisch"))
 (|removeZeros|
  (($ $ |#2|)
   "\\spad{removeZeros(s,{} k)} removes leading zero terms in \\spad{s} with exponent smaller than \\spad{k}"))
 (|apply_taylor|
  (($ (|Stream| |#1|) $)
   "\\spad{apply_taylor(ts,{} s)} applies Taylor series with coefficients \\spad{ts} to \\spad{s},{} that is computes infinite sum \\spad{ts}(0) + \\spad{ts}(1)\\spad{*s} + \\spad{ts}(2)\\spad{*s^2} + ... Note: \\spad{s} must be of positive order"))
 (|infsum|
  (($ (|Stream| $))
   "\\spad{infsum(x)} computes sum of all elements of \\spad{x}. Degrees of elements of \\spad{x} must be nondecreasing and tend to infinity."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#2| '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (|devaluate| |#2|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (|devaluate| |#2|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#2| '(|AbelianGroup|))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianGroup|)))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|)))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
  (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianGroup|)))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianGroup|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|AbelianGroup|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) (|devaluate| |#2|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|GeneralHenselPackage| RP TP) 
((|constructor|
  (NIL
   "\\indented{1}{Author : \\spad{P}.Gianni} General Hensel Lifting Used for Factorization of bivariate polynomials over a finite field."))
 (|reduction|
  ((|#2| |#2| |#1|)
   "\\spad{reduction(u,{} pol)} computes the symmetric reduction of \\spad{u} mod pol"))
 (|completeHensel|
  (((|List| |#2|) |#2| (|List| |#2|) |#1| (|PositiveInteger|))
   "\\spad{completeHensel(pol,{} lfact,{} prime,{} bound)} lifts \\spad{lfact},{} the factorization mod \\spad{prime} of \\spad{pol},{} to the factorization mod prime^k>bound. Factors are recombined on the way."))
 (|HenselLift|
  (((|Record| (|:| |plist| (|List| |#2|)) (|:| |modulo| |#1|)) |#2|
    (|List| |#2|) |#1| (|PositiveInteger|))
   "\\spad{HenselLift(pol,{} lfacts,{} prime,{} bound)} lifts \\spad{lfacts},{} that are the factors of \\spad{pol} mod \\spad{prime},{} to factors of \\spad{pol} mod prime^k > bound. No recombining is done ."))) 
NIL 
(|GeneralModulePolynomial| |vl| R IS E |ff| P) 
((|constructor| (NIL "This package \\undocumented"))
 (* (($ |#6| $) "\\spad{p*x} \\undocumented"))
 (|multMonom|
  (($ |#2| |#4| $) "\\spad{multMonom(r,{} e,{} x)} \\undocumented"))
 (|build| (($ |#2| |#3| |#4|) "\\spad{build(r,{} i,{} e)} \\undocumented"))
 (|unitVector| (($ |#3|) "\\spad{unitVector(x)} \\undocumented"))
 (|monomial|
  (($ |#2| (|ModuleMonomial| |#3| |#4| |#5|))
   "\\spad{monomial(r,{} x)} \\undocumented"))
 (|reductum| (($ $) "\\spad{reductum(x)} \\undocumented"))
 (|leadingIndex| ((|#3| $) "\\spad{leadingIndex(x)} \\undocumented"))
 (|leadingExponent| ((|#4| $) "\\spad{leadingExponent(x)} \\undocumented"))
 (|leadingMonomial|
  (((|ModuleMonomial| |#3| |#4| |#5|) $)
   "\\spad{leadingMonomial(x)} \\undocumented"))
 (|leadingCoefficient|
  ((|#2| $) "\\spad{leadingCoefficient(x)} \\undocumented"))) 
((OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#6| '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#6| '(|AbelianGroup|))
     (|HasCategory| |#6| '(|AbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#6| '(|AbelianMonoid|)))) 
(|GuessOption|) 
((|constructor|
  (NIL
   "GuessOption is a domain whose elements are various options used by \\spadtype{Guess}."))
 (|option|
  (((|Union| (|Any|) "failed") (|List| $) (|Symbol|))
   "\\spad{option(l,{} option)} returns which options are given."))
 (|displayKind|
  (($ (|Symbol|))
   "\\spad{displayKind(d)} specifies kind of the result: generating function,{} recurrence or equation. This option should not be set by the user,{} but rather by the \\spad{HP}-specification."))
 (|indexName|
  (($ (|Symbol|))
   "\\spad{indexName(d)} specifies the index variable used for the formulas. This option is expressed in the form \\spad{indexName == d}."))
 (|variableName|
  (($ (|Symbol|))
   "\\spad{variableName(d)} specifies the variable used in by the algebraic differential equation. This option is expressed in the form \\spad{variableName == d}."))
 (|functionNames|
  (($ (|List| (|Symbol|)))
   "\\spad{functionNames(d)} specifies the names for the function in algebraic dependence. This option is expressed in the form \\spad{functionNames == d}."))
 (|functionName|
  (($ (|Symbol|))
   "\\spad{functionName(d)} specifies the name of the function given by the algebraic differential equation or recurrence. This option is expressed in the form \\spad{functionName == d}."))
 (|debug|
  (($ (|Boolean|))
   "\\spad{debug(d)} specifies whether we want additional output on the progress. This option is expressed in the form \\spad{debug == d}."))
 (|one|
  (($ (|Boolean|))
   "\\spad{one(d)} specifies whether we are happy with one solution. This option is expressed in the form \\spad{one == d}."))
 (|checkExtraValues|
  (($ (|Boolean|))
   "\\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. This option is expressed in the form \\spad{checkExtraValues == d}"))
 (|check|
  (($ (|Union| "skip" "MonteCarlo" "deterministic"))
   "\\spad{check(d)} specifies how we want to check the solution. If the value is \"skip\",{} we return the solutions found by the interpolation routine without checking. If the value is \"MonteCarlo\",{} we use a probabilistic check. This option is expressed in the form \\spad{check == d}"))
 (|safety|
  (($ (|NonNegativeInteger|))
   "\\spad{safety(d)} specifies the number of values reserved for testing any solutions found. This option is expressed in the form \\spad{safety == d}."))
 (|allDegrees|
  (($ (|Boolean|))
   "\\spad{allDegrees(d)} specifies whether all possibilities of the degree vector - taking into account maxDegree - should be tried. This is mainly interesting for rational interpolation. This option is expressed in the form \\spad{allDegrees == d}."))
 (|maxMixedDegree|
  (($ (|NonNegativeInteger|))
   "\\spad{maxMixedDegree(d)} specifies the maximum \\spad{q}-degree of the coefficient polynomials in a recurrence with polynomial coefficients,{} in the case of mixed shifts. Although slightly inconsistent,{} maxMixedDegree(0) specifies that no mixed shifts are allowed. This option is expressed in the form \\spad{maxMixedDegree == d}."))
 (|maxDegree|
  (($ (|Union| (|NonNegativeInteger|) "arbitrary"))
   "\\spad{maxDegree(d)} specifies the maximum degree of the coefficient polynomials in an algebraic differential equation or a recursion with polynomial coefficients. For rational functions with an exponential term,{} \\spad{maxDegree} bounds the degree of the denominator polynomial. This option is expressed in the form \\spad{maxDegree == d}."))
 (|maxLevel|
  (($ (|Union| (|NonNegativeInteger|) "arbitrary"))
   "\\spad{maxLevel(d)} specifies the maximum number of recursion levels operators guessProduct and guessSum will be applied. This option is expressed in the form spad{maxLevel \\spad{==} \\spad{d}}."))
 (|Somos|
  (($ (|Union| (|PositiveInteger|) (|Boolean|)))
   "\\spad{Somos(d)} specifies whether we want that the total degree of the differential operators is constant,{} and equal to \\spad{d},{} or maxDerivative if \\spad{true}. If \\spad{true},{} maxDerivative must be set,{} too."))
 (|homogeneous|
  (($ (|Union| (|PositiveInteger|) (|Boolean|)))
   "\\spad{homogeneous(d)} specifies whether we allow only homogeneous algebraic differential equations. This option is expressed in the form \\spad{homogeneous == d}. If \\spad{true},{} then maxPower must be set,{} too,{} and ADEs with constant total degree are allowed. If a PositiveInteger is given,{} only ADE\\spad{'s} with this total degree are allowed."))
 (|maxPower|
  (($ (|Union| (|PositiveInteger|) "arbitrary"))
   "\\spad{maxPower(d)} specifies the maximum degree in an algebraic differential equation. For example,{} the degree of (\\spad{f}\\spad{''})\\spad{^3} \\spad{f'} is 4. maxPower(\\spad{-1}) specifies that the maximum exponent can be arbitrary. This option is expressed in the form \\spad{maxPower == d}."))
 (|maxSubst|
  (($ (|Union| (|PositiveInteger|) "arbitrary"))
   "\\spad{maxSubst(d)} specifies the maximum degree of the monomial substituted into the function we are looking for. That is,{} if \\spad{maxSubst == d},{} we look for polynomials such that \\$\\spad{p}(\\spad{f}(\\spad{x}),{} \\spad{f}(\\spad{x^2}),{} ...,{} \\spad{f}(\\spad{x^d}))\\spad{=0}\\$. equation. This option is expressed in the form \\spad{maxSubst == d}."))
 (|maxShift|
  (($ (|Union| (|NonNegativeInteger|) "arbitrary"))
   "\\spad{maxShift(d)} specifies the maximum shift in a recurrence equation. This option is expressed in the form \\spad{maxShift == d}."))
 (|maxDerivative|
  (($ (|Union| (|NonNegativeInteger|) "arbitrary"))
   "\\spad{maxDerivative(d)} specifies the maximum derivative in an algebraic differential equation. This option is expressed in the form \\spad{maxDerivative == d}."))) 
NIL 
(|GuessOptionFunctions0|) 
((|constructor|
  (NIL
   "\\spad{GuessOptionFunctions0} provides operations that extract the values of options for \\spadtype{Guess}."))
 (|checkOptions|
  (((|Void|) (|List| (|GuessOption|)))
   "\\spad{checkOptions checks} whether the given options are consistent,{} and yields an error otherwise"))
 (|debug|
  (((|Boolean|) (|List| (|GuessOption|)))
   "\\spad{debug returns} whether we want additional output on the progress,{} default being \\spad{false}"))
 (|displayKind|
  (((|Symbol|) (|List| (|GuessOption|)))
   "\\spad{displayKind(d)} specifies kind of the result: generating function,{} recurrence or equation. This option should not be set by the user,{} but rather by the \\spad{HP}-specification."))
 (|indexName|
  (((|Symbol|) (|List| (|GuessOption|)))
   "\\spad{indexName returns} the name of the index variable used for the formulas,{} default being \\spad{n}"))
 (|variableName|
  (((|Symbol|) (|List| (|GuessOption|)))
   "\\spad{variableName returns} the name of the variable used in by the algebraic differential equation,{} default being \\spad{x}"))
 (|functionNames|
  (((|List| (|Symbol|)) (|List| (|GuessOption|)))
   "\\spad{functionNames returns} the names for the function in the algebraic dependence,{} default being \\%\\spad{f1},{} \\%\\spad{f2},{} ..."))
 (|functionName|
  (((|Symbol|) (|List| (|GuessOption|)))
   "\\spad{functionName returns} the name of the function given by the algebraic differential equation,{} default being \\spad{f}"))
 (|one|
  (((|Boolean|) (|List| (|GuessOption|)))
   "\\spad{one returns} whether we need only one solution,{} default being \\spad{true}."))
 (|checkExtraValues|
  (((|Boolean|) (|List| (|GuessOption|)))
   "\\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. The default is \\spad{true}."))
 (|check|
  (((|Union| "skip" "MonteCarlo" "deterministic") (|List| (|GuessOption|)))
   "\\spad{check(d)} specifies how we want to check the solution. If the value is \"skip\",{} we return the solutions found by the interpolation routine without checking. If the value is \"MonteCarlo\",{} we use a probabilistic check. The default is \"deterministic\"."))
 (|safety|
  (((|NonNegativeInteger|) (|List| (|GuessOption|)))
   "\\spad{safety returns} the specified safety or 1 as default."))
 (|allDegrees|
  (((|Boolean|) (|List| (|GuessOption|)))
   "\\spad{allDegrees returns} whether all possibilities of the degree vector should be tried,{} the default being \\spad{false}."))
 (|maxMixedDegree|
  (((|NonNegativeInteger|) (|List| (|GuessOption|)))
   "\\spad{maxMixedDegree returns} the specified maxMixedDegree."))
 (|maxDegree|
  (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxDegree returns} the specified maxDegree."))
 (|maxLevel|
  (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxLevel returns} the specified maxLevel."))
 (|Somos|
  (((|Union| (|PositiveInteger|) (|Boolean|)) (|List| (|GuessOption|)))
   "\\spad{Somos returns} whether we allow only Somos-like operators,{} default being \\spad{false}"))
 (|homogeneous|
  (((|Union| (|PositiveInteger|) (|Boolean|)) (|List| (|GuessOption|)))
   "\\spad{homogeneous returns} whether we allow only homogeneous algebraic differential equations,{} default being \\spad{false}"))
 (|maxPower|
  (((|Union| (|PositiveInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxPower returns} the specified maxPower."))
 (|maxSubst|
  (((|Union| (|PositiveInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxSubst returns} the specified maxSubst."))
 (|maxShift|
  (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxShift returns} the specified maxShift."))
 (|maxDerivative|
  (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|)))
   "\\spad{maxDerivative returns} the specified maxDerivative."))) 
NIL 
(|GosperSummationMethod| E V R P Q) 
((|constructor| (NIL "Gosper\\spad{'s} summation algorithm."))
 (|GospersMethod|
  (((|Union| |#5| "failed") |#5| |#2| (|Mapping| |#2|))
   "\\spad{GospersMethod(b,{} n,{} new)} returns a rational function \\spad{rf(n)} such that \\spad{a(n) * rf(n)} is the indefinite sum of \\spad{a(n)} with respect to upward difference on \\spad{n},{} \\spadignore{i.e.} \\spad{a(n+1) * rf(n+1) - a(n) * rf(n) = a(n)},{} where \\spad{b(n) = a(n)/a(n-1)} is a rational function. Returns \"failed\" if no such rational function \\spad{rf(n)} exists. Note: \\spad{new} is a nullary function returning a new \\spad{V} every time. The condition on \\spad{a(n)} is that \\spad{a(n)/a(n-1)} is a rational function of \\spad{n}."))) 
NIL 
(|MaybeSkewPolynomialCategory&| S R E |VarSet|) 
((|constructor|
  (NIL
   "The category for general multi-variate possibly skew polynomials over a ring \\spad{R},{} in variables from VarSet,{} with exponents from the \\spadtype{OrderedAbelianMonoidSup}."))
 (|primitiveMonomials|
  (((|List| $) $)
   "\\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \\spad{p} with their coefficients removed. Note: \\spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),{} ...,{} X^(n)]}."))
 (|variables|
  (((|List| |#4|) $)
   "\\spad{variables(p)} returns the list of those variables actually appearing in the polynomial \\spad{p}."))
 (|totalDegreeSorted|
  (((|NonNegativeInteger|) $ (|List| |#4|))
   "\\spad{totalDegreeSorted(p,{} lv)} returns the maximum sum (over all monomials of polynomial \\spad{p}) of the degree in variables in the list \\spad{lv}. \\spad{lv} is assumed to be sorted in decreasing order."))
 (|totalDegree|
  (((|NonNegativeInteger|) $ (|List| |#4|))
   "\\spad{totalDegree(p,{} lv)} returns the maximum sum (over all monomials of polynomial \\spad{p}) of the variables in the list \\spad{lv}.")
  (((|NonNegativeInteger|) $)
   "\\spad{totalDegree(p)} returns the largest sum over all monomials of all exponents of a monomial."))
 (|monomial|
  (($ $ (|List| |#4|) (|List| (|NonNegativeInteger|)))
   "\\spad{monomial(a,{} [v1..vn],{} [e1..en])} returns \\spad{a*prod(vi^ei)}.")
  (($ $ |#4| (|NonNegativeInteger|))
   "\\spad{monomial(a,{} x,{} n)} creates the monomial \\spad{a*x^n} where \\spad{a} is a polynomial,{} \\spad{x} is a variable and \\spad{n} is a nonnegative integer."))
 (|mainVariable|
  (((|Union| |#4| "failed") $)
   "\\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \\spad{p},{} or \"failed\" if no variables are present. fails precisely if polynomial satisfies ground?"))
 (|monomials|
  (((|List| $) $)
   "\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p},{} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),{} ...,{} a_(n) X^(n)]}."))
 (|coefficient|
  (($ $ (|List| |#4|) (|List| (|NonNegativeInteger|)))
   "\\spad{coefficient(p,{} lv,{} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv^ln},{} \\spadignore{i.e.} \\spad{prod(lv_i ^ ln_i)}.")
  (($ $ |#4| (|NonNegativeInteger|))
   "\\spad{coefficient(p,{} v,{} n)} views the polynomial \\spad{p} as a univariate polynomial in \\spad{v} and returns the coefficient of the \\spad{v^n} term."))
 (|degree|
  (((|List| (|NonNegativeInteger|)) $ (|List| |#4|))
   "\\spad{degree(p,{} lv)} gives the list of degrees of polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}.")
  (((|NonNegativeInteger|) $ |#4|)
   "\\spad{degree(p,{} v)} gives the degree of polynomial \\spad{p} with respect to the variable \\spad{v}."))
 (|canonicalUnitNormal|
  ((|attribute|)
   "we can choose a unique representative for each associate class. This normalization is chosen to be normalization of leading coefficient (by default)."))) 
((|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|Ring|))) 
(|MaybeSkewPolynomialCategory| R E |VarSet|) 
((|constructor|
  (NIL
   "The category for general multi-variate possibly skew polynomials over a ring \\spad{R},{} in variables from VarSet,{} with exponents from the \\spadtype{OrderedAbelianMonoidSup}."))
 (|primitiveMonomials|
  (((|List| $) $)
   "\\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \\spad{p} with their coefficients removed. Note: \\spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),{} ...,{} X^(n)]}."))
 (|variables|
  (((|List| |#3|) $)
   "\\spad{variables(p)} returns the list of those variables actually appearing in the polynomial \\spad{p}."))
 (|totalDegreeSorted|
  (((|NonNegativeInteger|) $ (|List| |#3|))
   "\\spad{totalDegreeSorted(p,{} lv)} returns the maximum sum (over all monomials of polynomial \\spad{p}) of the degree in variables in the list \\spad{lv}. \\spad{lv} is assumed to be sorted in decreasing order."))
 (|totalDegree|
  (((|NonNegativeInteger|) $ (|List| |#3|))
   "\\spad{totalDegree(p,{} lv)} returns the maximum sum (over all monomials of polynomial \\spad{p}) of the variables in the list \\spad{lv}.")
  (((|NonNegativeInteger|) $)
   "\\spad{totalDegree(p)} returns the largest sum over all monomials of all exponents of a monomial."))
 (|monomial|
  (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|)))
   "\\spad{monomial(a,{} [v1..vn],{} [e1..en])} returns \\spad{a*prod(vi^ei)}.")
  (($ $ |#3| (|NonNegativeInteger|))
   "\\spad{monomial(a,{} x,{} n)} creates the monomial \\spad{a*x^n} where \\spad{a} is a polynomial,{} \\spad{x} is a variable and \\spad{n} is a nonnegative integer."))
 (|mainVariable|
  (((|Union| |#3| "failed") $)
   "\\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \\spad{p},{} or \"failed\" if no variables are present. fails precisely if polynomial satisfies ground?"))
 (|monomials|
  (((|List| $) $)
   "\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p},{} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),{} ...,{} a_(n) X^(n)]}."))
 (|coefficient|
  (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|)))
   "\\spad{coefficient(p,{} lv,{} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv^ln},{} \\spadignore{i.e.} \\spad{prod(lv_i ^ ln_i)}.")
  (($ $ |#3| (|NonNegativeInteger|))
   "\\spad{coefficient(p,{} v,{} n)} views the polynomial \\spad{p} as a univariate polynomial in \\spad{v} and returns the coefficient of the \\spad{v^n} term."))
 (|degree|
  (((|List| (|NonNegativeInteger|)) $ (|List| |#3|))
   "\\spad{degree(p,{} lv)} gives the list of degrees of polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}.")
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{degree(p,{} v)} gives the degree of polynomial \\spad{p} with respect to the variable \\spad{v}."))
 (|canonicalUnitNormal|
  ((|attribute|)
   "we can choose a unique representative for each associate class. This normalization is chosen to be normalization of leading coefficient (by default)."))) 
NIL 
(|GeneralPolynomialSet| R E |VarSet| P) 
((|constructor| (NIL "A domain for polynomial sets."))
 (|convert|
  (($ (|List| |#4|))
   "\\spad{convert(lp)} returns the polynomial set whose members are the polynomials of \\spad{lp}."))) 
((AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#4| '(|BasicType|)) (|HasCategory| |#4| '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|GradedAlgebra&| S R E) 
((|constructor|
  (NIL
   "GradedAlgebra(\\spad{R},{} \\spad{E}) denotes ``E-graded \\spad{R}-algebra\\spad{''}. A graded algebra is a graded module together with a degree preserving \\spad{R}-linear map,{} called the {\\em product}. \\blankline The name ``product\\spad{''} is written out in full so inner and outer products with the same mapping type can be distinguished by name."))
 (|product|
  (($ $ $)
   "\\spad{product(a,{} b)} is the degree-preserving \\spad{R}-linear product: \\blankline \\indented{2}{\\spad{degree product(a,{} b) = degree a + degree b}} \\indented{2}{\\spad{product(a1+a2,{} b) = product(a1,{} b) + product(a2,{} b)}} \\indented{2}{\\spad{product(a,{} b1+b2) = product(a,{} b1) + product(a,{} b2)}} \\indented{2}{\\spad{product(r*a,{} b) = product(a,{} r*b) = r*product(a,{} b)}} \\indented{2}{\\spad{product(a,{} product(b,{} c)) = product(product(a,{} b),{} c)}}"))
 ((|One|) (($) "1 is the identity for \\spad{product}."))) 
NIL 
(|GradedAlgebra| R E) 
((|constructor|
  (NIL
   "GradedAlgebra(\\spad{R},{} \\spad{E}) denotes ``E-graded \\spad{R}-algebra\\spad{''}. A graded algebra is a graded module together with a degree preserving \\spad{R}-linear map,{} called the {\\em product}. \\blankline The name ``product\\spad{''} is written out in full so inner and outer products with the same mapping type can be distinguished by name."))
 (|product|
  (($ $ $)
   "\\spad{product(a,{} b)} is the degree-preserving \\spad{R}-linear product: \\blankline \\indented{2}{\\spad{degree product(a,{} b) = degree a + degree b}} \\indented{2}{\\spad{product(a1+a2,{} b) = product(a1,{} b) + product(a2,{} b)}} \\indented{2}{\\spad{product(a,{} b1+b2) = product(a,{} b1) + product(a,{} b2)}} \\indented{2}{\\spad{product(r*a,{} b) = product(a,{} r*b) = r*product(a,{} b)}} \\indented{2}{\\spad{product(a,{} product(b,{} c)) = product(product(a,{} b),{} c)}}"))
 ((|One|) (($) "1 is the identity for \\spad{product}."))) 
NIL 
(|GrayCode|) 
((|constructor|
  (NIL
   "GrayCode provides a function for efficiently running through all subsets of a finite set,{} only changing one element by another one."))
 (|firstSubsetGray|
  (((|Vector| (|Vector| (|Integer|))) (|PositiveInteger|))
   "\\spad{firstSubsetGray(n)} creates the first vector {\\em ww} to start a loop using {\\em nextSubsetGray(ww,{} n)}"))
 (|nextSubsetGray|
  (((|Vector| (|Vector| (|Integer|))) (|Vector| (|Vector| (|Integer|)))
    (|PositiveInteger|))
   "\\spad{nextSubsetGray(ww,{} n)} returns a vector {\\em vv} whose components have the following meanings: \\begin{items} \\item {\\em vv.1}: a vector of length \\spad{n} whose entries are 0 or 1. This \\indented{3}{can be interpreted as a code for a subset of the set 1,{} ...,{} \\spad{n};} \\indented{3}{{\\em vv.1} differs from {\\em ww.1} by exactly one entry;} \\item {\\em vv.2.1} is the number of the entry of {\\em vv.1} which \\indented{3}{will be changed next time;} \\item {\\em vv.2.1 = n+1} means that {\\em vv.1} is the last subset; \\indented{3}{trying to compute nextSubsetGray(\\spad{vv}) if {\\em vv.2.1 = n+1}} \\indented{3}{will produce an error!} \\end{items} The other components of {\\em vv.2} are needed to compute nextSubsetGray efficiently. Note: this is an implementation of [Williamson,{} Topic II,{} 3.54,{} \\spad{p}. 112] for the special case {\\em r1 = r2 = ... = rn = 2}; Note: nextSubsetGray produces a side-effect,{} \\spadignore{i.e.} {\\em nextSubsetGray(vv)} and {\\em vv := nextSubsetGray(vv)} will have the same effect."))) 
NIL 
(|GraphicsDefaults|) 
((|constructor|
  (NIL
   "TwoDimensionalPlotSettings sets global flags and constants for 2-dimensional plotting."))
 (|screenResolution|
  (((|Integer|) (|Integer|))
   "\\spad{screenResolution(n)} sets the screen resolution to \\spad{n}.")
  (((|Integer|))
   "\\spad{screenResolution()} returns the screen resolution \\spad{n}."))
 (|minPoints|
  (((|Integer|) (|Integer|))
   "\\spad{minPoints()} sets the minimum number of points in a plot.")
  (((|Integer|))
   "\\spad{minPoints()} returns the minimum number of points in a plot."))
 (|maxPoints|
  (((|Integer|) (|Integer|))
   "\\spad{maxPoints()} sets the maximum number of points in a plot.")
  (((|Integer|))
   "\\spad{maxPoints()} returns the maximum number of points in a plot."))
 (|adaptive|
  (((|Boolean|) (|Boolean|))
   "\\spad{adaptive(true)} turns adaptive plotting on; \\spad{adaptive(false)} turns adaptive plotting off.")
  (((|Boolean|))
   "\\spad{adaptive()} determines whether plotting will be done adaptively."))
 (|drawToScale|
  (((|Boolean|) (|Boolean|))
   "\\spad{drawToScale(true)} causes plots to be drawn to scale. \\spad{drawToScale(false)} causes plots to be drawn so that they fill up the viewport window. The default setting is \\spad{false}.")
  (((|Boolean|))
   "\\spad{drawToScale()} determines whether or not plots are to be drawn to scale."))
 (|clipPointsDefault|
  (((|Boolean|) (|Boolean|))
   "\\spad{clipPointsDefault(true)} turns on automatic clipping; \\spad{clipPointsDefault(false)} turns off automatic clipping. The default setting is \\spad{true}.")
  (((|Boolean|))
   "\\spad{clipPointsDefault()} determines whether or not automatic clipping is to be done."))) 
NIL 
(|GraphImage|) 
((|constructor|
  (NIL
   "TwoDimensionalGraph creates virtual two dimensional graphs (to be displayed on TwoDimensionalViewports)."))
 (|putColorInfo|
  (((|List| (|List| (|Point| (|DoubleFloat|))))
    (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|)))
   "\\spad{putColorInfo(llp,{} lpal)} takes a list of list of points,{} \\spad{llp},{} and returns the points with their hue and shade components set according to the list of palette colors,{} \\spad{lpal}."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(\\spad{gi})} returns the indicated graph,{} \\spad{\\spad{gi}},{} of domain \\spadtype{GraphImage} as output of the domain \\spadtype{OutputForm}.")
  (($ (|List| (|List| (|Point| (|DoubleFloat|)))))
   "\\spad{coerce(llp)} creates and returns a graph of the domain \\spadtype{GraphImage} which is composed of the list of list of points given by \\spad{llp},{} and whose point colors,{} line colors and point sizes are determined by the default functions \\spadfun{pointColorDefault},{} \\spadfun{lineColorDefault},{} and \\spadfun{pointSizeDefault}. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window."))
 (|point|
  (((|Void|) $ (|Point| (|DoubleFloat|)) (|Palette|))
   "\\spad{point(\\spad{gi},{} pt,{} pal)} modifies the graph \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage} to contain one point component,{} \\spad{pt} whose point color is set to be the palette color \\spad{pal},{} and whose line color and point size are determined by the default functions \\spadfun{lineColorDefault} and \\spadfun{pointSizeDefault}."))
 (|appendPoint|
  (((|Void|) $ (|Point| (|DoubleFloat|)))
   "\\spad{appendPoint(\\spad{gi},{} pt)} appends the point \\spad{pt} to the end of the list of points component for the graph,{} \\spad{\\spad{gi}},{} which is of the domain \\spadtype{GraphImage}."))
 (|component|
  (((|Void|) $ (|Point| (|DoubleFloat|)) (|Palette|) (|Palette|)
    (|PositiveInteger|))
   "\\spad{component(\\spad{gi},{} pt,{} pal1,{} pal2,{} ps)} modifies the graph \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage} to contain one point component,{} \\spad{pt} whose point color is set to the palette color \\spad{pal1},{} line color is set to the palette color \\spad{pal2},{} and point size is set to the positive integer \\spad{ps}.")
  (((|Void|) $ (|Point| (|DoubleFloat|)))
   "\\spad{component(\\spad{gi},{} pt)} modifies the graph \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage} to contain one point component,{} \\spad{pt} whose point color,{} line color and point size are determined by the default functions \\spadfun{pointColorDefault},{} \\spadfun{lineColorDefault},{} and \\spadfun{pointSizeDefault}.")
  (((|Void|) $ (|List| (|Point| (|DoubleFloat|))) (|Palette|) (|Palette|)
    (|PositiveInteger|))
   "\\spad{component(\\spad{gi},{} lp,{} pal1,{} pal2,{} p)} sets the components of the graph,{} \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage},{} to the values given. The point list for \\spad{\\spad{gi}} is set to the list \\spad{lp},{} the color of the points in \\spad{lp} is set to the palette color \\spad{pal1},{} the color of the lines which connect the points \\spad{lp} is set to the palette color \\spad{pal2},{} and the size of the points in \\spad{lp} is given by the integer \\spad{p}."))
 (|units|
  (((|List| (|Float|)) $ (|List| (|Float|)))
   "\\spad{units(\\spad{gi},{} lu)} modifies the list of unit increments for the \\spad{x} and \\spad{y} axes of the given graph,{} \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage},{} to be that of the list of unit increments,{} \\spad{lu},{} and returns the new list of units for \\spad{\\spad{gi}}.")
  (((|List| (|Float|)) $)
   "\\spad{units(\\spad{gi})} returns the list of unit increments for the \\spad{x} and \\spad{y} axes of the indicated graph,{} \\spad{\\spad{gi}},{} of the domain \\spadtype{GraphImage}."))
 (|ranges|
  (((|List| (|Segment| (|Float|))) $ (|List| (|Segment| (|Float|))))
   "\\spad{ranges(\\spad{gi},{} lr)} modifies the list of ranges for the given graph,{} \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage},{} to be that of the list of range segments,{} \\spad{lr},{} and returns the new range list for \\spad{\\spad{gi}}.")
  (((|List| (|Segment| (|Float|))) $)
   "\\spad{ranges(\\spad{gi})} returns the list of ranges of the point components from the indicated graph,{} \\spad{\\spad{gi}},{} of the domain \\spadtype{GraphImage}."))
 (|key|
  (((|Integer|) $)
   "\\spad{key(\\spad{gi})} returns the process ID of the given graph,{} \\spad{\\spad{gi}},{} of the domain \\spadtype{GraphImage}."))
 (|pointLists|
  (((|List| (|List| (|Point| (|DoubleFloat|)))) $)
   "\\spad{pointLists(\\spad{gi})} returns the list of lists of points which compose the given graph,{} \\spad{\\spad{gi}},{} of the domain \\spadtype{GraphImage}."))
 (|makeGraphImage|
  (($ (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|))
    (|List| (|Palette|)) (|List| (|PositiveInteger|)) (|List| (|DrawOption|)))
   "\\spad{makeGraphImage(llp,{} lpal1,{} lpal2,{} lp,{} lopt)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \\spad{llp},{} whose point colors are indicated by the list of palette colors,{} \\spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \\spad{lpal2}. The paramater \\spad{lp} is a list of integers which denote the size of the data points,{} and \\spad{lopt} is the list of draw command options.")
  (($ (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|))
    (|List| (|Palette|)) (|List| (|PositiveInteger|)))
   "\\spad{makeGraphImage(llp,{} lpal1,{} lpal2,{} lp)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \\spad{llp},{} whose point colors are indicated by the list of palette colors,{} \\spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \\spad{lpal2}. The paramater \\spad{lp} is a list of integers which denote the size of the data points.")
  (($ (|List| (|List| (|Point| (|DoubleFloat|)))))
   "\\spad{makeGraphImage(llp)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \\spad{llp},{} with default point size and default point and line colours."))
 (|sendGraphImage|
  (((|Void|) $)
   "\\spad{sendGraphImage(\\spad{gi})} takes the given graph,{} \\spad{\\spad{gi}} of the domain \\spadtype{GraphImage},{} and sends it\\spad{'s} data to the viewport manager where it waits to be included in a two-dimensional viewport window. \\spad{\\spad{gi}} cannot be an empty graph."))
 (|graphImage|
  (($)
   "\\spad{graphImage()} returns an empty graph with 0 point lists of the domain \\spadtype{GraphImage}. A graph image contains the graph data component of a two dimensional viewport."))) 
NIL 
(|GradedModule&| S R E) 
((|constructor|
  (NIL
   "GradedModule(\\spad{R},{} \\spad{E}) denotes ``E-graded \\spad{R}-module\\spad{''},{} \\spadignore{i.e.} collection of \\spad{R}-modules indexed by an abelian monoid \\spad{E}. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with {\\em degree} \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules."))
 (+
  (($ $ $)
   "\\spad{g+h} is the sum of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h}. Error: if \\spad{g} and \\spad{h} have different degrees."))
 (-
  (($ $ $)
   "\\spad{g-h} is the difference of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h}. Error: if \\spad{g} and \\spad{h} have different degrees.")
  (($ $)
   "\\spad{-g} is the additive inverse of \\spad{g} in the module of elements of the same grade as \\spad{g}."))
 (* (($ $ |#2|) "\\spad{g*r} is right module multiplication.")
    (($ |#2| $) "\\spad{r*g} is left module multiplication."))
 ((|Zero|) (($) "0 denotes the zero of degree 0."))
 (|degree|
  ((|#3| $)
   "\\spad{degree(g)} names the degree of \\spad{g}. The set of all elements of a given degree form an \\spad{R}-module."))) 
NIL 
(|GradedModule| R E) 
((|constructor|
  (NIL
   "GradedModule(\\spad{R},{} \\spad{E}) denotes ``E-graded \\spad{R}-module\\spad{''},{} \\spadignore{i.e.} collection of \\spad{R}-modules indexed by an abelian monoid \\spad{E}. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with {\\em degree} \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules."))
 (+
  (($ $ $)
   "\\spad{g+h} is the sum of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h}. Error: if \\spad{g} and \\spad{h} have different degrees."))
 (-
  (($ $ $)
   "\\spad{g-h} is the difference of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h}. Error: if \\spad{g} and \\spad{h} have different degrees.")
  (($ $)
   "\\spad{-g} is the additive inverse of \\spad{g} in the module of elements of the same grade as \\spad{g}."))
 (* (($ $ |#1|) "\\spad{g*r} is right module multiplication.")
    (($ |#1| $) "\\spad{r*g} is left module multiplication."))
 ((|Zero|) (($) "0 denotes the zero of degree 0."))
 (|degree|
  ((|#2| $)
   "\\spad{degree(g)} names the degree of \\spad{g}. The set of all elements of a given degree form an \\spad{R}-module."))) 
NIL 
(|GroebnerSolve| |lv| F R) 
((|constructor|
  (NIL
   "\\indented{1}{Author : \\spad{P}.Gianni,{} Summer \\spad{'88},{} revised November \\spad{'89}} Solve systems of polynomial equations using Groebner bases Total order Groebner bases are computed and then converted to lex ones This package is mostly intended for internal use."))
 (|genericPosition|
  (((|Record|
     (|:| |dpolys| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
     (|:| |coords| (|List| (|Integer|))))
    (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|OrderedVariableList| |#1|)))
   "\\spad{genericPosition(lp,{} lv)} puts a radical zero dimensional ideal in general position,{} for system \\spad{lp} in variables \\spad{lv}."))
 (|testDim|
  (((|Union|
     (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
     "failed")
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|OrderedVariableList| |#1|)))
   "\\spad{testDim(lp,{} lv)} tests if the polynomial system \\spad{lp} in variables \\spad{lv} is zero dimensional."))
 (|groebSolve|
  (((|List| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
    (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|OrderedVariableList| |#1|)))
   "\\spad{groebSolve(lp,{} lv)} reduces the polynomial system \\spad{lp} in variables \\spad{lv} to triangular form. Algorithm based on groebner bases algorithm with linear algebra for change of ordering. Preprocessing for the general solver. The polynomials in input are of type \\spadtype{DMP}."))) 
NIL 
(|Group&| S) 
((|constructor|
  (NIL
   "The class of multiplicative groups,{} \\spadignore{i.e.} monoids with multiplicative inverses. \\blankline"))
 (|commutator|
  (($ $ $)
   "\\spad{commutator(p,{} q)} computes \\spad{inv(p) * inv(q) * p * q}."))
 (|conjugate|
  (($ $ $)
   "\\spad{conjugate(p,{} q)} computes \\spad{inv(q) * p * q}; this is 'right action by conjugation'."))
 (^
  (($ $ (|Integer|))
   "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n}."))
 (/
  (($ $ $)
   "\\spad{x/y} is the same as \\spad{x} times the inverse of \\spad{y}."))
 (|inv| (($ $) "\\spad{inv(x)} returns the inverse of \\spad{x}."))) 
NIL 
(|Group|) 
((|constructor|
  (NIL
   "The class of multiplicative groups,{} \\spadignore{i.e.} monoids with multiplicative inverses. \\blankline"))
 (|commutator|
  (($ $ $)
   "\\spad{commutator(p,{} q)} computes \\spad{inv(p) * inv(q) * p * q}."))
 (|conjugate|
  (($ $ $)
   "\\spad{conjugate(p,{} q)} computes \\spad{inv(q) * p * q}; this is 'right action by conjugation'."))
 (^
  (($ $ (|Integer|))
   "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n}."))
 (/
  (($ $ $)
   "\\spad{x/y} is the same as \\spad{x} times the inverse of \\spad{y}."))
 (|inv| (($ $) "\\spad{inv(x)} returns the inverse of \\spad{x}."))) 
NIL 
(|GroupPresentation|) 
((|constructor|
  (NIL
   "\\indented{2}{Group represented by its generators and relations.} \\indented{2}{Here we use it to hold homotopy group such as fundamental group.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/presentation/} Date Created: Jan 2016 Basic Operations: Related packages: Related categories: Related Domains: PermutationGroup Also See: AMS Classifications:"))
 (|toPermutationIfCan|
  (((|Union| (|PermutationGroup| (|Integer|)) "failed") $
    (|List| (|List| (|Integer|))) (|Boolean|))
   "\\spad{toPermutationIfCan(a,{} sg,{} trace)} returns permutation representation of a on cosets of subgroup generate by \\spad{sg} or \"failed\" if computation exceed resource limit. trace activates debugging printouts.")
  (((|Union| (|PermutationGroup| (|Integer|)) "failed") $ (|Boolean|))
   "convert to permutation group return \"failed\" for infinite groups. For more information about the algorithm see: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/pres2perm/}")
  (((|Union| (|PermutationGroup| (|Integer|)) "failed") $)
   "convert to permutation group return \"failed\" for infinite groups. For more information about the algorithm see: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/pres2perm/}"))
 (|symmetricGroup|
  (($ (|PositiveInteger|))
   "\\spad{symmetricGroup(n)} constructs the symmetric group of order \\spad{n}-1. Note: generates all possible relations may not be minimal."))
 (|dihedralGroup|
  (($ (|PositiveInteger|))
   "\\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,{} ...,{} \\spad{N}."))
 (|cyclicGroup|
  (($ (|PositiveInteger|))
   "\\spad{cyclicGroup(n)} constructs the cyclic group of order \\spad{n} acting on the integers 1,{} ...,{} \\spad{n}."))
 (|directProduct| (($ $ $) "\\spad{directProduct of} two groups"))
 (|quotient|
  (($ $ (|List| (|List| (|Integer|))))
   "take quotient by adding relations specified by addrel")
  (($ $ (|List| (|NonNegativeInteger|)))
   "take quotient by removing generators specified by remgen"))
 (|refactor|
  (($ $)
   "actual value of generators is not important,{} it is only important that they correspond to the appropriate entries in the relations. Therefore we can refactor the generators without changing the group represented."))
 (|simplify| (($ $ (|Boolean|)) "simplify with option to trace")
  (($ $)
   "There may not be a simplest form but it is possible to do some simplifications as follows: 1. Remove all zero terms in relations. 2. If a relation consists of a single generator then remove \\indented{3}{that generator.} 3. If a relation consists of a pair of generators then make the \\indented{3}{second generator the inverse of the first.} 4. If a generator is adjacent to its inverse then cancel them out. 5. Remove duplicate relations. 6. Substitute one relation in another."))
 (|groupPresentation|
  (($) "construct trivial group with no generators or relations")
  (($ (|List| (|NonNegativeInteger|)))
   "construct free group with generators but no relations")
  (($ (|List| (|NonNegativeInteger|)) (|List| (|List| (|Integer|))))
   "construct from generators and relations"))) 
NIL 
(|GroupPresentationFunctions1| S) 
((|convert|
  (((|GroupPresentation|) (|List| |#1|) (|List| (|FreeGroup| |#1|)))
   "\\spad{convert(lg,{} lr)} builds group presentation from list of generators \\spad{lg} and list of relations \\spad{lr}."))) 
NIL 
(|GeneralUnivariatePowerSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,{} f(x)]},{} where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x\\^r)}."))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|coerce|
  (($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|))
   "\\spad{coerce(f)} converts a Puiseux series to a general power series.")
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (LIST '|Fraction| '(|Integer|))
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|)
                                  (LIST '|Fraction| '(|Integer|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Fraction| (|Integer|)) '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (LIST '|Fraction| '(|Integer|)))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|)))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))) 
(|GeneralSparseTable| |Key| |Entry| |Tbl| |dent|) 
((|constructor|
  (NIL
   "A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|GeneralTriangularSet| R E V P) 
((|constructor|
  (NIL
   "A domain constructor of the category \\spadtype{TriangularSetCategory}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. Triangular sets are stored as sorted lists \\spad{w}.\\spad{r}.\\spad{t}. the main variables of their members but they are displayed in reverse order.\\newline"))) 
((AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#4| '(|BasicType|)) (|HasCategory| |#4| '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#3| '(|Finite|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|Guess| F S EXPRR |retract| |coerce|) 
((|constructor|
  (NIL
   "This package implements guessing of sequences. Packages for the most common cases are provided as \\spadtype{GuessInteger},{} \\spadtype{GuessPolynomial},{} etc."))
 (|shiftHP|
  (((|Mapping|
     (|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
               (|:| |guessStream|
                    (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                               (|UnivariateFormalPowerSeries| |#1|)))
               (|:| |guessModGen|
                    (|Mapping|
                     (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                                (|Integer|) (|Integer|))
                     (|NonNegativeInteger|)))
               (|:| |testGen|
                    (|Mapping|
                     (|Mapping|
                      (|Vector|
                       (|UnivariateFormalPowerSeries|
                        (|SparseMultivariatePolynomial| |#1|
                                                        (|NonNegativeInteger|))))
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|List| (|PositiveInteger|))))
               (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
               (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
               (|:| A
                    (|Mapping| |#2| (|NonNegativeInteger|)
                               (|NonNegativeInteger|)
                               (|SparseUnivariatePolynomial| |#2|)))
               (|:| AF
                    (|Mapping|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|))
                     (|NonNegativeInteger|) (|NonNegativeInteger|)
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|)))))
               (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
               (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
     (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the \\$\\spad{q}\\$-shift operator,{} or,{} if \\spad{maxMixedDegree > 0} for mixed shifts")
  (((|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
              (|:| |guessStream|
                   (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                              (|UnivariateFormalPowerSeries| |#1|)))
              (|:| |guessModGen|
                   (|Mapping|
                    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                               (|Integer|) (|Integer|))
                    (|NonNegativeInteger|)))
              (|:| |testGen|
                   (|Mapping|
                    (|Mapping|
                     (|Vector|
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|))))
                    (|List| (|PositiveInteger|))))
              (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
              (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
              (|:| A
                   (|Mapping| |#2| (|NonNegativeInteger|)
                              (|NonNegativeInteger|)
                              (|SparseUnivariatePolynomial| |#2|)))
              (|:| AF
                   (|Mapping|
                    (|SparseMultivariatePolynomial| |#1|
                                                    (|NonNegativeInteger|))
                    (|NonNegativeInteger|) (|NonNegativeInteger|)
                    (|UnivariateFormalPowerSeries|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|)))))
              (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
              (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
    (|List| (|GuessOption|)))
   "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the shift operator"))
 (|substHP|
  (((|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
              (|:| |guessStream|
                   (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                              (|UnivariateFormalPowerSeries| |#1|)))
              (|:| |guessModGen|
                   (|Mapping|
                    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                               (|Integer|) (|Integer|))
                    (|NonNegativeInteger|)))
              (|:| |testGen|
                   (|Mapping|
                    (|Mapping|
                     (|Vector|
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|))))
                    (|List| (|PositiveInteger|))))
              (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
              (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
              (|:| A
                   (|Mapping| |#2| (|NonNegativeInteger|)
                              (|NonNegativeInteger|)
                              (|SparseUnivariatePolynomial| |#2|)))
              (|:| AF
                   (|Mapping|
                    (|SparseMultivariatePolynomial| |#1|
                                                    (|NonNegativeInteger|))
                    (|NonNegativeInteger|) (|NonNegativeInteger|)
                    (|UnivariateFormalPowerSeries|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|)))))
              (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
              (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
    (|List| (|GuessOption|)))
   "\\spad{substHP options} returns a specification for Hermite-Pade approximation with the substitution operator"))
 (|diffHP|
  (((|Mapping|
     (|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
               (|:| |guessStream|
                    (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                               (|UnivariateFormalPowerSeries| |#1|)))
               (|:| |guessModGen|
                    (|Mapping|
                     (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                                (|Integer|) (|Integer|))
                     (|NonNegativeInteger|)))
               (|:| |testGen|
                    (|Mapping|
                     (|Mapping|
                      (|Vector|
                       (|UnivariateFormalPowerSeries|
                        (|SparseMultivariatePolynomial| |#1|
                                                        (|NonNegativeInteger|))))
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|List| (|PositiveInteger|))))
               (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
               (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
               (|:| A
                    (|Mapping| |#2| (|NonNegativeInteger|)
                               (|NonNegativeInteger|)
                               (|SparseUnivariatePolynomial| |#2|)))
               (|:| AF
                    (|Mapping|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|))
                     (|NonNegativeInteger|) (|NonNegativeInteger|)
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|)))))
               (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
               (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
     (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the \\$\\spad{q}\\$-dilation operator")
  (((|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
              (|:| |guessStream|
                   (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                              (|UnivariateFormalPowerSeries| |#1|)))
              (|:| |guessModGen|
                   (|Mapping|
                    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                               (|Integer|) (|Integer|))
                    (|NonNegativeInteger|)))
              (|:| |testGen|
                   (|Mapping|
                    (|Mapping|
                     (|Vector|
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|))))
                    (|List| (|PositiveInteger|))))
              (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
              (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
              (|:| A
                   (|Mapping| |#2| (|NonNegativeInteger|)
                              (|NonNegativeInteger|)
                              (|SparseUnivariatePolynomial| |#2|)))
              (|:| AF
                   (|Mapping|
                    (|SparseMultivariatePolynomial| |#1|
                                                    (|NonNegativeInteger|))
                    (|NonNegativeInteger|) (|NonNegativeInteger|)
                    (|UnivariateFormalPowerSeries|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|)))))
              (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
              (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
    (|List| (|GuessOption|)))
   "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the differential operator"))
 (|algDepHP|
  (((|Record| (|:| |degreeStream| (|Stream| (|NonNegativeInteger|)))
              (|:| |guessStream|
                   (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|))
                              (|UnivariateFormalPowerSeries| |#1|)))
              (|:| |guessModGen|
                   (|Mapping|
                    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
                               (|Integer|) (|Integer|))
                    (|NonNegativeInteger|)))
              (|:| |testGen|
                   (|Mapping|
                    (|Mapping|
                     (|Vector|
                      (|UnivariateFormalPowerSeries|
                       (|SparseMultivariatePolynomial| |#1|
                                                       (|NonNegativeInteger|))))
                     (|UnivariateFormalPowerSeries|
                      (|SparseMultivariatePolynomial| |#1|
                                                      (|NonNegativeInteger|))))
                    (|List| (|PositiveInteger|))))
              (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|)))
              (|:| |kind| (|Symbol|)) (|:| |qvar| (|Symbol|))
              (|:| A
                   (|Mapping| |#2| (|NonNegativeInteger|)
                              (|NonNegativeInteger|)
                              (|SparseUnivariatePolynomial| |#2|)))
              (|:| AF
                   (|Mapping|
                    (|SparseMultivariatePolynomial| |#1|
                                                    (|NonNegativeInteger|))
                    (|NonNegativeInteger|) (|NonNegativeInteger|)
                    (|UnivariateFormalPowerSeries|
                     (|SparseMultivariatePolynomial| |#1|
                                                     (|NonNegativeInteger|)))))
              (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|))
              (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|))))
    (|List| (|List| |#1|)) (|List| (|GuessOption|)))
   "\\spad{algDepHP(list,{} options)} returns a specification for Hermite-Pade approximation looking for algebraic dependencies"))
 (|guessRat|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessRat q} returns a guesser that tries to find a \\spad{q}-rational function whose first values are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessRec} with \\spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessRat l} tries to find a rational function whose first values are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessRat(l,{} options)} tries to find a rational function whose first values are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}."))
 (|guessPRec|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessPRec q} returns a guesser that tries to find a linear \\spad{q}-recurrence with polynomial coefficients whose first values are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(q)} with \\spad{maxPower == 1}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessPRec l} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l,{} maxPower == 1)}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessPRec(l,{} options)} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l,{} options)} with \\spad{maxPower == 1}."))
 (|guessRec|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessRec q} returns a guesser that finds an ordinary \\spad{q}-difference equation whose first values are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessRec(l,{} options)} tries to find an ordinary difference equation whose first values are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessRec l} tries to find an ordinary difference equation whose first values are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}."))
 (|guessPade|
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessPade(l,{} options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l,{} options)} with \\spad{maxDerivative == 0,{} maxPower == 1,{} allDegrees == true}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessPade(l,{} options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l,{} maxDerivative == 0,{} maxPower == 1,{} allDegrees == true)}."))
 (|guessHolo|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessHolo q} returns a guesser that tries to find a linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessHolo(l,{} options)} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l,{} options)} with \\spad{maxPower == 1}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessHolo l} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l,{} maxPower == 1)}."))
 (|guessAlg|
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessAlg(l,{} options)} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options. It is equivalent to \\spadfun{guessADE}(\\spad{l},{} options) with \\spad{maxDerivative == 0}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessAlg l} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}(\\spad{l},{} maxDerivative \\spad{==} 0)."))
 (|guessFE|
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessFE(l,{} options)} tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessFE l} tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}."))
 (|guessADE|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessADE q} returns a guesser that tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessADE(l,{} options)} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the given options.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessADE l} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l},{} using the default options described in \\spadtype{GuessOptionFunctions0}."))
 (|guessAlgDep|
  (((|List| |#3|) (|List| (|List| |#1|)) (|List| (|GuessOption|)))
   "\\spad{guessAlgDep ll} tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of \\spad{ll},{} using the given options.")
  (((|List| |#3|) (|List| (|List| |#1|)))
   "\\spad{guessAlgDep ll} tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of \\spad{ll},{} using the default options described in \\spadtype{GuessOptionFunctions0}."))
 (|guessBinRat|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessBinRat q} returns a guesser that tries to find a function of the form \\spad{n+}->qbinomial(a+b \\spad{n},{} \\spad{n}) \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{q^n}) is a \\spad{q}-rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessBinRat(l,{} options)} tries to find a function of the form \\spad{n+}->binomial(a+b \\spad{n},{} \\spad{n}) \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessBinRat(l,{} options)} tries to find a function of the form \\spad{n+}->binomial(a+b \\spad{n},{} \\spad{n}) \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}."))
 (|guessExpRat|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessExpRat q} returns a guesser that tries to find a function of the form \\spad{n+}->(a+b \\spad{q^n})\\spad{^n} \\spad{r}(\\spad{q^n}),{} where \\spad{r}(\\spad{q^n}) is a \\spad{q}-rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessExpRat(l,{} options)} tries to find a function of the form \\spad{n+}->(a+b \\spad{n})\\spad{^n} \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guessExpRat l} tries to find a function of the form \\spad{n+}->(a+b \\spad{n})\\spad{^n} \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}."))
 (|guess|
  (((|List| |#3|) (|List| |#1|)
    (|List| (|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|))))
    (|List| (|Symbol|)) (|List| (|GuessOption|)))
   "\\spad{guess(l,{} guessers,{} ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol \\spad{guessSum} and quotients if ops contains the symbol \\spad{guessProduct} to the list. The given options are used.")
  (((|List| |#3|) (|List| |#1|)
    (|List| (|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|))))
    (|List| (|Symbol|)))
   "\\spad{guess(l,{} guessers,{} ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol guessSum and quotients if ops contains the symbol guessProduct to the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guess(l,{} options)} applies recursively \\spadfun{guessRat} to the successive differences and quotients of the list. The given options are used.")
  (((|List| |#3|) (|List| |#1|))
   "\\spad{guess l} applies recursively \\spadfun{guessRat} to the successive differences and quotients of the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used."))) 
((AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Symbol|)))
      (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|))))) 
(|GuessAlgebraicNumber|) 
((|constructor|
  (NIL "This package exports guessing of sequences of rational functions"))) 
((|HasCategory| (|AlgebraicNumber|) (LIST '|RetractableTo| '(|Symbol|)))) 
(|GuessExpBin| F S EXPRR |retract| |coerce|) 
((|constructor|
  (NIL
   "This package implements guessing GuessExpRat and GuessBinRat functions of guessing package."))
 (|guessBinRat|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessBinRat q} returns a guesser that tries to find a function of the form \\spad{n+}->qbinomial(a+b \\spad{n},{} \\spad{n}) \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{q^n}) is a \\spad{q}-rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessBinRat(l,{} options)} tries to find a function of the form \\spad{n+}->binomial(a+b \\spad{n},{} \\spad{n}) \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}."))
 (|guessExpRat|
  (((|Mapping| (|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
    (|Symbol|))
   "\\spad{guessExpRat q} returns a guesser that tries to find a function of the form \\spad{n+}->(a+b \\spad{q^n})\\spad{^n} \\spad{r}(\\spad{q^n}),{} where \\spad{r}(\\spad{q^n}) is a \\spad{q}-rational function,{} that fits \\spad{l}.")
  (((|List| |#3|) (|List| |#1|) (|List| (|GuessOption|)))
   "\\spad{guessExpRat(l,{} options)} tries to find a function of the form \\spad{n+}->(a+b \\spad{n})\\spad{^n} \\spad{r}(\\spad{n}),{} where \\spad{r}(\\spad{n}) is a rational function,{} that fits \\spad{l}."))) 
((AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Symbol|)))
      (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|))))) 
(|GuessFinite| F) 
((|constructor|
  (NIL
   "This package exports guessing of sequences of numbers in a finite field"))) 
((|HasCategory| |#1| (LIST '|RetractableTo| '(|Symbol|)))) 
(|GuessFiniteFunctions| F) 
((|constructor|
  (NIL
   "This package exports coercion and retraction from EXPR INT to finite fields"))) 
NIL 
(|GuessInteger|) 
((|constructor|
  (NIL "This package exports guessing of sequences of rational numbers"))) 
((AND
  (|HasCategory| (|Fraction| (|Integer|)) (LIST '|RetractableTo| '(|Symbol|)))
  (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Symbol|))))) 
(|GuessPolynomial| R) 
((|constructor|
  (NIL "This package exports guessing of sequences of rational functions"))) 
((AND
  (|HasCategory| (|Fraction| (|Polynomial| |#1|))
                 (LIST '|RetractableTo| '(|Symbol|)))
  (|HasCategory| (|Polynomial| |#1|) (LIST '|RetractableTo| '(|Symbol|))))) 
(|GuessPolynomialFunctions| R) 
((|constructor|
  (NIL
   "This package exports coercion and retraction from EXPR INT to polynomials"))
 (|iiretractVar|
  (((|Polynomial| |#1|) (|Kernel| (|Expression| (|Integer|))))
   "should be local but conditional"))
 (|iim2| (((|Expression| (|Integer|)) |#1|) "should be local but conditional"))) 
NIL 
(|GuessPolynomialInteger|) 
((|constructor|
  (NIL
   "This package exports guessing of sequences of rational functions over the integers"))) 
((AND
  (|HasCategory| (|Fraction| (|Polynomial| (|Integer|)))
                 (LIST '|RetractableTo| '(|Symbol|)))
  (|HasCategory| (|Polynomial| (|Integer|))
                 (LIST '|RetractableTo| '(|Symbol|))))) 
(|Pi|) 
((|constructor|
  (NIL
   "\\indented{1}{Symbolic fractions in \\%\\spad{pi} with integer coefficients;} \\indented{1}{The point for using \\spad{Pi} as the default domain for those fractions} \\indented{1}{is that \\spad{Pi} is coercible to the float types,{} and not Expression.} Date Created: 21 Feb 1990"))
 (|pi| (($) "\\spad{\\spad{pi}()} returns the symbolic \\%\\spad{pi}."))) 
NIL 
(|HankelPackage| R) 
((|constructor| (NIL "Package to generate Hankel matrices."))
 (|HankelMatrix|
  (((|Matrix| |#1|) (|List| |#1|))
   "\\spad{HankelMatrix([a_0,{} a_1,{} a_2,{} ...,{} a_{2n}])} builds the Hankel matrix [ \\spad{a0},{} \\spad{a1},{} ...,{} an ] [ \\spad{a1},{} \\spad{a2},{} ... ] [ ... ] [ an,{} ...,{} a2n]"))) 
NIL 
(|HashState|) 
((|constructor|
  (NIL "This domain supports incremental computation of hash values."))
 (|value|
  (((|SingleInteger|) $)
   "\\spad{value(x)} returns a SingleInteger value corresponding to \\spad{x}."))
 (|update!|
  (($ $ (|SingleInteger|))
   "\\spad{update!(hs,{} x)} computes new values of HashState from \\spad{hs} and \\spad{x} and might destructively operate on its first argument."))
 (|new| (($) "\\spad{new()} return a new HashState."))) 
NIL 
(|HashTable| |Key| |Entry| |hashfn|) 
((|constructor|
  (NIL
   "This domain provides access to the underlying Lisp hash tables. By varying the hashfn parameter,{} tables suited for different purposes can be obtained."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|HallBasis|) 
((|constructor|
  (NIL
   "\\indented{1}{Author : Larry Lambe} Date Created : August 1988 Related Constructors: OrderedSetInts,{} Commutator,{} FreeNilpotentLie AMS Classification: Primary 17B05,{} 17B30; Secondary 17A50 Keywords: free Lie algebra,{} Hall basis,{} basic commutators Description : Generate a basis for the free Lie algebra on \\spad{n} generators over a ring \\spad{R} with identity up to basic commutators of length \\spad{c} using the algorithm of \\spad{P}. Hall as given in Serre\\spad{'s} book Lie Groups \\spad{--} Lie Algebras"))
 (|basis|
  (((|Vector| (|List| (|Integer|))) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{basis(numberOfGens,{} maximalWeight)} generates a vector of elements of the form [left,{} weight,{} right] which represents a \\spad{P}. Hall basis element for the free lie algebra on \\spad{numberOfGens} generators. We only generate those basis elements of weight less than or equal to maximalWeight"))
 (|inHallBasis?|
  (((|Boolean|) (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{inHallBasis?(numberOfGens,{} leftCandidate,{} rightCandidate,{} left)} tests to see if a new element should be added to the \\spad{P}. Hall basis being constructed. The list \\spad{[leftCandidate,{} wt,{} rightCandidate]} is included in the basis if in the unique factorization of \\spad{rightCandidate},{} we have left factor leftOfRight,{} and leftOfRight \\spad{<=} \\spad{leftCandidate}"))
 (|lfunc|
  (((|Integer|) (|Integer|) (|Integer|))
   "\\spad{lfunc(d,{} n)} computes the rank of the \\spad{n}th factor in the lower central series of the free \\spad{d}-generated free Lie algebra; This rank is \\spad{d} if \\spad{n} = 1 and binom(\\spad{d},{} 2) if \\spad{n} = 2"))) 
NIL 
(|HomogeneousDistributedMultivariatePolynomial| |vl| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is total degree ordering refined by reverse lexicographic ordering with respect to the position that the variables appear in the list of variables parameter."))
 (|reorder|
  (($ $ (|List| (|Integer|)))
   "\\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|)))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory|
  (|HomogeneousDirectProduct| (|call| LENGTH |#1|) (|NonNegativeInteger|))
  '(|Comparable|))
 (|HasCategory| |#2| '(|Field|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#2| '(|Ring|))
  (|HasCategory| (|OrderedVariableList| |#1|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|GcdDomain|))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|HomogeneousDirectProduct| |dim| S) 
((|constructor|
  (NIL
   "\\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered first by the sum of their components,{} and then refined using a reverse lexicographic ordering. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#2| '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| '(|unitsKnown|)) (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRng|))
 (|HasCategory| |#2| '(|Ring|)) (|HasCategory| |#2| '(|Monoid|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|Finite|))
 (OR (|HasCategory| |#2| '(|Finite|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| |#2| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|OrderedSet|)))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| '(|DifferentialRing|))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|Monoid|)))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|))
      (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|SemiGroup|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR (|HasCategory| |#2| '(|Monoid|)) (|HasCategory| |#2| '(|SemiGroup|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|BasicType|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
 (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|)))
  (|HasCategory| |#2| '(|Ring|)))
 (AND
  (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND
      (|HasCategory| |#2|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| |#2| '(|SemiRng|)))
     (AND (|HasCategory| |#2| '(|AbelianMonoid|))
          (|HasCategory| |#2| '(|SemiRng|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Finite|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Monoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiRng|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|SemiRng|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|SemiRng|)) (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|)))) 
(|Heap| S) 
((|constructor|
  (NIL "Heap implemented in a flexible array to allow for insertions"))
 (|heap|
  (($ (|List| |#1|))
   "\\spad{heap(ls)} creates a heap of elements consisting of the elements of \\spad{ls}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|HyperellipticFiniteDivisor| F UP UPUP R) 
((|constructor|
  (NIL
   "This domains implements finite rational divisors on an hyperelliptic curve,{} that is finite formal sums SUM(\\spad{n} * \\spad{P}) where the \\spad{n}\\spad{'s} are integers and the \\spad{P}\\spad{'s} are finite rational points on the curve. The equation of the curve must be \\spad{y^2} = \\spad{f}(\\spad{x}) and \\spad{f} must have odd degree."))) 
NIL 
(|HeuGcd| BP) 
((|constructor|
  (NIL
   "This package provides the functions for the heuristic integer \\spad{gcd}. Geddes\\spad{'s} algorithm,{} for univariate polynomials with integer coefficients"))
 (|lintgcd|
  (((|Integer|) (|List| (|Integer|)))
   "\\spad{lintgcd([a1,{} ..,{} ak])} = \\spad{gcd} of a list of integers"))
 (|content|
  (((|List| (|Integer|)) (|List| |#1|))
   "\\spad{content([f1,{} ..,{} fk])} = content of a list of univariate polynonials"))
 (|gcdcofactprim|
  (((|List| |#1|) (|List| |#1|))
   "\\spad{gcdcofactprim([f1,{} ..fk])} = \\spad{gcd} and cofactors of \\spad{k} primitive polynomials."))
 (|gcdcofact|
  (((|List| |#1|) (|List| |#1|))
   "\\spad{gcdcofact([f1,{} ..fk])} = \\spad{gcd} and cofactors of \\spad{k} univariate polynomials."))
 (|gcdprim|
  ((|#1| (|List| |#1|))
   "\\spad{gcdprim([f1,{} ..,{} fk])} = \\spad{gcd} of \\spad{k} PRIMITIVE univariate polynomials"))
 (|gcd|
  ((|#1| (|List| |#1|))
   "\\spad{gcd([f1,{} ..,{} fk])} = \\spad{gcd} of the polynomials \\spad{fi}."))) 
NIL 
(|HexadecimalExpansion|) 
((|constructor|
  (NIL
   "This domain allows rational numbers to be presented as repeating hexadecimal expansions."))
 (|hex|
  (($ (|Fraction| (|Integer|)))
   "\\spad{hex(r)} converts a rational number to a hexadecimal expansion."))
 (|fractionPart|
  (((|Fraction| (|Integer|)) $)
   "\\spad{fractionPart(h)} returns the fractional part of a hexadecimal expansion."))
 (|coerce|
  (((|RadixExpansion| 16) $)
   "\\spad{coerce(h)} converts a hexadecimal expansion to a radix expansion with base 16.")
  (((|Fraction| (|Integer|)) $)
   "\\spad{coerce(h)} converts a hexadecimal expansion to a rational number."))) 
((|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|RealConstant|))
 (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|StepThrough|))
 (|HasCategory| (|Integer|) (LIST '|InnerEvalable| '(|Symbol|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Eltable| '(|Integer|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|DifferentialRing|))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegerNumberSystem|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|Integer|) '(|CharacteristicNonZero|)))) 
(|HomogeneousAggregate&| A S) 
((|constructor|
  (NIL
   "A homogeneous aggregate is an aggregate of elements all of the same type. In the current system,{} all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \\spadtype{finiteAggregate} have a finite number of members. Of course,{} such a domain may have an infinite number of elements,{} like,{} for example \\spadtype{List}. Those domains with attribute \\spadtype{shallowlyMutable} allow an element to be modified or updated without changing its overall value."))
 (|member?|
  (((|Boolean|) |#2| $)
   "\\spad{member?(x,{} u)} tests if \\spad{x} is a member of \\spad{u}. For collections,{} \\spad{member?(x,{} u) = reduce(or,{} [x=y for y in u],{} false)}. However,{} \\spad{member?(x,{} u)} returns as soon as it finds a member."))
 (|min|
  ((|#2| $)
   "\\spad{min(u)} returns minimal element of \\spad{u}. Error if \\spad{u} is empty."))
 (|max|
  ((|#2| $)
   "\\spad{max(u)} returns maximal element of \\spad{u}. Error if \\spad{u} is empty.")
  ((|#2| (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{max(p,{} u)} returns maximal element of \\spad{u} with respect to total ordering predicate \\spad{p}. Error if \\spad{u} is empty."))
 (|members|
  (((|List| |#2|) $)
   "\\spad{members(u)} returns a list of the consecutive elements of \\spad{u}. For multisets \\spadfun{members} gives result with no repetition. See also \\spadfun{parts}."))
 (|parts|
  (((|List| |#2|) $)
   "\\spad{parts(u)} returns a list of the consecutive elements of \\spad{u}. For finite collections,{} \\spad{construct(parts(u)) = u}."))
 (|count|
  (((|NonNegativeInteger|) |#2| $)
   "\\spad{count(x,{} u)} returns the number of occurrences of \\spad{x} in \\spad{u}. For collections,{} \\spad{count(x,{} u) = reduce(+,{} [1 for y in u | x = y],{} 0)}.")
  (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{count(p,{} u)} returns the number of elements \\spad{x} in \\spad{u} such that \\spad{p(x)} is \\spad{true}. For collections,{} \\spad{count(p,{} u) = reduce(+,{} [1 for x in u | p(x)],{} 0)}."))
 (|every?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{every?(p,{} u)} tests if \\spad{p}(\\spad{x}) is \\spad{true} for all elements \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{every?(p,{} u) = reduce(and,{} map(p,{} u),{} true,{} false)}. However,{} \\spad{every?(p,{} u)} returns as soon as it finds an element for which \\spad{p} gives \\spad{false}."))
 (|any?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{any?(p,{} u)} tests if \\spad{p(x)} is \\spad{true} for any element \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{any?(p,{} u) = reduce(or,{} map(p,{} u),{} false,{} true)}. However,{} \\spad{any?(p,{} u)} returns as soon as it finds an element for which \\spad{p} gives \\spad{true}."))
 (|map!|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map!(f,{} u)} destructively replaces each element \\spad{x} of \\spad{u} by \\spad{f(x)}."))
 (|map|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map(f,{} u)} returns a copy of \\spad{u} with each element \\spad{x} replaced by \\spad{f}(\\spad{x}). For collections,{} \\spad{map(f,{} u) = [f(x) for x in u]}."))) 
((|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|BasicType|))
 (|HasCategory| |#1| '(|finiteAggregate|))
 (|HasCategory| |#1| '(|shallowlyMutable|))
 (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
 (|HasCategory| |#2| '(|SetCategory|))
 (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))) 
(|HomogeneousAggregate| S) 
((|constructor|
  (NIL
   "A homogeneous aggregate is an aggregate of elements all of the same type. In the current system,{} all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \\spadtype{finiteAggregate} have a finite number of members. Of course,{} such a domain may have an infinite number of elements,{} like,{} for example \\spadtype{List}. Those domains with attribute \\spadtype{shallowlyMutable} allow an element to be modified or updated without changing its overall value."))
 (|member?|
  (((|Boolean|) |#1| $)
   "\\spad{member?(x,{} u)} tests if \\spad{x} is a member of \\spad{u}. For collections,{} \\spad{member?(x,{} u) = reduce(or,{} [x=y for y in u],{} false)}. However,{} \\spad{member?(x,{} u)} returns as soon as it finds a member."))
 (|min|
  ((|#1| $)
   "\\spad{min(u)} returns minimal element of \\spad{u}. Error if \\spad{u} is empty."))
 (|max|
  ((|#1| $)
   "\\spad{max(u)} returns maximal element of \\spad{u}. Error if \\spad{u} is empty.")
  ((|#1| (|Mapping| (|Boolean|) |#1| |#1|) $)
   "\\spad{max(p,{} u)} returns maximal element of \\spad{u} with respect to total ordering predicate \\spad{p}. Error if \\spad{u} is empty."))
 (|members|
  (((|List| |#1|) $)
   "\\spad{members(u)} returns a list of the consecutive elements of \\spad{u}. For multisets \\spadfun{members} gives result with no repetition. See also \\spadfun{parts}."))
 (|parts|
  (((|List| |#1|) $)
   "\\spad{parts(u)} returns a list of the consecutive elements of \\spad{u}. For finite collections,{} \\spad{construct(parts(u)) = u}."))
 (|count|
  (((|NonNegativeInteger|) |#1| $)
   "\\spad{count(x,{} u)} returns the number of occurrences of \\spad{x} in \\spad{u}. For collections,{} \\spad{count(x,{} u) = reduce(+,{} [1 for y in u | x = y],{} 0)}.")
  (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{count(p,{} u)} returns the number of elements \\spad{x} in \\spad{u} such that \\spad{p(x)} is \\spad{true}. For collections,{} \\spad{count(p,{} u) = reduce(+,{} [1 for x in u | p(x)],{} 0)}."))
 (|every?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{every?(p,{} u)} tests if \\spad{p}(\\spad{x}) is \\spad{true} for all elements \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{every?(p,{} u) = reduce(and,{} map(p,{} u),{} true,{} false)}. However,{} \\spad{every?(p,{} u)} returns as soon as it finds an element for which \\spad{p} gives \\spad{false}."))
 (|any?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{any?(p,{} u)} tests if \\spad{p(x)} is \\spad{true} for any element \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{any?(p,{} u) = reduce(or,{} map(p,{} u),{} false,{} true)}. However,{} \\spad{any?(p,{} u)} returns as soon as it finds an element for which \\spad{p} gives \\spad{true}."))
 (|map!|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map!(f,{} u)} destructively replaces each element \\spad{x} of \\spad{u} by \\spad{f(x)}."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} u)} returns a copy of \\spad{u} with each element \\spad{x} replaced by \\spad{f}(\\spad{x}). For collections,{} \\spad{map(f,{} u) = [f(x) for x in u]}."))) 
NIL 
(|Homology|) 
((|constructor|
  (NIL
   "\\indented{2}{Intended to hold homology which is calculated using SmithNormalForm:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/} Date Created: June 2016 Basic Operations: Related packages: Related categories: Related Domains: FreeModule,{} FiniteSimplicialComplex Also See: AMS Classifications:"))
 (|dispGenerators| (((|OutputForm|) $) "more detailed output with generators"))
 (|homologyzc2|
  (($) "construct \\spad{Z+C2} homology,{} useful in validation code"))
 (|homologyc2|
  (($) "construct \\spad{C2} homology,{} useful in validation code"))
 (|homologyzz|
  (($) "construct \\spad{Z*Z} homology,{} useful in validation code"))
 (|homologyz|
  (($) "construct \\spad{Z} homology,{} useful in validation code"))
 (|homology0| (($) "construct empty homology,{} useful in validation code"))
 (|homology|
  (($ (|List| (|List| (|Integer|))) (|List| (|Integer|))
    (|List| (|List| (|Integer|))))
   "construct from lists"))
 (|homologyGroup|
  (($ (|Matrix| (|Integer|)) (|Matrix| (|Integer|)))
   "construct from differential over integers uses method described by Waldek Hebisch here: https://groups.google.com/forum/?hl=en\\#!topic/fricas-devel/mLOdQ-\\spad{fwbO0}"))) 
NIL 
(|HopfAlgebra| R |MxM|) 
((|constructor| (NIL "A Hopf algebra is a bialgebra with antipode."))
 (|antipode|
  (($ $) "\\spad{antipode(x)} computes the antipode of an element \\spad{x}."))) 
NIL 
(|HTMLFormat|) 
((|constructor|
  (NIL
   "\\spadtype{HtmlFormat} provides a coercion from \\spadtype{OutputForm} to html."))
 (|display|
  (((|Void|) (|String|))
   "\\spad{display(o)} prints the string returned by coerce."))
 (|exprex|
  (((|String|) (|OutputForm|))
   "\\spad{exprex(o)} coverts \\spadtype{OutputForm} to \\spadtype{String}"))
 (|coerceL|
  (((|String|) (|OutputForm|))
   "\\spad{coerceL(o)} changes \\spad{o} in the standard output format to html format and displays result as one long string."))
 (|coerceS|
  (((|String|) (|OutputForm|))
   "\\spad{coerceS(o)} changes \\spad{o} in the standard output format to html format and displays formatted result."))
 (|coerce|
  (((|String|) (|OutputForm|))
   "\\spad{coerce(o)} changes \\spad{o} in the standard output format to html format."))) 
NIL 
(|HyperbolicFunctionCategory&| S) 
((|constructor| (NIL "Category for the hyperbolic trigonometric functions."))
 (|tanh|
  (($ $) "\\spad{tanh(x)} returns the hyperbolic tangent of \\spad{x}."))
 (|sinh| (($ $) "\\spad{sinh(x)} returns the hyperbolic sine of \\spad{x}."))
 (|sech| (($ $) "\\spad{sech(x)} returns the hyperbolic secant of \\spad{x}."))
 (|csch|
  (($ $) "\\spad{csch(x)} returns the hyperbolic cosecant of \\spad{x}."))
 (|coth|
  (($ $) "\\spad{coth(x)} returns the hyperbolic cotangent of \\spad{x}."))
 (|cosh| (($ $) "\\spad{cosh(x)} returns the hyperbolic cosine of \\spad{x}."))) 
NIL 
(|HyperbolicFunctionCategory|) 
((|constructor| (NIL "Category for the hyperbolic trigonometric functions."))
 (|tanh|
  (($ $) "\\spad{tanh(x)} returns the hyperbolic tangent of \\spad{x}."))
 (|sinh| (($ $) "\\spad{sinh(x)} returns the hyperbolic sine of \\spad{x}."))
 (|sech| (($ $) "\\spad{sech(x)} returns the hyperbolic secant of \\spad{x}."))
 (|csch|
  (($ $) "\\spad{csch(x)} returns the hyperbolic cosecant of \\spad{x}."))
 (|coth|
  (($ $) "\\spad{coth(x)} returns the hyperbolic cotangent of \\spad{x}."))
 (|cosh| (($ $) "\\spad{cosh(x)} returns the hyperbolic cosine of \\spad{x}."))) 
NIL 
(|I16Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of 16-bit signed integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|I16Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of signed 16-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|I32Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of signed 32-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|I32Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of signed 32-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|I8Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of 8-bit signed integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|I8Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of signed 8-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|InnerAlgFactor| F UP |AlExt| |AlPol|) 
((|constructor|
  (NIL
   "Factorization of univariate polynomials with coefficients in an algebraic extension of a field over which we can factor UP\\spad{'s}."))
 (|factor|
  (((|Factored| |#4|) |#4| (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{factor(p,{} f)} returns a prime factorisation of \\spad{p}; \\spad{f} is a factorisation map for elements of UP."))) 
NIL 
(|IndexedOneDimensionalArray| S |mn|) 
((|constructor|
  (NIL
   "\\indented{1}{Author Micheal Monagan \\spad{Aug/87}} This is the basic one dimensional array data type."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|IndexedTwoDimensionalArray| R |mnRow| |mnCol|) 
((|constructor|
  (NIL
   "\\indented{1}{An IndexedTwoDimensionalArray is a 2-dimensional array where} the minimal row and column indices are parameters of the type. Rows and columns are returned as IndexedOneDimensionalArray\\spad{'s} with minimal indices matching those of the IndexedTwoDimensionalArray. The index of the 'first' row may be obtained by calling the function 'minRowIndex'. The index of the 'first' column may be obtained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa."))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|ChineseRemainderToolsForIntegralBases| K R UP) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Clifton Williamson} Date Created: 9 August 1993 Basic Operations: chineseRemainder,{} factorList Related Domains: PAdicWildFunctionFieldIntegralBasis(\\spad{K},{} \\spad{R},{} UP,{} \\spad{F}) Also See: WildFunctionFieldIntegralBasis,{} FunctionFieldIntegralBasis AMS Classifications: Keywords: function field,{} finite field,{} integral basis Examples: References: Description:"))
 (|chineseRemainder|
  (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|)))
    (|List| |#3|)
    (|List|
     (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
               (|:| |basisInv| (|Matrix| |#2|))))
    (|NonNegativeInteger|))
   "\\spad{chineseRemainder(lu,{} lr,{} n)} \\undocumented"))
 (|listConjugateBases|
  (((|List|
     (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
               (|:| |basisInv| (|Matrix| |#2|))))
    (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|)))
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{listConjugateBases(bas,{} q,{} n)} returns the list \\spad{[bas,{} bas^Frob,{} bas^(Frob^2),{} ...bas^(Frob^(n-1))]},{} where \\spad{Frob} raises the coefficients of all polynomials appearing in the basis \\spad{bas} to the \\spad{q}th power."))
 (|factorList|
  (((|List| (|SparseUnivariatePolynomial| |#1|)) |#1| (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{factorList(k,{} n,{} m,{} j)} \\undocumented"))) 
NIL 
(|IntegralBasisTools| R UP F) 
((|constructor|
  (NIL
   "This package contains functions used in the packages FunctionFieldIntegralBasis and NumberFieldIntegralBasis."))
 (|moduleSum|
  (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|)
              (|:| |basisInv| (|Matrix| |#1|)))
    (|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|)
              (|:| |basisInv| (|Matrix| |#1|)))
    (|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|)
              (|:| |basisInv| (|Matrix| |#1|))))
   "\\spad{moduleSum(m1,{} m2)} returns the sum of two modules in the framed algebra \\spad{F}. Each module \\spad{\\spad{mi}} is represented as follows: \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn} and \\spad{\\spad{mi}} is a record \\spad{[basis,{} basisDen,{} basisInv]}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then a basis \\spad{v1,{} ...,{} vn} for \\spad{\\spad{mi}} is given by \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|idealiserMatrix|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{idealiserMatrix(m1,{} m2)} returns the matrix representing the linear conditions on the Ring associated with an ideal defined by \\spad{m1} and \\spad{m2}."))
 (|idealiser|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) |#1|)
   "\\spad{idealiser(m1,{} m2,{} d)} computes the order of an ideal defined by \\spad{m1} and \\spad{m2} where \\spad{d} is the known part of the denominator")
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{idealiser(m1,{} m2)} computes the order of an ideal defined by \\spad{m1} and \\spad{m2}"))
 (|leastPower|
  (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{leastPower(p,{} n)} returns \\spad{e},{} where \\spad{e} is the smallest integer such that \\spad{p ^e >= n}"))
 (|divideIfCan!|
  ((|#1| (|Matrix| |#1|) (|Matrix| |#1|) |#1| (|Integer|))
   "\\spad{divideIfCan!(matrix,{} matrixOut,{} prime,{} n)} attempts to divide the entries of \\spad{matrix} by \\spad{prime} and store the result in \\spad{matrixOut}. If it is successful,{} 1 is returned and if not,{} \\spad{prime} is returned. Here both \\spad{matrix} and \\spad{matrixOut} are \\spad{n}-by-\\spad{n} upper triangular matrices."))
 (|matrixGcd|
  ((|#1| (|Matrix| |#1|) |#1| (|NonNegativeInteger|))
   "\\spad{matrixGcd(mat,{} sing,{} n)} is \\spad{gcd(sing,{} g)} where \\spad{g} is the \\spad{gcd} of the entries of the \\spad{n}-by-\\spad{n} upper-triangular matrix \\spad{mat}."))
 (|diagonalProduct|
  ((|#1| (|Matrix| |#1|))
   "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m}"))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(x)} returns a square-free factorisation of \\spad{x}"))) 
NIL 
(|IndexedBits| |mn|) 
((|constructor|
  (NIL
   "\\spadtype{IndexedBits} is a domain to compactly represent large quantities of Boolean data."))
 (|And|
  (($ $ $)
   "\\spad{And(n,{} m)} returns the bit-by-bit logical {\\em And} of \\spad{n} and \\spad{m}."))
 (|Or|
  (($ $ $)
   "\\spad{Or(n,{} m)} returns the bit-by-bit logical {\\em Or} of \\spad{n} and \\spad{m}."))
 (|Not|
  (($ $)
   "\\spad{Not(n)} returns the bit-by-bit logical {\\em Not} of \\spad{n}."))) 
((AND (|HasCategory| (|Boolean|) (LIST '|Evalable| '(|Boolean|)))
      (|HasCategory| (|Boolean|) '(|SetCategory|)))
 (|HasCategory| (|Boolean|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Boolean|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Boolean|) '(|BasicType|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Boolean|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Boolean|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Boolean|) '(|OrderedSet|)))) 
(|IntegralBasisPolynomialTools| K R UP L) 
((|constructor|
  (NIL
   "IntegralBasisPolynomialTools provides functions for \\indented{1}{mapping functions on the coefficients of univariate and bivariate} \\indented{1}{polynomials.}"))
 (|mapBivariate|
  (((|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#4|))
    (|Mapping| |#4| |#1|) |#3|)
   "\\spad{mapBivariate(f,{} p(x,{} y))} applies the function \\spad{f} to the coefficients of \\spad{p(x,{} y)}."))
 (|mapMatrixIfCan|
  (((|Union| (|Matrix| |#2|) "failed") (|Mapping| (|Union| |#1| "failed") |#4|)
    (|Matrix| (|SparseUnivariatePolynomial| |#4|)))
   "\\spad{mapMatrixIfCan(f,{} mat)} applies the function \\spad{f} to the coefficients of the entries of \\spad{mat} if possible,{} and returns \\spad{\"failed\"} otherwise."))
 (|mapUnivariateIfCan|
  (((|Union| |#2| "failed") (|Mapping| (|Union| |#1| "failed") |#4|)
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{mapUnivariateIfCan(f,{} p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)},{} if possible,{} and returns \\spad{\"failed\"} otherwise."))
 (|mapUnivariate|
  (((|SparseUnivariatePolynomial| |#4|) (|Mapping| |#4| |#1|) |#2|)
   "\\spad{mapUnivariate(f,{} p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)}.")
  ((|#2| (|Mapping| |#1| |#4|) (|SparseUnivariatePolynomial| |#4|))
   "\\spad{mapUnivariate(f,{} p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)}."))) 
NIL 
(|IndexCard|) 
((|constructor|
  (NIL
   "\\indented{1}{This domain implements a container of information} about the FriCAS library"))
 (|coerce|
  (($ (|String|))
   "\\spad{coerce(s)} converts \\spad{s} into an \\spad{IndexCard}. Warning: if \\spad{s} is not of the right format then an error will occur when using it."))
 (|fullDisplay|
  (((|Void|) $)
   "\\spad{fullDisplay(ic)} prints all of the information contained in \\spad{ic}."))
 (|display|
  (((|Void|) $)
   "\\spad{display(ic)} prints a summary of the information contained in \\spad{ic}."))
 (|elt|
  (((|String|) $ (|Symbol|))
   "\\spad{elt(ic,{} s)} selects a particular field from \\spad{ic}. Valid fields are \\spad{name,{} nargs,{} exposed,{} type,{} abbreviation,{} kind,{} origin,{} params,{} condition,{} doc}."))) 
NIL 
(|InnerCommonDenominator| R Q A B) 
((|constructor|
  (NIL
   "InnerCommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain."))
 (|splitDenominator|
  (((|Record| (|:| |num| |#3|) (|:| |den| |#1|)) |#4|)
   "\\spad{splitDenominator([q1,{} ...,{} qn])} returns \\spad{[[p1,{} ...,{} pn],{} d]} such that \\spad{\\spad{qi} = pi/d} and \\spad{d} is a common denominator for the \\spad{qi}\\spad{'s}."))
 (|clearDenominator|
  ((|#3| |#4|)
   "\\spad{clearDenominator([q1,{} ...,{} qn])} returns \\spad{[p1,{} ...,{} pn]} such that \\spad{\\spad{qi} = pi/d} where \\spad{d} is a common denominator for the \\spad{qi}\\spad{'s}."))
 (|commonDenominator|
  ((|#1| |#4|)
   "\\spad{commonDenominator([q1,{} ...,{} qn])} returns a common denominator \\spad{d} for \\spad{q1},{} ...,{} \\spad{qn}."))) 
NIL 
(|PolynomialIdeal| F |Expon| |VarSet| |DPoly|) 
((|constructor|
  (NIL
   "This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations,{} including intersection,{} sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is \\spad{true} if the generators are a Groebner basis. The algorithms used are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings."))
 (|relationsIdeal|
  (((|SuchThat| (|List| (|Polynomial| |#1|))
                (|List| (|Equation| (|Polynomial| |#1|))))
    (|List| |#4|))
   "\\spad{relationsIdeal(polyList)} returns the ideal of relations among the polynomials in \\spad{polyList}."))
 (|saturate|
  (($ $ |#4| (|List| |#3|))
   "\\spad{saturate(I,{} f,{} lvar)} is the saturation with respect to the prime principal ideal which is generated by \\spad{f} in the polynomial ring \\spad{F[lvar]}.")
  (($ $ |#4|)
   "\\spad{saturate(I,{} f)} is the saturation of the ideal \\spad{I} with respect to the multiplicative set generated by the polynomial \\spad{f}."))
 (|coerce|
  (($ (|List| |#4|))
   "\\spad{coerce(polyList)} converts the list of polynomials \\spad{polyList} to an ideal."))
 (|generators|
  (((|List| |#4|) $)
   "\\spad{generators(I)} returns a list of generators for the ideal \\spad{I}."))
 (|groebner?|
  (((|Boolean|) $)
   "\\spad{groebner?(I)} tests if the generators of the ideal \\spad{I} are a Groebner basis."))
 (|groebnerIdeal|
  (($ (|List| |#4|))
   "\\spad{groebnerIdeal(polyList)} constructs the ideal generated by the list of polynomials \\spad{polyList} which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation."))
 (|ideal|
  (($ (|List| |#4|))
   "\\spad{ideal(polyList)} constructs the ideal generated by the list of polynomials \\spad{polyList}."))
 (|leadingIdeal|
  (($ $)
   "\\spad{leadingIdeal(I)} is the ideal generated by the leading terms of the elements of the ideal \\spad{I}."))
 (|dimension|
  (((|Integer|) $)
   "\\spad{dimension(I)} gives the dimension of the ideal \\spad{I}. in the ring \\spad{F[lvar]},{} where lvar are the variables appearing in \\spad{I}")
  (((|Integer|) $ (|List| |#3|))
   "\\spad{dimension(I,{} lvar)} gives the dimension of the ideal \\spad{I},{} in the ring \\spad{F[lvar]}"))
 (|backOldPos|
  (($
    (|Record| (|:| |mval| (|Matrix| |#1|)) (|:| |invmval| (|Matrix| |#1|))
              (|:| |genIdeal| $)))
   "\\spad{backOldPos(genPos)} takes the result produced by \\spadfunFrom{generalPosition}{PolynomialIdeal} and performs the inverse transformation,{} returning the original ideal \\spad{backOldPos(generalPosition(I,{} listvar))} = \\spad{I}."))
 (|generalPosition|
  (((|Record| (|:| |mval| (|Matrix| |#1|)) (|:| |invmval| (|Matrix| |#1|))
              (|:| |genIdeal| $))
    $ (|List| |#3|))
   "\\spad{generalPosition(I,{} listvar)} perform a random linear transformation on the variables in listvar and returns the transformed ideal along with the change of basis matrix."))
 (|groebner|
  (($ $)
   "\\spad{groebner(I)} returns a set of generators of \\spad{I} that are a Groebner basis for \\spad{I}."))
 (|quotient|
  (($ $ |#4|)
   "\\spad{quotient(I,{} f)} computes the quotient of the ideal \\spad{I} by the principal ideal generated by the polynomial \\spad{f},{} \\spad{(I: (f))}.")
  (($ $ $)
   "\\spad{quotient(I,{} J)} computes the quotient of the ideals \\spad{I} and \\spad{J},{} \\spad{(I: J)}."))
 (|intersect|
  (($ (|List| $))
   "\\spad{intersect(LI)} computes the intersection of the list of ideals \\spad{LI}.")
  (($ $ $)
   "\\spad{intersect(I,{} J)} computes the intersection of the ideals \\spad{I} and \\spad{J}."))
 (|zeroDim?|
  (((|Boolean|) $)
   "\\spad{zeroDim?(I)} tests if the ideal \\spad{I} is zero dimensional,{} \\spadignore{i.e.} all its associated primes are maximal,{} in the ring \\spad{F[lvar]},{} where lvar are the variables appearing in \\spad{I}")
  (((|Boolean|) $ (|List| |#3|))
   "\\spad{zeroDim?(I,{} lvar)} tests if the ideal \\spad{I} is zero dimensional,{} \\spadignore{i.e.} all its associated primes are maximal,{} in the ring \\spad{F[lvar]}"))
 (|inRadical?|
  (((|Boolean|) |#4| $)
   "\\spad{inRadical?(f,{} I)} tests if some power of the polynomial \\spad{f} belongs to the ideal \\spad{I}."))
 (|in?|
  (((|Boolean|) $ $)
   "\\spad{in?(I,{} J)} tests if the ideal \\spad{I} is contained in the ideal \\spad{J}."))
 (|element?|
  (((|Boolean|) |#4| $)
   "\\spad{element?(f,{} I)} tests whether the polynomial \\spad{f} belongs to the ideal \\spad{I}."))
 (|zero?|
  (((|Boolean|) $)
   "\\spad{zero?(I)} tests whether the ideal \\spad{I} is the zero ideal"))
 (|one?|
  (((|Boolean|) $)
   "\\spad{one?(I)} tests whether the ideal \\spad{I} is the unit ideal,{} \\spadignore{i.e.} contains 1."))
 (+
  (($ $ $)
   "\\spad{I+J} computes the ideal generated by the union of \\spad{I} and \\spad{J}."))
 (^
  (($ $ (|NonNegativeInteger|))
   "\\spad{I^n} computes the \\spad{n}th power of the ideal \\spad{I}."))
 (*
  (($ $ $)
   "\\spad{I*J} computes the product of the ideal \\spad{I} and \\spad{J}."))) 
((|HasCategory| |#3| (LIST '|ConvertibleTo| '(|Symbol|)))) 
(|IdealDecompositionPackage| |vl|) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides functions for the primary decomposition of} polynomial ideals over the rational numbers. The ideals are members of the \\spadtype{PolynomialIdeal} domain,{} and the polynomial generators are required to be from the \\spadtype{DistributedMultivariatePolynomial} domain."))
 (|contract|
  (((|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|))))
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|))))
    (|List| (|OrderedVariableList| |#1|)))
   "\\spad{contract(I,{} lvar)} contracts the ideal \\spad{I} to the polynomial ring \\spad{F[lvar]}."))
 (|primaryDecomp|
  (((|List|
     (|PolynomialIdeal| (|Fraction| (|Integer|))
                        (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                        (|OrderedVariableList| |#1|)
                        (|DistributedMultivariatePolynomial| |#1|
                                                             (|Fraction|
                                                              (|Integer|)))))
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|)))))
   "\\spad{primaryDecomp(I)} returns a list of primary ideals such that their intersection is the ideal \\spad{I}."))
 (|radical|
  (((|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|))))
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|)))))
   "\\spad{radical(I)} returns the radical of the ideal \\spad{I}."))
 (|prime?|
  (((|Boolean|)
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|)))))
   "\\spad{prime?(I)} tests if the ideal \\spad{I} is prime."))
 (|zeroDimPrimary?|
  (((|Boolean|)
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|)))))
   "\\spad{zeroDimPrimary?(I)} tests if the ideal \\spad{I} is 0-dimensional primary."))
 (|zeroDimPrime?|
  (((|Boolean|)
    (|PolynomialIdeal| (|Fraction| (|Integer|))
                       (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                       (|OrderedVariableList| |#1|)
                       (|DistributedMultivariatePolynomial| |#1|
                                                            (|Fraction|
                                                             (|Integer|)))))
   "\\spad{zeroDimPrime?(I)} tests if the ideal \\spad{I} is a 0-dimensional prime."))) 
NIL 
(|IndexedDirectProductCategory| A S) 
((|constructor|
  (NIL
   "This category represents the direct product of some set with respect to an ordered indexing set. The ordered set \\spad{S} is considered as the ``basis elements\\spad{''} and the elements from \\spad{A} as ``coefficients\\spad{''}."))
 (|numberOfMonomials|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfMonomials(x)} returns the number of monomials of \\spad{x}."))
 (|listOfTerms|
  (((|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))) $)
   "\\spad{listOfTerms(x)} returns a list \\spad{lt} of terms with type \\spad{Record(k: S,{} c: R)} such that \\spad{x} equals \\spad{construct(lt)}. If \\spad{S has Comparable} than \\spad{x} equals \\spad{constructOrdered(lt)}."))) 
NIL 
(|IndexedDirectProductObject| A S) 
((|constructor|
  (NIL
   "Indexed direct products of objects over a set \\spad{A} of generators indexed by an ordered set \\spad{S}. It currently provides the ground for,{} \\spadignore{e.g.} \\spadtype{FreeModule} which lies at the basis of polynomials of all sorts. All items have finite support. If A is a monoid,{} then only non-zero terms are stored. If A has additive structure,{} it is propagated coordinatewise to the product. Similarly,{} comparisons are propagated using lexicographic ordering."))) 
((|HasCategory| |#1| '(|AbelianGroup|))
 (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
      (|HasCategory| |#2| '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#2| '(|Comparable|))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| |#2| '(|Comparable|))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| |#2| '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
          (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| |#2| '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
          (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoid|))
          (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
          (|HasCategory| |#2| '(|OrderedSet|))))) 
(|InnerEigenPackage| F) 
((|constructor|
  (NIL
   "This is a package for the exact computation of eigenvalues and eigenvectors. This package works for matrices with coefficients from a field over which we can factor polynomials. Eigenvalues in base field are always explicitly computed while the other are expressed in terms of their minimal polynomial."))
 (|eigenvectors|
  (((|List|
     (|Record|
      (|:| |eigval| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
      (|:| |eigmult| (|NonNegativeInteger|))
      (|:| |eigvec| (|List| (|Vector| (|SparseUnivariatePolynomial| |#1|))))))
    (|Matrix| |#1|))
   "\\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \\spad{m}. The eigenvalues in base field and corresponding eigenvectors are explicitly computed,{} while the non rational ones are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a \"generic\" root of such a polynomial.")
  (((|List|
     (|Record|
      (|:| |eigval| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
      (|:| |eigmult| (|NonNegativeInteger|))
      (|:| |eigvec| (|List| (|Vector| (|SparseUnivariatePolynomial| |#1|))))))
    (|Matrix| |#1|)
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#1|))
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{eigenvectors(m,{} fac)} returns the eigenvalues and eigenvectors for the matrix \\spad{m}. The eigenvalues in base field and corresponding eigenvectors are explicitly computed,{} while the other eigenvalues are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a \"generic\" root of such a polynomial. fac is a factorizer for polynomials over \\spad{F}."))
 (|generalizedEigenvectors|
  (((|List|
     (|Record|
      (|:| |eigval| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
      (|:| |geneigvec|
           (|List| (|Vector| (|SparseUnivariatePolynomial| |#1|))))))
    (|Matrix| |#1|))
   "\\spad{generalizedEigenvectors(m)} returns the generalized eigenvectors of the matrix \\spad{m}.")
  (((|List|
     (|Record|
      (|:| |eigval| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
      (|:| |geneigvec|
           (|List| (|Vector| (|SparseUnivariatePolynomial| |#1|))))))
    (|Matrix| |#1|)
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#1|))
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{generalizedEigenvectors(m,{} fac)} returns the generalized eigenvectors of the matrix \\spad{m}. fac is a factorizer for polynomials over \\spad{F}."))
 (|generalizedEigenvector|
  (((|List| (|Vector| (|SparseUnivariatePolynomial| |#1|)))
    (|Record| (|:| |eigval| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
              (|:| |eigmult| (|NonNegativeInteger|))
              (|:| |eigvec|
                   (|List| (|Vector| (|SparseUnivariatePolynomial| |#1|)))))
    (|Matrix| |#1|))
   "\\spad{generalizedEigenvector(eigen,{} m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \\spad{eigen},{} as returned by the function eigenvectors.")
  (((|List| (|Vector| (|SparseUnivariatePolynomial| |#1|)))
    (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)) (|Matrix| |#1|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{generalizedEigenvector(alpha,{} m,{} k,{} g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \\spad{alpha}. The integers \\spad{k} and \\spad{g} are respectively the algebraic and the geometric multiplicity of the eigenvalue \\spad{alpha}."))
 (|eigenvector|
  (((|List| (|Vector| (|SparseUnivariatePolynomial| |#1|)))
    (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)) (|Matrix| |#1|))
   "\\spad{eigenvector(eigval,{} m)} returns the eigenvectors belonging to the eigenvalue \\spad{eigval} for the matrix \\spad{m}."))
 (|eigenvalues|
  (((|List| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|)))
    (|Matrix| |#1|))
   "\\spad{eigenvalues(m)} returns the eigenvalues of the matrix \\spad{m}.")
  (((|List| (|Union| |#1| (|SparseUnivariatePolynomial| |#1|))) (|Matrix| |#1|)
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#1|))
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{eigenvalues(m,{} fac)} returns the eigenvalues of the matrix \\spad{m}. Eigenvalues in base field are given explicitly,{} other are represented by mininal polynomial. fac is a factorizer for polynomials over \\spad{F}."))
 (|characteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) (|Matrix| |#1|))
   "\\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \\spad{m}"))) 
((|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))) 
(|InnerEvalable&| S A B) 
((|constructor|
  (NIL
   "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\\spad{''} substitutions. The difference between this and \\spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation."))
 (|eval|
  (($ $ (|List| |#2|) (|List| |#3|))
   "\\spad{eval(f,{} [x1,{} ...,{} xn],{} [v1,{} ...,{} vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f}.")
  (($ $ |#2| |#3|)
   "\\spad{eval(f,{} x,{} v)} replaces \\spad{x} by \\spad{v} in \\spad{f}."))) 
NIL 
(|InnerEvalable| A B) 
((|constructor|
  (NIL
   "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\\spad{''} substitutions. The difference between this and \\spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation."))
 (|eval|
  (($ $ (|List| |#1|) (|List| |#2|))
   "\\spad{eval(f,{} [x1,{} ...,{} xn],{} [v1,{} ...,{} vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f}.")
  (($ $ |#1| |#2|)
   "\\spad{eval(f,{} x,{} v)} replaces \\spad{x} by \\spad{v} in \\spad{f}."))) 
NIL 
(|IndexedFlexibleArray| S |mn|) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Michael Monagan \\spad{July/87},{} modified \\spad{SMW} \\spad{June/91}} A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations \\indented{2}{\\spad{concat!(a,{} x)} meaning append item \\spad{x} at the end of the array \\spad{a}} \\indented{2}{\\spad{delete!(a,{} n)} meaning delete the last item from the array \\spad{a}} Flexible arrays support the other operations inherited from \\spadtype{ExtensibleLinearAggregate}. However,{} these are not efficient. Flexible arrays combine the \\spad{O(1)} access time property of arrays with growing and shrinking at the end in \\spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50\\% larger) array. Conversely,{} when the array becomes less than 1/2 full,{} it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps,{} stacks and sets."))
 (|removeRepeats!|
  (($ $)
   "\\spad{removeRepeats!(u)} destructively replaces runs of consecutive equal elements of \\spad{u} by single elements."))
 (|shrinkable|
  (((|Boolean|) (|Boolean|))
   "\\spad{shrinkable(b)} sets the shrinkable attribute of flexible arrays to \\spad{b} and returns the previous value"))
 (|physicalLength!|
  (($ $ (|Integer|))
   "\\spad{physicalLength!(x,{} n)} changes the physical length of \\spad{x} to be \\spad{n} and returns the new array."))
 (|physicalLength|
  (((|NonNegativeInteger|) $)
   "\\spad{physicalLength(x)} returns the number of elements \\spad{x} can accommodate before growing"))
 (|flexibleArray|
  (($ (|List| |#1|))
   "\\spad{flexibleArray(l)} creates a flexible array from the list of elements \\spad{l}"))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|InnerFiniteField| |p| |n|) 
((|constructor|
  (NIL
   "InnerFiniteField(\\spad{p},{} \\spad{n}) implements finite fields with \\spad{p^n} elements where \\spad{p} is assumed prime but does not check. For a version which checks that \\spad{p} is prime,{} see \\spadtype{FiniteField}."))) 
((|HasCategory| (|InnerPrimeField| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|InnerPrimeField| |#1|) '(|Finite|))
 (OR (|HasCategory| (|InnerPrimeField| |#1|) '(|CharacteristicNonZero|))
     (|HasCategory| (|InnerPrimeField| |#1|) '(|Finite|)))
 (|HasCategory| (|InnerPrimeField| |#1|) '(|Field|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|InnerPrimeField| |#1|) '(|Finite|)))) 
(|InnerIndexedTwoDimensionalArray| R |mnRow| |mnCol| |Row| |Col|) 
((|constructor|
  (NIL
   "\\indented{1}{This is an internal type which provides an implementation of} 2-dimensional arrays as PrimitiveArray\\spad{'s} of PrimitiveArray\\spad{'s}."))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|IndexedJetBundle| |x| |u| |p| |n| |m|) 
((|constructor|
  (NIL
   "\\spadtype{JetBundle} provides the standard implementation for a jet bundle with a given number of dependent and independent variables."))) 
NIL 
(|IndexedList| S |mn|) 
((|constructor|
  (NIL
   "\\spadtype{IndexedList} is an implementation of \\spadtype{ListAggregate},{} the beginning index of the list is the second parameter to the constructor (\\spad{mn}). That is,{} if \\spad{l} is a list,{} then \\spad{elt(l,{} mn)} is the first value."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))) 
(|ILogic|) 
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toStringUnwrapped|
  (((|String|) $)
   "similar to 'toString' but does not put outer compound terms in brackets"))
 (|toString|
  (((|String|) $)
   "creates a string representation of this term and its sub-terms"))
 (|parseILTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseIL. It would rarely be called externally but it is here to allow it to call parseIL that is to allow circular calls"))
 (|parseIL2|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "Constructs intuitionistic logic terms from a string notation assumes format like this: <term2> : \\spad{:=} var | \"(\"<term>\")\" <term> : \\spad{:=} var | <term>/\\spad{\\<}term> | <term>\\spad{\\/}<term> | \\indented{11}{<term>-><term> | \"(\"<term>\")\"}"))
 (|parseIL|
  (($ (|String|))
   "Constructs intuitionistic logic terms from a string notation assumes format like this: <term> : \\spad{:=} var | <term>/\\spad{\\<}term> | <term>\\spad{\\/}<term> | \\indented{11}{<term>-><term> | \"(\"<term>\")\"}"))
 (|value|
  (((|Symbol|) $)
   "returns: \\indented{2}{\"T\"::Symbol = \\spad{T}} \\indented{2}{\"F\"::Symbol = \\spad{_|_}} \\indented{2}{\"E\"::Symbol = error} \\indented{2}{\"P\"::Symbol = proposition} \\indented{2}{\"C\"::Symbol = compound} Constructs lambda term and bind any variables with the name provided"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|opType|
  (((|Symbol|) $)
   "if this is a compound op then opType returns the type of that op: \"IMPLY\"::Symbol =implies \"AND\"::Symbol=/\\ \"OR\"::Symbol=\\spad{\\/} \"NOT\"::Symbol=~ \"OTHER\"::Symbol=not compound op"))
 (~
  (($ $)
   "\\spad{~(x)} returns the logical complement of \\spad{x}. TODO not sure if complement should be included here? intuitionistic logic can have complement but has different axioms to complement in Boolean algebra. Equivalent capability can be provided by implication."))
 (=
  (((|Boolean|) $ $)
   "returns \\spad{true} (boolean \\spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic"))
 (|deductions|
  (((|List| $) (|List| $))
   "assumes \\spad{ln} contains a list of factors which must be \\spad{true} for the whole to be \\spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \\spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|factor|
  (((|List| $) $)
   "splits \\spad{n} into a list of factors which must be \\spad{true} for the whole to be \\spad{true}. This assumes that the top level is already a set of factors separated by \\spad{/\\} otherwise the result will just be a list with one entry: \\spad{'n'}. This is used when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|redux|
  (($ $)
   "attempt to simplify theory apply recursively to subnodes normally this should not be necessary since logic values are interpreted when constructed"))
 (|implies|
  (($ $ $)
   "\\spad{implies(a,{} b)} returns the logical implication of ILogic a and \\spad{b}. a is premise,{} \\spad{b} is conclusion,{} result is \\spad{false} (contradiction) if premise=true and conclusion=false does not mean there is a causal connection"))
 (|proposition| (($ (|String|)) "Constructs a proposition"))
 (|logicF| (($) "\\spad{false} (contradiction) is a logical constant."))
 (|logicT| (($) "\\spad{true} is a logical constant."))) 
NIL 
(|InnerMatrixLinearAlgebraFunctions| R |Row| |Col| M) 
((|constructor|
  (NIL
   "\\spadtype{InnerMatrixLinearAlgebraFunctions} is an internal package which provides standard linear algebra functions on domains in \\spad{MatrixCategory}"))
 (|row_operation_modular|
  (((|Void|) |#4| (|Integer|) (|Integer|) (|Integer|) (|Integer|) |#1|
    (|Integer|))
   "\\spad{row_operation_modular should} be local,{} but conditional"))
 (|row_operation_base|
  (((|Void|) |#4| (|Integer|) (|Integer|) (|Integer|) (|Integer|) |#1|)
   "\\spad{row_operation_base should} be local,{} but conditional"))
 (|inverse|
  (((|Union| |#4| "failed") |#4|)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m}. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square."))
 (|generalizedInverse|
  ((|#4| |#4|)
   "\\spad{generalizedInverse(m)} returns the generalized (Moore--Penrose) inverse of the matrix \\spad{m},{} \\spadignore{i.e.} the matrix \\spad{h} such that m*h*m=h,{} h*m*h=m,{} \\spad{m*h} and \\spad{h*m} are both symmetric matrices."))
 (|determinant|
  ((|#1| |#4|)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}. an error message is returned if the matrix is not square."))
 (|nullSpace|
  (((|List| |#3|) |#4|)
   "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) |#4|)
   "\\spad{nullity(m)} returns the mullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) |#4|)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|rowEchelon|
  ((|#4| |#4|)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))) 
((|HasCategory| |#1| '(|Field|)) (|HasCategory| |#3| '(|shallowlyMutable|))) 
(|InnerMatrixQuotientFieldFunctions| R |Row| |Col| M QF |Row2| |Col2| M2) 
((|constructor|
  (NIL
   "\\spadtype{InnerMatrixQuotientFieldFunctions} provides functions on matrices over an integral domain which involve the quotient field of that integral domain. The functions rowEchelon and inverse return matrices with entries in the quotient field."))
 (|nullSpace|
  (((|List| |#3|) |#4|)
   "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m}."))
 (|inverse|
  (((|Union| |#8| "failed") |#4|)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m}. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square. Note: the result will have entries in the quotient field."))
 (|rowEchelon|
  ((|#8| |#4|)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}. the result will have entries in the quotient field."))) 
((|HasCategory| |#7| '(|shallowlyMutable|))) 
(|IndexedMatrix| R |mnRow| |mnCol|) 
((|constructor|
  (NIL
   "An \\spad{IndexedMatrix} is a matrix where the minimal row and column indices are parameters of the type. The domains Row and Col are both IndexedVectors. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a 'Row' is the same as the index of the first column in a matrix and vice versa."))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRng|))
 (AND (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|InnerModularHermitePade|) 
((|constructor|
  (NIL
   "This package solves Hermite-Pade interpolation problem \\indented{1}{over ring of integer polynomials.\\space{2}We use reduction modulo primes} \\indented{1}{and modular reconstruction to reduce problem to polynomials modulo} \\indented{1}{\\$\\spad{Z_p}\\$.\\space{2}Then we use evaluation and Lagrange interpolation to} \\indented{1}{reduce problem to solving over \\$\\spad{Z_p}\\$.}"))) 
NIL 
(|InnerNormalBasisFieldFunctions| GF) 
((|constructor|
  (NIL
   "InnerNormalBasisFieldFunctions(\\spad{GF}) (unexposed): This package has functions used by every normal basis finite field extension domain."))
 (|minimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) (|Vector| |#1|))
   "\\spad{minimalPolynomial(x)} \\undocumented{} See \\spadfunFrom{minimalPolynomial}{FiniteAlgebraicExtensionField}"))
 (|normalElement|
  (((|Vector| |#1|) (|PositiveInteger|))
   "\\spad{normalElement(n)} \\undocumented{} See \\spadfunFrom{normalElement}{FiniteAlgebraicExtensionField}"))
 (|basis|
  (((|Vector| (|Vector| |#1|)) (|PositiveInteger|))
   "\\spad{basis(n)} \\undocumented{} See \\spadfunFrom{basis}{FiniteAlgebraicExtensionField}"))
 (|normal?|
  (((|Boolean|) (|Vector| |#1|))
   "\\spad{normal?(x)} \\undocumented{} See \\spadfunFrom{normal?}{FiniteAlgebraicExtensionField}"))
 (|lookup|
  (((|PositiveInteger|) (|Vector| |#1|))
   "\\spad{lookup(x)} \\undocumented{} See \\spadfunFrom{lookup}{Finite}"))
 (|inv|
  (((|Vector| |#1|) (|Vector| |#1|))
   "\\spad{inv x} \\undocumented{} See \\spadfunFrom{inv}{DivisionRing}"))
 (|trace|
  (((|Vector| |#1|) (|Vector| |#1|) (|PositiveInteger|))
   "\\spad{trace(x,{} n)} \\undocumented{} See \\spadfunFrom{trace}{FiniteAlgebraicExtensionField}"))
 (|norm|
  (((|Vector| |#1|) (|Vector| |#1|) (|PositiveInteger|))
   "\\spad{norm(x,{} n)} \\undocumented{} See \\spadfunFrom{norm}{FiniteAlgebraicExtensionField}"))
 (/
  (((|Vector| |#1|) (|Vector| |#1|) (|Vector| |#1|))
   "\\spad{x/y} \\undocumented{} See \\spadfunFrom{/}{Field}"))
 (*
  (((|Vector| |#1|) (|Vector| |#1|) (|Vector| |#1|))
   "\\spad{x*y} \\undocumented{} See \\spadfunFrom{*}{SemiGroup}"))
 (^
  (((|Vector| |#1|) (|Vector| |#1|) (|Integer|))
   "\\spad{x^n} \\undocumented{} See \\spadfunFrom{^}{DivisionRing}"))
 (|qPot|
  (((|Vector| |#1|) (|Vector| |#1|) (|Integer|))
   "\\spad{qPot(v,{} e)} computes \\spad{v^(q^e)},{} interpreting \\spad{v} as an element of normal basis field,{} \\spad{q} the size of the ground field. This is done by a cyclic \\spad{e}-shift of the vector \\spad{v}."))
 (|expPot|
  (((|Vector| |#1|) (|Vector| |#1|) (|SingleInteger|) (|SingleInteger|))
   "\\spad{expPot(v,{} e,{} d)} returns the sum from \\spad{i = 0} to \\spad{e - 1} of \\spad{v^(q^i*d)},{} interpreting \\spad{v} as an element of a normal basis field and where \\spad{q} is the size of the ground field. Note: for a description of the algorithm,{} see \\spad{T}.Itoh and \\spad{S}.Tsujii,{} \"A fast algorithm for computing multiplicative inverses in \\spad{GF}(2^m) using normal bases\",{} Information and Computation 78,{} \\spad{pp}.171-177,{} 1988."))
 (|repSq|
  (((|Vector| |#1|) (|Vector| |#1|) (|NonNegativeInteger|))
   "\\spad{repSq(v,{} e)} computes \\spad{v^e} by repeated squaring,{} interpreting \\spad{v} as an element of a normal basis field."))
 (|dAndcExp|
  (((|Vector| |#1|) (|Vector| |#1|) (|NonNegativeInteger|) (|SingleInteger|))
   "\\spad{dAndcExp(v,{} n,{} k)} computes \\spad{v^e} interpreting \\spad{v} as an element of normal basis field. A divide and conquer algorithm similar to the one from \\spad{D}.\\spad{R}.Stinson,{} \"Some observations on parallel Algorithms for fast exponentiation in \\spad{GF}(2^n)\",{} Siam \\spad{J}. Computation,{} Vol.19,{} No.4,{} \\spad{pp}.711-717,{} August 1990 is used. Argument \\spad{k} is a parameter of this algorithm."))
 (|xn|
  (((|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|))
   "\\spad{xn(n)} returns the polynomial \\spad{x^n-1}."))
 (|pol|
  (((|SparseUnivariatePolynomial| |#1|) (|Vector| |#1|))
   "\\spad{pol(v)} turns the vector \\spad{[v0,{} ...,{} vn]} into the polynomial \\spad{v0+v1*x+ ... + vn*x^n}."))
 (|index|
  (((|Vector| |#1|) (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{index(n,{} m)} is a index function for vectors of length \\spad{n} over the ground field."))
 (|random|
  (((|Vector| |#1|) (|PositiveInteger|))
   "\\spad{random(n)} creates a vector over the ground field with random entries."))
 (|setFieldInfo|
  (((|Void|)
    (|Vector|
     (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))
    |#1|)
   "\\spad{setFieldInfo(m,{} p)} initializes the field arithmetic,{} where \\spad{m} is the multiplication table and \\spad{p} is the respective normal element of the ground field \\spad{GF}."))) 
NIL 
(|IncidenceAlgebra| R S) 
((|constructor| (NIL "A domain for incidence matrices of finite posets."))
 (^
  (($ $ (|NonNegativeInteger|))
   "\\spad{x ^ n} computes a non-negative integral power of the matrix \\spad{x}. Error: if the matrix is not square."))
 (+
  (($ $ $)
   "\\spad{x + y} is the sum of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible."))
 (*
  (($ $ |#1|)
   "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ |#1| $)
   "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ $ $)
   "\\spad{x * y} is the product of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible.")
  (($ (|Permutation| (|Integer|)) $)
   "\\spad{\\pi * A} permutes the indices and the matrix according to the permutation \\spad{\\pi}."))
 (|apply|
  ((|#1| $ |#2| |#2|)
   "\\spad{A(s,{} t)} returns \\$A_{\\spad{i},{} \\spad{j}}\\$,{} where \\$\\spad{i}\\$,{} \\$\\spad{j}\\$ are the positions of \\$\\spad{s}\\$ and \\$\\spad{t}\\$ in the index list.")
  ((|#1| $ (|Integer|) (|Integer|))
   "\\spad{A(i,{} j)} returns \\$A_{\\spad{i},{} \\spad{j}}\\$"))
 (|matrix|
  (((|Matrix| |#1|) $)
   "\\spad{matrix(A)} returns the underlying matrix of the incidence matrix A"))
 (|indices|
  (((|OneDimensionalArray| |#2|) $)
   "\\spad{indices(A)} returns the indices of the incidence matrix A"))
 (|incidenceAlgebra|
  (($ (|Matrix| |#1|) (|OneDimensionalArray| |#2|))
   "\\spad{incidenceAlgebra(A,{} ss)} constructs an adjacency matrix with with indices \\spad{ss} and Matrix A")
  (($ (|Matrix| |#1|) (|List| |#2|))
   "\\spad{incidenceAlgebra(A,{} ss)} constructs an adjacency matrix with with indices \\spad{ss} and Matrix A"))) 
NIL 
(|IncrementingMaps| R) 
((|constructor|
  (NIL "This package provides operations to create incrementing functions."))
 (|incrementBy|
  (((|Mapping| |#1| |#1|) |#1|)
   "\\spad{incrementBy(n)} produces a function which adds \\spad{n} to whatever argument it is given. For example,{} if {\\spad{f} \\spad{:=} increment(\\spad{n})} then \\spad{f x} is \\spad{x+n}."))
 (|increment|
  (((|Mapping| |#1| |#1|))
   "\\spad{increment()} produces a function which adds \\spad{1} to whatever argument it is given. For example,{} if {\\spad{f} \\spad{:=} increment()} then \\spad{f x} is \\spad{x+1}."))) 
NIL 
(|IndexedExponents| |Varset|) 
((|constructor|
  (NIL
   "\\indented{2}{IndexedExponents of an ordered set of variables gives a representation} for the degree of polynomials in commuting variables. It gives an ordered pairing of non negative integer exponents with variables"))) 
((|HasCategory| (|NonNegativeInteger|) '(|AbelianGroup|))
 (|HasCategory| |#1| '(|Comparable|))) 
(|InnerNumericEigenPackage| K F |Par|) 
((|constructor|
  (NIL
   "This package is the inner package to be used by NumericRealEigenPackage and NumericComplexEigenPackage for the computation of numeric eigenvalues and eigenvectors."))
 (|innerEigenvectors|
  (((|List|
     (|Record| (|:| |outval| |#2|) (|:| |outmult| (|Integer|))
               (|:| |outvect| (|List| (|Matrix| |#2|)))))
    (|Matrix| |#1|) |#3|
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#1|))
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{innerEigenvectors(m,{} eps,{} factor)} computes explicitly the eigenvalues and the correspondent eigenvectors of the matrix \\spad{m}. The parameter \\spad{eps} determines the type of the output,{} factor is the univariate factorizer used to reduce the characteristic polynomial into irreducible factors."))
 (|solve1|
  (((|List| |#2|) (|SparseUnivariatePolynomial| |#1|) |#3|)
   "\\spad{solve1(pol,{} eps)} finds the roots of the univariate polynomial polynomial \\spad{pol} to precision eps. If \\spad{K} is \\spad{Fraction Integer} then only the real roots are returned,{} if \\spad{K} is \\spad{Complex Fraction Integer} then all roots are found."))
 (|charpol|
  (((|SparseUnivariatePolynomial| |#1|) (|Matrix| |#1|))
   "\\spad{charpol(m)} computes the characteristic polynomial of a matrix \\spad{m} with entries in \\spad{K}."))) 
NIL 
(|InfiniteCyclicGroup| |g|) 
((|constructor| (NIL "Infinite cyclic groups."))
 (|exponent|
  (((|Integer|) $)
   "\\spad{exponent(g^k)} returns the representative integer \\$\\spad{k}\\$."))
 (|generator| (($) "\\spad{generator()} returns the generator."))) 
NIL 
(|Infinity|) 
((|constructor|
  (NIL
   "Default infinity signatures for the interpreter; Date Created: 4 Oct 1989"))
 (|minusInfinity|
  (((|OrderedCompletion| (|Integer|)))
   "\\spad{minusInfinity()} returns minusInfinity."))
 (|plusInfinity|
  (((|OrderedCompletion| (|Integer|)))
   "\\spad{plusInfinity()} returns plusInfinity."))
 (|infinity|
  (((|OnePointCompletion| (|Integer|)))
   "\\spad{infinity()} returns infinity."))) 
NIL 
(|InputForm|) 
((|constructor|
  (NIL
   "Domain of parsed forms which can be passed to the interpreter. This is also the interface between algebra code and facilities in the interpreter."))
 (|compile|
  (((|Symbol|) (|Symbol|) (|List| $))
   "\\spad{compile(f,{} [t1,{} ...,{} tn])} forces the interpreter to compile the function \\spad{f} with signature \\spad{(t1,{} ...,{} tn) -> ?}. returns the symbol \\spad{f} if successful. Error: if \\spad{f} was not defined beforehand in the interpreter,{} or if the \\spad{ti}\\spad{'s} are not valid types,{} or if the compiler fails."))
 (|declare|
  (((|Symbol|) (|List| $))
   "\\spad{declare(t)} returns a name \\spad{f} such that \\spad{f} has been declared to the interpreter to be of type \\spad{t},{} but has not been assigned a value yet. Note: \\spad{t} should be created as \\spad{devaluate(T)\\$Lisp} where \\spad{T} is the actual type of \\spad{f} (this hack is required for the case where \\spad{T} is a mapping type)."))
 (|parse|
  (($ (|String|))
   "\\spad{parse(s)} is the inverse of unparse. It parses a string to InputForm"))
 (|unparse|
  (((|String|) $)
   "\\spad{unparse(f)} returns a string \\spad{s} such that the parser would transform \\spad{s} to \\spad{f}. Error: if \\spad{f} is not the parsed form of a string."))
 (|flatten|
  (($ $)
   "\\spad{flatten(s)} returns an input form corresponding to \\spad{s} with all the nested operations flattened to triples using new local variables. If \\spad{s} is a piece of code,{} this speeds up the compilation tremendously later on."))
 ((|One|) (($) "\\spad{1} returns the input form corresponding to 1."))
 ((|Zero|) (($) "\\spad{0} returns the input form corresponding to 0."))
 (^
  (($ $ (|Integer|))
   "\\spad{a ^ b} returns the input form corresponding to \\spad{a ^ b}.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{a ^ b} returns the input form corresponding to \\spad{a ^ b}."))
 (/
  (($ $ $)
   "\\spad{a / b} returns the input form corresponding to \\spad{a / b}."))
 (*
  (($ $ $)
   "\\spad{a * b} returns the input form corresponding to \\spad{a * b}."))
 (+
  (($ $ $)
   "\\spad{a + b} returns the input form corresponding to \\spad{a + b}."))
 (|lambda|
  (($ $ (|List| (|Symbol|)))
   "\\spad{lambda(code,{} [x1,{} ...,{} xn])} returns the input form corresponding to \\spad{(x1,{} ...,{} xn) +-> code} if \\spad{n > 1},{} or to \\spad{x1 +-> code} if \\spad{n = 1}."))
 (|function|
  (($ $ (|List| (|Symbol|)) (|Symbol|))
   "\\spad{function(code,{} [x1,{} ...,{} xn],{} f)} returns the input form corresponding to \\spad{f(x1,{} ...,{} xn) == code}."))
 (|binary|
  (($ $ (|List| $))
   "\\spad{binary(op,{} [a1,{} ...,{} an])} returns the input form corresponding to \\spad{a1 op a2 op ... op an}."))
 (|convert|
  (($ (|SExpression|))
   "\\spad{convert(s)} makes \\spad{s} into an input form."))
 (|interpret|
  (((|Any|) $) "\\spad{interpret(f)} passes \\spad{f} to the interpreter."))) 
NIL 
(|InputFormFunctions1| R) 
((|constructor| (NIL "Tools for manipulating input forms."))
 (|interpret|
  ((|#1| (|InputForm|))
   "\\spad{interpret(f)} passes \\spad{f} to the interpreter,{} and transforms the result into an object of type \\spad{R}."))
 (|getType|
  (((|InputForm|))
   "\\spad{getType()} returns the input form corresponding to \\spad{R}"))
 (|pretendOfType|
  (((|InputForm|) (|InputForm|))
   "\\spad{pretendOfType(f)} returns the input form corresponding to \\spad{f pretend R}"))
 (|atType|
  (((|InputForm|) (|InputForm|))
   "\\spad{atType(f)} returns the input form corresponding to \\spad{f@R}"))
 (|coerceToType|
  (((|InputForm|) (|InputForm|))
   "\\spad{coerceToType(f)} returns the input form corresponding to f::R"))
 (|packageCall|
  (((|InputForm|) (|Symbol|) (|List| (|InputForm|)))
   "\\spad{packageCall(f,{} l)} returns the input form corresponding to \\spad{f}(\\spad{l}.1,{} \\spad{l}.2,{} ...)\\$\\spad{R}.")
  (((|InputForm|) (|Symbol|))
   "\\spad{packageCall(f)} returns the input form corresponding to \\spad{f}\\$\\spad{R}."))) 
NIL 
(|InfiniteLambertProduct| |Coef| UTS) 
((|constructor|
  (NIL "This package computes infinite products of univariate Taylor series"))
 (|generalInfiniteProduct|
  ((|#2| |#2| (|Integer|) (|Integer|))
   "\\spad{generalInfiniteProduct(f(x),{} a,{} d)} computes \\spad{product(n=a,{} a+d,{} a+2*d,{} ...,{} f(x^n))}. The series \\spad{f(x)} should have constant coefficient 1."))
 (|oddInfiniteProduct|
  ((|#2| |#2|)
   "\\spad{oddInfiniteProduct(f(x))} computes \\spad{product(n=1,{} 3,{} 5...,{} f(x^n))}. The series \\spad{f(x)} should have constant coefficient 1."))
 (|evenInfiniteProduct|
  ((|#2| |#2|)
   "\\spad{evenInfiniteProduct(f(x))} computes \\spad{product(n=2,{} 4,{} 6...,{} f(x^n))}. The series \\spad{f(x)} should have constant coefficient 1."))
 (|infiniteProduct|
  ((|#2| |#2|)
   "\\spad{infiniteProduct(f(x))} computes \\spad{product(n=1,{} 2,{} 3...,{} f(x^n))}. The series \\spad{f(x)} should have constant coefficient 1."))) 
NIL 
(|InnerNumericFloatSolvePackage| K F |Par|) 
((|constructor|
  (NIL
   "This is an internal package for computing approximate solutions to systems of polynomial equations. The parameter \\spad{K} specifies the coefficient field of the input polynomials and must be either \\spad{Fraction(Integer)} or \\spad{Complex(Fraction Integer)}. The parameter \\spad{F} specifies where the solutions must lie and can be one of the following: \\spad{Float},{} \\spad{Fraction(Integer)},{} \\spad{Complex(Float)},{} \\spad{Complex(Fraction Integer)}. The last parameter specifies the type of the precision operand and must be either \\spad{Fraction(Integer)} or \\spad{Float}."))
 (|makeEq|
  (((|List| (|Equation| (|Polynomial| |#2|))) (|List| |#2|)
    (|List| (|Symbol|)))
   "\\spad{makeEq(lsol,{} lvar)} returns a list of equations formed by corresponding members of lvar and \\spad{lsol}."))
 (|innerSolve|
  (((|List| (|List| |#2|)) (|List| (|Polynomial| |#1|))
    (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)) |#3|)
   "\\spad{innerSolve(lnum,{} lden,{} lvar,{} eps)} returns a list of solutions of the system of polynomials \\spad{lnum},{} with the side condition that none of the members of \\spad{lden} vanish identically on any solution. Each solution is expressed as a list corresponding to the list of variables in \\spad{lvar} and with precision specified by eps."))
 (|innerSolve1|
  (((|List| |#2|) (|Polynomial| |#1|) |#3|)
   "\\spad{innerSolve1(p,{} eps)} returns the list of the zeros of the polynomial \\spad{p} with precision eps.")
  (((|List| |#2|) (|SparseUnivariatePolynomial| |#1|) |#3|)
   "\\spad{innerSolve1(up,{} eps)} returns the list of the zeros of the univariate polynomial \\spad{up} with precision eps."))) 
NIL 
(|InnerModularGcd| R BP |pMod| |nextMod|) 
((|constructor|
  (NIL
   "This file contains the functions for modular \\spad{gcd} algorithm for univariate polynomials with coefficients in a non-trivial euclidean domain (\\spadignore{i.e.} not a field). The package parametrised by the coefficient domain,{} the polynomial domain,{} a prime,{} and a function for choosing the next prime"))
 (|reduction|
  ((|#2| |#2| |#1|)
   "\\spad{reduction(f,{} p)} reduces the coefficients of the polynomial \\spad{f} modulo the prime \\spad{p}."))
 (|modularGcdPrimitive|
  ((|#2| (|List| |#2|))
   "\\spad{modularGcdPrimitive(listf)} computes the \\spad{gcd} of the list of primitive polynomials \\spad{listf} by modular methods."))) 
NIL 
(|InnerMultFact| OV E R P) 
((|constructor|
  (NIL
   "\\indented{2}{This is an inner package for factoring multivariate polynomials} over various coefficient domains in characteristic 0. The univariate factor operation is passed as a parameter. Multivariate hensel lifting is used to lift the univariate factorization"))
 (|factor|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|)
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#3|))
               (|SparseUnivariatePolynomial| |#3|)))
   "\\spad{factor(p,{} ufact)} factors the multivariate polynomial \\spad{p} by specializing variables and calling the univariate factorizer ufact. \\spad{p} is represented as a univariate polynomial with multivariate coefficients.")
  (((|Factored| |#4|) |#4|
    (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#3|))
               (|SparseUnivariatePolynomial| |#3|)))
   "\\spad{factor(p,{} ufact)} factors the multivariate polynomial \\spad{p} by specializing variables and calling the univariate factorizer ufact."))) 
NIL 
(|InnerPolySign| R UP) 
((|constructor|
  (NIL "Find the sign of a polynomial around a point or infinity."))
 (|signAround|
  (((|Union| (|Integer|) #1="failed") |#2| |#1|
    (|Mapping| (|Union| (|Integer|) #1#) |#1|))
   "\\spad{signAround(u,{} r,{} f)} \\undocumented")
  (((|Union| (|Integer|) #1#) |#2| |#1| (|Integer|)
    (|Mapping| (|Union| (|Integer|) #1#) |#1|))
   "\\spad{signAround(u,{} r,{} i,{} f)} \\undocumented")
  (((|Union| (|Integer|) #1#) |#2| (|Integer|)
    (|Mapping| (|Union| (|Integer|) #1#) |#1|))
   "\\spad{signAround(u,{} i,{} f)} \\undocumented"))) 
NIL 
(|IntegerNumberSystem&| S) 
((|constructor|
  (NIL "An \\spad{IntegerNumberSystem} is a model for the integers."))
 (|invmod|
  (($ $ $)
   "\\spad{invmod(a,{} b)},{} \\spad{0<=a<b>1},{} \\spad{(a,{} b)=1} means \\spad{1/a mod b}."))
 (|powmod|
  (($ $ $ $)
   "\\spad{powmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a^b mod p}."))
 (|mulmod|
  (($ $ $ $)
   "\\spad{mulmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a*b mod p}."))
 (|submod|
  (($ $ $ $)
   "\\spad{submod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a-b mod p}."))
 (|addmod|
  (($ $ $ $)
   "\\spad{addmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a+b mod p}."))
 (|mask|
  (($ $) "\\spad{mask(n)} returns \\spad{2^n-1} (an \\spad{n} bit mask)."))
 (|dec| (($ $) "\\spad{dec(x)} returns \\spad{x - 1}."))
 (|inc| (($ $) "\\spad{inc(x)} returns \\spad{x + 1}."))
 (|copy| (($ $) "\\spad{copy(n)} gives a copy of \\spad{n}."))
 (|random|
  (($ $) "\\spad{random(n)} creates a random element from 0 to \\spad{n-1}."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(n)} creates a rational number,{} or returns \"failed\" if this is not possible."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(n)} creates a rational number (see \\spadtype{Fraction Integer})."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(n)} tests if \\spad{n} is a rational number (see \\spadtype{Fraction Integer})."))
 (|symmetricRemainder|
  (($ $ $)
   "\\spad{symmetricRemainder(a,{} b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{-b/2 <= r < b/2}."))
 (|positiveRemainder|
  (($ $ $)
   "\\spad{positiveRemainder(a,{} b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{0 <= r < b} and \\spad{r = a rem b}."))
 (|bit?|
  (((|Boolean|) $ $)
   "\\spad{bit?(n,{} i)} returns \\spad{true} if and only if \\spad{i}-th bit of \\spad{n} is a 1."))
 (|shift|
  (($ $ $) "\\spad{shift(a,{} i)} shift \\spad{a} by \\spad{i} digits."))
 (|length| (($ $) "\\spad{length(a)} length of \\spad{a} in digits."))
 (|base|
  (($)
   "\\spad{base()} returns the base for the operations of \\spad{IntegerNumberSystem}."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even?(n)} returns \\spad{true} if and only if \\spad{n} is even."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd?(n)} returns \\spad{true} if and only if \\spad{n} is odd."))) 
NIL 
(|IntegerNumberSystem|) 
((|constructor|
  (NIL "An \\spad{IntegerNumberSystem} is a model for the integers."))
 (|invmod|
  (($ $ $)
   "\\spad{invmod(a,{} b)},{} \\spad{0<=a<b>1},{} \\spad{(a,{} b)=1} means \\spad{1/a mod b}."))
 (|powmod|
  (($ $ $ $)
   "\\spad{powmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a^b mod p}."))
 (|mulmod|
  (($ $ $ $)
   "\\spad{mulmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a*b mod p}."))
 (|submod|
  (($ $ $ $)
   "\\spad{submod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a-b mod p}."))
 (|addmod|
  (($ $ $ $)
   "\\spad{addmod(a,{} b,{} p)},{} \\spad{0<=a,{} b<p>1},{} means \\spad{a+b mod p}."))
 (|mask|
  (($ $) "\\spad{mask(n)} returns \\spad{2^n-1} (an \\spad{n} bit mask)."))
 (|dec| (($ $) "\\spad{dec(x)} returns \\spad{x - 1}."))
 (|inc| (($ $) "\\spad{inc(x)} returns \\spad{x + 1}."))
 (|copy| (($ $) "\\spad{copy(n)} gives a copy of \\spad{n}."))
 (|random|
  (($ $) "\\spad{random(n)} creates a random element from 0 to \\spad{n-1}."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(n)} creates a rational number,{} or returns \"failed\" if this is not possible."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(n)} creates a rational number (see \\spadtype{Fraction Integer})."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(n)} tests if \\spad{n} is a rational number (see \\spadtype{Fraction Integer})."))
 (|symmetricRemainder|
  (($ $ $)
   "\\spad{symmetricRemainder(a,{} b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{-b/2 <= r < b/2}."))
 (|positiveRemainder|
  (($ $ $)
   "\\spad{positiveRemainder(a,{} b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{0 <= r < b} and \\spad{r = a rem b}."))
 (|bit?|
  (((|Boolean|) $ $)
   "\\spad{bit?(n,{} i)} returns \\spad{true} if and only if \\spad{i}-th bit of \\spad{n} is a 1."))
 (|shift|
  (($ $ $) "\\spad{shift(a,{} i)} shift \\spad{a} by \\spad{i} digits."))
 (|length| (($ $) "\\spad{length(a)} length of \\spad{a} in digits."))
 (|base|
  (($)
   "\\spad{base()} returns the base for the operations of \\spad{IntegerNumberSystem}."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even?(n)} returns \\spad{true} if and only if \\spad{n} is even."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd?(n)} returns \\spad{true} if and only if \\spad{n} is odd."))) 
NIL 
(|Integer|) 
((|constructor|
  (NIL
   "\\spadtype{Integer} provides the domain of arbitrary precision integers."))
 (|seedRandom|
  (((|Void|))
   "\\spad{seedRandom()} seeds the pseudo random number generator with a new random seed. Note that internally there is only one (global) pseudo random number generator as a source for random data. All other random objects are derived from that source."))
 (|random|
  (($ $) "\\spad{random(n)} returns a random integer from 0 to \\spad{n-1}."))) 
((|HasCategory| $ '(|CharacteristicNonZero|))) 
(|InnerTable| |Key| |Entry| |addDom|) 
((|constructor|
  (NIL
   "This domain is used to provide a conditional \"add\" domain for the implementation of \\spadtype{Table}."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|AlgebraicIntegration| R F) 
((|constructor|
  (NIL
   "This package provides functions for the integration of algebraic integrands over transcendental functions."))
 (|algextint_base|
  (((|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
    (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|SparseUnivariatePolynomial| |#2|)
               (|SparseUnivariatePolynomial| |#2|))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#2|)) (|List| |#2|))
   "\\spad{algextint_base(x,{} y,{} d,{} csolve,{} [g1,{} ...,{} gn])} is like algextint but assumes that \\spad{y} and \\spad{gi}-\\spad{s} are purely algebraic"))
 (|algextint|
  (((|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
    (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|SparseUnivariatePolynomial| |#2|)
               (|SparseUnivariatePolynomial| |#2|))
    (|Mapping|
     (|List|
      (|Record|
       (|:| |ratpart| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
       (|:| |coeffs| (|Vector| |#2|))))
     (|List| (|Fraction| (|SparseUnivariatePolynomial| |#2|))))
    (|Mapping|
     (|List|
      (|Record|
       (|:| |ratpart| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
       (|:| |coeffs| (|Vector| |#2|))))
     (|Fraction| (|SparseUnivariatePolynomial| |#2|))
     (|List| (|Fraction| (|SparseUnivariatePolynomial| |#2|))))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#2|)) (|List| |#2|))
   "\\spad{algextint(x,{} y,{} d,{} ext,{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns \\spad{[h,{} [c1,{} ...,{} cn]]} such that \\spad{f = dh/dx + sum(\\spad{ci} \\spad{gi})} and dci/dx = 0,{} if such \\spad{[h,{} [c1,{} ...,{} cn]]} exist,{} \"failed\" otherwise."))
 (|algint|
  (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|SparseUnivariatePolynomial| |#2|)
               (|SparseUnivariatePolynomial| |#2|))
    (|Mapping| (|IntegrationResult| |#2|) |#2|))
   "\\spad{algint(f,{} x,{} y,{} d)} returns the integral of \\spad{f(x,{} y)dx} where \\spad{y} is an algebraic function of \\spad{x}; \\spad{d} is the derivation to use on \\spad{k[x]}."))) 
NIL 
(|AlgebraicIntegrate| R0 F UP UPUP R) 
((|constructor|
  (NIL
   "This package provides functions for integrating a function on an algebraic curve."))
 (|palgintegrate|
  (((|Record| (|:| |result1| (|IntegrationResult| |#5|)) (|:| |result2| |#2|))
    |#5| |#2| (|Mapping| |#3| |#3|))
   "\\spad{palgintegrate(f,{} x,{} d)} integrates \\spad{f} with respect to the derivation \\spad{d}. Argument \\spad{f} must be a pure algebraic function."))
 (|algintegrate|
  (((|IntegrationResult| |#5|) |#5| (|Mapping| |#3| |#3|)
    (|Mapping| (|IntegrationResult| |#2|) |#2|))
   "\\spad{algintegrate(f,{} d,{} rec)} integrates \\spad{f} with respect to the derivation \\spad{d}."))) 
NIL 
(|AlgebraicIntegrate2| R0 F UP UPUP R) 
((|algextint_base|
  (((|List| (|Record| (|:| |ratpart| |#5|) (|:| |coeffs| (|Vector| |#2|))))
    (|Mapping| |#3| |#3|) (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#2|))
    (|List| |#5|))
   "\\spad{algextint_base(der,{} csolve,{} [g1,{} ...,{} gn])} is like algextint(\\spad{der},{} ext,{} rde,{} \\spad{csolve},{} [\\spad{g1},{} ...,{} \\spad{gn}]),{} but assumes that field is algebraic extension of rational functions and that \\spad{gi}-\\spad{s} have no poles at infinity."))
 (|algextint|
  (((|List| (|Record| (|:| |ratpart| |#5|) (|:| |coeffs| (|Vector| |#2|))))
    (|Mapping| |#3| |#3|)
    (|Mapping|
     (|List|
      (|Record| (|:| |ratpart| (|Fraction| |#3|))
                (|:| |coeffs| (|Vector| |#2|))))
     (|List| (|Fraction| |#3|)))
    (|Mapping|
     (|List|
      (|Record| (|:| |ratpart| (|Fraction| |#3|))
                (|:| |coeffs| (|Vector| |#2|))))
     (|Fraction| |#3|) (|List| (|Fraction| |#3|)))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#2|)) (|List| |#5|))
   "\\spad{algextint(der,{} ext,{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solutions of the homogeneous system \\spad{h' + c1*g1 + ... + cn*gn = 0}. Argument \\spad{ext} is an extended integration function on \\spad{F},{} \\spad{rde} is RDE solver,{} \\spad{csolve} is linear solver over constants."))) 
NIL 
(|IntegerBits|) 
((|constructor|
  (NIL "This package provides functions to lookup bits in integers."))
 (|bitTruth|
  (((|Boolean|) (|Integer|) (|NonNegativeInteger|))
   "\\spad{bitTruth(n,{} m)} returns \\spad{true} if coefficient of 2^m in two complement representation of \\spad{n} is 1."))
 (|bitCoef|
  (((|Integer|) (|Integer|) (|NonNegativeInteger|))
   "\\spad{bitCoef(n,{} m)} returns the coefficient of 2^m in two complement representation of \\spad{n}."))) 
NIL 
(|IntervalCategory| R) 
((|constructor|
  (NIL
   "\\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: + This category implements of interval arithmetic and transcendental + functions over intervals."))
 (|contains?|
  (((|Boolean|) $ |#1|)
   "\\spad{contains?(i,{} f)} returns \\spad{true} if \\spad{f} is contained within the interval \\spad{i},{} \\spad{false} otherwise."))
 (|negative?|
  (((|Boolean|) $)
   "\\spad{negative?(u)} returns \\spad{true} if every element of \\spad{u} is negative,{} \\spad{false} otherwise."))
 (|positive?|
  (((|Boolean|) $)
   "\\spad{positive?(u)} returns \\spad{true} if every element of \\spad{u} is positive,{} \\spad{false} otherwise."))
 (|width| ((|#1| $) "\\spad{width(u)} returns \\spad{sup(u) - inf(u)}."))
 (|sup| ((|#1| $) "\\spad{sup(u)} returns the supremum of \\spad{u}."))
 (|inf| ((|#1| $) "\\spad{inf(u)} returns the infinum of \\spad{u}."))
 (|qinterval|
  (($ |#1| |#1|)
   "\\spad{qinterval(inf,{} sup)} creates a new interval \\spad{[inf,{} sup]},{} without checking the ordering on the elements."))
 (|interval|
  (($ (|Fraction| (|Integer|)))
   "\\spad{interval(f)} creates a new interval around \\spad{f}.")
  (($ |#1|) "\\spad{interval(f)} creates a new interval around \\spad{f}.")
  (($ |#1| |#1|)
   "\\spad{interval(inf,{} sup)} creates a new interval,{} either \\spad{[inf,{} sup]} if \\spad{inf <= sup} or \\spad{[sup,{} inf]} otherwise."))) 
NIL 
(|DenominatorIntegration| R F) 
((|constructor|
  (NIL
   "This package generates logarithmic integrals and polylogs corresponding to denominator of the integrand."))
 (|solve_u|
  (((|Union| (|List| (|List| |#2|)) "failed") |#2| |#2| (|Symbol|))
   "\\spad{solve_u(f1,{} u,{} x)} returns [[\\spad{c1},{} \\spad{k1}],{} ...,{} [\\spad{cn},{} \\spad{kn}]] such that \\spad{f1} = \\spad{c1*u^k1} + ... + cn^kn and \\spad{D}(\\spad{ci},{} \\spad{x}) = 0 or \"failed\"."))
 (|poly_int|
  (((|Record| (|:| |answer| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
              (|:| |logpart| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
              (|:| |ir|
                   (|IntegrationResult|
                    (|Fraction| (|SparseUnivariatePolynomial| |#2|)))))
    (|Fraction| (|SparseUnivariatePolynomial| |#2|)) (|Kernel| |#2|)
    (|Symbol|))
   "\\spad{poly_int(f,{} k,{} x)} generates polylogarithms."))
 (|li_int|
  (((|Record| (|:| |answer| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
              (|:| |logpart| (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
              (|:| |ir|
                   (|IntegrationResult|
                    (|Fraction| (|SparseUnivariatePolynomial| |#2|)))))
    (|Fraction| (|SparseUnivariatePolynomial| |#2|)) (|Kernel| |#2|)
    (|Symbol|))
   "\\spad{li_int(f,{} k,{} x)} generates logarithmic integrals."))) 
NIL 
(|IntegralDomain|) 
((|constructor|
  (NIL
   "The category of commutative integral domains,{} \\spadignore{i.e.} commutative rings with no zero divisors. \\blankline"))) 
NIL 
(|IntegrateSolutions| F L) 
((|constructor|
  (NIL
   "\\spadtype{IntegrateSolutions} implements a method \\indented{1}{to compute integral of solution of differential operator.}"))
 (|integrate_sols|
  (((|Record| (|:| |ltilde| |#2|) (|:| |r| (|Union| |#2| "failed"))) |#2|
    (|Mapping|
     (|Record| (|:| |particular| (|Union| |#1| "failed"))
               (|:| |basis| (|List| |#1|)))
     |#2| |#1|))
   "\\spad{integrate_sols(l,{} rat_solve)} integrates the solutions of an operator \\spad{l} given rat_solve(op,{} \\spad{g}) that returns \\spad{[\"failed\",{} []]} if the equation \\spad{op y = g} has no rational solution. Otherwise,{} the rat_solve function should return \\spad{[f,{} [y1,{} ...,{} ym]]} where \\spad{f} is a particular rational solution and the \\spad{yi}\\spad{'s} form a basis for the rational solutions of the homogeneous equation."))
 (|adjoint| (($ $) "\\spad{adjoint(a)} returns the adjoint operator of a."))) 
NIL 
(|ElementaryIntegration| R F) 
((|constructor|
  (NIL
   "This package provides functions for integration,{} limited integration,{} extended integration and the risch differential equation for elemntary functions."))
 (|lfintegrate|
  (((|IntegrationResult| |#2|) |#2| (|Symbol|))
   "\\spad{lfintegrate(f,{} x)} = \\spad{g} such that \\spad{dg/dx = f}."))
 (|lfextendedint|
  (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2|
    (|Symbol|) |#2|)
   "\\spad{lfextendedint(f,{} x,{} g)} returns functions \\spad{[h,{} c]} such that \\spad{dh/dx = f - cg},{} if (\\spad{h},{} \\spad{c}) exist,{} \"failed\" otherwise."))) 
NIL 
(|IntegerFactorizationPackage| I) 
((|constructor|
  (NIL
   "\\indented{1}{This Package contains basic methods for integer factorization.} The factor operation employs trial division up to 10,{} 000. It then tests to see if \\spad{n} is a perfect power before using Pollards rho method. Because Pollards method may fail,{} the result of factor may contain composite factors. We should also employ Lenstra\\spad{'s} eliptic curve method."))
 (|PollardSmallFactor|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{PollardSmallFactor(n)} returns a factor of \\spad{n} or \"failed\" if no one is found"))
 (|BasicMethod|
  (((|Factored| |#1|) |#1|)
   "\\spad{BasicMethod(n)} returns the factorization of integer \\spad{n} by trial division"))
 (|squareFree|
  (((|Factored| |#1|) |#1|)
   "\\spad{squareFree(n)} returns the square free factorization of integer \\spad{n}"))
 (|factor|
  (((|Factored| |#1|) |#1|)
   "\\spad{factor(n)} returns the full factorization of integer \\spad{n}"))) 
NIL 
(|GenusZeroIntegration| R F L) 
((|constructor|
  (NIL
   "This internal package rationalises integrands on curves of the form: \\indented{2}{\\spad{y\\^2 = a x\\^2 + b x + c}} \\indented{2}{\\spad{y\\^2 = (a x + b) / (c x + d)}} \\indented{2}{\\spad{f(x,{} y) = 0} where \\spad{f} has degree 1 in \\spad{x}} The rationalization is done for integration,{} limited integration,{} extended integration and the risch differential equation."))
 (|palgLODE0|
  (((|Record| (|:| |particular| (|Union| |#2| #1="failed"))
              (|:| |basis| (|List| |#2|)))
    |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Kernel| |#2|) |#2|
    (|Fraction| (|SparseUnivariatePolynomial| |#2|)) |#2|)
   "\\spad{palgLODE0(op,{} g,{} x,{} y,{} z,{} t,{} c)} returns the solution of \\spad{op f = g}. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{x = eval(t,{} z,{} ry)} and \\spad{c = d/dz t}; \\spad{r} is rational function of \\spad{x},{} \\spad{c} and \\spad{t} are rational functions of \\spad{z}.")
  (((|Record| (|:| |particular| (|Union| |#2| #1#))
              (|:| |basis| (|List| |#2|)))
    |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2|
    (|SparseUnivariatePolynomial| |#2|))
   "\\spad{palgLODE0(op,{} g,{} x,{} y,{} d,{} p)} returns the solution of \\spad{op f = g}. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2y(x)\\^2 = P(x)}."))
 (|rationalize_ir|
  (((|IntegrationResult| |#2|) (|IntegrationResult| |#2|) (|Kernel| |#2|))
   "\\spad{rationalize_ir(irf,{} k1)} eliminates square root \\spad{k1} from the integration result."))
 (|lift|
  (((|SparseUnivariatePolynomial|
     (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
    (|SparseUnivariatePolynomial| |#2|) (|Kernel| |#2|))
   "\\spad{lift(u,{} k)} \\undocumented"))
 (|multivariate|
  ((|#2|
    (|SparseUnivariatePolynomial|
     (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
    (|Kernel| |#2|) |#2|)
   "\\spad{multivariate(u,{} k,{} f)} \\undocumented"))
 (|univariate|
  (((|SparseUnivariatePolynomial|
     (|Fraction| (|SparseUnivariatePolynomial| |#2|)))
    |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|SparseUnivariatePolynomial| |#2|))
   "\\spad{univariate(f,{} k,{} k,{} p)} \\undocumented"))
 (|palgRDE0|
  (((|Union| |#2| #2="failed") |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|Union| |#2| #2#) |#2| |#2| (|Symbol|)) (|Kernel| |#2|) |#2|
    (|Fraction| (|SparseUnivariatePolynomial| |#2|)) |#2|)
   "\\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} t,{} c)} returns a function \\spad{z(x,{} y)} such that \\spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \\spad{z} exists,{} and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{x = eval(t,{} z,{} ry)} and \\spad{c = d/dz t}; \\spad{r} is rational function of \\spad{x},{} \\spad{c} and \\spad{t} are rational functions of \\spad{z}. Argument \\spad{foo},{} called by \\spad{foo(a,{} b,{} x)},{} is a function that solves \\spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y}.")
  (((|Union| |#2| #2#) |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|Union| |#2| #2#) |#2| |#2| (|Symbol|)) |#2|
    (|SparseUnivariatePolynomial| |#2|))
   "\\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} d,{} p)} returns a function \\spad{z(x,{} y)} such that \\spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \\spad{z} exists,{} and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2y(x)\\^2 = P(x)}. Argument \\spad{foo},{} called by \\spad{foo(a,{} b,{} x)},{} is a function that solves \\spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y}."))
 (|palgint0|
  (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|)
    (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|)) |#2|)
   "\\spad{palgint0(f,{} x,{} y,{} z,{} t,{} c)} returns the integral of \\spad{f(x,{} y)dx} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{x = eval(t,{} z,{} ry)} and \\spad{c = d/dz t}; \\spad{r} is rational function of \\spad{x},{} \\spad{c} and \\spad{t} are rational functions of \\spad{z}. Argument \\spad{z} is a dummy variable not appearing in \\spad{f(x,{} y)}.")
  (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2|
    (|SparseUnivariatePolynomial| |#2|))
   "\\spad{palgint0(f,{} x,{} y,{} d,{} p)} returns the integral of \\spad{f(x,{} y)dx} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2 y(x)\\^2 = P(x)}."))) 
((|HasCategory| |#3|
                (LIST '|LinearOrdinaryDifferentialOperatorCategory|
                      (|devaluate| |#2|)))) 
(|GenerateEllipticIntegrals| F UP UPUP R) 
((|constructor|
  (NIL
   "This package provides support functions for generating elliptic integrals."))
 (|fsqrt| ((|#1| |#1|) "\\spad{fsqrt(f)} should be local but conditional"))
 (|gen_ef|
  (((|Union| (|Record| (|:| |result1| (|Fraction| |#2|)) (|:| |result2| |#1|))
             "failed")
    |#1| |#2| |#4| |#4|)
   "\\spad{gen_ef(f_var,{} f_pol,{} cfr,{} cer)} produces linear combination"))
 (|get_elliptics|
  (((|List|
     (|Record| (|:| |f_form| |#4|) (|:| |e_form| |#4|) (|:| |f_var| |#1|)
               (|:| |f_pol| |#2|)))
    (|Mapping| |#2| |#2|) |#1|)
   "\\spad{get_elliptics(der,{} x)} tries to find elliptic forms on \\spad{R} \\spad{x} is expression for variable of integration in \\spad{F}"))) 
NIL 
(|IntegerNumberTheoryFunctions|) 
((|constructor|
  (NIL
   "This package provides various number theoretic functions on the integers."))
 (|sumOfKthPowerDivisors|
  (((|Integer|) (|Integer|) (|NonNegativeInteger|))
   "\\spad{sumOfKthPowerDivisors(n,{} k)} returns the sum of the \\spad{k}th powers of the integers between 1 and \\spad{n} (inclusive) which divide \\spad{n}. the sum of the \\spad{k}th powers of the divisors of \\spad{n} is often denoted by \\spad{sigma_k(n)}."))
 (|sumOfDivisors|
  (((|Integer|) (|Integer|))
   "\\spad{sumOfDivisors(n)} returns the sum of the integers between 1 and \\spad{n} (inclusive) which divide \\spad{n}. The sum of the divisors of \\spad{n} is often denoted by \\spad{sigma(n)}."))
 (|numberOfDivisors|
  (((|Integer|) (|Integer|))
   "\\spad{numberOfDivisors(n)} returns the number of integers between 1 and \\spad{n} (inclusive) which divide \\spad{n}. The number of divisors of \\spad{n} is often denoted by \\spad{tau(n)}."))
 (|moebiusMu|
  (((|Integer|) (|Integer|))
   "\\spad{moebiusMu(n)} returns the Moebius function \\spad{mu(n)}. \\spad{mu(n)} is either \\spad{-1},{} 0 or 1 as follows: \\spad{mu(n) = 0} if \\spad{n} is divisible by a square > 1,{} \\spad{mu(n) = (-1)^k} if \\spad{n} is square-free and has \\spad{k} distinct prime divisors."))
 (|legendre|
  (((|Integer|) (|Integer|) (|Integer|))
   "\\spad{legendre(a,{} p)} returns the Legendre symbol \\spad{L(a/p)}. \\spad{L(a/p) = (-1)^((p-1)/2) mod p} (\\spad{p} prime),{} which is 0 if \\spad{a} is 0,{} 1 if \\spad{a} is a quadratic residue \\spad{mod p} and \\spad{-1} otherwise. Note: because the primality test is expensive,{} if it is known that \\spad{p} is prime then use \\spad{jacobi(a,{} p)}."))
 (|jacobi|
  (((|Integer|) (|Integer|) (|Integer|))
   "\\spad{jacobi(a,{} b)} returns the Jacobi symbol \\spad{J(a/b)}. When \\spad{b} is odd,{} \\spad{J(a/b) = product(L(a/p) for p in factor b )}. Note: by convention,{} 0 is returned if \\spad{gcd(a,{} b) ~= 1}. Iterative \\spad{O(log(b)^2)} version coded by Michael Monagan June 1987."))
 (|harmonic|
  (((|Fraction| (|Integer|)) (|Integer|))
   "\\spad{harmonic(n)} returns the \\spad{n}th harmonic number. This is \\spad{H[n] = sum(1/k,{} k=1..n)}."))
 (|fibonacci|
  (((|Integer|) (|Integer|))
   "\\spad{fibonacci(n)} returns the \\spad{n}th Fibonacci number,{} \\spad{F[n]}. The Fibonacci numbers are defined by \\spad{F[0] = 0},{} \\spad{F[1] = 1} and \\spad{F[n] = F[n-1] + F[n-2]}. The algorithm has running time \\spad{O(log(n)^3)}. Reference: Knuth,{} The Art of Computer Programming Vol 2,{} Semi-Numerical Algorithms."))
 (|eulerPhi|
  (((|Integer|) (|Integer|))
   "\\spad{eulerPhi(n)} returns the number of integers between 1 and \\spad{n} (including 1) which are relatively prime to \\spad{n}. This is the Euler phi function \\spad{phi(n)} is also called the totient function."))
 (|euler|
  (((|Integer|) (|Integer|))
   "\\spad{euler(n)} returns the \\spad{n}th Euler number. This is \\spad{2^n E(n,{} 1/2)},{} where \\spad{E(n,{} x)} is the \\spad{n}th Euler polynomial."))
 (|divisors|
  (((|List| (|Integer|)) (|Integer|))
   "\\spad{divisors(n)} returns a list of the divisors of \\spad{n}."))
 (|chineseRemainder|
  (((|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{chineseRemainder(x1,{} m1,{} x2,{} m2)} returns \\spad{w},{} where \\spad{w} is such that \\spad{w = x1 mod m1} and \\spad{w = x2 mod m2}. Note: \\spad{m1} and \\spad{m2} must be relatively prime."))
 (|carmichaelLambda|
  (((|Integer|) (|Integer|))
   "\\spad{carmichaelLambda(n)} returns exponent of the multiplicative group of integers modulo \\spad{n},{} that is smallest positive integer \\spad{k} such that \\spad{i^k rem n = 1} for all \\spad{i} relatively prime to \\spad{n}."))
 (|bernoulli|
  (((|Fraction| (|Integer|)) (|Integer|))
   "\\spad{bernoulli(n)} returns the \\spad{n}th Bernoulli number. this is \\spad{B(n,{} 0)},{} where \\spad{B(n,{} x)} is the \\spad{n}th Bernoulli polynomial."))) 
NIL 
(|AlgebraicHermiteIntegration| F UP UPUP R) 
((|constructor| (NIL "algebraic Hermite redution."))
 (|HermiteIntegrate|
  (((|Record| (|:| |answer| |#4|) (|:| |logpart| |#4|)) |#4|
    (|Mapping| |#2| |#2|) |#4|)
   "\\spad{HermiteIntegrate(f,{} ',{} d0)} returns \\spad{[g,{} h]} such that \\spad{f = g' + d0*g + h} and \\spad{h} has a only simple finite normal poles. Note: \\spad{d0} must be integral.")
  (((|Record| (|:| |answer| |#4|) (|:| |logpart| |#4|)) |#4|
    (|Mapping| |#2| |#2|))
   "\\spad{HermiteIntegrate(f,{} ')} returns \\spad{[g,{} h]} such that \\spad{f = g' + h} and \\spad{h} has a only simple finite normal poles."))) 
NIL 
(|TranscendentalHermiteIntegration| F UP) 
((|constructor| (NIL "Hermite integration,{} transcendental case."))
 (|HermiteIntegrate|
  (((|Record| (|:| |answer| (|Fraction| |#2|))
              (|:| |logpart| (|Fraction| |#2|))
              (|:| |specpart| (|Fraction| |#2|)) (|:| |polypart| |#2|))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|) |#2|)
   "\\spad{HermiteIntegrate(f,{} D,{} d0)} returns \\spad{[g,{} h,{} s,{} p]} such that \\spad{f = Dg + g*d0 + h + s + p},{} \\spad{h} has a squarefree denominator normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} and all the squarefree factors of the denominator of \\spad{s} are special \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D}. Furthermore,{} \\spad{h} and \\spad{s} have no polynomial parts. \\spad{D} is the derivation to use on \\spadtype{UP}.")
  (((|Record| (|:| |answer| (|Fraction| |#2|))
              (|:| |logpart| (|Fraction| |#2|))
              (|:| |specpart| (|Fraction| |#2|)) (|:| |polypart| |#2|))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|))
   "\\spad{HermiteIntegrate(f,{} D)} returns \\spad{[g,{} h,{} s,{} p]} such that \\spad{f = Dg + h + s + p},{} \\spad{h} has a squarefree denominator normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} and all the squarefree factors of the denominator of \\spad{s} are special \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D}. Furthermore,{} \\spad{h} and \\spad{s} have no polynomial parts. \\spad{D} is the derivation to use on \\spadtype{UP}."))) 
NIL 
(|IntegerLocalizedAtPrime| |p|) 
((|constructor|
  (NIL
   "IntegerLocalizedAtPrime(\\spad{p}) represents the Euclidean domain of integers localized at a prime \\spad{p},{} \\spadignore{i.e.} the set of rational numbers whose denominator is not divisible by \\spad{p}."))
 (|unitPart|
  (((|Fraction| (|Integer|)) $)
   "Each element \\spad{x} can be written as x=p^n*a/b with \\spad{gcd}(\\spad{p},{}a)=gcd(\\spad{p},{}\\spad{b})\\spad{=1}. unitPart(\\spad{x}) returns a/b."))
 (|exponent|
  (((|NonNegativeInteger|) $)
   "Each element \\spad{x} can be written as x=p^n*a/b with \\spad{gcd}(\\spad{p},{}a)=gcd(\\spad{p},{}\\spad{b})\\spad{=1}. exponent(\\spad{x}) returns \\spad{n}."))) 
NIL 
(|PureAlgebraicIntegration| R F L) 
((|constructor|
  (NIL
   "This package provides functions for integration,{} limited integration,{} extended integration and the risch differential equation for pure algebraic integrands."))
 (|palgLODE|
  (((|Record| (|:| |particular| (|Union| |#2| #1="failed"))
              (|:| |basis| (|List| |#2|)))
    |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Symbol|))
   "\\spad{palgLODE(op,{} g,{} kx,{} y,{} x)} returns the solution of \\spad{op f = g}. \\spad{y} is an algebraic function of \\spad{x}."))
 (|param_LODE|
  (((|Record|
     (|:| |particular|
          (|List|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|)))))
     (|:| |basis| (|List| |#2|)))
    (|List| |#2|) (|List| |#2|) (|Kernel| |#2|) (|Kernel| |#2|))
   "\\spad{param_LODE(eq,{} lg,{} x,{} y)}"))
 (|param_RDE|
  (((|Record|
     (|:| |particular|
          (|List|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|)))))
     (|:| |basis| (|List| |#2|)))
    |#2| (|List| |#2|) (|Kernel| |#2|) (|Kernel| |#2|))
   "\\spad{param_RDE(fp,{} lg,{} x,{} y)}"))
 (|palgRDE|
  (((|Union| |#2| #1#) |#2| |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|)
    (|Mapping| (|Union| |#2| #1#) |#2| |#2| (|Symbol|)))
   "\\spad{palgRDE(nfp,{} f,{} g,{} x,{} y,{} foo)} returns a function \\spad{z(x,{} y)} such that \\spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \\spad{z} exists,{} \"failed\" otherwise; \\spad{y} is an algebraic function of \\spad{x}; \\spad{foo(a,{} b,{} x)} is a function that solves \\spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y}. \\spad{nfp} is \\spad{n * df/dx}."))
 (|palgint|
  (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|))
   "\\spad{palgint(f,{} x,{} y)} returns the integral of \\spad{f(x,{} y)dx} where \\spad{y} is an algebraic function of \\spad{x}."))) 
((|HasCategory| |#3|
                (LIST '|LinearOrdinaryDifferentialOperatorCategory|
                      (|devaluate| |#2|)))) 
(|ParametricTranscendentalIntegration| F UP) 
((|monologextint|
  (((|Record| (|:| |logands| (|List| (|Fraction| |#2|)))
              (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
    (|List| |#2|)
    (|Mapping| (|List| (|Vector| (|Fraction| (|Integer|)))) (|Matrix| |#1|))
    (|Mapping|
     (|Record| (|:| |logands| (|List| |#1|))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| |#1|)))
   "\\spad{monologextint(lup,{} csolve,{} rec)} is a helper for logextint"))
 (|logextint|
  (((|Record| (|:| |logands| (|List| (|Fraction| |#2|)))
              (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
    (|Mapping| |#2| |#2|) (|Mapping| (|Factored| |#2|) |#2|)
    (|Mapping| (|List| (|Vector| (|Fraction| (|Integer|)))) (|Matrix| |#1|))
    (|Mapping|
     (|Record| (|:| |logands| (|List| (|Fraction| |#2|)))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| |#2|))
    (|List| (|Fraction| |#2|)))
   "\\spad{logextint(der,{} ufactor,{} csolve,{} rec,{} [g1,{} ...,{} gn])} returns [[\\spad{u1},{} ...,{} um],{} bas] giving basis of solution of the homogeneous systym \\spad{c1*g1 + ... + cn*gn + c_{n+1}u1'/u1 + ... c_{n+m}um'/um = 0}"))
 (|unkextint|
  (((|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
     (|List| |#1|))
    (|Mapping| (|List| (|Vector| |#1|)) (|Matrix| |#1|))
    (|List| (|Fraction| |#2|)))
   "\\spad{unkextint(ext,{} csolve,{} [g1,{} ...,{} gn])} is like primextint and expextint but for makes no assumption about generator of the extension."))
 (|diffextint|
  (((|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
     (|List| |#2|))
    (|Mapping| (|List| (|Vector| |#1|)) (|Matrix| |#1|))
    (|List| (|Fraction| |#2|)))
   "\\spad{diffextint(ext,{} csolve,{} [g1,{} ...,{} gn])} is like primextint and expextint but for differentialy transcendental extensions."))
 (|expextint|
  (((|List|
     (|Record| (|:| |ratpart| (|Fraction| |#2|))
               (|:| |coeffs| (|Vector| |#1|))))
    (|Mapping| |#2| |#2|)
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
     (|Integer|) (|List| |#1|))
    (|Mapping| (|List| (|Vector| |#1|)) (|Matrix| |#1|))
    (|List| (|Fraction| |#2|)))
   "\\spad{expextint(',{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solution of the homogeneous system \\spad{h' + c1*g1 + ... + cn*gn = 0} Argument foo is an parametric \\spad{rde} solver on \\spad{F}. \\spad{csolve} is solver over constants."))
 (|primextint|
  (((|List|
     (|Record| (|:| |ratpart| (|Fraction| |#2|))
               (|:| |coeffs| (|Vector| |#1|))))
    (|Mapping| |#2| |#2|)
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))
     (|List| |#1|))
    (|Mapping| (|List| (|Vector| |#1|)) (|Matrix| |#1|))
    (|List| (|Fraction| |#2|)))
   "\\spad{primextint(',{} ext,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solutions of the homogeneous system \\spad{h' + c1*g1 + ... + cn*gn = 0}. Argument \\spad{ext} is an extended integration function on \\spad{F}. \\spad{csolve} is solver over constants."))) 
NIL 
(|ParametricIntegration| R F) 
((|logextint|
  (((|Record| (|:| |logands| (|List| |#2|))
              (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
    (|Symbol|) (|List| (|Kernel| |#2|)) (|List| |#2|))
   "\\spad{logextint(x,{} lk,{} lg)} returns [[\\spad{u1},{} ...,{} um],{} bas] giving basis of solution of the homogeneous systym \\spad{c1*g1 + ... + cn*gn + c_{n+1}u1'/u1 + ... c_{n+m}um'/um = 0}"))
 (|polylog_int|
  (((|Union|
     (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|) (|:| |prim| |#2|))
     "failed")
    |#2| (|Symbol|) (|Kernel| |#2|) (|NonNegativeInteger|)
    (|List| (|Kernel| |#2|)) |#2|)
   "\\spad{polylog_int(f,{} x,{} k0,{} [k1,{} ...,{} kn],{} g)}"))
 (|extendedint|
  (((|Record|
     (|:| |particular|
          (|Union|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|)))
           #1="failed"))
     (|:| |basis|
          (|List|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))))
    |#2| (|Symbol|) (|List| |#2|))
   "\\spad{extendedint(f,{} x,{} [g1,{} ...,{} gn])} returns solution of the system \\spad{f = dh/dx + c1*g1 + ... + cn*gn} and and a basis of the associated homogeneous system \\spad{dh/dx + c1*g1 + ... + cn*gn = 0}. Solutions are in the field generated by kernels of \\spad{f} and \\spad{g1},{} ...,{} \\spad{gn}.")
  (((|Record|
     (|:| |particular|
          (|Union|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))) #1#))
     (|:| |basis|
          (|List|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))))
    |#2| (|Symbol|) (|List| (|Kernel| |#2|)) (|List| |#2|))
   "\\spad{extendedint(f,{} x,{} [k1,{} ...,{} kn],{} [g1,{} ...,{} gn])} is like extendedint(\\spad{f},{} [\\spad{k1},{} ...,{} \\spad{kn}],{} [\\spad{g1},{} ...,{} \\spad{gn}]) but looks for solutions in the field generated by \\spad{k1},{} ...,{} \\spad{kn}.")
  (((|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
    (|Symbol|) (|List| (|Kernel| |#2|)) (|List| |#2|))
   "\\spad{extendedint(x,{} [k1,{} ...,{} kn],{} [g1,{} ...,{} gn])} returns a basis of the homogeneous system \\spad{dh/dx + c1*g1 + ... + cn*gn = 0}. Solutions are in the field generated by \\spad{k1},{} ...,{} \\spad{kn}."))) 
NIL 
(|PatternMatchIntegration| R F) 
((|constructor|
  (NIL
   "\\spadtype{PatternMatchIntegration} provides functions that use the pattern matcher to find some indefinite and definite integrals involving special functions and found in the literature."))
 (|pmintegrate|
  (((|Union| |#2| "failed") |#2| (|Symbol|) (|OrderedCompletion| |#2|)
    (|OrderedCompletion| |#2|))
   "\\spad{pmintegrate(f,{} x = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b} if it can be found by the built-in pattern matching rules."))
 (|splitConstant|
  (((|Record| (|:| |const| |#2|) (|:| |nconst| |#2|)) |#2| (|Symbol|))
   "\\spad{splitConstant(f,{} x)} returns \\spad{[c,{} g]} such that \\spad{f = c * g} and \\spad{c} does not involve \\spad{t}."))) 
((AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
  (|HasCategory| |#2| '(|SpecialFunctionCategory|)))) 
(|RationalIntegration| F UP) 
((|constructor|
  (NIL
   "This package provides functions for the base case of the Risch algorithm."))
 (|infieldint|
  (((|Union| (|Fraction| |#2|) "failed") (|Fraction| |#2|))
   "\\spad{infieldint(f)} returns \\spad{g} such that \\spad{g' = f} or \"failed\" if the integral of \\spad{f} is not a rational function."))
 (|integrate|
  (((|IntegrationResult| (|Fraction| |#2|)) (|Fraction| |#2|))
   "\\spad{integrate(f)} returns \\spad{g} such that \\spad{g' = f}."))) 
NIL 
(|IntegerRetractions| S) 
((|constructor|
  (NIL
   "Provides integer testing and retraction functions. Date Created: March 1990"))
 (|integerIfCan|
  (((|Union| (|Integer|) "failed") |#1|)
   "\\spad{integerIfCan(x)} returns \\spad{x} as an integer,{} \"failed\" if \\spad{x} is not an integer."))
 (|integer?|
  (((|Boolean|) |#1|)
   "\\spad{integer?(x)} is \\spad{true} if \\spad{x} is an integer,{} \\spad{false} otherwise."))
 (|integer|
  (((|Integer|) |#1|)
   "\\spad{integer(x)} returns \\spad{x} as an integer; error if \\spad{x} is not an integer."))) 
NIL 
(|RationalFunctionIntegration| F) 
((|constructor|
  (NIL
   "This package provides functions for the integration of rational functions."))
 (|infieldIntegrate|
  (((|Union| (|Fraction| (|Polynomial| |#1|)) "failed")
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{infieldIntegrate(f,{} x)} returns a fraction \\spad{g} such that \\spad{dg/dx = f} if \\spad{g} exists,{} \"failed\" otherwise."))
 (|internalIntegrate|
  (((|IntegrationResult| (|Fraction| (|Polynomial| |#1|)))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{internalIntegrate(f,{} x)} returns \\spad{g} such that \\spad{dg/dx = f}."))) 
NIL 
(|Interval| R) 
((|constructor|
  (NIL
   "\\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: + This domain is an implementation of interval arithmetic and transcendental + functions over intervals."))) 
NIL 
(|IntegerSolveLinearPolynomialEquation|) 
((|constructor|
  (NIL
   "This package provides the implementation for the \\spadfun{solveLinearPolynomialEquation} operation over the integers. It uses a lifting technique from the package GenExEuclid"))
 (|solveLinearPolynomialEquation|
  (((|Union| (|List| (|SparseUnivariatePolynomial| (|Integer|))) "failed")
    (|List| (|SparseUnivariatePolynomial| (|Integer|)))
    (|SparseUnivariatePolynomial| (|Integer|)))
   "\\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of \\spad{ai}\\spad{'s} exists."))) 
NIL 
(|IntegrationTools| R F) 
((|constructor|
  (NIL
   "\\indented{1}{Tools for the integrator} Author: Manuel Bronstein Date Created: 25 April 1990 Keywords: elementary,{} function,{} integration."))
 (|mkPrim|
  ((|#2| |#2| (|Symbol|))
   "\\spad{mkPrim(f,{} x)} makes the logs in \\spad{f} which are linear in \\spad{x} primitive with respect to \\spad{x}."))
 (|removeConstantTerm|
  ((|#2| |#2| (|Symbol|))
   "\\spad{removeConstantTerm(f,{} x)} returns \\spad{f} minus any additive constant with respect to \\spad{x}."))
 (|vark|
  (((|List| (|Kernel| |#2|)) (|List| |#2|) (|Symbol|))
   "\\spad{vark([f1,{} ...,{} fn],{} x)} returns the set-theoretic union of \\spad{(varselect(f1,{} x),{} ...,{} varselect(fn,{} x))}."))
 (|union|
  (((|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|)))
   "\\spad{union(l1,{} l2)} returns set-theoretic union of \\spad{l1} and \\spad{l2}."))
 (|ksec|
  (((|Kernel| |#2|) (|Kernel| |#2|) (|List| (|Kernel| |#2|)) (|Symbol|))
   "\\spad{ksec(k,{} [k1,{} ...,{} kn],{} x)} returns the second top-level \\spad{ki} after \\spad{k} involving \\spad{x}."))
 (|kmax|
  (((|Kernel| |#2|) (|List| (|Kernel| |#2|)))
   "\\spad{kmax([k1,{} ...,{} kn])} returns the top-level \\spad{ki} for integration."))
 (|varselect|
  (((|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|)) (|Symbol|))
   "\\spad{varselect([k1,{} ...,{} kn],{} x)} returns the \\spad{ki} which involve \\spad{x}."))) 
((AND (|HasCategory| |#1| '(|GcdDomain|))
      (|HasCategory| |#2| '(|ElementaryFunctionCategory|)))
 (|HasCategory| |#1| '(|IntegralDomain|))) 
(|TranscendentalIntegration| F UP) 
((|constructor|
  (NIL
   "This package provides functions for the transcendental case of the Risch algorithm."))
 (|monomialIntPoly|
  (((|Record| (|:| |answer| |#2|) (|:| |polypart| |#2|)) |#2|
    (|Mapping| |#2| |#2|))
   "\\spad{monomialIntPoly(p,{} ')} returns [\\spad{q},{} \\spad{r}] such that \\spad{p = q' + r} and \\spad{degree(r) < degree(t')}. Error if \\spad{degree(t') < 2}."))
 (|monomialIntegrate|
  (((|Record| (|:| |ir| (|IntegrationResult| (|Fraction| |#2|)))
              (|:| |specpart| (|Fraction| |#2|)) (|:| |polypart| |#2|))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|))
   "\\spad{monomialIntegrate(f,{} ')} returns \\spad{[ir,{} s,{} p]} such that \\spad{f = ir' + s + p} and all the squarefree factors of the denominator of \\spad{s} are special \\spad{w}.\\spad{r}.\\spad{t} the derivation '."))
 (|lambintegrate|
  (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|)))
              (|:| |a0| (|IntegrationResult| |#1|)))
    (|Fraction| |#2|) |#1| (|Mapping| |#1| |#1|) (|Mapping| |#2| |#2|)
    (|Mapping|
     (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed")
     |#1|)
    (|Mapping| (|IntegrationResult| |#1|) |#1|))
   "\\spad{lambintegrate(f,{} dx,{} D1,{} D2,{} extint,{} int)} integrates \\spad{f} in extension by LambertW function. \\spad{dx} is derivative of the argument of LambertW,{} \\spad{D1} is dervative on \\spad{F},{} \\spad{D2} is derivative on UP,{} \\spad{extint} is extended integration function on \\spad{F},{} int is integration function on \\spad{F}."))
 (|expintegrate|
  (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|)))
              (|:| |a0| |#1|))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|)
    (|Mapping|
     (|Record| (|:| |answer| (|Fraction| |#2|))
               (|:| |logpart| (|Fraction| |#2|))
               (|:| |ir| (|IntegrationResult| (|Fraction| |#2|))))
     (|Fraction| |#2|))
    (|Mapping|
     (|Record| (|:| |ans| |#1|) (|:| |right| |#1|) (|:| |primpart| |#1|)
               (|:| |sol?| (|Boolean|)))
     (|Integer|) |#1|))
   "\\spad{expintegrate(f,{} ',{} foo)} returns \\spad{[g,{} a]} such that \\spad{f = g' + a},{} and \\spad{a = 0} or \\spad{a} has no integral in \\spad{F}; Argument foo is a Risch differential equation solver on \\spad{F}."))
 (|primintegrate|
  (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|)))
              (|:| |a0| |#1|))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|)
    (|Mapping|
     (|Record| (|:| |answer| (|Fraction| |#2|))
               (|:| |logpart| (|Fraction| |#2|))
               (|:| |ir| (|IntegrationResult| (|Fraction| |#2|))))
     (|Fraction| |#2|))
    (|Mapping|
     (|Union|
      (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|) (|:| |prim| |#1|))
      "failed")
     |#1| (|NonNegativeInteger|)))
   "\\spad{primintegrate(f,{} ',{} foo)} returns \\spad{[g,{} a]} such that \\spad{f = g' + a},{} and \\spad{a = 0} or \\spad{a} has no integral in UP. Argument foo is an extended integration function on \\spad{F}."))) 
NIL 
(|InverseLaplaceTransform| R F) 
((|constructor| (NIL "This package computes the inverse Laplace Transform."))
 (|inverseLaplace|
  (((|Union| |#2| "failed") |#2| (|Symbol|) (|Symbol|))
   "\\spad{inverseLaplace(f,{} s,{} t)} returns the Inverse Laplace transform of \\spad{f(s)} using \\spad{t} as the new variable or \"failed\" if unable to find a closed form. Handles only rational \\spad{f(s)}."))) 
NIL 
(|InnerPAdicInteger| |p| |unBalanced?|) 
((|constructor|
  (NIL
   "This domain implements \\spad{Zp},{} the \\spad{p}-adic completion of the integers. This is an internal domain."))) 
NIL 
(|IndexedProductCategory| A S) 
((|constructor|
  (NIL
   "This category represents the product of some set with respect to an indexing set. The set \\spad{S} is considered as the ``basis elements\\spad{''} and the elements from \\spad{A} as ``coefficients\\spad{''}. Elements may have infinite support. For \\spad{Comparable} (ordered) \\spad{S} we assume that support of each element is well-orderd."))
 (|leadingTerm|
  (((|Record| (|:| |k| |#2|) (|:| |c| |#1|)) $)
   "\\spad{leadingTerm(x)} returns the leading (with respect to the ordering on the indexing set) term of \\spad{z}. Error: if \\spad{z} has no support."))
 (|constructOrdered|
  (($ (|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))))
   "\\spad{constructOrdered(l)} takes a list of terms and creates the object with these components. The list is assumed to be sorted (in reverse order) with respect to the ordering of \\spad{S}. If \\spad{R} is a monoid,{} then the list is assumend to contain no zero elements. Caution: No checking is performed,{} so this should only be used in cases where those conditions are assured. If in doubt use \\spad{construct}."))
 (|reductum|
  (($ $)
   "\\spad{reductum(z)} returns a new element created by removing the leading coefficient/support pair from the element \\spad{z}. Error: if \\spad{z} has no support."))
 (|leadingSupport|
  ((|#2| $)
   "\\spad{leadingSupport(z)} returns the index of leading (with respect to the ordering on the indexing set) monomial of \\spad{z}. Error: if \\spad{z} has no support."))
 (|leadingCoefficient|
  ((|#1| $)
   "\\spad{leadingCoefficient(z)} returns the coefficient of the leading (with respect to the ordering on the indexing set) monomial of \\spad{z}. Error: if \\spad{z} has no support."))
 (|leadingMonomial|
  (($ $)
   "\\spad{leadingMonomial(x)} returns the monomial supported by the first element from \\spad{S}. Error: if \\spad{x} has no support."))
 (|construct|
  (($ (|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))))
   "\\spad{construct(l)} takes a list of terms and creates the object with these components. First components of elements of \\spad{l} should be different."))
 (|monomial?|
  (((|Boolean|) $)
   "\\spad{monomial?(x)} returns \\spad{true} if \\spad{x} is a single monomial,{} that is support of \\spad{x} consists of a single element."))
 (|monomial|
  (($ |#1| |#2|)
   "\\spad{monomial(a,{} s)} constructs a direct product element with the \\spad{s} component set to \\spad{a}"))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} z)} returns the new element created by applying the function \\spad{f} to each component of the direct product element \\spad{z}."))) 
NIL 
(|InnerPrimeField| |p|) 
((|constructor|
  (NIL
   "InnerPrimeField(\\spad{p}) implements the field with \\spad{p} elements by using IntegerMod \\spad{p}. Note: argument \\spad{p} MUST be a prime (this domain does not check). See \\spadtype{PrimeField} for a domain that does check. In addition to the inherited operations of IntegerMod \\spad{p},{} the domain provides exploits the structure of the cyclic group of its invertible elements. It stores a primitive element \\spad{w},{} \\spad{i}.a. generator of this group and it stores a logarithm table for \\spad{w} as soon as this is required. sqrt was added in 2018."))
 (|quadraticNonResidue|
  (($)
   "\\spad{quadraticNonResidue()} computes the smallest non negative integer,{} which represents a quadratic non residue."))
 (|sqrt|
  (($ $)
   "\\spad{sqrt(x)} computes one \\spad{y} such that \\spad{y^2} = \\spad{x},{} error if there is no square root,{} \\spadignore{i.e.} jacobi(\\spad{x},{}\\spad{p}) = \\spad{-1}. Implementation according to http://www.staff.uni-mainz.de/pommeren/Cryptology/Asymmetric/5_NTh/"))) 
((|HasCategory| $ '(|CharacteristicNonZero|)) (|HasCategory| $ '(|Field|))
 (|HasCategory| $ '(|Finite|))) 
(|InternalPrintPackage|) 
((|constructor|
  (NIL "A package to print strings without line-feed nor carriage-return."))
 (|iprint|
  (((|Void|) (|String|))
   "\\spad{iprint(s)} prints \\spad{s} at the current position of the cursor."))) 
NIL 
(|IntegrationResult| F) 
((|constructor|
  (NIL
   "If a function \\spad{f} has an elementary integral \\spad{g},{} then \\spad{g} can be written in the form \\spad{g = h + c1 log(u1) + c2 log(u2) + ... + cn log(un)} where \\spad{h},{} which is in the same field as \\spad{f},{} is called the rational part of the integral,{} and \\spad{c1 log(u1) + ... cn log(un)} is called the logarithmic part of the integral. This domain manipulates integrals represented in that form,{} by keeping both parts separately. The logs are not explicitly computed."))
 (|differentiate|
  ((|#1| $ (|Symbol|))
   "\\spad{differentiate(ir,{} x)} differentiates \\spad{ir} with respect to \\spad{x}")
  ((|#1| $ (|Mapping| |#1| |#1|))
   "\\spad{differentiate(ir,{} D)} differentiates \\spad{ir} with respect to the derivation \\spad{D}."))
 (|integral|
  (($ |#1| (|Symbol|))
   "\\spad{integral(f,{} x)} returns the formal integral of \\spad{f} with respect to \\spad{x}")
  (($ |#1| |#1|)
   "\\spad{integral(f,{} x)} returns the formal integral of \\spad{f} with respect to \\spad{x}"))
 (|elem?|
  (((|Boolean|) $)
   "\\spad{elem?(ir)} tests if an integration result is elementary over \\spad{F?}"))
 (|notelem|
  (((|List| (|Record| (|:| |integrand| |#1|) (|:| |intvar| |#1|))) $)
   "\\spad{notelem(ir)} returns the non-elementary part of an integration result"))
 (|logpart|
  (((|List|
     (|Record| (|:| |scalar| (|Fraction| (|Integer|)))
               (|:| |coeff| (|SparseUnivariatePolynomial| |#1|))
               (|:| |logand| (|SparseUnivariatePolynomial| |#1|))))
    $)
   "\\spad{logpart(ir)} returns the logarithmic part of an integration result"))
 (|ratpart|
  ((|#1| $)
   "\\spad{ratpart(ir)} returns the rational part of an integration result"))
 (|mkAnswer|
  (($ |#1|
    (|List|
     (|Record| (|:| |scalar| (|Fraction| (|Integer|)))
               (|:| |coeff| (|SparseUnivariatePolynomial| |#1|))
               (|:| |logand| (|SparseUnivariatePolynomial| |#1|))))
    (|List| (|Record| (|:| |integrand| |#1|) (|:| |intvar| |#1|))))
   "\\spad{mkAnswer(r,{} l,{} ne)} creates an integration result from a rational part \\spad{r},{} a logarithmic part \\spad{l},{} and a non-elementary part ne."))) 
((|HasCategory| (|Fraction| (|Integer|)) '(|AbelianGroup|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|))
 (OR (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianGroup|))
     (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Symbol|)))) 
(|IntegrationResultFunctions2| E F) 
((|constructor|
  (NIL
   "\\indented{1}{Internally used by the integration packages} Author: Manuel Bronstein Date Created: 1987 Keywords: integration."))
 (|map|
  (((|Union|
     (|Record| (|:| |mainpart| |#2|)
               (|:| |limitedlogs|
                    (|List|
                     (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|)))))
     "failed")
    (|Mapping| |#2| |#1|)
    (|Union|
     (|Record| (|:| |mainpart| |#1|)
               (|:| |limitedlogs|
                    (|List|
                     (|Record| (|:| |coeff| |#1|) (|:| |logand| |#1|)))))
     "failed"))
   "\\spad{map(f,{} ufe)} \\undocumented")
  (((|Union| |#2| "failed") (|Mapping| |#2| |#1|) (|Union| |#1| "failed"))
   "\\spad{map(f,{} ue)} \\undocumented")
  (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed")
    (|Mapping| |#2| |#1|)
    (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed"))
   "\\spad{map(f,{} ure)} \\undocumented")
  (((|IntegrationResult| |#2|) (|Mapping| |#2| |#1|)
    (|IntegrationResult| |#1|))
   "\\spad{map(f,{} ire)} \\undocumented"))) 
NIL 
(|IntegrationResultToFunction| R F) 
((|constructor|
  (NIL
   "This package allows a sum of logs over the roots of a polynomial to be expressed as explicit logarithms and arc tangents,{} provided that the indexing polynomial can be factored into quadratics."))
 (|complexExpand|
  ((|#2| (|IntegrationResult| |#2|))
   "\\spad{complexExpand(i)} returns the expanded complex function corresponding to \\spad{i}."))
 (|expand|
  (((|List| |#2|) (|IntegrationResult| |#2|) (|Symbol|))
   "\\spad{expand(i,{} x)} returns the list of possible real functions of \\spad{x} corresponding to \\spad{i}."))
 (|split|
  (((|IntegrationResult| |#2|) (|IntegrationResult| |#2|))
   "\\spad{split(u(x) + sum_{P(a)=0} Q(a,{} x))} returns \\spad{u(x) + sum_{P1(a)=0} Q(a,{} x) + ... + sum_{Pn(a)=0} Q(a,{} x)} where \\spad{P1},{} ...,{} \\spad{Pn} are the factors of \\spad{P}."))) 
NIL 
(|IntegerRoots| I) 
((|constructor|
  (NIL
   "The \\spadtype{IntegerRoots} package computes square roots and \\indented{2}{\\spad{n}th roots of integers efficiently.}"))
 (|approxSqrt|
  ((|#1| |#1|)
   "\\spad{approxSqrt(n)} returns an approximation \\spad{x} to \\spad{sqrt(n)} such that \\spad{-1 < x - sqrt(n) < 1}. Returns 0 if \\spad{n} is negative. A variable precision Newton iteration is used. The running time is \\spad{O( log(n)^2 )}."))
 (|perfectSqrt|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{perfectSqrt(n)} returns the square root of \\spad{n} if \\spad{n} is a perfect square and returns \"failed\" otherwise"))
 (|perfectSquare?|
  (((|Boolean|) |#1|)
   "\\spad{perfectSquare?(n)} returns \\spad{true} if \\spad{n} is a perfect square and \\spad{false} otherwise"))
 (|approxNthRoot|
  ((|#1| |#1| (|NonNegativeInteger|))
   "\\spad{approxRoot(n,{} r)} returns an approximation \\spad{x} to \\spad{n^(1/r)} such that \\spad{-1 < x - n^(1/r) < 1}"))
 (|perfectNthRoot|
  (((|Record| (|:| |base| |#1|) (|:| |exponent| (|NonNegativeInteger|))) |#1|)
   "\\spad{perfectNthRoot(n)} returns \\spad{[x,{} r]},{} where \\spad{n = x\\^r} and \\spad{r} is the largest integer such that \\spad{n} is a perfect \\spad{r}th power")
  (((|Union| |#1| "failed") |#1| (|NonNegativeInteger|))
   "\\spad{perfectNthRoot(n,{} r)} returns the \\spad{r}th root of \\spad{n} if \\spad{n} is an \\spad{r}th power and returns \"failed\" otherwise"))
 (|perfectNthPower?|
  (((|Boolean|) |#1| (|NonNegativeInteger|))
   "\\spad{perfectNthPower?(n,{} r)} returns \\spad{true} if \\spad{n} is an \\spad{r}th power and \\spad{false} otherwise"))) 
NIL 
(|IrredPolyOverFiniteField| GF) 
((|constructor|
  (NIL
   "This package exports the function generateIrredPoly that computes a monic irreducible polynomial of degree \\spad{n} over a finite field."))
 (|generateIrredPoly|
  (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|))
   "\\spad{generateIrredPoly(n)} generates an irreducible univariate polynomial of the given degree \\spad{n} over the finite field."))) 
NIL 
(|IntegrationResultRFToFunction| R) 
((|constructor|
  (NIL
   "\\indented{2}{This package allows a sum of logs over the roots of a polynomial} \\indented{2}{to be expressed as explicit logarithms and arc tangents,{} provided} \\indented{2}{that the indexing polynomial can be factored into quadratics.} Date Created: 21 August 1988"))
 (|complexIntegrate|
  (((|Expression| |#1|) (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{complexIntegrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable."))
 (|integrate|
  (((|Union| (|Expression| |#1|) (|List| (|Expression| |#1|)))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{integrate(f,{} x)} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a real variable."))
 (|complexExpand|
  (((|Expression| |#1|) (|IntegrationResult| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{complexExpand(i)} returns the expanded complex function corresponding to \\spad{i}."))
 (|expand|
  (((|List| (|Expression| |#1|))
    (|IntegrationResult| (|Fraction| (|Polynomial| |#1|))) (|Symbol|))
   "\\spad{expand(i,{} x)} returns the list of possible real functions of \\spad{x} corresponding to \\spad{i}."))
 (|split|
  (((|IntegrationResult| (|Fraction| (|Polynomial| |#1|)))
    (|IntegrationResult| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{split(u(x) + sum_{P(a)=0} Q(a,{} x))} returns \\spad{u(x) + sum_{P1(a)=0} Q(a,{} x) + ... + sum_{Pn(a)=0} Q(a,{} x)} where \\spad{P1},{} ...,{} \\spad{Pn} are the factors of \\spad{P}."))) 
((|HasCategory| |#1| '(|CharacteristicZero|))) 
(|IrrRepSymNatPackage|) 
((|constructor|
  (NIL
   "IrrRepSymNatPackage contains functions for computing the ordinary irreducible representations of symmetric groups on \\spad{n} letters {\\em {1,{} 2,{} ...,{} n}} in Young\\spad{'s} natural form and their dimensions. These representations can be labelled by number partitions of \\spad{n},{} \\spadignore{i.e.} a weakly decreasing sequence of integers summing up to \\spad{n},{} \\spadignore{e.g.} {\\em [3,{} 3,{} 3,{} 1]} labels an irreducible representation for \\spad{n} equals 10. Note: whenever a \\spadtype{List Integer} appears in a signature,{} a partition required."))
 (|irreducibleRepresentation|
  (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|))
    (|List| (|Permutation| (|Integer|))))
   "\\spad{irreducibleRepresentation(lambda,{} listOfPerm)} is the list of the irreducible representations corresponding to {\\em lambda} in Young\\spad{'s} natural form for the list of permutations given by {\\em listOfPerm}.")
  (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|)))
   "\\spad{irreducibleRepresentation(lambda)} is the list of the two irreducible representations corresponding to the partition {\\em lambda} in Young\\spad{'s} natural form for the following two generators of the symmetric group,{} whose elements permute {\\em {1,{} 2,{} ...,{} n}},{} namely {\\em (1 2)} (2-cycle) and {\\em (1 2 ... n)} (\\spad{n}-cycle).")
  (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|Permutation| (|Integer|)))
   "\\spad{irreducibleRepresentation(lambda,{} \\spad{pi})} is the irreducible representation corresponding to partition {\\em lambda} in Young\\spad{'s} natural form of the permutation {\\em \\spad{pi}} in the symmetric group,{} whose elements permute {\\em {1,{} 2,{} ...,{} n}}."))
 (|dimensionOfIrreducibleRepresentation|
  (((|NonNegativeInteger|) (|List| (|Integer|)))
   "\\spad{dimensionOfIrreducibleRepresentation(lambda)} is the dimension of the ordinary irreducible representation of the symmetric group corresponding to {\\em lambda}. Note: the Robinson-Thrall hook formula is implemented."))) 
NIL 
(|InternalRationalUnivariateRepresentationPackage| R E V P TS) 
((|constructor|
  (NIL
   "\\indented{1}{An internal package for computing the rational univariate representation} \\indented{1}{of a zero-dimensional algebraic variety given by a square-free} \\indented{1}{triangular set.} \\indented{1}{The main operation is \\spadopFrom{rur}{InternalRationalUnivariateRepresentationPackage}.} \\indented{1}{It is based on the {\\em generic} algorithm description in [1]. \\newline References:} [1] \\spad{D}. LAZARD \"Solving Zero-dimensional Algebraic Systems\" \\indented{4}{Journal of Symbolic Computation,{} 1992,{} 13,{} 117-131}"))
 (|checkRur|
  (((|Boolean|) |#5| (|List| |#5|))
   "\\spad{checkRur(ts,{} lus)} returns \\spad{true} if \\spad{lus} is a rational univariate representation of \\spad{ts}."))
 (|rur|
  (((|List| |#5|) |#5| (|Boolean|))
   "\\spad{rur(ts,{} univ?)} returns a rational univariate representation of \\spad{ts}. This assumes that the lowest polynomial in \\spad{ts} is a variable \\spad{v} which does not occur in the other polynomials of \\spad{ts}. This variable will be used to define the simple algebraic extension over which these other polynomials will be rewritten as univariate polynomials with degree one. If \\spad{univ?} is \\spad{true} then these polynomials will have a constant initial."))) 
NIL 
(|IntegerSmithNormalForm|) 
((|completeSmith|
  (((|Record| (|:| |Smith| (|Matrix| (|Integer|)))
              (|:| |leftEqMat| (|Matrix| (|Integer|)))
              (|:| |rightEqMat| (|Matrix| (|Integer|))))
    (|Matrix| (|Integer|))
    (|Mapping|
     (|Record| (|:| |Smith| (|Matrix| (|Integer|)))
               (|:| |leftEqMat| (|Matrix| (|Integer|)))
               (|:| |rightEqMat| (|Matrix| (|Integer|))))
     (|Matrix| (|Integer|))))
   "\\spad{completeSmith(m,{} full)} computes record containing Smith normal form of \\spad{m} and the left and right equivalence matrices. It first reduces \\spad{m} to smaller matrix and then uses full to finish."))
 (|smith|
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|))
    (|Mapping| (|Matrix| (|Integer|)) (|Matrix| (|Integer|))))
   "\\spad{smith(m,{} full)} computes Smith normal form of \\spad{m}. It first reduces \\spad{m} to smaller matrix and then uses full to finish.")
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)))
   "\\spad{smith(m)} computes Smith normal form of \\spad{m}"))) 
NIL 
(|IndexedString| |mn|) 
((|constructor| (NIL "This domain implements low-level strings"))) 
((|HasCategory| (|Character|) '(|OrderedSet|))
 (|HasCategory| (|Character|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Character|) '(|BasicType|))
 (|HasCategory| (|Character|) '(|Comparable|))
 (OR (|HasCategory| (|Character|) '(|Comparable|))
     (|HasCategory| (|Character|) '(|OrderedSet|)))
 (|HasCategory| (|Character|) '(|SetCategory|))
 (AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
      (|HasCategory| (|Character|) '(|SetCategory|)))
 (OR (|HasCategory| (|Character|) '(|BasicType|))
     (|HasCategory| (|Character|) '(|Comparable|))
     (|HasCategory| (|Character|) '(|OrderedSet|))
     (|HasCategory| (|Character|) '(|SetCategory|)))
 (OR (|HasCategory| (|Character|) '(|Comparable|))
     (|HasCategory| (|Character|) '(|OrderedSet|))
     (|HasCategory| (|Character|) '(|SetCategory|)))
 (|HasCategory| (|Character|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Character|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Character|) '(|Comparable|))
     (|HasCategory| (|Character|) '(|OrderedSet|))
     (|HasCategory| (|Character|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Character|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|OrderedSet|)))
  (|HasCategory| (|Character|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|OrderedSet|)))
  (|HasCategory| (|Character|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|OrderedSet|)))
  (|HasCategory| (|Character|) '(|SetCategory|)))) 
(|InnerPolySum| E V R P) 
((|constructor| (NIL "tools for the summation packages."))
 (|sum|
  (((|Record| (|:| |num| |#4|) (|:| |den| (|Integer|))) |#4| |#2|)
   "\\spad{sum(p(n),{} n)} returns \\spad{P(n)},{} the indefinite sum of \\spad{p(n)} with respect to upward difference on \\spad{n},{} \\spadignore{i.e.} \\spad{P(n+1) - P(n) = p(n)}.")
  (((|Record| (|:| |num| |#4|) (|:| |den| (|Integer|))) |#4| |#2|
    (|Segment| |#4|))
   "\\spad{sum(p(n),{} n = a..b)} returns \\spad{p(a) + p(a+1) + ... + p(b)}."))) 
NIL 
(|InnerSparseUnivariatePowerSeries| |Coef|) 
((|constructor|
  (NIL
   "InnerSparseUnivariatePowerSeries is an internal domain \\indented{2}{used for creating sparse Taylor and Laurent series.}"))
 (|cAcsch|
  (($ $)
   "\\spad{cAcsch(f)} computes the inverse hyperbolic cosecant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAsech|
  (($ $)
   "\\spad{cAsech(f)} computes the inverse hyperbolic secant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAcoth|
  (($ $)
   "\\spad{cAcoth(f)} computes the inverse hyperbolic cotangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAtanh|
  (($ $)
   "\\spad{cAtanh(f)} computes the inverse hyperbolic tangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAcosh|
  (($ $)
   "\\spad{cAcosh(f)} computes the inverse hyperbolic cosine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAsinh|
  (($ $)
   "\\spad{cAsinh(f)} computes the inverse hyperbolic sine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCsch|
  (($ $)
   "\\spad{cCsch(f)} computes the hyperbolic cosecant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cSech|
  (($ $)
   "\\spad{cSech(f)} computes the hyperbolic secant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCoth|
  (($ $)
   "\\spad{cCoth(f)} computes the hyperbolic cotangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cTanh|
  (($ $)
   "\\spad{cTanh(f)} computes the hyperbolic tangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCosh|
  (($ $)
   "\\spad{cCosh(f)} computes the hyperbolic cosine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cSinh|
  (($ $)
   "\\spad{cSinh(f)} computes the hyperbolic sine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAcsc|
  (($ $)
   "\\spad{cAcsc(f)} computes the arccosecant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAsec|
  (($ $)
   "\\spad{cAsec(f)} computes the arcsecant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAcot|
  (($ $)
   "\\spad{cAcot(f)} computes the arccotangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAtan|
  (($ $)
   "\\spad{cAtan(f)} computes the arctangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAcos|
  (($ $)
   "\\spad{cAcos(f)} computes the arccosine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cAsin|
  (($ $)
   "\\spad{cAsin(f)} computes the arcsine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCsc|
  (($ $)
   "\\spad{cCsc(f)} computes the cosecant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cSec|
  (($ $)
   "\\spad{cSec(f)} computes the secant of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCot|
  (($ $)
   "\\spad{cCot(f)} computes the cotangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cTan|
  (($ $)
   "\\spad{cTan(f)} computes the tangent of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cCos|
  (($ $)
   "\\spad{cCos(f)} computes the cosine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cSin|
  (($ $)
   "\\spad{cSin(f)} computes the sine of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cLog|
  (($ $)
   "\\spad{cLog(f)} computes the logarithm of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cExp|
  (($ $)
   "\\spad{cExp(f)} computes the exponential of the power series \\spad{f}. For use when the coefficient ring is commutative."))
 (|cRationalPower|
  (($ $ (|Fraction| (|Integer|)))
   "\\spad{cRationalPower(f,{} r)} computes \\spad{f^r}. For use when the coefficient ring is commutative."))
 (|cPower|
  (($ $ |#1|)
   "\\spad{cPower(f,{} r)} computes \\spad{f^r},{} where \\spad{f} has constant coefficient 1. For use when the coefficient ring is commutative."))
 (|integrate|
  (($ $)
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. Warning: function does not check for a term of degree \\spad{-1}."))
 (|seriesToOutputForm|
  (((|OutputForm|) (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)))
    (|Reference| (|OrderedCompletion| (|Integer|))) (|Symbol|) |#1|
    (|Fraction| (|Integer|)))
   "\\spad{seriesToOutputForm(st,{} refer,{} var,{} cen,{} r)} prints the series \\spad{f((var - cen)^r)}."))
 (|iCompose|
  (($ $ $)
   "\\spad{iCompose(f,{} g)} returns \\spad{f(g(x))}. This is an internal function which should only be called for Taylor series \\spad{f(x)} and \\spad{g(x)} such that the constant coefficient of \\spad{g(x)} is zero."))
 (|taylorQuoByVar|
  (($ $)
   "\\spad{taylorQuoByVar(a0 + a1 x + a2 x^2 + ...)} returns \\spad{a1 + a2 x + a3 x^2 + ...}"))
 (|iExquo|
  (((|Union| $ "failed") $ $ (|Boolean|))
   "\\spad{iExquo(f,{} g,{} taylor?)} is the quotient of the power series \\spad{f} and \\spad{g}. If \\spad{taylor?} is \\spad{true},{} then we must have \\spad{order(f) >= order(g)}."))
 (|multiplyCoefficients|
  (($ (|Mapping| |#1| (|Integer|)) $)
   "\\spad{multiplyCoefficients(fn,{} f)} returns the series \\spad{sum(fn(n) * an * x^n,{} n = n0..)},{} where \\spad{f} is the series \\spad{sum(an * x^n,{} n = n0..)}."))
 (|monomial?|
  (((|Boolean|) $)
   "\\spad{monomial?(f)} tests if \\spad{f} is a single monomial."))
 (|series|
  (($ (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))))
   "\\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))
 (|getStream|
  (((|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))) $)
   "\\spad{getStream(f)} returns the stream of terms representing the series \\spad{f}."))
 (|getRef|
  (((|Reference| (|OrderedCompletion| (|Integer|))) $)
   "\\spad{getRef(f)} returns a reference containing the order to which the terms of \\spad{f} have been computed."))
 (|makeSeries|
  (($ (|Reference| (|OrderedCompletion| (|Integer|)))
    (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))))
   "\\spad{makeSeries(refer,{} str)} creates a power series from the reference \\spad{refer} and the stream \\spad{str}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|Integer|)
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|) '(|Integer|)
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Integer|) '(|SemiGroup|))
 (|HasCategory| (|Integer|) '(|Comparable|)) (|HasCategory| |#1| '(|Field|))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|Integer|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|Integer|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))) 
(|InnerTaylorSeries| |Coef|) 
((|constructor|
  (NIL
   "Internal package for dense Taylor series. This is an internal Taylor series type in which Taylor series are represented by a \\spadtype{Stream} of \\spadtype{Ring} elements. For univariate series,{} the \\spad{Stream} elements are the Taylor coefficients. For multivariate series,{} the \\spad{n}th Stream element is a form of degree \\spad{n} in the power series variables."))
 (*
  (($ $ (|Integer|))
   "\\spad{x*i} returns the product of integer \\spad{i} and the series \\spad{x}.")
  (($ $ |#1|)
   "\\spad{x*c} returns the product of \\spad{c} and the series \\spad{x}.")
  (($ |#1| $)
   "\\spad{c*x} returns the product of \\spad{c} and the series \\spad{x}."))
 (|order|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{order(x,{} n)} returns the minimum of \\spad{n} and the order of \\spad{x}.")
  (((|NonNegativeInteger|) $)
   "\\spad{order(x)} returns the order of a power series \\spad{x},{} \\indented{1}{\\spadignore{i.e.} the degree of the first non-zero term of the series.}"))
 (|pole?|
  (((|Boolean|) $)
   "\\spad{pole?(x)} tests if the series \\spad{x} has a pole. \\indented{1}{Note: this is \\spad{false} when \\spad{x} is a Taylor series.}"))
 (|series|
  (($ (|Stream| |#1|))
   "\\spad{series(s)} creates a power series from a stream of \\indented{1}{ring elements.} \\indented{1}{For univariate series types,{} the stream \\spad{s} should be a stream} \\indented{1}{of Taylor coefficients. For multivariate series types,{} the} \\indented{1}{stream \\spad{s} should be a stream of forms the \\spad{n}th element} \\indented{1}{of which is a} \\indented{1}{form of degree \\spad{n} in the power series variables.}"))
 (|coefficients|
  (((|Stream| |#1|) $)
   "\\spad{coefficients(x)} returns a stream of ring elements. \\indented{1}{When \\spad{x} is a univariate series,{} this is a stream of Taylor} \\indented{1}{coefficients. When \\spad{x} is a multivariate series,{} the} \\indented{1}{\\spad{n}th element of the stream is a form of} \\indented{1}{degree \\spad{n} in the power series variables.}"))) 
((|HasCategory| |#1| '(|IntegralDomain|))) 
(|InfiniteTupleFunctions2| A B) 
((|constructor| (NIL "Functions defined on streams with entries in two sets."))
 (|map|
  (((|InfiniteTuple| |#2|) (|Mapping| |#2| |#1|) (|InfiniteTuple| |#1|))
   "\\spad{map(f,{} [x0,{} x1,{} x2,{} ...])} returns \\spad{[f(x0),{} f(x1),{} f(x2),{} ..]}."))) 
NIL 
(|InfiniteTupleFunctions3| A B C) 
((|constructor|
  (NIL "Functions defined on streams with entries in three sets."))
 (|map|
  (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|InfiniteTuple| |#1|)
    (|Stream| |#2|))
   "\\spad{map(f,{} a,{} b)} \\undocumented")
  (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|Stream| |#1|)
    (|InfiniteTuple| |#2|))
   "\\spad{map(f,{} a,{} b)} \\undocumented")
  (((|InfiniteTuple| |#3|) (|Mapping| |#3| |#1| |#2|) (|InfiniteTuple| |#1|)
    (|InfiniteTuple| |#2|))
   "\\spad{map(f,{} a,{} b)} \\undocumented"))) 
NIL 
(|InnerTrigonometricManipulations| R F FG) 
((|constructor|
  (NIL
   "This package provides transformations from trigonometric functions to exponentials and logarithms,{} and back. \\spad{F} and \\spad{FG} should be the same type of function space."))
 (|do_liou|
  (((|Complex| |#2|) (|BasicOperator|) (|List| (|Complex| |#2|)))
   "\\spad{do_liou(op,{} lf)} should be local but conditional."))
 (|trigs2explogs|
  ((|#3| |#3| (|List| (|Kernel| |#3|)))
   "\\spad{trigs2explogs(f,{} [k1,{} ...,{} kn])} rewrites all the trigonometric functions appearing in \\spad{f} in terms of complex logarithms and exponentials. A kernel of the form \\spad{tan(u)} is expressed using \\spad{exp(u)^2} if it is one of the \\spad{\\spad{ki}'s},{} in terms of \\spad{exp(2*u)} otherwise."))
 (|explogs2trigs|
  (((|Complex| |#2|) |#3|)
   "\\spad{explogs2trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions."))
 (F2FG ((|#3| |#2|) "\\spad{F2FG(a + sqrt(-1) b)} returns \\spad{a + i b}."))
 (FG2F ((|#2| |#3|) "\\spad{FG2F(a + i b)} returns \\spad{a + sqrt(-1) b}."))
 (GF2FG
  ((|#3| (|Complex| |#2|))
   "\\spad{GF2FG(a + i b)} returns \\spad{a + i b} viewed as a function with the \\spad{i} pushed down into the coefficient domain."))) 
NIL 
(|InfiniteTuple| S) 
((|constructor|
  (NIL
   "\\indented{1}{This package implements 'infinite tuples' for the interpreter.} The representation is a stream."))
 (|construct|
  (((|Stream| |#1|) $)
   "\\spad{construct(t)} converts an infinite tuple to a stream."))
 (|stream|
  (($ (|Mapping| |#1| |#1|) |#1|)
   "\\spad{stream(f,{} s)} returns \\spad{[s,{} f(s),{} f(f(s)),{} ...]}."))
 (|select|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{select(p,{} t)} returns \\spad{[x for x in t | p(x)]}."))
 (|filterUntil|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{filterUntil(p,{} t)} returns \\spad{[x for x in t while not p(x)]}."))
 (|filterWhile|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{filterWhile(p,{} t)} returns \\spad{[x for x in t while p(x)]}."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} t)} replaces the tuple \\spad{t} by \\spad{[f(x) for x in t]}."))) 
NIL 
(|IndexedVector| R |mn|) 
((|constructor|
  (NIL
   "\\indented{2}{This type represents vector like objects with varying lengths} and a user-specified initial index."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (|HasCategory| |#1| '(|AbelianMonoid|)) (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|SemiGroup|))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|Ring|))
 (AND (|HasCategory| |#1| '(|RadicalCategory|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|IndexedAggregate&| S |Index| |Entry|) 
((|constructor|
  (NIL
   "An indexed aggregate is a many-to-one mapping of indices to entries. For example,{} a one-dimensional-array is an indexed aggregate where the index is an integer. Also,{} a table is an indexed aggregate where the indices and entries may have any type."))
 (|swap!|
  (((|Void|) $ |#2| |#2|)
   "\\spad{swap!(u,{} i,{} j)} interchanges elements \\spad{i} and \\spad{j} of aggregate \\spad{u}. No meaningful value is returned."))
 (|fill!|
  (($ $ |#3|)
   "\\spad{fill!(u,{} x)} replaces each entry in aggregate \\spad{u} by \\spad{x}. The modified \\spad{u} is returned as value."))
 (|first|
  ((|#3| $)
   "\\spad{first(u)} returns the first element \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{first([x,{} y,{} ...,{} z]) = x}. Error: if \\spad{u} is empty."))
 (|minIndex|
  ((|#2| $)
   "\\spad{minIndex(u)} returns the minimum index \\spad{i} of aggregate \\spad{u}. Note: in general,{} \\spad{minIndex(a) = reduce(min,{} indices a)}; for List,{} \\spad{minIndex(a) = 1}."))
 (|maxIndex|
  ((|#2| $)
   "\\spad{maxIndex(u)} returns the maximum index \\spad{i} of aggregate \\spad{u}. Note: in general,{} \\spad{maxIndex(u) = reduce(max,{} indices u)}; for List,{} \\spad{maxIndex(u) = \\#u}."))
 (|entry?|
  (((|Boolean|) |#3| $)
   "\\spad{entry?(x,{} u)} tests if \\spad{x} equals \\spad{u . i} for some index \\spad{i}."))
 (|indices|
  (((|List| |#2|) $)
   "\\spad{indices(u)} returns a list of indices of aggregate \\spad{u} in no particular order."))
 (|index?|
  (((|Boolean|) |#2| $)
   "\\spad{index?(i,{} u)} tests if \\spad{i} is an index of aggregate \\spad{u}."))
 (|entries|
  (((|List| |#3|) $)
   "\\spad{entries(u)} returns a list of all the entries of aggregate \\spad{u} in no assumed order."))) 
((|HasCategory| |#1| '(|shallowlyMutable|))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#1| '(|finiteAggregate|))
 (|HasCategory| |#3| '(|BasicType|))) 
(|IndexedAggregate| |Index| |Entry|) 
((|constructor|
  (NIL
   "An indexed aggregate is a many-to-one mapping of indices to entries. For example,{} a one-dimensional-array is an indexed aggregate where the index is an integer. Also,{} a table is an indexed aggregate where the indices and entries may have any type."))
 (|swap!|
  (((|Void|) $ |#1| |#1|)
   "\\spad{swap!(u,{} i,{} j)} interchanges elements \\spad{i} and \\spad{j} of aggregate \\spad{u}. No meaningful value is returned."))
 (|fill!|
  (($ $ |#2|)
   "\\spad{fill!(u,{} x)} replaces each entry in aggregate \\spad{u} by \\spad{x}. The modified \\spad{u} is returned as value."))
 (|first|
  ((|#2| $)
   "\\spad{first(u)} returns the first element \\spad{x} of \\spad{u}. Note: for collections,{} \\spad{first([x,{} y,{} ...,{} z]) = x}. Error: if \\spad{u} is empty."))
 (|minIndex|
  ((|#1| $)
   "\\spad{minIndex(u)} returns the minimum index \\spad{i} of aggregate \\spad{u}. Note: in general,{} \\spad{minIndex(a) = reduce(min,{} indices a)}; for List,{} \\spad{minIndex(a) = 1}."))
 (|maxIndex|
  ((|#1| $)
   "\\spad{maxIndex(u)} returns the maximum index \\spad{i} of aggregate \\spad{u}. Note: in general,{} \\spad{maxIndex(u) = reduce(max,{} indices u)}; for List,{} \\spad{maxIndex(u) = \\#u}."))
 (|entry?|
  (((|Boolean|) |#2| $)
   "\\spad{entry?(x,{} u)} tests if \\spad{x} equals \\spad{u . i} for some index \\spad{i}."))
 (|indices|
  (((|List| |#1|) $)
   "\\spad{indices(u)} returns a list of indices of aggregate \\spad{u} in no particular order."))
 (|index?|
  (((|Boolean|) |#1| $)
   "\\spad{index?(i,{} u)} tests if \\spad{i} is an index of aggregate \\spad{u}."))
 (|entries|
  (((|List| |#2|) $)
   "\\spad{entries(u)} returns a list of all the entries of aggregate \\spad{u} in no assumed order."))) 
NIL 
(|JetBundleBaseFunctionCategory&| S JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleBaseFunctionCategory} defines the category of functions (local sections) of the base space of a jet bundle,{} \\spadignore{i.e.} functions depending only on the independent variables. Such a category is needed \\spadignore{e.g.} for the representation of solutions."))) 
NIL 
(|JetBundleBaseFunctionCategory| JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleBaseFunctionCategory} defines the category of functions (local sections) of the base space of a jet bundle,{} \\spadignore{i.e.} functions depending only on the independent variables. Such a category is needed \\spadignore{e.g.} for the representation of solutions."))) 
NIL 
(|JetBundleCategory&| S) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleCategory} provides basic data structures and procedures for jet bundles. Nearly all necessary functions are implemented already here. Only the representation and functions which directly access it must be implemented in a domain. Two notations of derivatives are supported. Default is multi-index notation,{} where the \\spad{i}-th entry of the index denotes the number of differentiations taken with respect to \\spad{x^i}. In repeated index notation each entry \\spad{i} in the index denotes a differentiation with respect to \\spad{x^i}. The choice affects,{} however,{} only in- and output. Internally,{} multi-index notation is used throughout."))
 (|numDepVar|
  (((|PositiveInteger|))
   "\\spad{numDepVar} returns the number of dependent variables."))
 (|numIndVar|
  (((|PositiveInteger|))
   "\\spad{numIndVar} returns the number of independent variables."))
 (|dimS|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimS(q)} computes dimension of \\spad{SqT} \\spad{x} VE (= number of derivatives of order \\spad{q})."))
 (|dimJ|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimJ(q)} computes the (fibre) dimension of the \\spad{q}\\spad{-}th order jet bundle."))
 (|variables|
  (((|List| $) (|NonNegativeInteger|) (|PositiveInteger|))
   "\\spad{variables(q,{} c)} computes all jet variables of order \\spad{q} whose class is greater than or equal to \\spad{c}.")
  (((|List| $) (|NonNegativeInteger|))
   "\\spad{variables(q)} computes the list of all jet variables up to order \\spad{q}."))
 (|one?|
  (((|Boolean|) $)
   "\\spad{one?(jv)} checks whether the jet variables \\spad{jv} is the special variable 1."))
 ((|One|)
  (($)
   "\\spad{1} generates the special \"jet variable\" 1,{} which is needed for the representation of linear functions."))
 (|Pr|
  (($ (|PositiveInteger|) (|List| (|PositiveInteger|)))
   "\\spad{Pr(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a repeated index."))
 (|Pm|
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{Pm(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a multi-index."))
 (P
  (($ (|NonNegativeInteger|))
   "\\spad{P(i)} generates the \\spad{i}\\spad{-}th derivative of the only dependent variable \\spad{wrt} the only independent variable.")
  (($ (|PositiveInteger|) (|NonNegativeInteger|))
   "\\spad{P(i,{} j)} generates the \\spad{j}\\spad{-}th derivative of the \\spad{i}\\spad{-}th independent variable \\spad{wrt} the only independent variable.")
  (($ (|List| (|NonNegativeInteger|)))
   "\\spad{P(ind)} generates the derivative of the only dependent variable \\spad{wrt} the index \\spad{ind}.")
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{P(i,{} ind)} generates the derivative of the \\spad{i}\\spad{-}th dependent variable \\spad{wrt} the index \\spad{ind}. Whether \\spad{ind} is interpreted as multi-index or as repeated index depends on the chosen notation."))
 (U (($) "\\spad{U()} generates the only dependent variable.")
  (($ (|PositiveInteger|))
   "\\spad{U(i)} generates the \\spad{i}\\spad{-}th dependent variable."))
 (X (($) "\\spad{X()} generates the only independent variable.")
  (($ (|PositiveInteger|))
   "\\spad{X(i)} generates the \\spad{i}\\spad{-}th independent variable."))
 (|integrate|
  (($ $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} is like \\spad{integrateIfCan(jv,{} i)} but yields an error,{} if the integration is not possible."))
 (|integrateIfCan|
  (((|Union| $ "failed") $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} integrated \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable,{} if possible."))
 (|derivativeOf?|
  (((|List| (|NonNegativeInteger|)) $ $)
   "\\spad{derivativeOf?(jv1,{} jv2)} checks whether \\spad{jv1} is a derivative of \\spad{jv2}. In this case,{} the difference of their multi-indices is returned. Otherwise,{} an empty list is returned."))
 (|differentiate|
  (((|Union| $ "0") $ (|PositiveInteger|))
   "\\spad{differentiate(jv,{} i)} differentiates \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable."))
 (>
  (((|Boolean|) $ $)
   "\\spad{jv1 > jv2} checks whether \\spad{jv1} is greater than \\spad{jv2} in the internal ordering."))
 (|weight|
  (((|NonNegativeInteger|) $)
   "\\spad{weight(jv)} assigns each jet variable a unique integer reflecting its position in the internal ordering. The variable with the greater weight is also greater in this ordering."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(jv)} yields the order of the jet variable \\spad{jv} (Order as derivative)."))
 (|class|
  (((|NonNegativeInteger|) $)
   "\\spad{class(jv)} yields the class of the jet variable \\spad{jv} (Class of multi-index for derivative,{} 0 else).")
  (((|NonNegativeInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{class(ind)} yields the class of the multi-index \\spad{ind} (Position for first non-vanishing entry)."))
 (|name|
  (((|Symbol|) $)
   "\\spad{name(jv)} yields the name of the jet variable \\spad{jv}."))
 (|type|
  (((|Symbol|) $)
   "\\spad{type(jv)} yields the type (\\spad{Const,{} Indep,{} Dep,{} Deriv}) of the jet variable \\spad{jv}."))
 (|index|
  (((|PositiveInteger|) $)
   "\\spad{index(jv)} yields number of the jet variable \\spad{jv}."))
 (|allRepeated|
  (((|List| (|List| (|PositiveInteger|))) (|List| (|NonNegativeInteger|)))
   "\\spad{allRepeated(ind)} returns a list of all possible realizations of a given multi-index as repeated index."))
 (|m2r|
  (((|List| (|PositiveInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{m2r(ind)} transforms a multi-index into a repeated index."))
 (|r2m|
  (((|List| (|NonNegativeInteger|)) (|List| (|PositiveInteger|)))
   "\\spad{r2m(ind)} transforms a repeated index into a multi-index."))
 (|repeatedIndex|
  (((|List| (|PositiveInteger|)) $)
   "\\spad{repeatedIndex(jv)} returns the multi-index of the jet variable \\spad{jv} in repeated index notation."))
 (|multiIndex|
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{multiIndex(jv)} returns the multi-index of the jet variable \\spad{jv}."))
 (|getNotation|
  (((|Symbol|)) "\\spad{getNotation()} shows the currently used notation."))
 (|setNotation|
  (((|Symbol|) (|Symbol|))
   "\\spad{setNotation(s)} chooses the notation used for derivatives. Returns the old value."))) 
NIL 
(|JetBundleCategory|) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleCategory} provides basic data structures and procedures for jet bundles. Nearly all necessary functions are implemented already here. Only the representation and functions which directly access it must be implemented in a domain. Two notations of derivatives are supported. Default is multi-index notation,{} where the \\spad{i}-th entry of the index denotes the number of differentiations taken with respect to \\spad{x^i}. In repeated index notation each entry \\spad{i} in the index denotes a differentiation with respect to \\spad{x^i}. The choice affects,{} however,{} only in- and output. Internally,{} multi-index notation is used throughout."))
 (|numDepVar|
  (((|PositiveInteger|))
   "\\spad{numDepVar} returns the number of dependent variables."))
 (|numIndVar|
  (((|PositiveInteger|))
   "\\spad{numIndVar} returns the number of independent variables."))
 (|dimS|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimS(q)} computes dimension of \\spad{SqT} \\spad{x} VE (= number of derivatives of order \\spad{q})."))
 (|dimJ|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimJ(q)} computes the (fibre) dimension of the \\spad{q}\\spad{-}th order jet bundle."))
 (|variables|
  (((|List| $) (|NonNegativeInteger|) (|PositiveInteger|))
   "\\spad{variables(q,{} c)} computes all jet variables of order \\spad{q} whose class is greater than or equal to \\spad{c}.")
  (((|List| $) (|NonNegativeInteger|))
   "\\spad{variables(q)} computes the list of all jet variables up to order \\spad{q}."))
 (|one?|
  (((|Boolean|) $)
   "\\spad{one?(jv)} checks whether the jet variables \\spad{jv} is the special variable 1."))
 ((|One|)
  (($)
   "\\spad{1} generates the special \"jet variable\" 1,{} which is needed for the representation of linear functions."))
 (|Pr|
  (($ (|PositiveInteger|) (|List| (|PositiveInteger|)))
   "\\spad{Pr(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a repeated index."))
 (|Pm|
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{Pm(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a multi-index."))
 (P
  (($ (|NonNegativeInteger|))
   "\\spad{P(i)} generates the \\spad{i}\\spad{-}th derivative of the only dependent variable \\spad{wrt} the only independent variable.")
  (($ (|PositiveInteger|) (|NonNegativeInteger|))
   "\\spad{P(i,{} j)} generates the \\spad{j}\\spad{-}th derivative of the \\spad{i}\\spad{-}th independent variable \\spad{wrt} the only independent variable.")
  (($ (|List| (|NonNegativeInteger|)))
   "\\spad{P(ind)} generates the derivative of the only dependent variable \\spad{wrt} the index \\spad{ind}.")
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{P(i,{} ind)} generates the derivative of the \\spad{i}\\spad{-}th dependent variable \\spad{wrt} the index \\spad{ind}. Whether \\spad{ind} is interpreted as multi-index or as repeated index depends on the chosen notation."))
 (U (($) "\\spad{U()} generates the only dependent variable.")
  (($ (|PositiveInteger|))
   "\\spad{U(i)} generates the \\spad{i}\\spad{-}th dependent variable."))
 (X (($) "\\spad{X()} generates the only independent variable.")
  (($ (|PositiveInteger|))
   "\\spad{X(i)} generates the \\spad{i}\\spad{-}th independent variable."))
 (|integrate|
  (($ $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} is like \\spad{integrateIfCan(jv,{} i)} but yields an error,{} if the integration is not possible."))
 (|integrateIfCan|
  (((|Union| $ "failed") $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} integrated \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable,{} if possible."))
 (|derivativeOf?|
  (((|List| (|NonNegativeInteger|)) $ $)
   "\\spad{derivativeOf?(jv1,{} jv2)} checks whether \\spad{jv1} is a derivative of \\spad{jv2}. In this case,{} the difference of their multi-indices is returned. Otherwise,{} an empty list is returned."))
 (|differentiate|
  (((|Union| $ "0") $ (|PositiveInteger|))
   "\\spad{differentiate(jv,{} i)} differentiates \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable."))
 (>
  (((|Boolean|) $ $)
   "\\spad{jv1 > jv2} checks whether \\spad{jv1} is greater than \\spad{jv2} in the internal ordering."))
 (|weight|
  (((|NonNegativeInteger|) $)
   "\\spad{weight(jv)} assigns each jet variable a unique integer reflecting its position in the internal ordering. The variable with the greater weight is also greater in this ordering."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(jv)} yields the order of the jet variable \\spad{jv} (Order as derivative)."))
 (|class|
  (((|NonNegativeInteger|) $)
   "\\spad{class(jv)} yields the class of the jet variable \\spad{jv} (Class of multi-index for derivative,{} 0 else).")
  (((|NonNegativeInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{class(ind)} yields the class of the multi-index \\spad{ind} (Position for first non-vanishing entry)."))
 (|name|
  (((|Symbol|) $)
   "\\spad{name(jv)} yields the name of the jet variable \\spad{jv}."))
 (|type|
  (((|Symbol|) $)
   "\\spad{type(jv)} yields the type (\\spad{Const,{} Indep,{} Dep,{} Deriv}) of the jet variable \\spad{jv}."))
 (|index|
  (((|PositiveInteger|) $)
   "\\spad{index(jv)} yields number of the jet variable \\spad{jv}."))
 (|allRepeated|
  (((|List| (|List| (|PositiveInteger|))) (|List| (|NonNegativeInteger|)))
   "\\spad{allRepeated(ind)} returns a list of all possible realizations of a given multi-index as repeated index."))
 (|m2r|
  (((|List| (|PositiveInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{m2r(ind)} transforms a multi-index into a repeated index."))
 (|r2m|
  (((|List| (|NonNegativeInteger|)) (|List| (|PositiveInteger|)))
   "\\spad{r2m(ind)} transforms a repeated index into a multi-index."))
 (|repeatedIndex|
  (((|List| (|PositiveInteger|)) $)
   "\\spad{repeatedIndex(jv)} returns the multi-index of the jet variable \\spad{jv} in repeated index notation."))
 (|multiIndex|
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{multiIndex(jv)} returns the multi-index of the jet variable \\spad{jv}."))
 (|getNotation|
  (((|Symbol|)) "\\spad{getNotation()} shows the currently used notation."))
 (|setNotation|
  (((|Symbol|) (|Symbol|))
   "\\spad{setNotation(s)} chooses the notation used for derivatives. Returns the old value."))) 
NIL 
(|JetBundleExpression| JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleExpression} defines expressions over a jet bundle based on \\spadtype{Expression Integer}. It allows all kind of algebraic operations. \\spad{simplify} is implemented using Groebner bases in polynomials over kernels. Thus it might not work correctly for general expressions. This also affects \\spad{dimension}."))
 (|function|
  (($ (|Symbol|) (|List| $) (|NonNegativeInteger|))
   "\\spad{function(f,{} arg,{} show)} generates a function with name \\spad{f} and arguments \\spad{arg}. In the output only the first \\spad{show} arguments are shown."))
 (|reduce| (($ $) "\\spad{reduce(x)} reduces algebraics in \\spad{x}."))
 (|numerJP|
  (((|SparseMultivariatePolynomial| (|Expression| (|Integer|)) |#1|) $)
   "\\spad{numerJP(f)} writes \\spad{f} as polynomial over \\spad{JB}."))) 
((|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) '(|Ring|)) (|HasCategory| (|Integer|) '(|Group|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (OR
  (|HasCategory| (|Integer|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|IntegralDomain|))))
 (OR
  (AND
   (|HasCategory| (|Integer|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND
   (|HasCategory| (|Integer|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
       (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|)
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Group|)))
  (|HasCategory| (|Integer|) '(|Ring|)))
 (|HasCategory| (|Integer|) '(|AbelianSemiGroup|))
 (|HasCategory| (|Integer|) '(|SemiGroup|)) (|HasCategory| $ '(|Ring|))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))) 
(|JetBundleFunctionCategory&| S JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleFunctionCategory} defines the category of functions (local sections) over a jet bundle. The formal derivative is defined already here. It uses the Jacobi matrix of the functions. The columns of the matrices are enumerated by jet variables. Thus they are represented as a \\spadtype{Record} of the matrix and a list of the jet variables. Several simplification routines are implemented already here."))
 (|autoReduce|
  (((|List| $) (|List| $))
   "\\spad{autoReduce(sys)} tries to simplify a system by solving each equation for its leading term and substituting it into the other equations."))
 (|reduceMod|
  (((|List| $) (|List| $) (|List| $))
   "\\spad{reduceMod(sys1,{} sys2)} reduces the system \\spad{sys1} modulo the system \\spad{sys2}."))
 (|simpMod|
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#2| $))
              (|:| |Depend|
                   (|Union| #1="failed"
                            (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#2| $) (|List| $))
   "\\spad{simpMod(sys1,{} sys2)} simplifies the system \\spad{sys1} modulo the system \\spad{sys2}. Returns the same information as \\spad{simplify}.")
  (((|List| $) (|List| $) (|List| $))
   "\\spad{simpMod(sys1,{} sys2)} simplifies the system \\spad{sys1} modulo the system \\spad{sys2}."))
 (|simpOne|
  (($ $)
   "\\spad{simpOne(f)} removes unnecessary coefficients and exponents,{} denominators etc."))
 (|simplify|
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#2| $))
              (|:| |Depend|
                   (|Union| #1# (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#2| $))
   "\\spad{simplify(sys,{} jm)} simplifies a system with given Jacobi matrix. The Jacobi matrix of the simplified system is returned,{} too. \\spad{Depend} contains for each equation of the simplified system the numbers of the equations of the original system out of which it is build,{} if it is possible to obtain this information. If one can generate equations of lower order by purely algebraic operations,{} then \\spad{simplify} should do this."))
 (|dSubst|
  (($ $ |#2| $)
   "\\spad{dSubst(f,{} jv,{} exp)} is like \\spad{subst(f,{} jv,{} exp)}. But additionally for all derivatives of \\spad{jv} the corresponding substitutions are performed."))
 (|solveFor|
  (((|Union| $ "failed") $ |#2|)
   "\\spad{solveFor(fun,{} jv)} tries to solve \\spad{fun} for the jet variable \\spad{jv}."))
 (|sortLD|
  (((|List| $) (|List| $))
   "\\spad{sortLD(sys)} sorts the functions in \\spad{sys} according to their leading derivatives."))
 (|leadingDer|
  ((|#2| $)
   "\\spad{leadingDer(fun)} yields the leading derivative of \\spad{fun}. If \\spad{fun} contains no derivatives \\spad{1} is returned."))
 (|subst|
  (($ $ |#2| $)
   "\\spad{subst(f,{} jv,{} exp)} substitutes \\spad{exp} for the jet variable \\spad{jv} in the function \\spad{f}."))
 (|freeOf?|
  (((|Boolean|) $ |#2|)
   "\\spad{freeOf?(fun,{} jv)} checks whether \\spad{fun} contains the jet variable \\spad{jv}."))
 (|orderDim|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#2| $)
    (|NonNegativeInteger|))
   "\\spad{orderDim(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \\spad{sys} with Jacobi matrix \\spad{jm} in the jet bundle of order \\spad{q} over the jet bundle of order \\spad{q-1}."))
 (|dimension|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#2| $)
    (|NonNegativeInteger|))
   "\\spad{dimension(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \\spad{sys} with Jacobi matrix \\spad{jm} in the jet bundle of order \\spad{q}."))
 (|formalDiff2|
  (((|Record| (|:| |DSys| (|List| $)) (|:| |JVars| (|List| (|List| |#2|))))
    (|List| $) (|PositiveInteger|) (|SparseEchelonMatrix| |#2| $))
   "\\spad{formalDiff2(sys,{} i,{} jm)} is like the other \\spadfun{\\spad{formalDiff2}} but for systems.")
  (((|Record| (|:| |DPhi| $) (|:| |JVars| (|List| |#2|))) $ (|PositiveInteger|)
    (|SparseEchelonMatrix| |#2| $))
   "\\spad{formalDiff2(f,{} i,{} jm)} formally differentiates the function \\spad{f} with the Jacobi matrix \\spad{jm} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable. \\spad{JVars} is a list of the jet variables effectively in the result \\spad{DPhi} (might be too large)."))
 (|formalDiff|
  (((|List| $) (|List| $) (|PositiveInteger|))
   "\\spad{formalDiff(sys,{} i)} formally differentiates a family \\spad{sys} of functions \\spad{wrt} the \\spad{i}\\spad{-}th independent variable.")
  (($ $ (|List| (|NonNegativeInteger|)))
   "\\spad{formalDiff(f,{} mu)} formally differentiates \\spad{f} as indicated by the multi-index \\spad{mu}.")
  (($ $ (|PositiveInteger|))
   "\\spad{formalDiff(f,{} i)} formally (totally) differentiates \\spad{f} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable."))
 (|differentiate|
  (($ $ |#2|)
   "\\spad{differentiate(f,{} jv)} differentiates the function \\spad{f} \\spad{wrt} the jet variable \\spad{jv}."))
 (|symbol|
  (((|SparseEchelonMatrix| |#2| $) (|List| $))
   "\\spad{symbol(sys)} computes directly the symbol of the family \\spad{sys} of functions."))
 (|extractSymbol|
  (((|SparseEchelonMatrix| |#2| $) (|SparseEchelonMatrix| |#2| $))
   "\\spad{extractSymbol(jm)} extracts the highest order part of the Jacobi matrix."))
 (|jacobiMatrix|
  (((|SparseEchelonMatrix| |#2| $) (|List| $) (|List| (|List| |#2|)))
   "\\spad{jacobiMatrix(sys,{} jvars)} constructs the Jacobi matrix of the family \\spad{sys} of functions. \\spad{jvars} contains for each function the effectively occurring jet variables. The columns of the matrix are ordered.")
  (((|SparseEchelonMatrix| |#2| $) (|List| $))
   "\\spad{jacobiMatrix(sys)} constructs the Jacobi matrix of the family \\spad{sys} of functions."))
 (|denominator|
  (($ $) "\\spad{denominator(f)} yields the denominator of \\spad{f}."))
 (|numerator|
  (($ $) "\\spad{numerator(f)} yields the numerator of \\spad{f}."))
 (|class|
  (((|NonNegativeInteger|) $)
   "\\spad{class(f)} is defined as the highest class of the jet variables effectively occurring in \\spad{f}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(f)} gives highest order of the jet variables effectively occurring in \\spad{f}."))
 (|const?|
  (((|Boolean|) $)
   "\\spad{const?(f)} checks whether \\spad{f} depends of jet variables."))
 (|jetVariables|
  (((|List| |#2|) $)
   "\\spad{jetVariables(f)} yields all jet variables effectively occurring in \\spad{f} in an ordered list."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(jv)} coerces the jet variable \\spad{jv} into a local section."))) 
NIL 
(|JetBundleFunctionCategory| JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleFunctionCategory} defines the category of functions (local sections) over a jet bundle. The formal derivative is defined already here. It uses the Jacobi matrix of the functions. The columns of the matrices are enumerated by jet variables. Thus they are represented as a \\spadtype{Record} of the matrix and a list of the jet variables. Several simplification routines are implemented already here."))
 (|autoReduce|
  (((|List| $) (|List| $))
   "\\spad{autoReduce(sys)} tries to simplify a system by solving each equation for its leading term and substituting it into the other equations."))
 (|reduceMod|
  (((|List| $) (|List| $) (|List| $))
   "\\spad{reduceMod(sys1,{} sys2)} reduces the system \\spad{sys1} modulo the system \\spad{sys2}."))
 (|simpMod|
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#1| $))
              (|:| |Depend|
                   (|Union| #1="failed"
                            (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#1| $) (|List| $))
   "\\spad{simpMod(sys1,{} sys2)} simplifies the system \\spad{sys1} modulo the system \\spad{sys2}. Returns the same information as \\spad{simplify}.")
  (((|List| $) (|List| $) (|List| $))
   "\\spad{simpMod(sys1,{} sys2)} simplifies the system \\spad{sys1} modulo the system \\spad{sys2}."))
 (|simpOne|
  (($ $)
   "\\spad{simpOne(f)} removes unnecessary coefficients and exponents,{} denominators etc."))
 (|simplify|
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#1| $))
              (|:| |Depend|
                   (|Union| #1# (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#1| $))
   "\\spad{simplify(sys,{} jm)} simplifies a system with given Jacobi matrix. The Jacobi matrix of the simplified system is returned,{} too. \\spad{Depend} contains for each equation of the simplified system the numbers of the equations of the original system out of which it is build,{} if it is possible to obtain this information. If one can generate equations of lower order by purely algebraic operations,{} then \\spad{simplify} should do this."))
 (|dSubst|
  (($ $ |#1| $)
   "\\spad{dSubst(f,{} jv,{} exp)} is like \\spad{subst(f,{} jv,{} exp)}. But additionally for all derivatives of \\spad{jv} the corresponding substitutions are performed."))
 (|solveFor|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{solveFor(fun,{} jv)} tries to solve \\spad{fun} for the jet variable \\spad{jv}."))
 (|sortLD|
  (((|List| $) (|List| $))
   "\\spad{sortLD(sys)} sorts the functions in \\spad{sys} according to their leading derivatives."))
 (|leadingDer|
  ((|#1| $)
   "\\spad{leadingDer(fun)} yields the leading derivative of \\spad{fun}. If \\spad{fun} contains no derivatives \\spad{1} is returned."))
 (|subst|
  (($ $ |#1| $)
   "\\spad{subst(f,{} jv,{} exp)} substitutes \\spad{exp} for the jet variable \\spad{jv} in the function \\spad{f}."))
 (|freeOf?|
  (((|Boolean|) $ |#1|)
   "\\spad{freeOf?(fun,{} jv)} checks whether \\spad{fun} contains the jet variable \\spad{jv}."))
 (|orderDim|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#1| $)
    (|NonNegativeInteger|))
   "\\spad{orderDim(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \\spad{sys} with Jacobi matrix \\spad{jm} in the jet bundle of order \\spad{q} over the jet bundle of order \\spad{q-1}."))
 (|dimension|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#1| $)
    (|NonNegativeInteger|))
   "\\spad{dimension(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \\spad{sys} with Jacobi matrix \\spad{jm} in the jet bundle of order \\spad{q}."))
 (|formalDiff2|
  (((|Record| (|:| |DSys| (|List| $)) (|:| |JVars| (|List| (|List| |#1|))))
    (|List| $) (|PositiveInteger|) (|SparseEchelonMatrix| |#1| $))
   "\\spad{formalDiff2(sys,{} i,{} jm)} is like the other \\spadfun{\\spad{formalDiff2}} but for systems.")
  (((|Record| (|:| |DPhi| $) (|:| |JVars| (|List| |#1|))) $ (|PositiveInteger|)
    (|SparseEchelonMatrix| |#1| $))
   "\\spad{formalDiff2(f,{} i,{} jm)} formally differentiates the function \\spad{f} with the Jacobi matrix \\spad{jm} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable. \\spad{JVars} is a list of the jet variables effectively in the result \\spad{DPhi} (might be too large)."))
 (|formalDiff|
  (((|List| $) (|List| $) (|PositiveInteger|))
   "\\spad{formalDiff(sys,{} i)} formally differentiates a family \\spad{sys} of functions \\spad{wrt} the \\spad{i}\\spad{-}th independent variable.")
  (($ $ (|List| (|NonNegativeInteger|)))
   "\\spad{formalDiff(f,{} mu)} formally differentiates \\spad{f} as indicated by the multi-index \\spad{mu}.")
  (($ $ (|PositiveInteger|))
   "\\spad{formalDiff(f,{} i)} formally (totally) differentiates \\spad{f} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable."))
 (|differentiate|
  (($ $ |#1|)
   "\\spad{differentiate(f,{} jv)} differentiates the function \\spad{f} \\spad{wrt} the jet variable \\spad{jv}."))
 (|symbol|
  (((|SparseEchelonMatrix| |#1| $) (|List| $))
   "\\spad{symbol(sys)} computes directly the symbol of the family \\spad{sys} of functions."))
 (|extractSymbol|
  (((|SparseEchelonMatrix| |#1| $) (|SparseEchelonMatrix| |#1| $))
   "\\spad{extractSymbol(jm)} extracts the highest order part of the Jacobi matrix."))
 (|jacobiMatrix|
  (((|SparseEchelonMatrix| |#1| $) (|List| $) (|List| (|List| |#1|)))
   "\\spad{jacobiMatrix(sys,{} jvars)} constructs the Jacobi matrix of the family \\spad{sys} of functions. \\spad{jvars} contains for each function the effectively occurring jet variables. The columns of the matrix are ordered.")
  (((|SparseEchelonMatrix| |#1| $) (|List| $))
   "\\spad{jacobiMatrix(sys)} constructs the Jacobi matrix of the family \\spad{sys} of functions."))
 (|denominator|
  (($ $) "\\spad{denominator(f)} yields the denominator of \\spad{f}."))
 (|numerator|
  (($ $) "\\spad{numerator(f)} yields the numerator of \\spad{f}."))
 (|class|
  (((|NonNegativeInteger|) $)
   "\\spad{class(f)} is defined as the highest class of the jet variables effectively occurring in \\spad{f}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(f)} gives highest order of the jet variables effectively occurring in \\spad{f}."))
 (|const?|
  (((|Boolean|) $)
   "\\spad{const?(f)} checks whether \\spad{f} depends of jet variables."))
 (|jetVariables|
  (((|List| |#1|) $)
   "\\spad{jetVariables(f)} yields all jet variables effectively occurring in \\spad{f} in an ordered list."))
 (|coerce|
  (($ |#1|)
   "\\spad{coerce(jv)} coerces the jet variable \\spad{jv} into a local section."))) 
NIL 
(|JetBundleLinearFunction| JB D) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleLinearFunction} implements linear functions over a jet bundle. The coefficients are functions of the independent variables only."))
 (|retract|
  (($ (|JetBundleExpression| |#1|))
   "\\spad{retract(p)} is like \\spad{retractIfCan(p)} put yields a hard error,{} if \\spad{p} contains further jet variables."))
 (|retractIfCan|
  (((|Union| $ "failed") (|JetBundleExpression| |#1|))
   "\\spad{retractIfCan(p)} tries to write a general expression as a linear function."))
 (|ground| (($ $) "\\spad{ground(l)} returns the ground part of \\spad{l}."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground?(l)} yields \\spad{true},{} if \\spad{l} is an element of the ground domain \\spad{D}."))
 (|coerce|
  (((|List| $) (|SparseEchelonMatrix| |#1| |#2|))
   "coercion to matrices over ground domain."))) 
((|HasCategory| |#2| '(|lazyRepresentation|))
 (|HasSignature| |#2|
                 (LIST '|retractIfCan|
                       (LIST
                        (LIST '|Union| (|devaluate| |#2|)
                              (|devaluate| "failed"))
                        (LIST '|JetBundleExpression| (|devaluate| |#1|)))))) 
(|JetBundlePolynomial| R JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundlePolynomial} implements polynomial sections over a jet bundle. The order is not fixed,{} thus jet variables of any order can appear."))
 (|groebner|
  (((|List| $) (|List| $))
   "\\spad{groebner(lp)} computes a Groebner basis for the ideal generated by \\spad{lp} \\spad{wrt} a lexicographic ordering."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|EntireRing|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2|
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (|HasCategory| $ '(|CommutativeRing|))) 
(|JetBundleSymAna| JB1 |xi| |eta|) 
((|constructor|
  (NIL
   "\\spad{JetBundleSymAna} is only necessary to have a valid return type for some procedures in \\spad{SymmetryAnalysis}. It is essentially identical with \\spad{JetBundle} but computes its parameters in a more complicated way."))
 (D
  (($ (|Symbol|) (|List| (|Symbol|)))
   "\\spad{D(u,{} der)} generates a derivative."))
 (|coerce|
  (($ (|Symbol|))
   "\\spad{coerce(s)} allows for the input of jet variables as symbols."))) 
NIL 
(|JetBundle| |IVar| |DVar|) 
((|constructor|
  (NIL
   "\\spad{JetBundle} implements a jet bundle of arbitrary order with given names for the independent and dependent variables. It supports only repeated index notation."))
 (D
  (($ (|Symbol|) (|List| (|Symbol|)))
   "\\spad{D(U,{} [X1,{} ...,{} Xq])} generates a derivative. \\spad{U} must be in \\spad{DVar}; all other symbols in \\spad{IVar}."))
 (|coerce|
  (($ (|Symbol|))
   "\\spad{coerce(sy)} allows for the input of jet variables as symbols. Yields an error,{} if the symbol is not contained in \\spad{IVar} or \\spad{DVar}."))) 
NIL 
(|JetBundleXExpression| JB) 
((|constructor|
  (NIL
   "\\spadtype{JetBundleXExpression} implements arbitrary functions in a jet bundle which depend only on the independent variables \\spad{x}. Otherwise it is identical with \\spadtype{JetBundleExpression}. Such a domain is needed for \\spadtype{JetLinearFunction}."))
 (|function|
  (($ (|Symbol|) (|List| $))
   "\\spad{function(f,{} arg)} generates a function with name \\spad{f} and arguments \\spad{arg}."))
 (|reduce| (($ $) "\\spad{reduce(x)} reduces the algebraics in \\spad{x}."))
 (|retract|
  (($ (|JetBundleExpression| |#1|))
   "\\spad{retract(p)} is like \\spad{retractIfCan(p)} put yields a hard error,{} if \\spad{p} contains further jet variables."))
 (|retractIfCan|
  (((|Union| $ "failed") (|JetBundleExpression| |#1|))
   "\\spad{retractIfCan(p)} checks whether \\spad{p} depends only on the independent variables. If yes,{} it is coerced."))) 
((|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) '(|Ring|)) (|HasCategory| (|Integer|) '(|Group|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (OR
  (|HasCategory| (|Integer|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|IntegralDomain|))))
 (OR
  (AND
   (|HasCategory| (|Integer|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND
   (|HasCategory| (|Integer|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
       (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|)
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Group|)))
  (|HasCategory| (|Integer|) '(|Ring|)))
 (|HasCategory| (|Integer|) '(|AbelianSemiGroup|))
 (|HasCategory| (|Integer|) '(|SemiGroup|)) (|HasCategory| $ '(|Ring|))
 (|HasCategory| $ (LIST '|RetractableTo| '(|Integer|)))) 
(|JetCoordinateTransformation| JB1 JB2 Y W) 
((|constructor|
  (NIL
   "\\spadtype{JetCoordinateTransformation} implements changes of local coordinates. Given are the changes of the coordinates of the base space,{} \\spadignore{i.e.} the independent and dependent variables. The transformations of the derivatives are computed via the chain rule. \\spad{Y} (\\spad{W}) contains expressions for the old variables in terms of the new ones."))
 (|transform|
  (((|JetBundleExpression| |#2|) (|JetBundleExpression| |#1|))
   "\\spad{transform(f)} rewrites a function of the old coordinates in the new ones.")
  (((|JetBundleExpression| |#2|) |#1|)
   "\\spad{transform(jv)} transforms a jet variable \\spad{jv} into a function of the new coordinates."))) 
NIL 
(|JetDifferentialEquation| JB D) 
((|constructor|
  (NIL
   "\\spadtype{JetDifferentialEquation} provides the basic data structures and procedures for differential equations as needed in the geometric theory. Differential equation means here always a submanifold in the jet bundle. The concrete equations which define this submanifold are called system. In an object of the type \\spadtype{JetDifferentialEquation} much more than only the system is stored. \\spad{D} denotes the class of functions allowed as equations. It is assumed that the \\spad{simplify} procedure of \\spad{D} returns only independent equations and a system with symbol in row echelon form."))
 (|tableau|
  (((|SparseEchelonMatrix| |#1| |#2|) (|SparseEchelonMatrix| |#1| |#2|)
    (|List| (|JetDifferential| |#1| |#2|)))
   "\\spad{tableau(symb,{} lchi)} computes the extended tableau parametrized by a given list of one-forms.")
  (((|SparseEchelonMatrix| |#1| |#2|) (|SparseEchelonMatrix| |#1| |#2|)
    (|JetDifferential| |#1| |#2|))
   "\\spad{tableau(symb,{} chi)} computes the tableau parametrized by a given one-form."))
 (|prolong|
  (((|Record| (|:| |SDe| $) (|:| IC (|List| |#2|))) $ (|NonNegativeInteger|))
   "\\spad{prolong(de,{} q)} is like \\spad{prolong(de)}. However,{} only equations of lower order than \\spad{q} are prolonged.")
  (((|Record| (|:| |SDe| $) (|:| IC (|List| |#2|))) $)
   "\\spad{prolong(de)} prolongs the differential equation \\spad{de}. Additionally the arising integrability conditions are returned."))
 (|project|
  (($ $ (|NonNegativeInteger|))
   "\\spad{project(de,{} q)} projects the differential equation \\spad{de} of order higher than \\spad{q} into the \\spad{q}\\spad{-}th order jet bundle."))
 (|prolongMV|
  (((|Record| (|:| |Rank| (|NonNegativeInteger|))
              (|:| |NumMultVar| (|NonNegativeInteger|))
              (|:| |Betas| (|List| (|NonNegativeInteger|))))
    (|Record| (|:| |Rank| (|NonNegativeInteger|))
              (|:| |NumMultVar| (|NonNegativeInteger|))
              (|:| |Betas| (|List| (|NonNegativeInteger|)))))
   "\\spad{prolongMV(mv)} calculates the number of multiplicative variables for the prolongation of an involutive symbol."))
 (|prolongSymbol|
  (((|SparseEchelonMatrix| |#1| |#2|) (|SparseEchelonMatrix| |#1| |#2|))
   "\\spad{prolongSymbol(symb)} prolongs directly the symbol \\spad{symb}."))
 (|analyseSymbol|
  (((|Record| (|:| |Rank| (|NonNegativeInteger|))
              (|:| |NumMultVar| (|NonNegativeInteger|))
              (|:| |Betas| (|List| (|NonNegativeInteger|))))
    (|SparseEchelonMatrix| |#1| |#2|))
   "\\spad{analyseSymbol(symb)} computes the multiplicative variables of the symbol \\spad{symb}."))
 (|extractSymbol|
  (((|SparseEchelonMatrix| |#1| |#2|) $ (|Boolean|))
   "\\spad{extractSymbol(de,{} solved?)} computes the symbol of the differential equation \\spad{de}. If \\spad{solved?} is \\spad{true},{} the row echelon form of the symbol is computed at once."))
 (|simplify|
  (((|Record| (|:| |SDe| $) (|:| IC (|List| |#2|))) $)
   "\\spad{simplify(de)} simplifies the equations of each order separately using the procedure \\spad{simplify} from \\spad{D}. Found integrability conditions are also returned separately."))
 (|setSimpMode|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{setSimpMode(i)} sets the flag controlling the used simplifications and returns the old value. Current values are: \\spad{i = 0} \\spad{->} No simplification modulo lower order equations. \\spad{i = 1} \\spad{->} Simplification modulo lower order equations. Default is 0."))
 (|dimension|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|))
   "\\spad{dimension(de,{} q)} computes the dimension of the differential equation \\spad{de} as a submanifold of the \\spad{q}\\spad{-}th order jet bundle. The result is correct only,{} if \\spad{de} is simplified."))
 (|insert|
  (($ (|List| |#2|) $)
   "\\spad{insert(sys,{} de)} adds the system \\spad{sys = 0} to the differential equation \\spad{de}."))
 (|join|
  (($ $ $)
   "\\spad{join(de1,{} de2)} combines \\spad{de1} and \\spad{de2} to a single differential equation."))
 (|makeSystem|
  (($ (|List| |#2|))
   "\\spad{makeSystem(sys)} creates a differential equation from a system."))
 (|jacobiMatrix|
  (((|List| (|SparseEchelonMatrix| |#1| |#2|)) $)
   "\\spad{jacobiMatrix(De)} returns a list of Jacobi matrices sorted by the order of the equations."))
 (|retract|
  (((|List| |#2|) $)
   "\\spad{retract(de)} returns the system defining the differential equation \\spad{de}."))
 (|copy| (($ $) "\\spad{copy(De)} returns a copy of the equation \\spad{De}."))
 (|display|
  (((|Void|) $)
   "\\spad{display(de)} prints all information stored about the differential equation \\spad{de}. This comprises the system ordered by the order of the equations,{} the Jacobi matrices separately for each order and the index of the independent variable with respect to which the equation was lastly differentiated (1 for not prolonged equations)."))
 (|printSys|
  (((|OutputForm|) (|List| |#2|))
   "\\spad{printSys(sys)} writes a list of functions as a vector of equations (with right hand side 0) and coerces the result to \\spadtype{OutputForm}."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(de)} transforms the differential equation \\spad{de} to \\spadtype{OutputForm}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(de)} yields the order of the differential equation \\spad{de}."))) 
NIL 
(|JetDifferential| JB D) 
((|constructor|
  (NIL
   "\\spad{JetDifferential(JB,{} D)} implements differentials (one-forms) \\indented{1}{over the jet bundle \\spad{JB} with coefficients from \\spad{D}.} \\indented{1}{The differentials operate on \\spad{JetVectorField(JB,{} D)}.}"))
 (|eval|
  ((|#2| $ (|JetVectorField| |#1| |#2|))
   "\\spad{eval(om,{} v)} applies the differential \\spad{om} to the vector field \\spad{v}."))
 (|contract|
  ((|#2| (|JetVectorField| |#1| |#2|) $)
   "\\spad{contract(v,{} om)} computes the interior derivative of \\spad{om} with respect to \\spad{v}."))
 (|lie|
  (($ (|JetVectorField| |#1| |#2|) $)
   "\\spad{lie(v,{} om)} calculates the Lie derivative of \\spad{om} with respect to \\spad{v}."))
 (|copy|
  (($ $) "\\spad{copy(om)} returns a copy of the differential \\spad{om}."))
 (|coefficient|
  ((|#2| $ |#1|)
   "\\spad{coefficient(om,{} jb)} returns the coefficient of \\spad{om} for the differential of \\spad{jb}."))
 (|differentials|
  (((|List| |#1|) $)
   "\\spad{directions(om)} yields the differentials where \\spad{om} has non-vanishing coefficients."))
 (|coefficients|
  (((|List| |#2|) $)
   "\\spad{coefficients(om)} yields the coefficients of \\spad{om}."))
 (|dP|
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{dP(i,{} mu)} returns the differential of \\spad{P(i,{} mu)}."))
 (|dU|
  (($ (|PositiveInteger|))
   "\\spad{dU(i)} returns the differential of \\spad{U(i)}."))
 (|dX|
  (($ (|PositiveInteger|))
   "\\spad{dX(i)} returns the differential of \\spad{X(i)}."))
 (|d| (($ |#2|) "\\spad{d(f)} computes the differential of \\spad{f}.")
  (($ |#1|) "\\spad{d(jb)} returns the differential of \\spad{jb}."))) 
((|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|AbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|)))) 
(|JFriCASSupport|) 
((|constructor|
  (NIL
   "\\indented{1}{The package \\spad{JFriCASSupport} provides a number of service} functions to more easily switch on/off certain formats,{} in particular the use of the FormatMathJax formatter. Use \\spad{setFormat! FormatMathJax} to switch on MathJax output or \\spad{setFormats [FormatMathJax,{} Format1D]} to enable several output formats."))
 (|setFormats!|
  (((|Void|) (|List| (|Type|)))
   "\\spad{setFormats!(l)} takes a list \\spad{l} of formatters and sets this for future output in a session. It also issues a command equivalent to \")set output formatted on\" if the given list is non-empty and \")set output formatted off\" if the input list is empty."))
 (|setFormat!|
  (((|Void|) (|Type|))
   "\\spad{setFormat! f} returns \\spad{setFormats! [f]}."))) 
NIL 
(|JetGroebner| R JB LJV P E) 
((|constructor|
  (NIL
   "\\spadtype{JetGroebner} provides a procedure to compute Groebner bases for arbitrary domains of jet polynomials. Two internal procedures transform to and from \\spadtype{DistributedJetBundlePolynomial} where the actual computation is done. The argument \\spad{LJV} contains all jet variables effectively occurring in the polynomials. The ordering is determined by the ordering in \\spad{P}."))
 (|groebner|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{groebner(lp)} computes a Groebner basis for the ideal generated by the polynomials \\spad{lp}."))) 
NIL 
(|JetLazyFunction| JB D) 
((|constructor|
  (NIL
   "\\spadtype{JetLazyFunction} takes as argument a domain in \\spadtype{JetBundleFunctionCategory} and returns another domain in the same category. This domain has basically the same properties as the argument domain,{} but there is a lazy evaluation mechanism for derivatives. This means that differentiations are not immediately performed. Instead a pointer is established to the function to be differentiated. Only when the exact value of the derivative is needed,{} the differentiation is executed. Special care is taken for leading derivatives and jet variables to avoid as much as possible the need to evaluate expressions. This entails that the result of \\spad{jetVariables} may contain spurious variables. Furthermore many functions in \\spadtype{JetLazyFunction} destructively change their arguments. This affects,{} however,{} only their internal representation,{} not the value obtained after full evaluation."))
 (|statistics|
  (((|Void|))
   "\\spad{statistics()} prints a statistic on the use of the lazy evaluation mechanism. It displays the number of lazy differentiations performed and how many of them had to be executed explicitly later on."))
 (|eqRep?|
  (((|Boolean|) $ $)
   "\\spad{eqRep?(x,{} y)} compares the representations of \\spad{x} and \\spad{y} without any evaluation. Thus it is much weaker than \\spad{=} and cannot decide equality of the evaluated expressions."))
 (*
  (($ |#2| $)
   "\\spad{d*exp} is provided mainly for internal use,{} as basically all calculations should be performed within \\spadtype{JetLazyFunction}."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground(exp)} is \\spad{true},{} if \\spad{exp} contains only fully evaluated parts."))
 (|eval|
  (($ $)
   "\\spad{eval(exp)} explicitly evaluates all terms in \\spad{exp}. \\spad{exp} is destructively altered."))
 (|eval1|
  (($ $)
   "\\spad{eval1(exp)} explicitly evaluates the next term in \\spad{exp}. \\spad{exp} is destructively altered."))
 (|collect|
  (($ $)
   "\\spad{collect(exp)} \"collects\" former lazy terms which have been meanwhile evaluated."))
 (|coerce|
  ((|#2| $)
   "\\spad{coerce(exp)} retracts an element to the base domain \\spad{D}. This looses all information about its leading derivative and its jet variables and requires complete evaluation of the expression.")
  (($ |#2|)
   "\\spad{coerce(d)} coerces an element of \\spad{D} into the new domain. This includes the calculation of its leading derivative and its jet variables."))
 (|lazyRepresentation|
  ((|attribute|) "The representation contains a lazy evaluation scheme."))) 
NIL 
(|JoinSemilattice|) 
((|constructor|
  (NIL
   "join semilattice \\indented{2}{Different from exterior Grassmann product operator as} \\indented{2}{that anticommutes.} \\indented{2}{need to check precedence when used as an infix operator} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (|\\/| (($ $ $) "returns the logical 'join',{} \\spadignore{e.g.} 'or'."))) 
NIL 
(|AssociatedJordanAlgebra| R A) 
((|constructor|
  (NIL
   "\\indented{1}{AssociatedJordanAlgebra takes an algebra \\spad{A} and uses \\spadfun{*\\$A}} \\indented{1}{to define the new multiplications \\spad{a*b := (a *\\$A b + b *\\$A a)/2}} \\indented{1}{(anticommutator).} \\indented{1}{The usual notation \\spad{{a,{} b}_+} cannot be used due to} \\indented{1}{restrictions in the current language.} \\indented{1}{This domain only gives a Jordan algebra if the} \\indented{1}{Jordan-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds} \\indented{1}{for all \\spad{a},{} \\spad{b},{} \\spad{c} in \\spad{A}.} \\indented{1}{This relation can be checked by} \\indented{1}{\\spadfun{jordanAdmissible?()\\$A}.} \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank,{} together with a fixed \\spad{R}-module basis),{} then the same is \\spad{true} for the associated Jordan algebra. Moreover,{} if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank),{} then the same \\spad{true} for the associated Jordan algebra."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(a)} coerces the element \\spad{a} of the algebra \\spad{A} to an element of the Jordan algebra \\spadtype{AssociatedJordanAlgebra}(\\spad{R},{} A)."))) 
((|HasCategory| |#2| (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|)))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| |#2|
                     (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))
 (|HasCategory| |#2|
                (LIST '|FiniteRankNonAssociativeAlgebra| (|devaluate| |#1|)))
 (OR
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| |#2|
                      (LIST '|FiniteRankNonAssociativeAlgebra|
                            (|devaluate| |#1|))))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| |#2|
                      (LIST '|FramedNonAssociativeAlgebra|
                            (|devaluate| |#1|)))))
 (OR
  (|HasCategory| |#2|
                 (LIST '|FiniteRankNonAssociativeAlgebra| (|devaluate| |#1|)))
  (|HasCategory| |#2|
                 (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))) 
(|JetVectorField| JB D) 
((|constructor|
  (NIL
   "\\spad{JetVectorField(JB,{} D)} implements vector fields over the jet bundle \\spad{JB} with coefficients from \\spad{D}. The fields operate on functions from \\spad{D}."))
 (|prolong|
  (($ $ (|NonNegativeInteger|))
   "\\spad{prolong(v,{} q)} prolongs a vector field \\spad{v} defined on the base space into the jet bundle of order \\spad{q}."))
 (|eval|
  ((|#2| $ |#2|)
   "\\spad{eval(v,{} f)} applies the vector field \\spad{v} to the function \\spad{f}."))
 (|lie|
  (($ $ $)
   "\\spad{lie(v,{} w)} calculates the Lie derivative of \\spad{w} with respect to \\spad{v}. (This yields the commutator of the fields.)"))
 (|table|
  (((|TwoDimensionalArray| $) (|List| $))
   "\\spad{table(lv)} computes the commutator table for a given list of vector fields."))
 (|commutator|
  (($ $ $)
   "\\spad{commutator(v,{} w)} calculates the commutator of two vector fields."))
 (|copy|
  (($ $) "\\spad{copy(v)} returns a copy of the vector field \\spad{v}."))
 (|coefficient|
  ((|#2| $ |#1|)
   "\\spad{coefficient(v,{} jb)} returns the coefficient of \\spad{v} in direction \\spad{jb}."))
 (|directions|
  (((|List| |#1|) $)
   "\\spad{directions(v)} yields the directions of the base vectors where \\spad{v} has non-vanishing coefficients."))
 (|coefficients|
  (((|List| |#2|) $)
   "\\spad{coefficients(v)} yields the coefficients of \\spad{v}."))
 (|diffP|
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{diffP(i,{} mu)} returns the base vector field in direction \\spad{P(i,{} mu)}."))
 (|diffU|
  (($ (|PositiveInteger|))
   "\\spad{diffU(i)} returns the base vector field in direction \\spad{U(i)}."))
 (|diffX|
  (($ (|PositiveInteger|))
   "\\spad{diffX(i)} returns the base vector field in direction \\spad{X(i)}."))
 (|diff|
  (($ |#1|)
   "\\spad{diff(jb)} returns the base vector field in direction \\spad{jb}."))) 
((|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|AbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|)))) 
(|KeyedAccessFile| |Entry|) 
((|constructor|
  (NIL
   "This domain allows a random access file to be viewed both as a table and as a file object."))
 (|pack!|
  (($ $)
   "\\spad{pack!(f)} reorganizes the file \\spad{f} on disk to recover unused space."))) 
((AND
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| '(|String|))
                             (LIST '|:| '|entry| (|devaluate| |#1|)))))
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                 '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| (|String|) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                '(|BasicType|))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                '(|OrderedSet|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                     '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                     '(|OrderedSet|)))) 
(|KeyedDictionary&| S |Key| |Entry|) 
((|constructor|
  (NIL
   "A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key."))
 (|search|
  (((|Union| |#3| "failed") |#2| $)
   "\\spad{search(k,{} t)} searches the table \\spad{t} for the key \\spad{k},{} returning the entry stored in \\spad{t} for key \\spad{k}. If \\spad{t} has no such key,{} \\spad{search(k,{}t)} returns \"failed\"."))
 (|remove!|
  (((|Union| |#3| "failed") |#2| $)
   "\\spad{remove!(k,{} t)} searches the table \\spad{t} for the key \\spad{k} removing (and return) the entry if there. If \\spad{t} has no such key,{} \\spad{remove!(k,{}t)} returns \"failed\"."))
 (|keys|
  (((|List| |#2|) $)
   "\\spad{keys(t)} returns the list of keys in table \\spad{t}."))
 (|key?|
  (((|Boolean|) |#2| $)
   "\\spad{key?(k,{} t)} tests if \\spad{k} is a key in table \\spad{t}."))) 
NIL 
(|KeyedDictionary| |Key| |Entry|) 
((|constructor|
  (NIL
   "A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key."))
 (|search|
  (((|Union| |#2| "failed") |#1| $)
   "\\spad{search(k,{} t)} searches the table \\spad{t} for the key \\spad{k},{} returning the entry stored in \\spad{t} for key \\spad{k}. If \\spad{t} has no such key,{} \\spad{search(k,{}t)} returns \"failed\"."))
 (|remove!|
  (((|Union| |#2| "failed") |#1| $)
   "\\spad{remove!(k,{} t)} searches the table \\spad{t} for the key \\spad{k} removing (and return) the entry if there. If \\spad{t} has no such key,{} \\spad{remove!(k,{}t)} returns \"failed\"."))
 (|keys|
  (((|List| |#1|) $)
   "\\spad{keys(t)} returns the list of keys in table \\spad{t}."))
 (|key?|
  (((|Boolean|) |#1| $)
   "\\spad{key?(k,{} t)} tests if \\spad{k} is a key in table \\spad{t}."))) 
NIL 
(|KernelCategory| S) 
((|constructor|
  (NIL
   "A kernel over a set \\spad{S} is an operator applied to a given list of arguments from \\spad{S}."))
 (|is?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{is?(op(a1,{} ...,{} an),{} s)} tests if the name of op is \\spad{s}.")
  (((|Boolean|) $ (|BasicOperator|))
   "\\spad{is?(op(a1,{} ...,{} an),{} f)} tests if op = \\spad{f}."))
 (|symbolIfCan|
  (((|Union| (|Symbol|) "failed") $)
   "\\spad{symbolIfCan(k)} returns \\spad{k} viewed as a symbol if \\spad{k} is a symbol,{} and \"failed\" otherwise."))
 (|kernel|
  (($ (|Symbol|)) "\\spad{kernel(x)} returns \\spad{x} viewed as a kernel.")
  (($ (|BasicOperator|) (|List| |#1|) (|NonNegativeInteger|))
   "\\spad{kernel(op,{} [a1,{} ...,{} an],{} m)} returns the kernel \\spad{op(a1,{} ...,{} an)} of nesting level \\spad{m}. Error: if \\spad{op} is \\spad{k}-ary for some \\spad{k} not equal to \\spad{n}."))
 (|height|
  (((|NonNegativeInteger|) $)
   "\\spad{height(k)} returns the nesting level of \\spad{k}."))
 (|argument|
  (((|List| |#1|) $)
   "\\spad{argument(op(a1,{} ...,{} an))} returns \\spad{[a1,{} ...,{} an]}."))
 (|operator|
  (((|BasicOperator|) $)
   "\\spad{operator(op(a1,{} ...,{} an))} returns the operator op."))
 (|name|
  (((|Symbol|) $) "\\spad{name(op(a1,{} ...,{} an))} returns the name of op."))) 
NIL 
(|Kernel| S) 
((|constructor|
  (NIL
   "A kernel over a set \\spad{S} is an operator applied to a given list of arguments from \\spad{S}."))) 
((|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))) 
(|KernelFunctions2| R S) 
((|constructor|
  (NIL "This package exports some auxiliary functions on kernels"))
 (|constantIfCan|
  (((|Union| |#1| "failed") (|Kernel| |#2|))
   "\\spad{constantIfCan(k)} \\undocumented"))
 (|constantKernel|
  (((|Kernel| |#2|) |#1|) "\\spad{constantKernel(r)} \\undocumented"))) 
NIL 
(|CoercibleTo| S) 
((|constructor|
  (NIL
   "A is coercible to \\spad{B} means any element of A can automatically be converted into an element of \\spad{B} by the interpreter."))
 (|coerce|
  ((|#1| $) "\\spad{coerce(a)} transforms a into an element of \\spad{S}."))) 
NIL 
(|CoercibleFrom| S) 
((|constructor|
  (NIL
   "A is coercible to \\spad{B} means any element of A can automatically be converted into an element of \\spad{B} by the interpreter."))
 (|coerce| (($ |#1|) "\\spad{coerce(a)} transforms a into an element of \\%."))) 
NIL 
(|ConvertibleFrom| S) 
((|constructor|
  (NIL
   "A is convertible to \\spad{B} means any element of A can be converted into an element of \\spad{B},{} but not automatically by the interpreter."))
 (|convert| (($ |#1|) "\\spad{convert(a)} transforms a into element of \\%."))) 
NIL 
(|ConvertibleTo| S) 
((|constructor|
  (NIL
   "A is convertible to \\spad{B} means any element of A can be converted into an element of \\spad{B},{} but not automatically by the interpreter."))
 (|convert|
  ((|#1| $) "\\spad{convert(a)} transforms a into an element of \\spad{S}."))) 
NIL 
(|Kovacic| F UP) 
((|constructor|
  (NIL
   "\\spadtype{Kovacic} provides a modified Kovacic\\spad{'s} algorithm for solving explicitly irreducible 2nd order linear ordinary differential equations."))
 (|kovacic|
  (((|Union| (|SparseUnivariatePolynomial| (|Fraction| |#2|)) "failed")
    (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|)
    (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{kovacic(a_0,{}a_1,{}a_2,{}ezfactor)} returns either \"failed\" or \\spad{P}(\\spad{u}) such that \\spad{\\$e^{\\int(-a_1/2a_2)} e^{\\int u}\\$} is a solution of \\indented{5}{\\spad{\\$a_2 y'' + a_1 y' + a0 y = 0\\$}} whenever \\spad{u} is a solution of \\spad{P u = 0}. The equation must be already irreducible over the rational functions. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles.")
  (((|Union| (|SparseUnivariatePolynomial| (|Fraction| |#2|)) "failed")
    (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|))
   "\\spad{kovacic(a_0,{}a_1,{}a_2)} returns either \"failed\" or \\spad{P}(\\spad{u}) such that \\spad{\\$e^{\\int(-a_1/2a_2)} e^{\\int u}\\$} is a solution of \\indented{5}{\\spad{a_2 y'' + a_1 y' + a0 y = 0}} whenever \\spad{u} is a solution of \\spad{P u = 0}. The equation must be already irreducible over the rational functions."))) 
NIL 
(|LocalAlgebra| A R) 
((|constructor|
  (NIL
   "LocalAlgebra produces the localization of an algebra,{} \\spadignore{i.e.} fractions whose numerators come from some \\spad{R} algebra."))
 (|denom| ((|#2| $) "\\spad{denom x} returns the denominator of \\spad{x}."))
 (|numer| ((|#1| $) "\\spad{numer x} returns the numerator of \\spad{x}."))
 (/ (($ |#1| |#2|) "\\spad{a / d} divides the element \\spad{a} by \\spad{d}.")
    (($ $ |#2|) "\\spad{x / d} divides the element \\spad{x} by \\spad{d}."))) 
((|HasCategory| |#1| '(|OrderedRing|))) 
(|LeftAlgebra&| S R) 
((|constructor|
  (NIL "The category of all left algebras over an arbitrary ring."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(r)} returns \\spad{r} * 1 where 1 is the identity of the left algebra."))) 
NIL 
(|LeftAlgebra| R) 
((|constructor|
  (NIL "The category of all left algebras over an arbitrary ring."))
 (|coerce|
  (($ |#1|)
   "\\spad{coerce(r)} returns \\spad{r} * 1 where 1 is the identity of the left algebra."))) 
NIL 
(|Lambda| UT) 
((|constructor| (NIL "macro to simplify output"))
 (|toString|
  (((|String|) $)
   "return string representation using deBruijn index for bound variables. notation assumes association to the left,{} in the absence of brackets,{} the term to the left binds more tightly than the one on the right."))
 (|toStringConven|
  (((|String|) $ (|List| (|String|)))
   "return string representation using conventional notation,{} that is deBruijn index is replaced by name using String value for bound variables. notation assumes association to the left,{} in the absence of brackets,{} the term to the left binds more tightly than the one on the right."))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal (deep search) that is: all terms at all levels in tree must be alpha-equivalent to return \\spad{true} That is the names,{} but not the deBruijn index,{} of the bound variables can be different. beta-equivalence is not implemented because it is not decidable."))
 (|redux|
  (($ $) "beta reduction - apply beta reduction recusivly to all subnodes"))
 (|unbind|
  (($ $)
   "if this is a lambda term then replace De Bruijn index in sub-nodes with string name"))
 (|bind|
  (($ $)
   "if this is a lambda term then replace string name in sub-nodes with De Bruijn index"))
 (|subst| (($ $ $ $) "substitution of 'a' for \\spad{'b'} in \\spad{'n'}"))
 (|getChildren|
  (((|List| $) $)
   "returns 2 child nodes if this is a compound term returns 1 child node if this is a lamda term otherwise returns []"))
 (|free?|
  (((|Boolean|) $)
   "if this is a lambda term then is it free,{} that is does its variable appear in its expression"))
 (|getVariable|
  ((|#1| $)
   "introspection: returns value of unbound variable in unbound leaf node or bound variable in lambda term"))
 (|getBoundValue|
  (((|NonNegativeInteger|) $)
   "introspection: returns deBruijn index of bound variable in bound leaf node"))
 (|isFreeNode?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a unbound leaf node"))
 (|isBoundNode?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a bound leaf node"))
 (|isLambda?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a lambda definition"))
 (|isCompound?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a compound term containing two nodes"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is free or bound variable otherwise return \\spad{false} if this is a compound or lambda definition"))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseLambda. It would rarely be called externally but it is here to allow it to call parseLambda that is to allow circular calls"))
 (|parseLambda|
  (($ (|String|))
   "Constructs nested lambda terms from a string notation assumes format like this: <term> : \\spad{:=} \"\\spad{\\\"} var \".\"<term> | \\spad{n} | <term><term> | \"(\"<term>\")\" where: \\\\ = lambda (\\spad{I} would like to use unicode lambda symbol but \\indented{12}{\\spad{I} would also like to keep maximum compatibility} \\indented{12}{with non-unicode versions of Lisp)} \\spad{n} = De Bruijn index which is a integer where,{} 1=inside inner \\indented{12}{lambda term,{} 2= next outer lambda term,{} 3= next} \\indented{12}{outer and so on.} brackets can be used around whole terms."))
 (|lambda|
  (($ $ |#1|)
   "Constructs lambda term and bind any variables with the name provided")
  (($ $ $) "Constructs a node containing multiple terms")
  (($ |#1|) "Constructs a reference to a free variable")
  (($ (|NonNegativeInteger|))
   "Constructs a reference to a bound variable from its deBruijn index"))) 
NIL 
(|LaplaceTransform| R F) 
((|constructor| (NIL "This package computes the forward Laplace Transform."))
 (|laplace|
  ((|#2| |#2| (|Symbol|) (|Symbol|))
   "\\spad{laplace(f,{} t,{} s)} returns the Laplace transform of \\spad{f(t)} using \\spad{s} as the new variable. This is \\spad{integral(exp(-s*t)*f(t),{} t = 0..\\%plusInfinity)}. Returns the formal object \\spad{laplace(f,{} t,{} s)} if it cannot compute the transform."))) 
NIL 
(|Lattice|) 
((|constructor|
  (NIL
   "lattice \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))) 
NIL 
(|LatticeJoinOfMeets|) 
((|constructor| (NIL "parse result includes term returned and new index"))
 (|coerce|
  (($ (|LatticeMeetOfJoins|))
   "convert lattice from meet-of-joins to join-of-meets")
  (((|LatticeMeetOfJoins|) $)
   "convert lattice from join-of-meets to meet-of-joins"))
 (|toStringUnwrapped|
  (((|String|) $)
   "similar to 'toString' but does not put outer compound terms in brackets"))
 (|toString|
  (((|String|) $)
   "creates a string representation of this term and its sub-terms"))
 (|value|
  (((|Symbol|) $)
   "returns: \\indented{2}{\"T\"::Symbol = \\spad{T}} \\indented{2}{\"F\"::Symbol = \\spad{_|_}} \\indented{2}{\"E\"::Symbol = error} \\indented{2}{\"P\"::Symbol = proposition} \\indented{2}{\"C\"::Symbol = compound} Constructs lambda term and bind any variables with the name provided"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|opType|
  (((|Symbol|) $)
   "if this is a compound op then opType returns the type of that op: \"IMPLY\"::Symbol =implies \"AND\"::Symbol=/\\ \"OR\"::Symbol=\\spad{\\/} \"NOT\"::Symbol=~ \"OTHER\"::Symbol=not compound op"))
 (=
  (((|Boolean|) $ $)
   "returns \\spad{true} (boolean \\spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic"))
 (|deductions|
  (((|List| $) (|List| $))
   "assumes \\spad{ln} contains a list of factors which must be \\spad{true} for the whole to be \\spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \\spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|factor|
  (((|List| $) $)
   "splits \\spad{n} into a list of factors which must be \\spad{true} for the whole to be \\spad{true}. This assumes that the top level is already a set of factors separated by \\spad{/\\} otherwise the result will just be a list with one entry: \\spad{'n'}. This is used when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|redux| (($ $) "attempt to simplify terms"))
 (|join| (($ (|List| $)) "\\spad{join of} set of elements"))
 (|meet| (($ (|List| $)) "\\spad{meet of} set of elements"))
 (|empty?| (((|Boolean|) $) "\\spad{true} if empty"))
 (|emptyLattice| (($) "construct an empty lattice"))
 (|latticeJoinOfMeets|
  (($
    (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
             (|:| |var| (|Record| (|:| |str| (|String|))))))
   "construct a lattice with one element"))
 (|variable| (($ (|String|)) "construct a variable"))
 (|logicF|
  (($) "construct \\spad{false} (contradiction): a logical constant."))
 (|logicT| (($) "construct true: a logical constant."))) 
NIL 
(|LatticeMeetOfJoins|) 
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toStringUnwrapped|
  (((|String|) $)
   "similar to 'toString' but does not put outer compound terms in brackets"))
 (|toString|
  (((|String|) $)
   "creates a string representation of this term and its sub-terms"))
 (|value|
  (((|Symbol|) $)
   "returns: \\indented{2}{\"T\"::Symbol = \\spad{T}} \\indented{2}{\"F\"::Symbol = \\spad{_|_}} \\indented{2}{\"E\"::Symbol = error} \\indented{2}{\"P\"::Symbol = proposition} \\indented{2}{\"C\"::Symbol = compound} Constructs lambda term and bind any variables with the name provided"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|opType|
  (((|Symbol|) $)
   "if this is a compound op then opType returns the type of that op: \"IMPLY\"::Symbol =implies \"AND\"::Symbol=/\\ \"OR\"::Symbol=\\spad{\\/} \"NOT\"::Symbol=~ \"OTHER\"::Symbol=not compound op"))
 (=
  (((|Boolean|) $ $)
   "returns \\spad{true} (boolean \\spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic"))
 (|deductions|
  (((|List| $) (|List| $))
   "assumes \\spad{ln} contains a list of factors which must be \\spad{true} for the whole to be \\spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \\spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|factor|
  (((|List| $) $)
   "splits \\spad{n} into a list of factors which must be \\spad{true} for the whole to be \\spad{true}. This assumes that the top level is already a set of factors separated by \\spad{/\\} otherwise the result will just be a list with one entry: \\spad{'n'}. This is used when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|redux| (($ $) "attempt to simplify terms"))
 (|join| (($ (|List| $)) "\\spad{join of} set of elements"))
 (|meet| (($ (|List| $)) "\\spad{meet of} set of elements"))
 (|empty?| (((|Boolean|) $) "\\spad{true} if empty"))
 (|emptyLattice| (($) "construct an empty lattice"))
 (|latticeMeetOfJoins|
  (($
    (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
             (|:| |var| (|Record| (|:| |str| (|String|))))))
   "construct a lattice with one element"))
 (|variable| (($ (|String|)) "construct a variable"))
 (|logicF|
  (($) "construct \\spad{false} (contradiction): a logical constant."))
 (|logicT| (($) "construct true: a logical constant."))) 
NIL 
(|LaurentPolynomial| R UP) 
((|constructor|
  (NIL
   "\\indented{1}{Univariate polynomials with negative and positive exponents.} Author: Manuel Bronstein Date Created: May 1988"))
 (|separate|
  (((|Record| (|:| |polyPart| $) (|:| |fracPart| (|Fraction| |#2|)))
    (|Fraction| |#2|))
   "\\spad{separate(x)} \\undocumented"))
 (|monomial| (($ |#1| (|Integer|)) "\\spad{monomial(x,{} n)} \\undocumented"))
 (|coefficient|
  ((|#1| $ (|Integer|)) "\\spad{coefficient(x,{} n)} \\undocumented"))
 (|trailingCoefficient|
  ((|#1| $) "\\spad{trailingCoefficient }\\undocumented"))
 (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient }\\undocumented"))
 (|reductum| (($ $) "\\spad{reductum(x)} \\undocumented"))
 (|order| (((|Integer|) $) "\\spad{order(x)} \\undocumented"))
 (|degree| (((|Integer|) $) "\\spad{degree(x)} \\undocumented"))
 (|monomial?| (((|Boolean|) $) "\\spad{monomial?(x)} \\undocumented"))) 
((|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))) 
(|LazardSetSolvingPackage| R E V P TS ST) 
((|constructor|
  (NIL
   "A package for solving polynomial systems by means of Lazard triangular sets [1]. This package provides two operations. One for solving in the sense of the regular zeros,{} and the other for solving in the sense of the Zariski closure. Both produce square-free regular sets. Moreover,{} the decompositions do not contain any redundant component. However,{} only zero-dimensional regular sets are normalized,{} since normalization may be time consumming in positive dimension. The decomposition process is that of [2].\\newline"))
 (|zeroSetSplit|
  (((|List| |#6|) (|List| |#4|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?)} has the same specifications as \\spadopFrom{zeroSetSplit}{RegularTriangularSetCategory}(\\spad{lp},{} clos?)."))
 (|normalizeIfCan|
  ((|#6| |#6|)
   "\\spad{normalizeIfCan(ts)} returns \\spad{ts} in an normalized shape if \\spad{ts} is zero-dimensional."))) 
NIL 
(|LeadingCoefDetermination| OV E Z P) 
((|constructor|
  (NIL
   "Package for leading coefficient determination in the lifting step. Package working for every unique factorization domain \\spad{R} . Uses algorithm given in section 3 of [1] generalized to arbitrary unique factorization domain."))
 (|distFact|
  (((|Union|
     (|Record| (|:| |polfac| (|List| |#4|)) (|:| |correct| |#3|)
               (|:| |corrfact| (|List| (|SparseUnivariatePolynomial| |#3|))))
     "failed")
    |#3| (|List| (|SparseUnivariatePolynomial| |#3|))
    (|Record| (|:| |contp| |#3|)
              (|:| |factors|
                   (|List|
                    (|Record| (|:| |irr| |#4|)
                              (|:| |pow| (|NonNegativeInteger|))))))
    (|List| |#3|) (|List| |#1|) (|List| |#3|))
   "\\spad{distFact(contm,{} unilist,{} plead,{} vl,{} lvar,{} lval)},{} where \\spad{contm} is the content of the evaluated polynomial,{} \\spad{unilist} is the list of factors of the evaluated polynomial,{} \\spad{plead} is the complete factorization of the leading coefficient,{} \\spad{vl} is the list of factors of the leading coefficient evaluated,{} \\spad{lvar} is the list of variables,{} lval is the list of values,{} returns a record giving the list of leading coefficients to impose on the univariate factors,{}"))
 (|polCase|
  (((|Boolean|) |#3| (|NonNegativeInteger|) (|List| |#3|))
   "\\spad{polCase(contprod,{} numFacts,{} evallcs)},{} where \\spad{contprod} is the product of the content of the leading coefficient of the polynomial to be factored with the content of the evaluated polynomial,{} \\spad{numFacts} is the number of factors of the leadingCoefficient,{} and evallcs is the list of the evaluated factors of the leadingCoefficient,{} returns \\spad{true} if the factors of the leading Coefficient can be distributed with this valuation."))) 
NIL 
(|LieExponentials| |VarSet| R |Order|) 
((|constructor|
  (NIL
   "Management of the Lie Group associated with a free nilpotent Lie algebra. Every Lie bracket with length greater than \\spad{Order} are assumed to be null. The implementation inherits from the \\spadtype{XPBWPolynomial} domain constructor: Lyndon coordinates are exponential coordinates of the second kind. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|identification|
  (((|List| (|Equation| |#2|)) $ $)
   "\\spad{identification(g,{} h)} returns the list of equations \\spad{g_i = h_i},{} where \\spad{g_i} (resp. \\spad{h_i}) are exponential coordinates of \\spad{g} (resp. \\spad{h})."))
 (|LyndonCoordinates|
  (((|List| (|Record| (|:| |k| (|LyndonWord| |#1|)) (|:| |c| |#2|))) $)
   "\\spad{LyndonCoordinates(g)} returns the exponential coordinates of \\spad{g}."))
 (|LyndonBasis|
  (((|List| (|LiePolynomial| |#1| |#2|)) (|List| |#1|))
   "\\spad{LyndonBasis(lv)} returns the Lyndon basis of the nilpotent free Lie algebra."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(g)} returns the list of variables of \\spad{g}."))
 (|mirror|
  (($ $)
   "\\spad{mirror(g)} is the mirror of the internal representation of \\spad{g}."))
 (|coerce|
  (((|XPBWPolynomial| |#1| |#2|) $)
   "\\spad{coerce(g)} returns the internal representation of \\spad{g}.")
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{coerce(g)} returns the internal representation of \\spad{g}."))
 (|listOfTerms|
  (((|List|
     (|Record| (|:| |k| (|PoincareBirkhoffWittLyndonBasis| |#1|))
               (|:| |c| |#2|)))
    $)
   "\\spad{listOfTerms(p)} returns the internal representation of \\spad{p}."))
 (|log|
  (((|LiePolynomial| |#1| |#2|) $)
   "\\spad{log(p)} returns the logarithm of \\spad{p}."))
 (|exp|
  (($ (|LiePolynomial| |#1| |#2|))
   "\\spad{exp(p)} returns the exponential of \\spad{p}."))) 
NIL 
(|LexTriangularPackage| R |ls|) 
((|constructor|
  (NIL
   "A package for solving polynomial systems with finitely many solutions. The decompositions are given by means of regular triangular sets. The computations use lexicographical Groebner bases. The main operations are \\spadopFrom{lexTriangular}{LexTriangularPackage} and \\spadopFrom{squareFreeLexTriangular}{LexTriangularPackage}. The second one provide decompositions by means of square-free regular triangular sets. Both are based on the {\\em lexTriangular} method described in [1]. They differ from the algorithm described in [2] by the fact that multiciplities of the roots are not kept. With the \\spadopFrom{squareFreeLexTriangular}{LexTriangularPackage} operation all multiciplities are removed. With the other operation some multiciplities may remain. Both operations admit an optional argument to produce normalized triangular sets. \\newline"))
 (|zeroSetSplit|
  (((|List|
     (|SquareFreeRegularTriangularSet| |#1|
                                       (|IndexedExponents|
                                        (|OrderedVariableList| |#2|))
                                       (|OrderedVariableList| |#2|)
                                       (|NewSparseMultivariatePolynomial| |#1|
                                                                          (|OrderedVariableList|
                                                                           |#2|))))
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} norm?)} decomposes the variety associated with \\spad{lp} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\spad{lp} needs to generate a zero-dimensional ideal. If \\spad{norm?} is \\spad{true} then the regular sets are normalized.")
  (((|List| (|RegularChain| |#1| |#2|))
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} norm?)} decomposes the variety associated with \\spad{lp} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\spad{lp} needs to generate a zero-dimensional ideal. If \\spad{norm?} is \\spad{true} then the regular sets are normalized."))
 (|squareFreeLexTriangular|
  (((|List|
     (|SquareFreeRegularTriangularSet| |#1|
                                       (|IndexedExponents|
                                        (|OrderedVariableList| |#2|))
                                       (|OrderedVariableList| |#2|)
                                       (|NewSparseMultivariatePolynomial| |#1|
                                                                          (|OrderedVariableList|
                                                                           |#2|))))
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|Boolean|))
   "\\spad{squareFreeLexTriangular(base,{} norm?)} decomposes the variety associated with \\spad{base} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\spad{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \\spad{norm?} is \\spad{true} then the regular sets are normalized."))
 (|lexTriangular|
  (((|List| (|RegularChain| |#1| |#2|))
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|Boolean|))
   "\\spad{lexTriangular(base,{} norm?)} decomposes the variety associated with \\spad{base} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\spad{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \\spad{norm?} is \\spad{true} then the regular sets are normalized."))
 (|groebner|
  (((|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))))
   "\\spad{groebner(lp)} returns the lexicographical Groebner basis of \\spad{lp}. If \\spad{lp} generates a zero-dimensional ideal then the {\\em FGLM} strategy is used,{} otherwise the {\\em Sugar} strategy is used."))
 (|fglmIfCan|
  (((|Union|
     (|List|
      (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
     "failed")
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))))
   "\\spad{fglmIfCan(lp)} returns the lexicographical Groebner basis of \\spad{lp} by using the {\\em FGLM} strategy,{} if \\spad{zeroDimensional?(lp)} holds ."))
 (|zeroDimensional?|
  (((|Boolean|)
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))))
   "\\spad{zeroDimensional?(lp)} returns \\spad{true} iff \\spad{lp} generates a zero-dimensional ideal \\spad{w}.\\spad{r}.\\spad{t}. the variables involved in \\spad{lp}."))) 
NIL 
(|LiouvillianFunction| R F) 
((|constructor|
  (NIL "This package provides liouvillian functions over an integral domain."))
 (|integral|
  ((|#2| |#2| (|SegmentBinding| |#2|))
   "\\spad{integral(f,{} x = a..b)} denotes the definite integral of \\spad{f} with respect to \\spad{x} from \\spad{a} to \\spad{b}.")
  ((|#2| |#2| (|Symbol|))
   "\\spad{integral(f,{} x)} indefinite integral of \\spad{f} with respect to \\spad{x}."))
 (|fresnelC|
  ((|#2| |#2|) "\\spad{fresnelC(f)} denotes the Fresnel integral \\spad{C}"))
 (|fresnelS|
  ((|#2| |#2|) "\\spad{fresnelS(f)} denotes the Fresnel integral \\spad{S}"))
 (|dilog| ((|#2| |#2|) "\\spad{dilog(f)} denotes the dilogarithm"))
 (|erfi| ((|#2| |#2|) "\\spad{erfi(f)} denotes \\spad{-\\%i*erf(\\%i*z)}"))
 (|erf| ((|#2| |#2|) "\\spad{erf(f)} denotes the error function"))
 (|li| ((|#2| |#2|) "\\spad{\\spad{li}(f)} denotes the logarithmic integral"))
 (|Chi| ((|#2| |#2|) "\\spad{Chi(f)} denotes the hyperbolic cosine integral"))
 (|Shi| ((|#2| |#2|) "\\spad{Shi(f)} denotes the hyperbolic sine integral"))
 (|Ci| ((|#2| |#2|) "\\spad{\\spad{Ci}(f)} denotes the cosine integral"))
 (|Si| ((|#2| |#2|) "\\spad{\\spad{Si}(f)} denotes the sine integral"))
 (|Ei| ((|#2| |#2|) "\\spad{\\spad{Ei}(f)} denotes the exponential integral"))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns the Liouvillian operator based on \\spad{op}"))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} checks if \\spad{op} is Liouvillian"))) 
NIL 
(|LiouvillianFunctionCategory|) 
((|constructor| (NIL "Category for the transcendental Liouvillian functions."))
 (|fresnelC|
  (($ $)
   "fresnelC is the Fresnel integral \\spad{C},{} defined by \\spad{C(x) = integrate(cos(\\%pi*t^2/2),{} t=0..x)}"))
 (|fresnelS|
  (($ $)
   "fresnelS is the Fresnel integral \\spad{S},{} defined by \\spad{S(x) = integrate(sin(\\%pi*t^2/2),{} t=0..x)}"))
 (|erfi| (($ $) "\\spad{erfi(x)} denotes \\spad{-\\%i*erf(\\%i*x)}"))
 (|erf|
  (($ $)
   "\\spad{erf(x)} returns the error function of \\spad{x},{} \\spadignore{i.e.} \\spad{2 / sqrt(\\%\\spad{pi})} times the integral of \\spad{exp(-x^2) dx}."))
 (|dilog|
  (($ $)
   "\\spad{dilog(x)} returns the dilogarithm of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{log(x) / (1 - x) dx}."))
 (|li|
  (($ $)
   "\\spad{\\spad{li}(x)} returns the logarithmic integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{dx / log(x)}."))
 (|Chi|
  (($ $)
   "\\spad{Chi(x)} returns the hyperbolic cosine integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{cosh(x) / x dx}."))
 (|Shi|
  (($ $)
   "\\spad{Shi(x)} returns the hyperbolic sine integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{sinh(x) / x dx}."))
 (|Ci|
  (($ $)
   "\\spad{\\spad{Ci}(x)} returns the cosine integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{cos(x) / x dx}."))
 (|Si|
  (($ $)
   "\\spad{\\spad{Si}(x)} returns the sine integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{sin(x) / x dx}."))
 (|Ei|
  (($ $)
   "\\spad{\\spad{Ei}(x)} returns the exponential integral of \\spad{x},{} \\spadignore{i.e.} the integral of \\spad{exp(x)/x dx}."))) 
NIL 
(|LinGroebnerPackage| |lv| F) 
((|constructor|
  (NIL
   "\\indented{1}{Given a Groebner basis \\spad{B} with respect to the total degree ordering for a} zero-dimensional ideal \\spad{I},{} compute a Groebner basis with respect to the lexicographical ordering by using linear algebra. This is an internal package,{} operations in this package may crash the system on invalid input."))
 (|transform|
  (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|DistributedMultivariatePolynomial| |#1| |#2|))
   "\\spad{transform }\\undocumented"))
 (|choosemon|
  (((|DistributedMultivariatePolynomial| |#1| |#2|)
    (|DistributedMultivariatePolynomial| |#1| |#2|)
    (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{choosemon }\\undocumented"))
 (|intcompBasis|
  (((|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|OrderedVariableList| |#1|)
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{intcompBasis }\\undocumented"))
 (|anticoord|
  (((|DistributedMultivariatePolynomial| |#1| |#2|) (|List| |#2|)
    (|DistributedMultivariatePolynomial| |#1| |#2|)
    (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{anticoord }\\undocumented"))
 (|coord|
  (((|Vector| |#2|) (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{coord }\\undocumented"))
 (|computeBasis|
  (((|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)))
   "computeBasis is a helper function which computes a basis of a linear space which contains a lexicographic Groebner basis. It expects a basis (ordered by total degree,{} reverse lexicographic) of a zero dimensional ideal."))
 (|minPol|
  (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|OrderedVariableList| |#1|))
   "\\spad{minPol }\\undocumented")
  (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
    (|OrderedVariableList| |#1|))
   "\\spad{minPol }\\undocumented"))
 (|totolex|
  (((|List| (|DistributedMultivariatePolynomial| |#1| |#2|))
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{totolex }\\undocumented"))
 (|groebgen|
  (((|Record|
     (|:| |glbase| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
     (|:| |glval| (|List| (|Integer|))))
    (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{groebgen }\\undocumented"))
 (|linGenPos|
  (((|Record|
     (|:| |gblist| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)))
     (|:| |gvlist| (|List| (|Integer|))))
    (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)))
   "\\spad{linGenPos }\\undocumented"))) 
NIL 
(|Library|) 
((|constructor|
  (NIL "This domain provides a simple way to save values in files."))
 (|close!|
  (($ $)
   "\\spad{close!(f)} returns the library \\spad{f} closed to input and output."))
 (|setelt!|
  (((|Any|) $ (|Symbol|) (|Any|))
   "\\spad{lib.k := v} saves the value \\spad{v} in the library \\spad{lib}. It can later be extracted using the key \\spad{k}."))
 (|elt|
  (((|Any|) $ (|Symbol|))
   "\\spad{elt(lib,{} k)} or \\spad{lib}.\\spad{k} extracts the value corresponding to the key \\spad{k} from the library \\spad{lib}."))
 (|pack!|
  (($ $)
   "\\spad{pack!(f)} reorganizes the file \\spad{f} on disk to recover unused space."))
 (|library|
  (($ (|FileName|)) "\\spad{library(ln)} creates a new library file."))) 
((|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                '(|BasicType|))
 (|HasCategory| (|String|) '(|OrderedSet|))
 (OR (|HasCategory| (|Any|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| (|Any|) '(|BasicType|))
 (|HasCategory| (|Any|) '(|SetCategory|))
 (AND (|HasCategory| (|Any|) (LIST '|Evalable| '(|Any|)))
      (|HasCategory| (|Any|) '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| '(|String|))
                             (LIST '|:| '|entry| '(|Any|)))))
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                 '(|SetCategory|)))
 (OR (|HasCategory| (|Any|) '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                    '(|SetCategory|)))
 (OR (|HasCategory| (|Any|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Any|) '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                    '(|SetCategory|)))
 (|HasCategory| (|Any|) '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                     '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Any|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Any|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                      '(|BasicType|)))
  (|HasCategory| (|Any|) '(|SetCategory|))
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|)))
                 '(|SetCategory|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Any|) '(|OrderedSet|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|AssociatedLieAlgebra| R A) 
((|constructor|
  (NIL
   "AssociatedLieAlgebra takes an algebra \\spad{A} and uses \\spadfun{*\\$A} to define the Lie bracket \\spad{a*b := (a *\\$A b - b *\\$A a)} (commutator). Note that the notation \\spad{[a,{} b]} cannot be used due to restrictions of the current compiler. This domain only gives a Lie algebra if the Jacobi-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \\spad{a},{} \\spad{b},{} \\spad{c} in \\spad{A}. This relation can be checked by \\spad{lieAdmissible?()\\$A}. \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank,{} together with a fixed \\spad{R}-module basis),{} then the same is \\spad{true} for the associated Lie algebra. Also,{} if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank),{} then the same is \\spad{true} for the associated Lie algebra."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(a)} coerces the element \\spad{a} of the algebra \\spad{A} to an element of the Lie algebra \\spadtype{AssociatedLieAlgebra}(\\spad{R},{} A)."))) 
((|HasCategory| |#2| (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|)))
 (AND (|HasCategory| |#1| '(|Finite|))
      (|HasCategory| |#2|
                     (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))
 (|HasCategory| |#2|
                (LIST '|FiniteRankNonAssociativeAlgebra| (|devaluate| |#1|)))
 (OR
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| |#2|
                      (LIST '|FiniteRankNonAssociativeAlgebra|
                            (|devaluate| |#1|))))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| |#2|
                      (LIST '|FramedNonAssociativeAlgebra|
                            (|devaluate| |#1|)))))
 (OR
  (|HasCategory| |#2|
                 (LIST '|FiniteRankNonAssociativeAlgebra| (|devaluate| |#1|)))
  (|HasCategory| |#2|
                 (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|FramedNonAssociativeAlgebra| (|devaluate| |#1|))))) 
(|LieAlgebra&| S R) 
((|constructor|
  (NIL
   "The category of Lie Algebras. It is used by the following domains of non-commutative algebra: \\spadtype{LiePolynomial} and \\spadtype{XPBWPolynomial}. \\newline Author : Michel Petitot (petitot@lifl.\\spad{fr})."))
 (/ (($ $ |#2|) "\\spad{x/r} returns the division of \\spad{x} by \\spad{r}."))
 (|construct|
  (($ $ $)
   "\\spad{construct(x,{} y)} returns the Lie bracket of \\spad{x} and \\spad{y}."))) 
((|HasCategory| |#2| '(|Field|))) 
(|LieAlgebra| R) 
((|constructor|
  (NIL
   "The category of Lie Algebras. It is used by the following domains of non-commutative algebra: \\spadtype{LiePolynomial} and \\spadtype{XPBWPolynomial}. \\newline Author : Michel Petitot (petitot@lifl.\\spad{fr})."))
 (/ (($ $ |#1|) "\\spad{x/r} returns the division of \\spad{x} by \\spad{r}."))
 (|construct|
  (($ $ $)
   "\\spad{construct(x,{} y)} returns the Lie bracket of \\spad{x} and \\spad{y}."))) 
NIL 
(|PowerSeriesLimitPackage| R FE) 
((|constructor|
  (NIL
   "PowerSeriesLimitPackage implements limits of expressions in one or more variables as one of the variables approaches a limiting value. Included are two-sided limits,{} left- and right- hand limits,{} and limits at plus or minus infinity."))
 (|complexLimit|
  (((|Union| (|OnePointCompletion| |#2|) "failed") |#2|
    (|Equation| (|OnePointCompletion| |#2|)))
   "\\spad{complexLimit(f(x),{} x = a)} computes the complex limit \\spad{lim(x -> a,{} f(x))}."))
 (|limit|
  (((|Union| (|OrderedCompletion| |#2|) #1="failed") |#2| (|Equation| |#2|)
    (|String|))
   "\\spad{limit(f(x),{}x=a,{}\"left\")} computes the left hand real limit \\spad{lim(x -> a-,{} f(x))}; \\spad{limit(f(x),{}x=a,{}\"right\")} computes the right hand real limit \\spad{lim(x -> a+,{} f(x))}.")
  (((|Union| (|OrderedCompletion| |#2|)
             (|Record|
              (|:| |leftHandLimit| (|Union| (|OrderedCompletion| |#2|) #1#))
              (|:| |rightHandLimit| (|Union| (|OrderedCompletion| |#2|) #1#)))
             "failed")
    |#2| (|Equation| (|OrderedCompletion| |#2|)))
   "\\spad{limit(f(x),{} x = a)} computes the real limit \\spad{lim(x -> a,{} f(x))}."))) 
NIL 
(|RationalFunctionLimitPackage| R) 
((|constructor| (NIL "Computation of limits for rational functions."))
 (|complexLimit|
  (((|OnePointCompletion| (|Fraction| (|Polynomial| |#1|)))
    (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{complexLimit(f(x),{} x = a)} computes the complex limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}.")
  (((|OnePointCompletion| (|Fraction| (|Polynomial| |#1|)))
    (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|OnePointCompletion| (|Polynomial| |#1|))))
   "\\spad{complexLimit(f(x),{} x = a)} computes the complex limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}."))
 (|limit|
  (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
             #1="failed")
    (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|Fraction| (|Polynomial| |#1|))) (|String|))
   "\\spad{limit(f(x),{}x,{}a,{}\"left\")} computes the real limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a} from the left; limit(\\spad{f}(\\spad{x}),{}\\spad{x},{}a,{}\"right\") computes the corresponding limit as \\spad{x} approaches \\spad{a} from the right.")
  (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
             (|Record|
              (|:| |leftHandLimit|
                   (|Union|
                    (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
                    #1#))
              (|:| |rightHandLimit|
                   (|Union|
                    (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
                    #1#)))
             #2="failed")
    (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{limit(f(x),{} x = a)} computes the real two-sided limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}.")
  (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
             (|Record|
              (|:| |leftHandLimit|
                   (|Union|
                    (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
                    #1#))
              (|:| |rightHandLimit|
                   (|Union|
                    (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))
                    #1#)))
             #2#)
    (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|OrderedCompletion| (|Polynomial| |#1|))))
   "\\spad{limit(f(x),{} x = a)} computes the real two-sided limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}."))) 
NIL 
(|LinearCombinationUtilities| F UP) 
((|lin_comb!|
  (((|Vector| |#1|) (|Vector| |#1|) (|Vector| |#1|) (|List| (|Vector| |#1|)))
   "\\spad{lin_comb!(v,{} w,{} [f1,{} ...,{} fn])} computes linear combination \\spad{w} + \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn} by modifying \\spad{w} in place. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length."))
 (|lin_comb|
  ((|#2| (|Vector| |#1|) (|List| |#2|))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length.")
  (((|LaurentPolynomial| |#1| |#2|) (|Vector| |#1|)
    (|List| (|LaurentPolynomial| |#1| |#2|)))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length.")
  (((|Fraction| |#2|) (|Vector| (|Fraction| (|Integer|)))
    (|List| (|Fraction| |#2|)))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length.")
  (((|Fraction| |#2|) (|Vector| |#1|) (|List| (|Fraction| |#2|)))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length.")
  (((|Vector| |#1|) (|Vector| |#1|) (|List| (|Vector| |#1|)))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal positive length.")
  ((|#1| (|Vector| (|Fraction| (|Integer|))) (|List| |#1|))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length.")
  ((|#1| (|Vector| |#1|) (|List| |#1|))
   "\\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \\spad{v}(1) \\spad{f1} + ... \\spad{v}(\\spad{n}) \\spad{fn}. Vector \\spad{v} and list [\\spad{f1},{} ...,{} \\spad{fn}] must be of equal length."))
 (|dehomogenize|
  (((|Record|
     (|:| |particular|
          (|Union|
           (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|)))
           "failed"))
     (|:| |basis|
          (|List|
           (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|))))))
    (|List| (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|)))))
   "\\spad{dehomogenize(ls)} converts list of solutions (a,{} [\\spad{c0},{} \\spad{c1},{} ...,{} \\spad{cn}]) to homogeneous equation \\spad{L}(a) + \\spad{c0} \\spad{f} + \\spad{c1} \\spad{g1} + ... + \\spad{cn} \\spad{gn} = 0 into list of solutions of inhomogeneous equation \\spad{L}(a) + \\spad{f} + \\spad{c1} \\spad{g1} + ... + \\spad{cn} \\spad{gn} = 0. This transformation works the same for all equations,{} so we only need list of solutions as argument"))) 
NIL 
(|LinearDependence| S R) 
((|constructor| (NIL "Test for linear dependence."))
 (|solveLinear|
  (((|Record|
     (|:| |particular| (|Union| (|Vector| (|Fraction| |#1|)) #1="failed"))
     (|:| |basis| (|List| (|Vector| (|Fraction| |#1|)))))
    (|Matrix| |#2|) (|Vector| |#2|))
   "\\spad{solveLinear([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}")
  (((|Record| (|:| |particular| (|Union| (|Vector| (|Fraction| |#1|)) #1#))
              (|:| |basis| (|List| (|Vector| (|Fraction| |#1|)))))
    (|Vector| |#2|) |#2|)
   "\\spad{solveLinear([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) #2="failed"))
              (|:| |basis| (|List| (|Vector| |#1|))))
    (|Matrix| |#2|) (|Vector| |#2|))
   "\\spad{solveLinear([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) #2#))
              (|:| |basis| (|List| (|Vector| |#1|))))
    (|Vector| |#2|) |#2|)
   "\\spad{solveLinear([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}"))
 (|particularSolution|
  (((|Union| (|Vector| (|Fraction| |#1|)) #1#) (|Matrix| |#2|) (|Vector| |#2|))
   "\\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such \\spad{ci}\\spad{'s} exist in the quotient field of \\spad{S}.")
  (((|Union| (|Vector| (|Fraction| |#1|)) #1#) (|Vector| |#2|) |#2|)
   "\\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such \\spad{ci}\\spad{'s} exist in the quotient field of \\spad{S}.")
  (((|Union| (|Vector| |#1|) #2#) (|Matrix| |#2|) (|Vector| |#2|))
   "\\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such \\spad{ci}\\spad{'s} exist in \\spad{S}.")
  (((|Union| (|Vector| |#1|) #2#) (|Vector| |#2|) |#2|)
   "\\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such \\spad{ci}\\spad{'s} exist in \\spad{S}."))
 (|linearDependence|
  (((|Union| (|Vector| |#1|) #2#) (|Vector| |#2|))
   "\\spad{linearDependence([v1,{} ...,{} vn])} returns \\spad{[c1,{} ...,{} cn]} if \\spad{c1*v1 + ... + cn*vn = 0} and not all the \\spad{ci}\\spad{'s} are 0,{} \"failed\" if the \\spad{vi}\\spad{'s} are linearly independent over \\spad{S}."))
 (|linearlyDependent?|
  (((|Boolean|) (|Vector| |#2|))
   "\\spad{linearlyDependent?([v1,{} ...,{} vn])} returns \\spad{true} if the \\spad{vi}\\spad{'s} are linearly dependent over \\spad{S},{} \\spad{false} otherwise."))) 
((|HasCategory| |#1| '(|Field|)) (|not| (|HasCategory| |#1| '(|Field|)))) 
(|LinearlyExplicitOver| R) 
((|constructor|
  (NIL "An extension ring with an explicit linear dependence test."))
 (|reducedSystem|
  (((|Record| (|:| |mat| (|Matrix| |#1|)) (|:| |vec| (|Vector| |#1|)))
    (|Matrix| $) (|Vector| $))
   "\\spad{reducedSystem(A,{} v)} returns a matrix \\spad{B} and a vector \\spad{w} such that \\spad{A x = v} and \\spad{B x = w} have the same solutions in \\spad{R}.")
  (((|Matrix| |#1|) (|Matrix| $))
   "\\spad{reducedSystem(A)} returns a matrix \\spad{B} such that \\spad{A x = 0} and \\spad{B x = 0} have the same solutions in \\spad{R}."))) 
NIL 
(|LinearMultivariateMatrixPencil| R) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Konrad Schrempf <schrempf@math.tugraz.at>} Date Created: Mit 2016-02-03 17:20 Date Changed: Sam 2018-09-01 10:37 Basic Functions: Related Constructors: Matrix Also See: FreeDivisionAlgebra AMS Classifications: Keywords: References: Description:"))
 (|eliminationSolve|
  (((|List| (|List| (|Equation| (|Polynomial| |#1|))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{eliminationSolve(lst_eqn)} calls eliminationSolve(\\spad{lst_eqn},{} [0,{}1],{} []).")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|))))
    (|List| (|Polynomial| |#1|)) (|List| |#1|)
    (|List| (|List| (|Equation| (|Polynomial| |#1|)))))
   "\\spad{eliminationSolve(lst_eqn,{} lst_val,{} lst_sub)} computes all solutions of the first equation of \\spad{lst_eqn} by trying the values of \\spad{lst_val} for undetermined variables with respect to given subsolutions lst_sub and return those which fulfill all other equations in \\spad{lst_eqn}.")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|)))) (|Polynomial| |#1|)
    (|List| |#1|) (|List| (|List| (|Equation| (|Polynomial| |#1|)))))
   "\\spad{eliminationSolve(eqn,{} lst_val,{} lst_sub)} computes all solutions of equation \\spad{eqn} by trying the values of \\spad{lst_val} for undetermined variables with respect to given subsolutions lst_sub.")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|)))) (|Polynomial| |#1|)
    (|List| |#1|) (|List| (|Equation| (|Polynomial| |#1|))))
   "\\spad{eliminationSolve(eqn,{} lst_val,{} sub)} computes all solutions of equation \\spad{eqn} by trying the values of \\spad{lst_val} for undetermined variables with respect to given subsolution sub.")
  (((|List| (|List| (|Equation| (|Polynomial| |#1|)))) (|Polynomial| |#1|)
    (|List| |#1|))
   "\\spad{eliminationSolve(eqn,{} lst_val)} computes all solutions of equation \\spad{eqn} by trying the values of lst_val for undetermined variables."))
 (|eliminationGroebner|
  (((|List| (|Polynomial| |#1|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{eliminationGroebner(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} computes a Groebner--Shirshov basis for the ideal generated by the equations from eliminationEquations(...) using the domain DistributedMultivariatePolynomial."))
 (|eliminationEquations|
  (((|List| (|Polynomial| |#1|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} returns a list of equations with equations to eliminate the entries in rows/columns rdst/cdst,{} \\spad{rex1/cex1} and \\spad{rex2/cex2},{} including det(\\spad{P})\\spad{-1} and det(\\spad{Q})\\spad{-1}.")
  (((|List| (|Matrix| (|Polynomial| |#1|))) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} returns a list of matrices with equations to eliminate the entries in rows/columns rdst/cdst,{} \\spad{rex1/cex1} and \\spad{rex2/cex2}.")
  (((|List| (|Matrix| (|Polynomial| |#1|))) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst)} returns a list of matrices with equations to eliminate the entries in rows/columns rdst/cdst."))
 (|eliminationTransformations|
  (((|List| (|Matrix| |#1|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|Equation| (|Polynomial| |#1|))))
   "\\spad{eliminationTransformations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} sol)} Uses eval to set the values in sol into the variables in the transformation matrices.")
  (((|List| (|Matrix| (|Polynomial| |#1|))) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{eliminationTransformations(p,{} row_P,{} col_P,{} row_Q,{} col_Q)} returns a pair of transformation matrices with commutative variables 'a[\\spad{i}] in rows/columns row_P/col_P respectively \\spad{'b}[\\spad{i}] in rows/columns row_Q/col_Q.")
  (((|List| (|Matrix| (|Polynomial| |#1|))) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|Symbol|) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|Symbol|))
   "\\spad{eliminationTransformations(p,{} row_P,{} col_P,{} sym_P,{} row_Q,{} col_Q,{} sym_Q)} returns a pair of transformation matrices with commutative variables \\spad{sym_P}[\\spad{i}] in rows/columns row_P/col_P respectively sym_Q[\\spad{i}] in rows/columns row_Q/col_Q."))
 (|blockElimination|
  (((|List| (|Matrix| |#1|)) $ (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))
    (|List| (|NonNegativeInteger|)))
   "\\spad{blockElimination(p,{} rsrc,{} rdst,{} rext,{} csrc,{} cdst,{} cext)} r___ rows,{} c___ columns _src source,{} _dst destination,{} _ext extra (zeros) Uses a linear system of equations to determine row and column transformation matrices to eliminate the entries in rdst+rext \\times cdst+cext and returns an empty list if there is no solution."))
 (|setsubPencil!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) $)
   "\\spad{setsubPencil!(p,{} i,{} j,{} q)} sets the matrices of pencil \\spad{q} into the matrices of \\spad{p} in position (\\spad{i},{}\\spad{j})."))
 (|setsubMatrix!|
  (((|Matrix| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|Matrix| |#1|))
   "\\spad{setsubMatrix!(p,{} i,{} j,{} l,{} a)} sets the matrix a into the matrix \\spad{l} of \\spad{p} in position (\\spad{i},{}\\spad{j})."))
 (|setelt!|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| |#1|))
   "\\spad{setelt!(p,{} i,{} j,{} lst)} sets the element (\\spad{i},{}\\spad{j}) in the matrices of the linear pencil \\spad{p} according to the elements in \\spad{lst}.")
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    |#1|)
   "\\spad{selelt!(p,{} i,{} j,{} l,{} alpha)} sets the element (\\spad{i},{}\\spad{j}) in matrix \\spad{l} of the linear pencil \\spad{p} to alpha."))
 (|qsetelt!|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List| |#1|))
   "\\spad{qsetelt!(p,{} i,{} j,{} lst)} sets the element (\\spad{i},{}\\spad{j}) in the matrices of the linear pencil \\spad{p} according to the elements in \\spad{lst}.")
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    |#1|)
   "\\spad{qselelt!(p,{} i,{} j,{} l,{} alpha)} sets the element (\\spad{i},{}\\spad{j}) in matrix \\spad{l} of the linear pencil \\spad{p} to alpha."))
 (|rightIdentity|
  (((|Matrix| |#1|) $)
   "\\spad{rightIdentity(p)} returns the right identity matrix."))
 (|leftIdentity|
  (((|Matrix| |#1|) $)
   "\\spad{leftIdentity(p)} returns the left identity matrix."))
 (|transformColumns!|
  (($ $ (|Matrix| |#1|))
   "\\spad{transformColumns!(p,{} U)} multiplies the matrices of the linear pencil from the right by \\spad{U}."))
 (|transformRows!|
  (($ $ (|Matrix| |#1|))
   "\\spad{transformRows!(p,{} T)} multiplies the matrices of the linear pencil from the left by \\spad{T}."))
 (* (($ (|Matrix| |#1|) $) "\\spad{T * P} row transformation ...")
    (($ $ (|Matrix| |#1|)) "\\spad{p * U} column transformation ..."))
 (|qscaleBlock!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{qscalesubMatrix!(p,{} i_min,{} i_max,{} j_min,{} j_max,{} l,{} alpha)} multiplies the entries in the specified block of matrix \\spad{l} with alpha."))
 (|qmultiplyColumn!|
  (($ $ (|NonNegativeInteger|) |#1|)
   "\\spad{multiplyColumn!(p,{} j,{} alphat)} multiplies column(\\spad{j}) by alpha."))
 (|multiplyColumn!|
  (($ $ (|NonNegativeInteger|) |#1|)
   "\\spad{multiplyColumn!(p,{} j,{} alphat)} multiplies column(\\spad{j}) by alpha."))
 (|qaddColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{addColumns!(p,{} i,{} j,{} alpha)} adds alpha*column(\\spad{i}) to column(\\spad{j}) in all matrices of the linear pencil \\spad{p}. (no index check)"))
 (|addColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{addColumns!(p,{} i,{} j,{} alpha)} adds alpha*column(\\spad{i}) to column(\\spad{j}) in all matrices of the linear pencil \\spad{p}."))
 (|swapColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapColumns!(p,{} i,{} j)} exchanges columns \\spad{i} and \\spad{j} in all matrices of the linear pencil \\spad{p}."))
 (|qswapColumns!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qswapColumns!(p,{} i,{} j)} exchanges columns \\spad{i} and \\spad{j} in all matrices of the linear pencil \\spad{p} (no index check)"))
 (|multiplyRow!|
  (($ $ (|NonNegativeInteger|) |#1|)
   "\\spad{multiplyRow!(p,{} i,{} alpha)} multiplies row(\\spad{i}) by alpha."))
 (|qmultiplyRow!|
  (($ $ (|NonNegativeInteger|) |#1|)
   "\\spad{qmultiplyRow!(p,{} i,{} alpha)} multiplies row(\\spad{i}) by alpha. (no index check)"))
 (|qaddRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{qaddRows!(p,{} i,{} j,{} alpha)} adds alpha*row(\\spad{i}) to row(\\spad{j}) in all matrices of the linear pencil \\spad{p} (no index check). (no index check)"))
 (|addRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{addRows!(p,{} i,{} j,{} alpha)} adds alpha*row(\\spad{i}) to row(\\spad{j}) in all matrices of the linear pencil \\spad{p}."))
 (|qswapRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qswapRows!(p,{} i,{} j)} exchanges rows \\spad{i} and \\spad{j} in all matrices of the linear pencil \\spad{p} (no index check)."))
 (|swapRows!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{swapRows!(p,{} i,{} j)} exchanges rows \\spad{i} and \\spad{j} in all matrices of the linear pencil \\spad{p}."))
 (|insertRowsColumns|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{insertRowsColumns(p,{} lst_row,{} lst_col)} returns a new pencil with additional rows and columns after the specified indices. addRowsColumns(\\spad{p},{} [0,{}0,{}1],{} [0,{}0,{}3]) would insert 2 rows and columns at the beginning an one row and column between rows 1 and 2 and columns 3 and 4 respectively."))
 (|removeRowsColumns|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{removeRowsColumns(p,{} lst_row,{} lst_col)} returns a new pencil with submatrices specified by the complement of the list of rows and columns."))
 (|subPencil|
  (($ $ (|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{subPencil(p,{} lst_row,{} lst_col)} returns a pencil with submatrices specified by a list of rows and columns.")
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{subPencil(p,{} r_min,{} r_max,{} c_min,{} c_max)} returns a pencil with the specified submatrices."))
 (|subMatrix|
  (((|Matrix| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{subMatrix(p,{} r_min,{} r_max,{} c_min,{} c_max,{} l)} returns the specified submatrix \\spad{l} of the linear pencil \\spad{p}."))
 (|matrix|
  (((|Matrix| |#1|) $ (|NonNegativeInteger|))
   "\\spad{matrix(p,{} l)} returns matrix \\spad{l} in the linear pencil \\spad{p}."))
 (|elt|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{elt(p,{} i,{} j)} returns the elements (\\spad{i},{}\\spad{j}) from the linear pencil \\spad{p} as a list.")
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{elt(p,{} i,{} j,{} l)} returns the element (\\spad{i},{}\\spad{j}) in matrix \\spad{l} of the linear pencil \\spad{p}."))
 (|qelt|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{elt(p,{} i,{} j)} returns the elements (\\spad{i},{}\\spad{j}) from the linear pencil \\spad{p} as a list (no check).")
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{elt(p,{} i,{} j,{} l)} returns the element (\\spad{i},{}\\spad{j}) in matrix \\spad{l} of the linear pencil \\spad{p} (no index-check)."))
 (|qrowIndices|
  (((|List| (|List| (|NonNegativeInteger|))) $ (|NonNegativeInteger|))
   "\\spad{qrowIndices(p,{} off)} returns a list of row indices for nonzero elements for every column starting at the specified offset. (no range check)")
  (((|List| (|List| (|NonNegativeInteger|))) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qrowIndices(p,{} off,{} l)} returns a list of row indices for nonzero elements in matrix \\spad{l} for every column starting at the specified offset. (no range check)")
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qrowIndices(p,{} off,{} j,{} l)} returns a list of row indices for nozero elements in column \\spad{j} in matrix \\spad{l} (no range check)"))
 (|qcolumnIndices|
  (((|List| (|List| (|NonNegativeInteger|))) $ (|NonNegativeInteger|))
   "\\spad{qcolumnIndices(p,{} off)} returns a list of column indices for nozero elements for every row starting at the specified offset. (no range check)")
  (((|List| (|NonNegativeInteger|)) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qcolumnIndices(p,{} off,{} i,{} l)} returns a list of column indices for nonzero elements in the specified row of matrix \\spad{l} for starting at the specified offset. (no range check)")
  (((|List| (|List| (|NonNegativeInteger|))) $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qcolumnIndices(p,{} off,{} l)} returns a list of column indices for nonzero elements in matrix \\spad{l} for every row starting at the specified offset. (no range check)"))
 (|qnilpotent?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qnilpotent?(p,{} k_min,{} k_max,{} l)} ist the matrix \\spad{l} nilpotent with respect to the specified block? (no range check)"))
 (|quppertriangular?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{quppertriangular?(p,{} k_min,{} k_max,{} l)} is the matrix \\spad{l} upper triangular with respect to the specified block? (no range check)"))
 (|uppertriangular?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{uppertriangular?(p,{} l)} is the matrix \\spad{l} upper triangular?"))
 (|qdiagonal|
  (((|List| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qdiagonal(p,{} k_min,{} k_max,{} l)} returns the entries along the diagonal between \\spad{k_min} and \\spad{k_max}. (no range check)"))
 (|diagonal|
  (((|List| |#1|) $ (|NonNegativeInteger|))
   "\\spad{diagonal(p,{} l)} returns the entries along the diagonal in a list."))
 (|qdiagonal?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{qdiagonal?(p,{} k_min,{} k_max,{} l)} is the matrix \\spad{l} diagonal between \\spad{k_min} and k_max? (no range check)"))
 (|diagonal?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{diagonal?(p,{} l)} is the matrix \\spad{l} diagonal?"))
 (|zero?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{zero?(p,{} i,{} j)} checks if all the entries (\\spad{i},{}\\spad{j}) of the linear pencil \\spad{p} are zero."))
 (|qsemizero?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qsemizero?(p,{} i_min,{} i_max,{} j_min,{} j_max,{} l)} checks,{} if the specified submatrix is zero except for matrix \\spad{l} (no index check)."))
 (|qzero?|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qzero?(p,{} i_min,{} i_max,{} j_min,{} j_max,{} l)} checks if the specified block of matrix \\spad{l} of the linear pencil \\spad{p} is zero (no index check)")
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qzero?(p,{} i_min,{} i_max,{} j_min,{} j_max)} checks if the specified block of the linear pencil \\spad{p} is zero for all matrices. (no index check)")
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qzero?(p,{} i,{} j)} checks if all the entries (\\spad{i},{}\\spad{j}) of the linear pencil \\spad{p} are zero. (no index check)"))
 (|nelem|
  (((|NonNegativeInteger|) $)
   "\\spad{nelem(p)} returns the number of elements."))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(p)} returns the number of columns."))
 (|nrows|
  (((|NonNegativeInteger|) $) "\\spad{nrows(p)} returns the number of rows."))
 (|qequal?|
  (((|Boolean|) $ (|List| (|NonNegativeInteger|)) $
    (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{qequal?(p,{} pos_p,{} q,{} pos_q,{} offset)} checks,{} if the matrices are equal starting at offset."))
 (|equal?|
  (((|Boolean|) $ (|List| (|NonNegativeInteger|)) $
    (|List| (|NonNegativeInteger|)))
   "\\spad{equal?(p,{} pos_p,{} q,{} pos_q)} checks,{} if the matrices \\spad{pos_p} in \\spad{p} are equal to the pos_q in \\spad{q}. Not spacified matrices have to be zero."))
 (= (((|Boolean|) $ $) "\\spad{p = q} entrywise equality."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(p)} prints the linear pencil \\spad{p} in list form."))
 (|append!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{append!(p,{} l)} appends \\spad{l} matrices to the linear pencil."))
 (|append|
  (($ $ (|NonNegativeInteger|))
   "\\spad{append(p,{} l)} appends \\spad{l} matrices to the linear pencil."))
 (|copy|
  (($ $) "\\spad{copy(p)} returns a copy of the linear pencil \\spad{p}."))
 (|qnew|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{qnew(m,{} n,{} l)} creates an empty linear pencil with \\spad{l} matrices with \\spad{m} rows and \\spad{n} columns."))) 
((|HasCategory| |#1| '(|Field|))) 
(|List| S) 
((|constructor|
  (NIL
   "\\spadtype{List} implements singly-linked lists that are addressable by indices; the index of the first element is 1. In addition to the operations provided by \\spadtype{ListAggregate},{} this constructor provides some LISP-like functions such as \\spadfun{cons} and \\spadfun{append}."))
 (|setDifference|
  (($ $ $)
   "\\spad{setDifference(u1,{} u2)} returns a list of the elements of \\spad{u1} that are not also in \\spad{u2}. The order of elements in the resulting list is unspecified."))
 (|setIntersection|
  (($ $ $)
   "\\spad{setIntersection(u1,{} u2)} returns a list of the elements that lists \\spad{u1} and \\spad{u2} have in common. The order of elements in the resulting list is unspecified."))
 (|setUnion|
  (($ $ $)
   "\\spad{setUnion(u1,{} u2)} appends the two lists \\spad{u1} and \\spad{u2},{} then removes all duplicates. The order of elements in the resulting list is unspecified."))
 (|tails|
  (((|List| $) $)
   "\\spad{tails(u)} returns list [rest(\\spad{u},{} 0),{} rest(\\spad{u},{} 1),{} ...,{} rest(\\spad{u},{} \\#u - 1)]."))
 (|append|
  (($ $ $)
   "\\spad{append(u1,{} u2)} appends the elements of list \\spad{u1} onto the front of list \\spad{u2}. This new list and \\spad{u2} will share some structure."))
 (|cons|
  (($ |#1| $)
   "\\spad{cons(element,{} u)} appends \\spad{element} onto the front of list \\spad{u} and returns the new list. This new list and the old one will share some structure."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OpenMath|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))) 
(|ListFunctions2| A B) 
((|constructor|
  (NIL
   "\\spadtype{ListFunctions2} implements utility functions that operate on two kinds of lists,{} each with a possibly different type of element."))
 (|map|
  (((|List| |#2|) (|Mapping| |#2| |#1|) (|List| |#1|))
   "\\spad{map(fn,{} u)} applies \\spad{fn} to each element of list \\spad{u} and returns a new list with the results. For example \\spad{map(square,{} [1,{} 2,{} 3]) = [1,{} 4,{} 9]}."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#1| |#2|) (|List| |#1|) |#2|)
   "\\spad{reduce(fn,{} u,{} ident)} successively uses the binary function \\spad{fn} on the elements of list \\spad{u} and the result of previous applications. \\spad{ident} is returned if the \\spad{u} is empty. Note the order of application in the following examples: \\spad{reduce(fn,{} [1,{} 2,{} 3],{} 0) = fn(3,{} fn(2,{} fn(1,{} 0)))} and \\spad{reduce(*,{} [2,{} 3],{} 1) = 3 * (2 * 1)}."))
 (|scan|
  (((|List| |#2|) (|Mapping| |#2| |#1| |#2|) (|List| |#1|) |#2|)
   "\\spad{scan(fn,{} u,{} ident)} successively uses the binary function \\spad{fn} to reduce more and more of list \\spad{u}. \\spad{ident} is returned if the \\spad{u} is empty. The result is a list of the reductions at each step. See \\spadfun{reduce} for more information. Examples: \\spad{scan(fn,{} [1,{} 2],{} 0) = [fn(2,{} fn(1,{} 0)),{} fn(1,{} 0)]} and \\spad{scan(*,{} [2,{} 3],{} 1) = [2 * 1,{} 3 * (2 * 1)]}."))) 
NIL 
(|ListToMap| A B) 
((|constructor|
  (NIL
   "\\spadtype{ListToMap} allows mappings to be described by a pair of lists of equal lengths. The image of an element \\spad{x},{} which appears in position \\spad{n} in the first list,{} is then the \\spad{n}th element of the second list. A default value or default function can be specified to be used when \\spad{x} does not appear in the first list. In the absence of defaults,{} an error will occur in that case."))
 (|match|
  ((|#2| (|List| |#1|) (|List| |#2|) |#1| (|Mapping| |#2| |#1|))
   "\\spad{match(la,{} lb,{} a,{} f)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length,{} and applies this map to a. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Argument \\spad{f} is a default function to call if a is not in \\spad{la}. The value returned is then obtained by applying \\spad{f} to argument a.")
  (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|) (|Mapping| |#2| |#1|))
   "\\spad{match(la,{} lb,{} f)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Argument \\spad{f} is used as the function to call when the given function argument is not in \\spad{la}. The value returned is \\spad{f} applied to that argument.")
  ((|#2| (|List| |#1|) (|List| |#2|) |#1| |#2|)
   "\\spad{match(la,{} lb,{} a,{} b)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length,{} and applies this map to a. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Argument \\spad{b} is the default target value if a is not in \\spad{la}. Error: if \\spad{la} and \\spad{lb} are not of equal length.")
  (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|) |#2|)
   "\\spad{match(la,{} lb,{} b)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length,{} where \\spad{b} is used as the default target value if the given function argument is not in \\spad{la}. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Error: if \\spad{la} and \\spad{lb} are not of equal length.")
  ((|#2| (|List| |#1|) (|List| |#2|) |#1|)
   "\\spad{match(la,{} lb,{} a)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length,{} where \\spad{a} is used as the default source value if the given one is not in \\spad{la}. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Error: if \\spad{la} and \\spad{lb} are not of equal length.")
  (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|))
   "\\spad{match(la,{} lb)} creates a map with no default source or target values defined by lists \\spad{la} and \\spad{lb} of equal length. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index in \\spad{lb}. Error: if \\spad{la} and \\spad{lb} are not of equal length. Note: when this map is applied,{} an error occurs when applied to a value missing from \\spad{la}."))) 
NIL 
(|ListFunctions3| A B C) 
((|constructor|
  (NIL
   "\\spadtype{ListFunctions3} implements utility functions that operate on three kinds of lists,{} each with a possibly different type of element."))
 (|map|
  (((|List| |#3|) (|Mapping| |#3| |#1| |#2|) (|List| |#1|) (|List| |#2|))
   "\\spad{map(fn,{} u1,{} u2)} applies the binary function \\spad{fn} to corresponding elements of lists \\spad{u1} and \\spad{u2} and returns a list of the results (in the same order). Thus \\spad{map(/,{} [1,{} 2,{} 3],{} [4,{} 5,{} 6]) = [1/4,{} 2/5,{} 1/2]}. The computation terminates when the end of either list is reached. That is,{} the length of the result list is equal to the minimum of the lengths of \\spad{u1} and \\spad{u2}."))) 
NIL 
(|ListPackage| T$) 
((|constructor| (NIL "splitting lists"))
 (|minShift|
  (((|List| |#1|) (|List| |#1|))
   "\\spad{minShift(l)} returns the lexicographically minimal cyclic rotation of the list \\spad{l}"))
 (|cartesianPower|
  (((|List| (|List| |#1|)) (|List| |#1|) (|NonNegativeInteger|))
   "\\spad{cartesianPower(S,{} n)} returns the \\spad{n}-th cartesian power of the list \\spad{S}"))
 (|cartesian|
  (((|List| (|List| |#1|)) (|List| (|List| |#1|)))
   "\\spad{cartesian([S1,{} S2,{} ...])} returns the set of lists [\\spad{s1},{} \\spad{s2},{} ...] with \\spad{si} in \\spad{Si}"))
 (|shiftLeft|
  (((|List| |#1|) (|List| |#1|))
   "\\spad{leftShift(l)} rotates the list \\spad{l} to the left and inserts the first element at the end"))
 (|topologicalSort|
  (((|List| |#1|) (|List| (|List| (|Boolean|))) (|List| |#1|))
   "\\spad{topologicalSort(xx)} returns a rearrangement of the elements which is compatible with the partial order. (Martin Baker) \\spad{I} added this version because predicate function can be difficult to work with so use table instead.")
  (((|List| |#1|) (|Mapping| (|Boolean|) |#1| |#1|) (|List| |#1|))
   "\\spad{topologicalSort(xx)} returns a rearrangement of the elements which is compatible with the partial order."))
 (|topologicalSort!|
  (((|List| |#1|) (|Mapping| (|Boolean|) |#1| |#1|) (|List| |#1|))
   "\\spad{topologicalSort(xx)} returns a rearrangement of the elements which is compatible with the partial order. The argument list \\spad{xx} is destroyed."))
 (|splitList|
  (((|Record| (|:| |yes| (|List| |#1|)) (|:| |no| (|List| |#1|)))
    (|Mapping| (|Boolean|) |#1|) (|List| |#1|))
   "\\spad{splitList(f,{} x)} splits the list \\spad{x} into a yes part and a no part according to the boolean function \\spad{f}"))) 
((|HasCategory| |#1| '(|OrderedSet|))) 
(|LiftLinearDependence| F Q UP) 
((|csolve_rmat|
  (((|List| (|Vector| |#2|))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#1|))
    (|Matrix| (|Fraction| |#3|)))
   "\\spad{csolve_rmat(solf,{} mrf)} uses \\spad{solf} to solve linear dependence for univariate rational functions."))
 (|csolve_rf|
  (((|List| (|Vector| |#2|))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#1|))
    (|List| (|Fraction| |#3|)))
   "\\spad{csolve_rf(solf,{} lrf)} uses \\spad{solf} to solve linear dependence for univariate rational functions."))
 (|csolve_pol|
  (((|List| (|Vector| |#2|))
    (|Mapping| (|List| (|Vector| |#2|)) (|Matrix| |#1|)) (|List| |#3|))
   "\\spad{csolve_pol(solf,{} lp)} uses \\spad{solf} to solve linear dependence for univariate polynomials."))) 
NIL 
(|LLLReduction|) 
((|constructor|
  (NIL
   "This package implements \\spad{LLL} reduction. Before \\indented{1}{use user must set appropriate floating point precision.\\space{2}Too} \\indented{1}{low precision may cause nontermination.\\space{2}Higher precisions} \\indented{1}{require more compute time.}"))
 (|find_relation|
  (((|List| (|Integer|)) (|List| (|Float|)) (|NonNegativeInteger|))
   "\\spad{find_relation(lf,{} k)} finds short integer relation between elements of \\spad{lf} rounded to \\spad{k} decimal places."))
 (|extendedLLL|
  (((|Record| (|:| |lll| (|Matrix| (|Integer|)))
              (|:| |trf| (|Matrix| (|Integer|))))
    (|Matrix| (|Integer|)))
   "\\spad{extendedLLL(m)} returns the \\spad{LLL} reductions of \\spad{m} together with the transformation matrix,{} \\spadignore{i.e.} if [\\spad{l},{} \\spad{t}] is returned then it holds \\spad{l} = \\spad{t*m}."))
 (|extendedLLL!|
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|NonNegativeInteger|))
   "\\spad{extendedLLL!(m,{} n)} with 1 \\spad{<=} \\spad{n} \\spad{<=} ncols(\\spad{m}) performs the \\spad{LLL} reduction of \\spad{m} where only the first \\spad{n} columns are considered significant. All matrix transformations,{} however,{} will be executed on the full matrix. \\spad{m} is destructively modified and will be lost after this call."))
 (LLL
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)))
   "\\spad{LLL(m)} computes \\spad{LLL} reduction of \\spad{m} \\spad{LLL}(\\spad{m}) is the same as extendedLLL!(copy \\spad{m},{} ncols \\spad{m})."))) 
NIL 
(|ListMultiDictionary| S) 
((|constructor|
  (NIL
   "The \\spadtype{ListMultiDictionary} domain implements a dictionary with duplicates allowed. The representation is a list with duplicates represented explicitly. Hence most operations will be relatively inefficient when the number of entries in the dictionary becomes large. If the objects in the dictionary belong to an ordered set,{} the entries are maintained in ascending order."))
 (|substitute|
  (($ |#1| |#1| $)
   "\\spad{substitute(x,{} y,{} d)} replace \\spad{x}\\spad{'s} with \\spad{y}\\spad{'s} in dictionary \\spad{d}."))
 (|duplicates?|
  (((|Boolean|) $)
   "\\spad{duplicates?(d)} tests if dictionary \\spad{d} has duplicate entries."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|LeftModule| R) 
((|constructor|
  (NIL
   "The category of left modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports left multiplication by elements of the \\spad{rng}. \\blankline"))
 (*
  (($ |#1| $)
   "\\spad{r*x} returns the left multiplication of the module element \\spad{x} by the ring element \\spad{r}."))) 
NIL 
(|ListMonoidOps| S E |un|) 
((|constructor|
  (NIL
   "This internal package represents monoid (abelian or not,{} with or without inverses) as lists and provides some common operations to the various flavors of monoids."))
 (|mapGen|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{mapGen(f,{} a1\\^e1 ... an\\^en)} returns \\spad{f(a1)\\^e1 ... f(an)\\^en}."))
 (|mapExpon|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{mapExpon(f,{} a1\\^e1 ... an\\^en)} returns \\spad{a1\\^f(e1) ... an\\^f(en)}."))
 (|leftMult|
  (($ |#1| $)
   "\\spad{leftMult(s,{} a)} returns \\spad{s * a} where \\spad{*} is the monoid operation,{} which is assumed non-commutative."))
 (|rightMult|
  (($ $ |#1|)
   "\\spad{rightMult(a,{} s)} returns \\spad{a * s} where \\spad{*} is the monoid operation,{} which is assumed non-commutative."))
 (|makeUnit|
  (($) "\\spad{makeUnit()} returns the unit element of the monomial."))
 (|size|
  (((|NonNegativeInteger|) $)
   "\\spad{size(l)} returns the number of monomials forming \\spad{l}."))
 (|reverse!|
  (($ $)
   "\\spad{reverse!(l)} reverses the list of monomials forming \\spad{l},{} destroying the element \\spad{l}."))
 (|reverse|
  (($ $)
   "\\spad{reverse(l)} reverses the list of monomials forming \\spad{l}. This has some effect if the monoid is non-abelian,{} \\spadignore{i.e.} \\spad{reverse(a1\\^e1 ... an\\^en) = an\\^en ... a1\\^e1} which is different."))
 (|nthFactor|
  ((|#1| $ (|Integer|))
   "\\spad{nthFactor(l,{} n)} returns the factor of the n^th monomial of \\spad{l}."))
 (|nthExpon|
  ((|#2| $ (|Integer|))
   "\\spad{nthExpon(l,{} n)} returns the exponent of the n^th monomial of \\spad{l}."))
 (|makeMulti|
  (($ (|List| (|Record| (|:| |gen| |#1|) (|:| |exp| |#2|))))
   "\\spad{makeMulti(l)} returns the element whose list of monomials is \\spad{l}."))
 (|makeTerm|
  (($ |#1| |#2|)
   "\\spad{makeTerm(s,{} e)} returns the monomial \\spad{s} exponentiated by \\spad{e} (\\spadignore{e.g.} s^e or \\spad{e} * \\spad{s})."))
 (|listOfMonoms|
  (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| |#2|))) $)
   "\\spad{listOfMonoms(l)} returns the list of the monomials forming \\spad{l}."))
 (|outputForm|
  (((|OutputForm|) $ (|Mapping| (|OutputForm|) (|OutputForm|) (|OutputForm|))
    (|Mapping| (|OutputForm|) (|OutputForm|) (|OutputForm|)) (|Integer|))
   "\\spad{outputForm(l,{} fop,{} fexp,{} unit)} converts the monoid element represented by \\spad{l} to an \\spadtype{OutputForm}. Argument unit is the output form for the \\spadignore{unit} of the monoid (\\spadignore{e.g.} 0 or 1),{} \\spad{fop(a,{} b)} is the output form for the monoid operation applied to \\spad{a} and \\spad{b} (\\spadignore{e.g.} \\spad{a + b},{} \\spad{a * b},{} \\spad{ab}),{} and \\spad{fexp(a,{} n)} is the output form for the exponentiation operation applied to \\spad{a} and \\spad{n} (\\spadignore{e.g.} \\spad{n a},{} \\spad{n * a},{} \\spad{a ^ n},{} \\spad{a\\^n})."))) 
NIL 
(|LinearAggregate&| A S) 
((|constructor|
  (NIL
   "A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings,{} lists,{} and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example,{} \\spadfun{concat} of two lists needs only to copy its first argument,{} whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. If the aggregate is a finite aggregate then it has several additional exports such as \\spadfun{reverse},{} \\spadfun{sort},{} and so on."))
 (|sort!|
  (($ $)
   "\\spad{sort!(u)} returns \\spad{u} with its elements in ascending order.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sort!(p,{} u)} returns \\spad{u} with its elements ordered by \\spad{p}."))
 (|reverse!|
  (($ $)
   "\\spad{reverse!(u)} returns \\spad{u} with its elements in reverse order."))
 (|copyInto!|
  (($ $ $ (|Integer|))
   "\\spad{copyInto!(u,{} v,{} i)} returns aggregate \\spad{u} containing a copy of \\spad{v} inserted at element \\spad{i}."))
 (|trim|
  (($ $ |#2|)
   "\\spad{trim(u,{} x)} returns a copy of \\spad{u} with all occurrences of \\spad{x} deleted from right and left ends. For example,{} \\spad{trim(\" abc \",{} char \" \")} returns \\spad{\"abc\"}."))
 (|rightTrim|
  (($ $ |#2|)
   "\\spad{rightTrim(u,{} x)} returns a copy of \\spad{u} with all trailing occurrences of \\spad{x} deleted. For example,{} \\spad{rightTrim(\" abc \",{} char \" \")} returns \\spad{\" abc\"}."))
 (|leftTrim|
  (($ $ |#2|)
   "\\spad{leftTrim(u,{} x)} returns a copy of \\spad{u} with all leading \\spad{x} deleted. For example,{} \\spad{leftTrim(\" abc \",{} char \" \")} returns \\spad{\"abc \"}."))
 (|position|
  (((|Integer|) |#2| $ (|Integer|))
   "\\spad{position(x,{} a,{} n)} returns the index \\spad{i} of the first occurrence of \\spad{x} in \\spad{a} where \\spad{i >= n},{} and \\spad{minIndex(a) - 1} if no such \\spad{x} is found.")
  (((|Integer|) |#2| $)
   "\\spad{position(x,{} a)} returns the index \\spad{i} of the first occurrence of \\spad{x} in a,{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}.")
  (((|Integer|) (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{position(p,{} a)} returns the index \\spad{i} of the first \\spad{x} in \\spad{a} such that \\spad{p(x)} is \\spad{true},{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}."))
 (|sorted?|
  (((|Boolean|) $)
   "\\spad{sorted?(u)} tests if the elements of \\spad{u} are in ascending order.")
  (((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sorted?(p,{} a)} tests if \\spad{a} is sorted according to predicate \\spad{p}."))
 (|sort|
  (($ $)
   "\\spad{sort(u)} returns an \\spad{u} with elements in ascending order. Note: \\spad{sort(u) = sort(<,{} u)}.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sort(p,{} a)} returns a copy of \\spad{a} sorted using total ordering predicate \\spad{p}."))
 (|reverse|
  (($ $)
   "\\spad{reverse(a)} returns a copy of \\spad{a} with elements in reverse order."))
 (|merge|
  (($ $ $)
   "\\spad{merge(u,{} v)} merges \\spad{u} and \\spad{v} in ascending order. Note: \\spad{merge(u,{} v) = merge(<=,{} u,{} v)}.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $)
   "\\spad{merge(p,{} a,{} b)} returns an aggregate \\spad{c} which merges \\spad{a} and \\spad{b}. The result is produced by examining each element \\spad{x} of \\spad{a} and \\spad{y} of \\spad{b} successively. If \\spad{p(x,{} y)} is \\spad{true},{} then \\spad{x} is inserted into the result; otherwise \\spad{y} is inserted. If \\spad{x} is chosen,{} the next element of \\spad{a} is examined,{} and so on. When all the elements of one aggregate are examined,{} the remaining elements of the other are appended. For example,{} \\spad{merge(<,{} [1,{} 3],{} [2,{} 7,{} 5])} returns \\spad{[1,{} 2,{} 3,{} 7,{} 5]}."))
 (|setelt!|
  ((|#2| $ (|UniversalSegment| (|Integer|)) |#2|)
   "\\spad{setelt!(u,{} i..j,{} x)} (also written: \\spad{u(i..j) := x}) destructively replaces each element in the segment \\spad{u(i..j)} by \\spad{x}. The value \\spad{x} is returned. Note: \\spad{u} is destructively changed so that \\spad{u.k := x for k in i..j}; its length remains unchanged."))
 (|insert|
  (($ $ $ (|Integer|))
   "\\spad{insert(v,{} u,{} i)} returns a copy of \\spad{u} having \\spad{v} inserted beginning at the \\spad{i}th element. Note: \\spad{insert(v,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(v,{} u(i..)))}.")
  (($ |#2| $ (|Integer|))
   "\\spad{insert(x,{} u,{} i)} returns a copy of \\spad{u} having \\spad{x} as its \\spad{i}th element. Note: \\spad{insert(x,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(x,{} u(i..)))}."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}. Error: if \\spad{u} has less than \\spad{n} elements."))
 (|delete|
  (($ $ (|UniversalSegment| (|Integer|)))
   "\\spad{delete(u,{} i..j)} returns a copy of \\spad{u} with the \\spad{i}th through \\spad{j}th element deleted. Note: \\spad{delete(u,{} i..j) = concat(u(minIndex(u)..i-1),{} u(j+1..))}.")
  (($ $ (|Integer|))
   "\\spad{delete(u,{} i)} returns a copy of \\spad{u} with the \\spad{i}th element deleted. Note: \\spad{delete(u,{} i) = concat(u(minIndex(u)..i - 1),{} u(i + 1..))}."))
 (|map|
  (($ (|Mapping| |#2| |#2| |#2|) $ $)
   "\\spad{map(f,{} u,{} v)} returns a new aggregate \\spad{w} with elements \\spad{z = f(x,{} y)} for corresponding elements \\spad{x} and \\spad{y} from \\spad{u} and \\spad{v}. Note: \\spad{w.i = f(u.i,{} v.i)}."))
 (|concat|
  (($ (|List| $))
   "\\spad{concat(u)},{} where \\spad{u} is a list of aggregates \\spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \\spad{a} followed by those of \\spad{b} followed ... by the elements of \\spad{c}. Note: \\spad{concat([a,{} b,{} ...,{} c]) = concat(a,{} concat([b,{} ...,{} c]))}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: if \\spad{w = concat(u,{} v)} then \\spad{w.i = u.i for i in indices u} and \\spad{w.(j + maxIndex u) = v.j for j in indices v}.")
  (($ |#2| $)
   "\\spad{concat(x,{} u)} returns aggregate \\spad{u} with additional element \\spad{x} at the front. Note: for lists: \\spad{concat(x,{} u) = concat([x],{} u)}.")
  (($ $ |#2|)
   "\\spad{concat(u,{} x)} returns aggregate \\spad{u} with additional element \\spad{x} at the end. Note: for lists,{} \\spad{concat(u,{} x) = concat(u,{} [x])}."))
 (|new|
  (($ (|NonNegativeInteger|) |#2|)
   "\\spad{new(n,{} x)} returns a new aggregate of size \\spad{n} all of whose entries are \\spad{x}."))) 
((|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#1| '(|finiteAggregate|))
 (|HasCategory| |#1| '(|shallowlyMutable|))) 
(|LinearAggregate| S) 
((|constructor|
  (NIL
   "A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings,{} lists,{} and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example,{} \\spadfun{concat} of two lists needs only to copy its first argument,{} whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. If the aggregate is a finite aggregate then it has several additional exports such as \\spadfun{reverse},{} \\spadfun{sort},{} and so on."))
 (|sort!|
  (($ $)
   "\\spad{sort!(u)} returns \\spad{u} with its elements in ascending order.")
  (($ (|Mapping| (|Boolean|) |#1| |#1|) $)
   "\\spad{sort!(p,{} u)} returns \\spad{u} with its elements ordered by \\spad{p}."))
 (|reverse!|
  (($ $)
   "\\spad{reverse!(u)} returns \\spad{u} with its elements in reverse order."))
 (|copyInto!|
  (($ $ $ (|Integer|))
   "\\spad{copyInto!(u,{} v,{} i)} returns aggregate \\spad{u} containing a copy of \\spad{v} inserted at element \\spad{i}."))
 (|trim|
  (($ $ |#1|)
   "\\spad{trim(u,{} x)} returns a copy of \\spad{u} with all occurrences of \\spad{x} deleted from right and left ends. For example,{} \\spad{trim(\" abc \",{} char \" \")} returns \\spad{\"abc\"}."))
 (|rightTrim|
  (($ $ |#1|)
   "\\spad{rightTrim(u,{} x)} returns a copy of \\spad{u} with all trailing occurrences of \\spad{x} deleted. For example,{} \\spad{rightTrim(\" abc \",{} char \" \")} returns \\spad{\" abc\"}."))
 (|leftTrim|
  (($ $ |#1|)
   "\\spad{leftTrim(u,{} x)} returns a copy of \\spad{u} with all leading \\spad{x} deleted. For example,{} \\spad{leftTrim(\" abc \",{} char \" \")} returns \\spad{\"abc \"}."))
 (|position|
  (((|Integer|) |#1| $ (|Integer|))
   "\\spad{position(x,{} a,{} n)} returns the index \\spad{i} of the first occurrence of \\spad{x} in \\spad{a} where \\spad{i >= n},{} and \\spad{minIndex(a) - 1} if no such \\spad{x} is found.")
  (((|Integer|) |#1| $)
   "\\spad{position(x,{} a)} returns the index \\spad{i} of the first occurrence of \\spad{x} in a,{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}.")
  (((|Integer|) (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{position(p,{} a)} returns the index \\spad{i} of the first \\spad{x} in \\spad{a} such that \\spad{p(x)} is \\spad{true},{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}."))
 (|sorted?|
  (((|Boolean|) $)
   "\\spad{sorted?(u)} tests if the elements of \\spad{u} are in ascending order.")
  (((|Boolean|) (|Mapping| (|Boolean|) |#1| |#1|) $)
   "\\spad{sorted?(p,{} a)} tests if \\spad{a} is sorted according to predicate \\spad{p}."))
 (|sort|
  (($ $)
   "\\spad{sort(u)} returns an \\spad{u} with elements in ascending order. Note: \\spad{sort(u) = sort(<,{} u)}.")
  (($ (|Mapping| (|Boolean|) |#1| |#1|) $)
   "\\spad{sort(p,{} a)} returns a copy of \\spad{a} sorted using total ordering predicate \\spad{p}."))
 (|reverse|
  (($ $)
   "\\spad{reverse(a)} returns a copy of \\spad{a} with elements in reverse order."))
 (|merge|
  (($ $ $)
   "\\spad{merge(u,{} v)} merges \\spad{u} and \\spad{v} in ascending order. Note: \\spad{merge(u,{} v) = merge(<=,{} u,{} v)}.")
  (($ (|Mapping| (|Boolean|) |#1| |#1|) $ $)
   "\\spad{merge(p,{} a,{} b)} returns an aggregate \\spad{c} which merges \\spad{a} and \\spad{b}. The result is produced by examining each element \\spad{x} of \\spad{a} and \\spad{y} of \\spad{b} successively. If \\spad{p(x,{} y)} is \\spad{true},{} then \\spad{x} is inserted into the result; otherwise \\spad{y} is inserted. If \\spad{x} is chosen,{} the next element of \\spad{a} is examined,{} and so on. When all the elements of one aggregate are examined,{} the remaining elements of the other are appended. For example,{} \\spad{merge(<,{} [1,{} 3],{} [2,{} 7,{} 5])} returns \\spad{[1,{} 2,{} 3,{} 7,{} 5]}."))
 (|setelt!|
  ((|#1| $ (|UniversalSegment| (|Integer|)) |#1|)
   "\\spad{setelt!(u,{} i..j,{} x)} (also written: \\spad{u(i..j) := x}) destructively replaces each element in the segment \\spad{u(i..j)} by \\spad{x}. The value \\spad{x} is returned. Note: \\spad{u} is destructively changed so that \\spad{u.k := x for k in i..j}; its length remains unchanged."))
 (|insert|
  (($ $ $ (|Integer|))
   "\\spad{insert(v,{} u,{} i)} returns a copy of \\spad{u} having \\spad{v} inserted beginning at the \\spad{i}th element. Note: \\spad{insert(v,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(v,{} u(i..)))}.")
  (($ |#1| $ (|Integer|))
   "\\spad{insert(x,{} u,{} i)} returns a copy of \\spad{u} having \\spad{x} as its \\spad{i}th element. Note: \\spad{insert(x,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(x,{} u(i..)))}."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}. Error: if \\spad{u} has less than \\spad{n} elements."))
 (|delete|
  (($ $ (|UniversalSegment| (|Integer|)))
   "\\spad{delete(u,{} i..j)} returns a copy of \\spad{u} with the \\spad{i}th through \\spad{j}th element deleted. Note: \\spad{delete(u,{} i..j) = concat(u(minIndex(u)..i-1),{} u(j+1..))}.")
  (($ $ (|Integer|))
   "\\spad{delete(u,{} i)} returns a copy of \\spad{u} with the \\spad{i}th element deleted. Note: \\spad{delete(u,{} i) = concat(u(minIndex(u)..i - 1),{} u(i + 1..))}."))
 (|map|
  (($ (|Mapping| |#1| |#1| |#1|) $ $)
   "\\spad{map(f,{} u,{} v)} returns a new aggregate \\spad{w} with elements \\spad{z = f(x,{} y)} for corresponding elements \\spad{x} and \\spad{y} from \\spad{u} and \\spad{v}. Note: \\spad{w.i = f(u.i,{} v.i)}."))
 (|concat|
  (($ (|List| $))
   "\\spad{concat(u)},{} where \\spad{u} is a list of aggregates \\spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \\spad{a} followed by those of \\spad{b} followed ... by the elements of \\spad{c}. Note: \\spad{concat([a,{} b,{} ...,{} c]) = concat(a,{} concat([b,{} ...,{} c]))}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: if \\spad{w = concat(u,{} v)} then \\spad{w.i = u.i for i in indices u} and \\spad{w.(j + maxIndex u) = v.j for j in indices v}.")
  (($ |#1| $)
   "\\spad{concat(x,{} u)} returns aggregate \\spad{u} with additional element \\spad{x} at the front. Note: for lists: \\spad{concat(x,{} u) = concat([x],{} u)}.")
  (($ $ |#1|)
   "\\spad{concat(u,{} x)} returns aggregate \\spad{u} with additional element \\spad{x} at the end. Note: for lists,{} \\spad{concat(u,{} x) = concat(u,{} [x])}."))
 (|new|
  (($ (|NonNegativeInteger|) |#1|)
   "\\spad{new(n,{} x)} returns a new aggregate of size \\spad{n} all of whose entries are \\spad{x}."))) 
NIL 
(|Localize| M R) 
((|constructor|
  (NIL
   "Localize(\\spad{M},{} \\spad{R}) produces fractions with numerators from an \\spad{R} module \\spad{M} and denominators being the nonzero elements of \\spad{R}."))
 (|denom| ((|#2| $) "\\spad{denom x} returns the denominator of \\spad{x}."))
 (|numer| ((|#1| $) "\\spad{numer x} returns the numerator of \\spad{x}."))
 (/ (($ |#1| |#2|) "\\spad{m / d} divides the element \\spad{m} by \\spad{d}.")
    (($ $ |#2|) "\\spad{x / d} divides the element \\spad{x} by \\spad{d}."))) 
((|HasCategory| |#1| '(|OrderedAbelianGroup|))
 (OR (|HasCategory| |#1| '(|OrderedAbelianGroup|))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|OrderedAbelianGroup|))
     (|HasCategory| |#2| '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|OrderedAbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|)))) 
(|ElementaryFunctionLODESolver| R F L) 
((|constructor|
  (NIL
   "\\spad{ElementaryFunctionLODESolver} provides the top-level functions for finding closed form solutions of linear ordinary differential equations and initial value problems."))
 (|solve|
  (((|Union| |#2| "failed") |#3| |#2| (|Symbol|) |#2| (|List| |#2|))
   "\\spad{solve(op,{} g,{} x,{} a,{} [y0,{} ...,{} ym])} returns either the solution of the initial value problem \\spad{op y = g,{} y(a) = y0,{} y'(a) = y1,{} ...} or \"failed\" if the solution cannot be found; \\spad{x} is the dependent variable.")
  (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|)))
             "failed")
    |#3| |#2| (|Symbol|))
   "\\spad{solve(op,{} g,{} x)} returns either a solution of the ordinary differential equation \\spad{op y = g} or \"failed\" if no non-trivial solution can be found; When found,{} the solution is returned in the form \\spad{[h,{} [b1,{} ...,{} bm]]} where \\spad{h} is a particular solution and and \\spad{[b1,{} ...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{op y = 0}. A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; \\spad{x} is the dependent variable."))) 
NIL 
(|LinearOrdinaryDifferentialOperator| A |diff|) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperator} defines a ring of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \\indented{4}{\\spad{(L1 * L2).(f) = L1 L2 f}}"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#1| '(|Field|))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|LinearOrdinaryDifferentialOperator1| A) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperator1} defines a ring of differential operators with coefficients in a differential ring A. Multiplication of operators corresponds to functional composition: \\indented{4}{\\spad{(L1 * L2).(f) = L1 L2 f}}"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#1| '(|Field|))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|LinearOrdinaryDifferentialOperator2| A M) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperator2} defines a ring of differential operators with coefficients in a differential ring A and acting on an A-module \\spad{M}. Multiplication of operators corresponds to functional composition: \\indented{4}{\\spad{(L1 * L2).(f) = L1 L2 f}}"))
 (|differentiate|
  (($ $) "\\spad{differentiate(x)} returns the derivative of \\spad{x}"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#1| '(|Field|))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|LinearOrdinaryDifferentialOperator3| |Coeff| A R) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperator3} is a ring \\indented{1}{differential operators with coefficients in a differential ring \\spad{R}.} \\indented{1}{Basic derivative is derivative in \\spad{R} times variable (monomial} \\indented{1}{of degree 1).}"))) 
((|HasCategory| |#3| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#3| '(|CharacteristicNonZero|))
 (|HasCategory| |#3| '(|CharacteristicZero|))
 (|HasCategory| |#3| '(|EntireRing|)) (|HasCategory| |#3| '(|CommutativeRing|))
 (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#3| '(|canonicalUnitNormal|))
 (|HasCategory| |#3| '(|Comparable|)) (|HasCategory| |#3| '(|Ring|))
 (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#3| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| '(|CharacteristicNonZero|))
     (|HasCategory| |#3| '(|CharacteristicZero|))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|EntireRing|)) (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|AbelianGroup|)) (|HasCategory| |#3| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#3| '(|IntegralDomain|))
 (OR (|HasCategory| |#3| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#3|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#3| '(|GcdDomain|))
 (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|AbelianMonoid|))
 (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#3| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#3| '(|AbelianGroup|))
  (|HasCategory| |#3| '(|AbelianMonoid|))
  (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#3| '(|Field|))
 (OR
  (AND (|HasCategory| |#3| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#3| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#3| '(|EntireRing|))
     (AND (|HasCategory| |#3| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#3| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#3| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#3| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#3| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#3| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#3| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#3| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#3| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#3| '(|Ring|)))
 (OR (|HasCategory| |#3| '(|AbelianMonoid|))
     (AND (|HasCategory| |#3| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#3| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#3| '(|AbelianGroup|))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#3| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#3| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (AND (|HasCategory| |#3| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#3| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|LinearOrdinaryDifferentialOperator3Aux| |Coeff| A R) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperator3Aux} is \\indented{1}{a helper for \\spad{LinearOrdinaryDifferentialOperator3}} \\indented{1}{defining appropriate derivative.}"))
 (|delta_deriv|
  ((|#3| |#3|)
   "\\spad{delta_deriv(f)} is x*f' where \\spad{x} is variable in A"))) 
NIL 
(|LinearOrdinaryDifferentialOperatorCategory&| S A) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \\indented{4}{\\spad{(L1 * L2).(f) = L1 L2 f}}"))
 (|directSum|
  (($ $ $)
   "\\spad{directSum(a,{} b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}."))
 (|symmetricSquare|
  (($ $)
   "\\spad{symmetricSquare(a)} computes \\spad{symmetricProduct(a,{} a)} using a more efficient method."))
 (|symmetricPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{symmetricPower(a,{} n)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}."))
 (|symmetricProduct|
  (($ $ $)
   "\\spad{symmetricProduct(a,{} b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}."))
 (|adjoint| (($ $) "\\spad{adjoint(a)} returns the adjoint operator of a."))
 (D
  (($)
   "\\spad{D()} provides the operator corresponding to a derivation in the ring \\spad{A}."))) 
((|HasCategory| |#2| '(|Field|))) 
(|LinearOrdinaryDifferentialOperatorCategory| A) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \\indented{4}{\\spad{(L1 * L2).(f) = L1 L2 f}}"))
 (|directSum|
  (($ $ $)
   "\\spad{directSum(a,{} b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}."))
 (|symmetricSquare|
  (($ $)
   "\\spad{symmetricSquare(a)} computes \\spad{symmetricProduct(a,{} a)} using a more efficient method."))
 (|symmetricPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{symmetricPower(a,{} n)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}."))
 (|symmetricProduct|
  (($ $ $)
   "\\spad{symmetricProduct(a,{} b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}."))
 (|adjoint| (($ $) "\\spad{adjoint(a)} returns the adjoint operator of a."))
 (D
  (($)
   "\\spad{D()} provides the operator corresponding to a derivation in the ring \\spad{A}."))) 
NIL 
(|LODOConvertions| |Coeff| |Ab| R) 
((|constructor|
  (NIL
   "\\spadtype{LODOConvertions} implements conversion between \\indented{1}{\\spadtype{LinearOrdinaryDifferentialOperator1} and} \\indented{1}{\\spadtype{LinearOrdinaryDifferentialOperator3} and back.}"))
 (|convert|
  (((|LinearOrdinaryDifferentialOperator1| |#3|)
    (|LinearOrdinaryDifferentialOperator3| |#1| |#2| |#3|))
   "\\spad{convert(l3)} converts an operator \\spad{l3} from \\spadtype{LinearOrdinaryDifferentialOperator3} to \\spadtype{LinearOrdinaryDifferentialOperator1} such that the resultant operator gives the same result as the original one on application to an element of domain \\spad{R}.")
  (((|LinearOrdinaryDifferentialOperator3| |#1| |#2| |#3|)
    (|LinearOrdinaryDifferentialOperator1| |#3|))
   "\\spad{convert(l1)} converts an operator \\spad{l1} from \\spadtype{LinearOrdinaryDifferentialOperator1} to \\spadtype{LinearOrdinaryDifferentialOperator3} such that the resultant operator gives the same result as the original one on application to an element of domain \\spad{R}."))) 
NIL 
(|LinearOrdinaryDifferentialOperatorFactorizer| F UP) 
((|constructor|
  (NIL
   "\\spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions."))
 (|factor1|
  (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
   "\\spad{factor1(a)} returns the factorisation of a,{} assuming that a has no first-order right factor."))
 (|factor|
  (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
   "\\spad{factor(a)} returns the factorisation of a.")
  (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{factor(a,{} zeros)} returns the factorisation of a. \\spad{zeros} is a zero finder in \\spad{UP}."))) 
((|HasCategory| |#1| '(|AlgebraicallyClosedField|))) 
(|LinearOrdinaryDifferentialOperatorFactorizer2| |var| |cen|) 
((|constructor|
  (NIL
   "\\spadtype{LinearOrdinaryDifferentialOperatorFactorizer2} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions."))
 (|ge_minimal|
  (((|List|
     (|Record|
      (|:| |singularity|
           (|Record|
            (|:| |point| (|Union| (|Expression| (|Integer|)) "infinity"))
            (|:| |lpf|
                 (|LinearOrdinaryDifferentialOperator3|
                  (|Expression| (|Integer|))
                  (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                            |#2|)
                  (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                             |#2|)))
            (|:| |dxt| (|PositiveInteger|))))
      (|:| |fos|
           (|List|
            (|Record|
             (|:| |op|
                  (|LinearOrdinaryDifferentialOperator3|
                   (|Expression| (|Integer|))
                   (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                             |#2|)
                   (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                              |#2|)))
             (|:| |ram|
                  (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))
             (|:| |expart|
                  (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                             |#2|)))))
      (|:| |mge|
           (|List|
            (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                       |#2|)))))
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
    (|String|))
   "to be documented later."))
 (|gen_exp|
  (((|List|
     (|Record|
      (|:| |ecs|
           (|List|
            (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|)))
      (|:| |ecr| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))
      (|:| |ect|
           (|Fraction|
            (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))))
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))
    (|Union| (|Expression| (|Integer|)) "infinity")
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|)))
     (|List| (|Expression| (|Integer|))))
    (|List| (|Expression| (|Integer|))))
   "to be documented later."))
 (|testgt|
  (((|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Kernel| (|Expression| (|Integer|))))
   "test function."))
 (|testis|
  (((|Boolean|)
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))
   "test function."))
 (|factor|
  (((|List|
     (|LinearOrdinaryDifferentialOperator1|
      (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|)))
     (|List| (|Expression| (|Integer|))))
    (|List| (|Expression| (|Integer|))))
   "to be documented later."))
 (|testlp|
  (((|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariateTaylorSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|)
                                           (|UnivariateLaurentSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|))
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))
    (|Union| (|Expression| (|Integer|)) "infinity"))
   "test function."))
 (|testfg|
  (((|List|
     (|LinearOrdinaryDifferentialOperator1|
      (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))
    (|LinearOrdinaryDifferentialOperator1|
     (|Fraction| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|)))))
   "test function."))
 (|testsc|
  (((|Boolean|)
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|)))))
   "test function."))
 (|testfo|
  (((|Union|
     (|List|
      (|Record|
       (|:| |op|
            (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                   (|UnivariateTaylorSeries|
                                                    (|Expression| (|Integer|))
                                                    |#1| |#2|)
                                                   (|UnivariateLaurentSeries|
                                                    (|Expression| (|Integer|))
                                                    |#1| |#2|)))
       (|:| |ram| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))
       (|:| |expart|
            (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|))))
     (|List|
      (|Union|
       (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                              (|UnivariateTaylorSeries|
                                               (|Expression| (|Integer|)) |#1|
                                               |#2|)
                                              (|UnivariateLaurentSeries|
                                               (|Expression| (|Integer|)) |#1|
                                               |#2|))
       (|Record|
        (|:| |ope|
             (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                    (|UnivariateTaylorSeries|
                                                     (|Expression| (|Integer|))
                                                     |#1| |#2|)
                                                    (|UnivariateLaurentSeries|
                                                     (|Expression| (|Integer|))
                                                     |#1| |#2|)))
        (|:| |dext| (|PositiveInteger|))
        (|:| |alpha| (|Expression| (|Integer|)))
        (|:| |rami|
             (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
    (|String|))
   "test function."))
 (|testro|
  (((|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariateTaylorSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|)
                                           (|UnivariateLaurentSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Expression| (|Integer|)) (|PositiveInteger|))
   "test function."))
 (|testsb|
  (((|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariateTaylorSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|)
                                           (|UnivariateLaurentSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|))
    (|Union| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
             (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|))))))
   "test function."))
 (|testfr|
  (((|Union|
     (|List|
      (|Record|
       (|:| |op|
            (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                   (|UnivariateTaylorSeries|
                                                    (|Expression| (|Integer|))
                                                    |#1| |#2|)
                                                   (|UnivariateLaurentSeries|
                                                    (|Expression| (|Integer|))
                                                    |#1| |#2|)))
       (|:| |ram| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))
       (|:| |expart|
            (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|))))
     (|List|
      (|Union|
       (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                              (|UnivariateTaylorSeries|
                                               (|Expression| (|Integer|)) |#1|
                                               |#2|)
                                              (|UnivariateLaurentSeries|
                                               (|Expression| (|Integer|)) |#1|
                                               |#2|))
       (|Record|
        (|:| |ope|
             (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                    (|UnivariateTaylorSeries|
                                                     (|Expression| (|Integer|))
                                                     |#1| |#2|)
                                                    (|UnivariateLaurentSeries|
                                                     (|Expression| (|Integer|))
                                                     |#1| |#2|)))
        (|:| |dext| (|PositiveInteger|))
        (|:| |alpha| (|Expression| (|Integer|)))
        (|:| |rami|
             (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
    (|String|))
   "test function."))
 (|testpd|
  (((|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariateTaylorSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|)
                                           (|UnivariateLaurentSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))
   "test function."))
 (|testcx|
  (((|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Fraction| (|Integer|)))
   "test function."))
 (|testco|
  (((|Boolean|)
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testcp|
  (((|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariateTaylorSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|)
                                           (|UnivariateLaurentSeries|
                                            (|Expression| (|Integer|)) |#1|
                                            |#2|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testlw|
  (((|Stream|
     (|Record|
      (|:| |Qt|
           (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                  (|UnivariateTaylorSeries|
                                                   (|Expression| (|Integer|))
                                                   |#1| |#2|)
                                                  (|UnivariateLaurentSeries|
                                                   (|Expression| (|Integer|))
                                                   |#1| |#2|)))
      (|:| |Rt|
           (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                  (|UnivariateTaylorSeries|
                                                   (|Expression| (|Integer|))
                                                   |#1| |#2|)
                                                  (|UnivariateLaurentSeries|
                                                   (|Expression| (|Integer|))
                                                   |#1| |#2|)))))
    (|Fraction| (|Integer|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testln|
  (((|Record|
     (|:| |main|
          (|Record|
           (|:| |Qt|
                (|LinearOrdinaryDifferentialOperator3|
                 (|Expression| (|Integer|))
                 (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                           |#2|)
                 (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                            |#2|)))
           (|:| |Rt|
                (|LinearOrdinaryDifferentialOperator3|
                 (|Expression| (|Integer|))
                 (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                           |#2|)
                 (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                            |#2|)))))
     (|:| |nf|
          (|Record|
           (|:| |Qt|
                (|LinearOrdinaryDifferentialOperator3|
                 (|Expression| (|Integer|))
                 (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                           |#2|)
                 (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                            |#2|)))
           (|:| |Rt|
                (|LinearOrdinaryDifferentialOperator3|
                 (|Expression| (|Integer|))
                 (|UnivariateTaylorSeries| (|Expression| (|Integer|)) |#1|
                                           |#2|)
                 (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1|
                                            |#2|)))))
     (|:| |error|
          (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                 (|UnivariateTaylorSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|)
                                                 (|UnivariateLaurentSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|))))
    (|Fraction| (|Integer|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testlc|
  (((|Record|
     (|:| |llc|
          (|List|
           (|Stream|
            (|Record| (|:| |k| (|Integer|))
                      (|:| |c| (|Expression| (|Integer|)))))))
     (|:| |rlc|
          (|List|
           (|Stream|
            (|Record| (|:| |k| (|Integer|))
                      (|:| |c| (|Expression| (|Integer|))))))))
    (|Fraction| (|Integer|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testll|
  (((|Record|
     (|:| |laurl|
          (|List|
           (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|)))
     (|:| |laurr|
          (|List|
           (|UnivariateLaurentSeries| (|Expression| (|Integer|)) |#1| |#2|))))
    (|Fraction| (|Integer|))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|Fraction| (|Integer|)) (|Integer|))
   "test function."))
 (|testf2|
  (((|Record|
     (|:| |Qt|
          (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                 (|UnivariateTaylorSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|)
                                                 (|UnivariateLaurentSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|)))
     (|:| |Rt|
          (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                                 (|UnivariateTaylorSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|)
                                                 (|UnivariateLaurentSeries|
                                                  (|Expression| (|Integer|))
                                                  |#1| |#2|))))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|UnivariatePolynomial| |#1| (|Expression| (|Integer|)))
    (|Fraction| (|Integer|)))
   "test function."))
 (|testfn|
  (((|List|
     (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                            (|UnivariateTaylorSeries|
                                             (|Expression| (|Integer|)) |#1|
                                             |#2|)
                                            (|UnivariateLaurentSeries|
                                             (|Expression| (|Integer|)) |#1|
                                             |#2|)))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|)))))
    (|Mapping|
     (|Factored| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
     (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
    (|String|))
   "test function."))
 (|testnp|
  (((|List|
     (|Record|
      (|:| |point| (|Record| (|:| |x| (|Integer|)) (|:| |y| (|Integer|))))
      (|:| |slope| (|Fraction| (|Integer|)))
      (|:| |npoly| (|UnivariatePolynomial| |#1| (|Expression| (|Integer|))))))
    (|LinearOrdinaryDifferentialOperator3| (|Expression| (|Integer|))
                                           (|UnivariatePolynomial| |#1|
                                                                   (|Expression|
                                                                    (|Integer|)))
                                           (|Fraction|
                                            (|UnivariatePolynomial| |#1|
                                                                    (|Expression|
                                                                     (|Integer|))))))
   "test function."))) 
NIL 
(|LinearOrdinaryDifferentialOperatorsOps| A L) 
((|constructor|
  (NIL
   "\\spad{LinearOrdinaryDifferentialOperatorsOps} provides symmetric products and sums for linear ordinary differential operators."))
 (|directSum|
  ((|#2| |#2| |#2| (|Mapping| |#1| |#1|))
   "\\spad{directSum(a,{} b,{} D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}. \\spad{D} is the derivation to use."))
 (|symmetricPower|
  ((|#2| |#2| (|NonNegativeInteger|) (|Mapping| |#1| |#1|))
   "\\spad{symmetricPower(a,{} n,{} D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}. \\spad{D} is the derivation to use."))
 (|symmetricProduct|
  ((|#2| |#2| |#2| (|Mapping| |#1| |#1|))
   "\\spad{symmetricProduct(a,{} b,{} D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}. \\spad{D} is the derivation to use."))) 
NIL 
(|Logic&| S) 
((|constructor|
  (NIL
   "'Logic' adds 'not' operation to lattices,{} Implements De Morgan\\spad{'s} laws."))
 (|false| (($) "\\spad{false} is a logical constant."))
 (|true| (($) "\\spad{true} is a logical constant."))
 (~ (($ $) "\\spad{~(x)} returns the logical complement of \\spad{x}."))) 
NIL 
(|Logic|) 
((|constructor|
  (NIL
   "'Logic' adds 'not' operation to lattices,{} Implements De Morgan\\spad{'s} laws."))
 (|false| (($) "\\spad{false} is a logical constant."))
 (|true| (($) "\\spad{true} is a logical constant."))
 (~ (($ $) "\\spad{~(x)} returns the logical complement of \\spad{x}."))) 
NIL 
(|Loop|) 
((|constructor|
  (NIL
   "This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \\spad{'='}."))
 (|entries|
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{entries(lp)} returns list of indexes that make this loop"))
 (|loop|
  (($ (|List| (|NonNegativeInteger|)))
   "\\spad{loop(\\spad{li})} constructs loop from list of indexes \\spad{li}"))) 
NIL 
(|LeftOreRing|) 
((|constructor|
  (NIL
   "This is category of left ore rings,{} that is noncommutaive rings without zero divisors where we can compute least left common multiple"))
 (|lcmCoef|
  (((|Record| (|:| |llcm_res| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $)
   "\\spad{lcmCoef(c1,{} c2)} computes (llcm_res,{} \\spad{coeff1},{} \\spad{coeff2}) such that llcm_res is least left common multiple of \\spad{c1} and \\spad{c2} and llcm_res = \\spad{coeff1*c1} = \\spad{coeff2*c2}"))) 
NIL 
(|LinearPolynomialEquationByFractions| R) 
((|constructor|
  (NIL
   "Given a PolynomialFactorizationExplicit ring,{} this package provides a defaulting rule for the \\spad{solveLinearPolynomialEquation} operation,{} by moving into the field of fractions,{} and solving it there via the \\spad{multiEuclidean} operation."))
 (|solveLinearPolynomialEquationByFractions|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#1|)) "failed")
    (|List| (|SparseUnivariatePolynomial| |#1|))
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{solveLinearPolynomialEquationByFractions([f1,{} ...,{} fn],{} g)} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such exists."))) 
NIL 
(|LiePolynomial| |VarSet| R) 
((|constructor|
  (NIL
   "This type supports Lie polynomials in Lyndon basis see Free Lie Algebras by \\spad{C}. Reutenauer (Oxford science publications). \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|construct|
  (($ $ (|LyndonWord| |#1|))
   "\\spad{construct(x,{} y)} returns the Lie bracket \\spad{[x,{} y]}.")
  (($ (|LyndonWord| |#1|) $)
   "\\spad{construct(x,{} y)} returns the Lie bracket \\spad{[x,{} y]}.")
  (($ (|LyndonWord| |#1|) (|LyndonWord| |#1|))
   "\\spad{construct(x,{} y)} returns the Lie bracket \\spad{[x,{} y]}."))
 (|LiePolyIfCan|
  (((|Union| $ "failed") (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{LiePolyIfCan(p)} returns \\spad{p} in Lyndon basis if \\spad{p} is a Lie polynomial,{} otherwise \\spad{\"failed\"} is returned."))) 
((|HasCategory| |#2| '(|AbelianGroup|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|AbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| (|LyndonWord| |#1|) '(|Comparable|))
 (AND (|HasCategory| |#2| '(|Comparable|))
      (|HasCategory| (|LyndonWord| |#1|) '(|Comparable|)))) 
(|ListAggregate&| A S) 
((|constructor|
  (NIL
   "A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation."))
 (|list|
  (($ |#2|) "\\spad{list(x)} returns the list of one element \\spad{x}."))) 
NIL 
(|ListAggregate| S) 
((|constructor|
  (NIL
   "A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation."))
 (|list|
  (($ |#1|) "\\spad{list(x)} returns the list of one element \\spad{x}."))) 
NIL 
(|LinearSystemMatrixPackage| F |Row| |Col| M) 
((|constructor|
  (NIL "This package solves linear system in the matrix form \\spad{AX = B}."))
 (|rank|
  (((|NonNegativeInteger|) |#4| |#3|)
   "\\spad{rank(A,{} B)} computes the rank of the complete matrix \\spad{(A|B)} of the linear system \\spad{AX = B}."))
 (|hasSolution?|
  (((|Boolean|) |#4| |#3|)
   "\\spad{hasSolution?(A,{} B)} tests if the linear system \\spad{AX = B} has a solution."))
 (|particularSolution|
  (((|Union| |#3| #1="failed") |#4| |#3|)
   "\\spad{particularSolution(A,{} B)} finds a particular solution of the linear system \\spad{AX = B}."))
 (|solve|
  (((|List|
     (|Record| (|:| |particular| (|Union| |#3| #1#))
               (|:| |basis| (|List| |#3|))))
    |#4| (|List| |#3|))
   "\\spad{solve(A,{} LB)} finds a particular soln of the systems \\spad{AX = B} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB}.")
  (((|Record| (|:| |particular| (|Union| |#3| #1#))
              (|:| |basis| (|List| |#3|)))
    |#4| |#3|)
   "\\spad{solve(A,{} B)} finds a particular solution of the system \\spad{AX = B} and a basis of the associated homogeneous system \\spad{AX = 0}."))) 
NIL 
(|LinearSystemMatrixPackage1| F) 
((|constructor|
  (NIL
   "This package solves linear system in the matrix form \\spad{AX = B}. It is essentially a particular instantiation of the package \\spadtype{LinearSystemMatrixPackage} for Matrix and Vector. This package\\spad{'s} existence makes it easier to use \\spadfun{solve} in the FriCAS interpreter."))
 (|rank|
  (((|NonNegativeInteger|) (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{rank(A,{} B)} computes the rank of the complete matrix \\spad{(A|B)} of the linear system \\spad{AX = B}."))
 (|hasSolution?|
  (((|Boolean|) (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{hasSolution?(A,{} B)} tests if the linear system \\spad{AX = B} has a solution."))
 (|particularSolution|
  (((|Union| (|Vector| |#1|) #1="failed") (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{particularSolution(A,{} B)} finds a particular solution of the linear system \\spad{AX = B}."))
 (|solve|
  (((|List|
     (|Record| (|:| |particular| (|Union| (|Vector| |#1|) #1#))
               (|:| |basis| (|List| (|Vector| |#1|)))))
    (|List| (|List| |#1|)) (|List| (|Vector| |#1|)))
   "\\spad{solve(A,{} LB)} finds a particular soln of the systems \\spad{AX = B} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB}.")
  (((|List|
     (|Record| (|:| |particular| (|Union| (|Vector| |#1|) #1#))
               (|:| |basis| (|List| (|Vector| |#1|)))))
    (|Matrix| |#1|) (|List| (|Vector| |#1|)))
   "\\spad{solve(A,{} LB)} finds a particular soln of the systems \\spad{AX = B} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB}.")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) #1#))
              (|:| |basis| (|List| (|Vector| |#1|))))
    (|List| (|List| |#1|)) (|Vector| |#1|))
   "\\spad{solve(A,{} B)} finds a particular solution of the system \\spad{AX = B} and a basis of the associated homogeneous system \\spad{AX = 0}.")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) #1#))
              (|:| |basis| (|List| (|Vector| |#1|))))
    (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{solve(A,{} B)} finds a particular solution of the system \\spad{AX = B} and a basis of the associated homogeneous system \\spad{AX = 0}."))) 
NIL 
(|LinearSystemPolynomialPackage| R E OV P) 
((|constructor|
  (NIL
   "this package finds the solutions of linear systems presented as a list of polynomials."))
 (|intoMatrix|
  (((|Record| (|:| |mat| (|Matrix| (|Fraction| |#4|)))
              (|:| |vec| (|Vector| (|Fraction| |#4|))))
    (|List| |#4|) (|List| |#3|))
   "\\spad{intoMatrix(lp,{} lvar)} converts linear in symbols lvar system of polynomials \\spad{lp} = 0 into matrix form"))
 (|linSolve|
  (((|Record|
     (|:| |particular| (|Union| (|Vector| (|Fraction| |#4|)) "failed"))
     (|:| |basis| (|List| (|Vector| (|Fraction| |#4|)))))
    (|List| |#4|) (|List| |#3|))
   "\\spad{linSolve(lp,{} lvar)} finds the solutions of the linear system of polynomials \\spad{lp} = 0 with respect to the list of symbols lvar."))) 
NIL 
(|LieSquareMatrix| |n| R) 
((|constructor|
  (NIL
   "LieSquareMatrix(\\spad{n},{} \\spad{R}) implements the Lie algebra of the \\spad{n} by \\spad{n} matrices over the commutative ring \\spad{R}. The Lie bracket (commutator) of the algebra is given by \\spad{a*b := (a *\\$SQMATRIX(n,{} R) b - b *\\$SQMATRIX(n,{} R) a)},{} where \\spadfun{*\\$SQMATRIX(\\spad{n},{} \\spad{R})} is the usual matrix multiplication."))
 (|convert|
  (($ (|SquareMatrix| |#1| |#2|))
   "converts a SquareMatrix to a LieSquareMatrix"))) 
((|HasCategory| |#2| '(|IntegralDomain|)) (|HasCategory| |#2| '(|Finite|))
 (|HasCategory| |#2| '(|Field|))) 
(|LUDecomposition| D) 
((|constructor|
  (NIL
   "\\spadtype{LUDecomposition} contains procedures to solve linear systems of equations or to compute inverses using a LU decomposition."))
 (|LUInverse|
  (((|Record| (|:| |Inv| (|Matrix| |#1|)) (|:| |Pivots| (|List| |#1|)))
    (|Matrix| |#1|))
   "\\spad{LUInverse(A)} computes the inverse of \\spad{A} using a LU decomposition."))
 (|LUSolve|
  (((|Vector| |#1|) (|Matrix| |#1|) (|Vector| (|Integer|)) (|Vector| |#1|))
   "\\spad{LUSolve(LU,{} Perm,{} B)} uses a previously computed \\spad{LU} decomposition to solve a linear system with right hand side \\spad{B}. \\spad{LU} and \\spad{Perm} are as given by \\spad{LUDecomp}."))
 (|LUDecomp|
  (((|Record| (|:| LU (|Matrix| |#1|)) (|:| |Perm| (|Vector| (|Integer|)))
              (|:| |Pivots| (|List| |#1|)))
    (|Matrix| |#1|))
   "\\spad{LUDecomp(A)} computes a LU decomposition of \\spad{A} using the algorithm of Crout. \\spad{LU} contains both triangular matrices; \\spad{Perm} is the permutation used for partial pivoting and \\spad{Pivots} yields the used pivots."))) 
NIL 
(|LyndonWord| |VarSet|) 
((|constructor|
  (NIL
   "Lyndon words over arbitrary (ordered) symbols: see Free Lie Algebras by \\spad{C}. Reutenauer (Oxford science publications). A Lyndon word is a word which is smaller than any of its right factors \\spad{w}.\\spad{r}.\\spad{t}. the pure lexicographical ordering. If \\spad{a} and \\spad{b} are two Lyndon words such that \\spad{a < b} holds \\spad{w}.\\spad{r}.\\spad{t} lexicographical ordering then \\spad{a*b} is a Lyndon word. Parenthesized Lyndon words can be generated from symbols by using the following rule: \\spad{[[a,{} b],{} c]} is a Lyndon word iff \\spad{a*b < c <= b} holds. Lyndon words are internally represented by binary trees using the \\spadtype{FreeMagma} domain constructor. Two ordering are provided: lexicographic and length-lexicographic. \\newline Author : Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|LyndonWordsList|
  (((|List| $) (|List| |#1|) (|PositiveInteger|))
   "\\spad{LyndonWordsList(vl,{} n)} returns the list of Lyndon words over the alphabet \\spad{vl},{} up to order \\spad{n}."))
 (|LyndonWordsList1|
  (((|OneDimensionalArray| (|List| $)) (|List| |#1|) (|PositiveInteger|))
   "\\spad{LyndonWordsList1(vl,{} n)} returns an array of lists of Lyndon words over the alphabet \\spad{vl},{} up to order \\spad{n}."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of distinct entries of \\spad{x}."))
 (|lyndonIfCan|
  (((|Union| $ "failed") (|FreeMonoid| |#1|))
   "\\spad{lyndonIfCan(w)} convert \\spad{w} into a Lyndon word."))
 (|lyndon|
  (($ (|FreeMonoid| |#1|))
   "\\spad{lyndon(w)} convert \\spad{w} into a Lyndon word,{} error if \\spad{w} is not a Lyndon word."))
 (|lyndon?|
  (((|Boolean|) (|FreeMonoid| |#1|))
   "\\spad{lyndon?(w)} test if \\spad{w} is a Lyndon word."))
 (|factor|
  (((|List| $) (|FreeMonoid| |#1|))
   "\\spad{factor(x)} returns the decreasing factorization into Lyndon words."))
 (|coerce|
  (((|FreeMagma| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMagma}(VarSet) corresponding to \\spad{x}.")
  (((|FreeMonoid| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMonoid}(VarSet) corresponding to \\spad{x}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{VarSet}."))
 (|length|
  (((|PositiveInteger|) $)
   "\\spad{length(x)} returns the number of entries in \\spad{x}."))
 (|right|
  (($ $)
   "\\spad{right(x)} returns right subtree of \\spad{x} or error if \\spadopFrom{retractable?}{LyndonWord}(\\spad{x}) is \\spad{true}."))
 (|left|
  (($ $)
   "\\spad{left(x)} returns left subtree of \\spad{x} or error if \\spadopFrom{retractable?}{LyndonWord}(\\spad{x}) is \\spad{true}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(x)} tests if \\spad{x} is a tree with only one entry."))) 
NIL 
(|LazyStreamAggregate&| A S) 
((|constructor|
  (NIL
   "LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?',{} \\spadignore{e.g.} 'first' and 'rest',{} will also cause lazy evaluation if necessary. Elements of LazyStreamAggregate are computed only when strictly needed. Lazy computation means that potential errors are delayed,{} so errors are detected later than in case of normal (eager) evaluation used by other aggregates. In some cases computation that would signal error when using eager evaluation can succeed when using lazy evaluation."))
 (|complete|
  (($ $)
   "\\spad{complete(st)} causes all entries of 'st' to be computed. this function should only be called on streams which are known to be finite."))
 (|extend|
  (($ $ (|Integer|))
   "\\spad{extend(st,{} n)} causes entries to be computed,{} if necessary,{} so that 'st' will have at least \\spad{'n'} explicit entries or so that all entries of 'st' will be computed if 'st' is finite with length \\spad{<=} \\spad{n}."))
 (|numberOfComputedEntries|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComputedEntries(st)} returns the number of explicitly computed entries of stream \\spad{st} which exist immediately prior to the time this function is called."))
 (|rst|
  (($ $)
   "\\spad{rst(s)} returns a pointer to the next node of stream \\spad{s}. Caution: this function should only be called after a \\spad{empty?} test has been made since there is no error check."))
 (|frst|
  ((|#2| $)
   "\\spad{frst(s)} returns the first element of stream \\spad{s}. Caution: this function should only be called after a \\spad{empty?} test has been made since there is no error check."))
 (|lazyEvaluate|
  (($ $)
   "\\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \\spad{s}. Caution: the first node must be a lazy evaluation mechanism (satisfies \\spad{lazy?(s) = true}) as there is no error check. Note: a call to this function may or may not produce an explicit first entry"))
 (|lazy?|
  (((|Boolean|) $)
   "\\spad{lazy?(s)} returns \\spad{true} if the first node of the stream \\spad{s} is a lazy evaluation mechanism which could produce an additional entry to \\spad{s}."))
 (|explicitlyEmpty?|
  (((|Boolean|) $)
   "\\spad{explicitlyEmpty?(s)} returns \\spad{true} if the stream is an (explicitly) empty stream. Note: this is a null test which will not cause lazy evaluation."))
 (|explicitEntries?|
  (((|Boolean|) $)
   "\\spad{explicitEntries?(s)} returns \\spad{true} if the stream \\spad{s} has explicitly computed entries,{} and \\spad{false} otherwise."))
 (|select|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{select(f,{} st)} returns a stream consisting of those elements of stream st satisfying the predicate \\spad{f}. Note: \\spad{select(f,{} st) = [x for x in st | f(x)]}."))
 (|remove|
  (($ (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{remove(f,{} st)} returns a stream consisting of those elements of stream st which do not satisfy the predicate \\spad{f}. Note: \\spad{remove(f,{} st) = [x for x in st | not f(x)]}."))) 
NIL 
(|LazyStreamAggregate| S) 
((|constructor|
  (NIL
   "LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?',{} \\spadignore{e.g.} 'first' and 'rest',{} will also cause lazy evaluation if necessary. Elements of LazyStreamAggregate are computed only when strictly needed. Lazy computation means that potential errors are delayed,{} so errors are detected later than in case of normal (eager) evaluation used by other aggregates. In some cases computation that would signal error when using eager evaluation can succeed when using lazy evaluation."))
 (|complete|
  (($ $)
   "\\spad{complete(st)} causes all entries of 'st' to be computed. this function should only be called on streams which are known to be finite."))
 (|extend|
  (($ $ (|Integer|))
   "\\spad{extend(st,{} n)} causes entries to be computed,{} if necessary,{} so that 'st' will have at least \\spad{'n'} explicit entries or so that all entries of 'st' will be computed if 'st' is finite with length \\spad{<=} \\spad{n}."))
 (|numberOfComputedEntries|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComputedEntries(st)} returns the number of explicitly computed entries of stream \\spad{st} which exist immediately prior to the time this function is called."))
 (|rst|
  (($ $)
   "\\spad{rst(s)} returns a pointer to the next node of stream \\spad{s}. Caution: this function should only be called after a \\spad{empty?} test has been made since there is no error check."))
 (|frst|
  ((|#1| $)
   "\\spad{frst(s)} returns the first element of stream \\spad{s}. Caution: this function should only be called after a \\spad{empty?} test has been made since there is no error check."))
 (|lazyEvaluate|
  (($ $)
   "\\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \\spad{s}. Caution: the first node must be a lazy evaluation mechanism (satisfies \\spad{lazy?(s) = true}) as there is no error check. Note: a call to this function may or may not produce an explicit first entry"))
 (|lazy?|
  (((|Boolean|) $)
   "\\spad{lazy?(s)} returns \\spad{true} if the first node of the stream \\spad{s} is a lazy evaluation mechanism which could produce an additional entry to \\spad{s}."))
 (|explicitlyEmpty?|
  (((|Boolean|) $)
   "\\spad{explicitlyEmpty?(s)} returns \\spad{true} if the stream is an (explicitly) empty stream. Note: this is a null test which will not cause lazy evaluation."))
 (|explicitEntries?|
  (((|Boolean|) $)
   "\\spad{explicitEntries?(s)} returns \\spad{true} if the stream \\spad{s} has explicitly computed entries,{} and \\spad{false} otherwise."))
 (|select|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{select(f,{} st)} returns a stream consisting of those elements of stream st satisfying the predicate \\spad{f}. Note: \\spad{select(f,{} st) = [x for x in st | f(x)]}."))
 (|remove|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{remove(f,{} st)} returns a stream consisting of those elements of stream st which do not satisfy the predicate \\spad{f}. Note: \\spad{remove(f,{} st) = [x for x in st | not f(x)]}."))) 
NIL 
(|ThreeDimensionalMatrix| R) 
((|constructor|
  (NIL
   "This domain represents three dimensional matrices over a general object type"))
 (|matrixDimensions|
  (((|Vector| (|NonNegativeInteger|)) $)
   "\\spad{matrixDimensions(x)} returns the dimensions of a matrix"))
 (|matrixConcat3D|
  (($ (|Symbol|) $ $)
   "\\spad{matrixConcat3D(s,{} x,{} y)} concatenates two 3-\\spad{D} matrices along a specified axis"))
 (|coerce|
  (((|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))) $)
   "\\spad{coerce(x)} moves from the domain to the representation type")
  (($ (|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))))
   "\\spad{coerce(p)} moves from the representation type (PrimitiveArray PrimitiveArray PrimitiveArray \\spad{R}) to the domain"))
 (|setelt!|
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)
    |#1|)
   "\\spad{setelt!(x,{} i,{} j,{} k,{} s)} (or \\spad{x}.\\spad{i}.\\spad{j}.\\spad{k} \\spad{:=} \\spad{s}) sets a specific element of the array to some value of type \\spad{R}"))
 (|elt|
  ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{elt(x,{} i,{} j,{} k)} extract an element from the matrix \\spad{x}"))
 (|construct|
  (($ (|List| (|List| (|List| |#1|))))
   "\\spad{construct(lll)} creates a 3-\\spad{D} matrix from a List List List \\spad{R} \\spad{lll}"))
 (|plus|
  (($ $ $)
   "\\spad{plus(x,{} y)} adds two matrices,{} term by term we note that they must be the same size"))
 (|identityMatrix|
  (($ (|NonNegativeInteger|))
   "\\spad{identityMatrix(n)} create an identity matrix we note that this must be square"))
 (|zeroMatrix|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{zeroMatrix(i,{} j,{} k)} create a matrix with all zero terms"))) 
((|HasCategory| |#1| '(|SetCategory|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| '(|Ring|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Ring|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|ModularAlgebraicGcd| MPT MD MO) 
((|constructor|
  (NIL
   "ModularAlgebraicGcd(\\spad{MPT},{} \\spad{MD},{} MO) is a compatibility \\indented{1}{wrapper around \\spad{ModularAlgebraicGcd2}.}"))) 
NIL 
(|ModularAlgebraicGcd2| PT MP MPT MD ME MO) 
((|constructor|
  (NIL
   "This package computes \\spad{gcd} over field of algebraic \\indented{1}{functions over \\spad{Q} using modular method based on \\spad{M}. Monagan and} \\indented{1}{van Hoej paper.} \\indented{1}{Core modular operations are passed as parameter (MO) to this} \\indented{1}{package.\\space{2}Similarly,{} evaluation functions are passed as} \\indented{1}{parameter ME.}"))
 (|algebraicGcd|
  (((|Polynomial| (|Integer|)) |#1| |#1| (|List| |#1|) (|List| (|Symbol|))
    (|Symbol|) (|List| (|Symbol|)))
   "\\spad{algebraicGcd(x,{} y,{} lm,{} lp,{} v,{} la)} computes \\spad{gcd} of \\spad{x} and \\spad{y} modulo polynomials in \\spad{lm}. la is list of algebraic parameters,{} \\spad{lp} is a list of transcendental parameters,{} \\spad{v} is main variable."))) 
NIL 
(|ModularAlgebraicGcdOperations| MP MPT MD) 
((|constructor|
  (NIL
   "This category specifies operations needed by \\indented{1}{ModularAlgebraicGcd package.\\space{2}Since we have multiple} \\indented{1}{implementations we specify interface here and put} \\indented{1}{implementations in separate packages.\\space{2}Most operations} \\indented{1}{are done using special purpose abstract representation.} \\indented{1}{Appropriate types are passed as parameters: \\spad{MPT} is type} \\indented{1}{of modular polynomials in one variable with coefficients} \\indented{1}{in some algebraic extension.\\space{2}\\spad{MD} is type of modulus.} \\indented{1}{Final results are converted to packed representation,{}} \\indented{1}{with coefficients (from prime field) stored in one} \\indented{1}{array and exponents (in main variable and in auxiliary} \\indented{1}{variables representing generators of algebrac extension)} \\indented{1}{stored in parallel array.}"))
 (|repack1|
  (((|Void|) |#2| (|U32Vector|) (|Integer|) |#3|)
   "\\spad{repack1(x,{} a,{} d,{} m)} stores coefficients of \\spad{x} in a. \\spad{d} is degree of \\spad{x}. Corresponding exponents are given by pack_exps."))
 (|pack_exps|
  (((|SortedExponentVector|) (|Integer|) (|Integer|) |#3|)
   "\\spad{pack_exps(d,{} s,{} m)} produces vector of exponents up to degree \\spad{d}. \\spad{s} is size (degree) of algebraic extension. Use together with \\spad{repack1}."))
 (|degree| (((|Integer|) |#2|) "\\spad{degree(x)} gives degree of \\spad{x}."))
 (|zero?| (((|Boolean|) |#2|) "\\spad{zero?(x)} checks if \\spad{x} is zero."))
 (|MPtoMPT|
  (((|Union| |#2| "failed") |#1| (|Symbol|) (|List| (|Symbol|)) |#3|)
   "\\spad{MPtoMPT(p,{} s,{} ls,{} m)} converts \\spad{p} to packed representation."))
 (|pack_modulus|
  (((|Union| |#3| "failed") (|List| |#1|) (|List| (|Symbol|)) (|Integer|))
   "\\spad{pack_modulus(lp,{} ls,{} p)} converts \\spad{lp},{} \\spad{ls} and prime \\spad{p} which together describe algebraic extension to packed representation."))
 (|canonicalIfCan|
  (((|Union| |#2| "failed") |#2| |#3|)
   "\\spad{canonicalIfCan(x,{} m)} tries to divide \\spad{x} by its leading coefficient modulo \\spad{m}."))
 (|pseudoRem|
  ((|#2| |#2| |#2| |#3|)
   "\\spad{pseudoRem(x,{} y,{} m)} computes pseudoremainder of \\spad{x} by \\spad{y} modulo \\spad{m}."))) 
NIL 
(|ModularAlgebraicGcdTools2|) 
NIL 
NIL 
(|ModularAlgebraicGcdTools3|) 
((|pack_exps0|
  (((|Void|) (|SortedExponentVector|) (|List| (|Integer|)) (|Integer|)
    (|Integer|))
   "\\spad{pack_exps0(exps,{} sizes,{} ns,{} start)} is used by pack_exps."))
 (|m_inverse|
  (((|Union| (|Polynomial| (|Integer|)) "failed") (|Polynomial| (|Integer|))
    (|List| (|Polynomial| (|Integer|))) (|List| (|Symbol|)) (|Integer|))
   "\\spad{m_inverse(x,{} lm,{} lv,{} p)} computes inverse of \\spad{x} in algebraic extension defined by \\spad{lm}."))) 
NIL 
(|ModularAlgebraicGcdTools4|) 
NIL 
NIL 
(|Magma&| S) 
((|constructor|
  (NIL
   "Magma is the class of all multiplicative magmas,{} \\spadignore{i.e.} sets with a binary operation."))
 (^
  (($ $ (|PositiveInteger|))
   "\\spad{a^n} returns the \\spad{n}\\spad{-}th power of \\spad{a},{} defined by repeated squaring."))
 (|leftPower|
  (($ $ (|PositiveInteger|))
   "\\spad{leftPower(a,{} n)} returns the \\spad{n}\\spad{-}th left power of \\spad{a},{} \\spadignore{i.e.} \\spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \\spad{leftPower(a,{} 1) := a}."))
 (|rightPower|
  (($ $ (|PositiveInteger|))
   "\\spad{rightPower(a,{} n)} returns the \\spad{n}\\spad{-}th right power of \\spad{a},{} \\spadignore{i.e.} \\spad{rightPower(a,{} n) := rightPower(a,{} n-1) * a} and \\spad{rightPower(a,{} 1) := a}."))
 (*
  (($ $ $)
   "\\spad{a*b} is the product of \\spad{a} and \\spad{b} in a set with a binary operation."))) 
NIL 
(|Magma|) 
((|constructor|
  (NIL
   "Magma is the class of all multiplicative magmas,{} \\spadignore{i.e.} sets with a binary operation."))
 (^
  (($ $ (|PositiveInteger|))
   "\\spad{a^n} returns the \\spad{n}\\spad{-}th power of \\spad{a},{} defined by repeated squaring."))
 (|leftPower|
  (($ $ (|PositiveInteger|))
   "\\spad{leftPower(a,{} n)} returns the \\spad{n}\\spad{-}th left power of \\spad{a},{} \\spadignore{i.e.} \\spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \\spad{leftPower(a,{} 1) := a}."))
 (|rightPower|
  (($ $ (|PositiveInteger|))
   "\\spad{rightPower(a,{} n)} returns the \\spad{n}\\spad{-}th right power of \\spad{a},{} \\spadignore{i.e.} \\spad{rightPower(a,{} n) := rightPower(a,{} n-1) * a} and \\spad{rightPower(a,{} 1) := a}."))
 (*
  (($ $ $)
   "\\spad{a*b} is the product of \\spad{a} and \\spad{b} in a set with a binary operation."))) 
NIL 
(|MagmaWithUnit&| S) 
((|constructor|
  (NIL
   "\\indented{1}{MagmaWithUnit is the class of multiplicative monads with unit,{}} \\indented{1}{\\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \\indented{3}{leftIdentity(\"*\":(\\%,{}\\%)\\spad{->}\\%,{}1)\\space{3}\\tab{30} 1*x=x} \\indented{3}{rightIdentity(\"*\":(\\%,{}\\%)\\spad{->}\\%,{}1)\\space{2}\\tab{30} x*1=x} Common Additional Axioms \\indented{3}{unitsKnown---if \"recip\" says \"failed\",{} that PROVES input wasn\\spad{'t} a unit}"))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (^
  (($ $ (|NonNegativeInteger|))
   "\\spad{a^n} returns the \\spad{n}\\spad{-}th power of \\spad{a},{} defined by repeated squaring."))
 (|leftPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{leftPower(a,{} n)} returns the \\spad{n}\\spad{-}th left power of \\spad{a},{} \\spadignore{i.e.} \\spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \\spad{leftPower(a,{} 0) := 1}."))
 (|rightPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rightPower(a,{} n)} returns the \\spad{n}\\spad{-}th right power of \\spad{a},{} \\spadignore{i.e.} \\spad{rightPower(a,{} n) := rightPower(a,{} n-1) * a} and \\spad{rightPower(a,{} 0) := 1}."))
 (|one?|
  (((|Boolean|) $) "\\spad{one?(a)} tests whether \\spad{a} is the unit 1."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 ((|One|) (($) "1 returns the unit element,{} denoted by 1."))) 
NIL 
(|MagmaWithUnit|) 
((|constructor|
  (NIL
   "\\indented{1}{MagmaWithUnit is the class of multiplicative monads with unit,{}} \\indented{1}{\\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \\indented{3}{leftIdentity(\"*\":(\\%,{}\\%)\\spad{->}\\%,{}1)\\space{3}\\tab{30} 1*x=x} \\indented{3}{rightIdentity(\"*\":(\\%,{}\\%)\\spad{->}\\%,{}1)\\space{2}\\tab{30} x*1=x} Common Additional Axioms \\indented{3}{unitsKnown---if \"recip\" says \"failed\",{} that PROVES input wasn\\spad{'t} a unit}"))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (^
  (($ $ (|NonNegativeInteger|))
   "\\spad{a^n} returns the \\spad{n}\\spad{-}th power of \\spad{a},{} defined by repeated squaring."))
 (|leftPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{leftPower(a,{} n)} returns the \\spad{n}\\spad{-}th left power of \\spad{a},{} \\spadignore{i.e.} \\spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \\spad{leftPower(a,{} 0) := 1}."))
 (|rightPower|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rightPower(a,{} n)} returns the \\spad{n}\\spad{-}th right power of \\spad{a},{} \\spadignore{i.e.} \\spad{rightPower(a,{} n) := rightPower(a,{} n-1) * a} and \\spad{rightPower(a,{} 0) := 1}."))
 (|one?|
  (((|Boolean|) $) "\\spad{one?(a)} tests whether \\spad{a} is the unit 1."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 ((|One|) (($) "1 returns the unit element,{} denoted by 1."))) 
NIL 
(|MatrixManipulation| R |Row| |Col| M) 
((|constructor|
  (NIL
   "Some functions for manipulating (dense) matrices. Supported are various kinds of slicing,{} splitting and stacking of matrices. The functions resemble operations often used in numerical linear algebra algorithms."))
 (|blockSplit|
  (((|List| (|List| |#4|)) |#4| (|PositiveInteger|)
    (|List| (|NonNegativeInteger|)))
   "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise,{} dividing a matrix into blocks.")
  (((|List| (|List| |#4|)) |#4| (|List| (|NonNegativeInteger|))
    (|PositiveInteger|))
   "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise,{} dividing a matrix into blocks."))
 (|bandMatrix|
  ((|#4| |#4| (|Segment| (|Integer|)))
   "\\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals.")
  ((|#4| |#4| (|List| (|Integer|)))
   "\\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals."))
 (|diagonalMatrix|
  ((|#4| |#4|)
   "\\spad{diagonalMatrix} returns the main diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one.")
  ((|#4| |#4| (|Integer|))
   "\\spad{diagonalMatrix} returns a diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals."))
 (|subMatrix|
  ((|#4| |#4| (|Segment| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{subMatrix} returns several elements out of a matrix. The elements are stacked into a submatrix.")
  ((|#4| |#4| (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{subMatrix} returns several elements out of a matrix. The elements are stacked into a submatrix."))
 (|columns|
  ((|#4| |#4| (|Segment| (|Integer|)))
   "\\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix.")
  ((|#4| |#4| (|List| (|Integer|)))
   "\\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix."))
 (|columnMatrix|
  ((|#4| |#4| (|Integer|))
   "\\spad{columnMatrix} returns a single column out of a matrix. The column is put into a one by \\spad{N} matrix."))
 (|rows|
  ((|#4| |#4| (|Segment| (|Integer|)))
   "\\spad{rows} returns several rows out of a matrix. The rows are stacked into a matrix.")
  ((|#4| |#4| (|List| (|Integer|)))
   "\\spad{rows} returns several rows out of a matrix. The rows are stacked into a matrix."))
 (|rowMatrix|
  ((|#4| |#4| (|Integer|))
   "\\spad{rowMatrix} returns a single row out of a matrix. The row is put into a one by \\spad{N} matrix."))
 (|element|
  ((|#4| |#4| (|Integer|) (|Integer|))
   "\\spad{element} returns a single element out of a matrix. The element is put into a one by one matrix."))) 
((|HasCategory| |#1| '(|AbelianMonoid|))) 
(|MappingPackageInternalHacks1| A) 
((|constructor| (NIL "various Currying operations."))
 (|recur|
  ((|#1| (|Mapping| |#1| (|NonNegativeInteger|) |#1|) (|NonNegativeInteger|)
    |#1|)
   "\\spad{recur(g,{} n,{} x)} is \\spad{g(n,{} g(n-1,{} ..g(1,{} x)..))}."))
 (|iter|
  ((|#1| (|Mapping| |#1| |#1|) (|NonNegativeInteger|) |#1|)
   "\\spad{iter(f,{} n,{} x)} applies \\spad{f} \\spad{n} times to \\spad{x}."))) 
NIL 
(|MappingPackageInternalHacks2| A C) 
((|constructor| (NIL "various Currying operations."))
 (|arg2|
  ((|#2| |#1| |#2|) "\\spad{arg2(a,{} c)} selects its second argument."))
 (|arg1| ((|#1| |#1| |#2|) "\\spad{arg1(a,{} c)} selects its first argument."))) 
NIL 
(|MappingPackageInternalHacks3| A B C) 
((|constructor| (NIL "various Currying operations."))
 (|comp|
  ((|#3| (|Mapping| |#3| |#2|) (|Mapping| |#2| |#1|) |#1|)
   "\\spad{comp(f,{} g,{} x)} is \\spad{f(g x)}."))) 
NIL 
(|MappingPackage1| A) 
((|constructor| (NIL "various Currying operations."))
 (|recur|
  (((|Mapping| |#1| (|NonNegativeInteger|) |#1|)
    (|Mapping| |#1| (|NonNegativeInteger|) |#1|))
   "\\spad{recur(g)} is the function \\spad{h} such that \\indented{1}{\\spad{h(n,{} x)= g(n,{} g(n-1,{} ..g(1,{} x)..))}.}"))
 (^
  (((|Mapping| |#1| |#1|) (|Mapping| |#1| |#1|) (|NonNegativeInteger|))
   "\\spad{f^n} is the function which is the \\spad{n}-fold application \\indented{1}{of \\spad{f}.}"))
 (|id| ((|#1| |#1|) "\\spad{id x} is \\spad{x}."))
 (|coerce|
  (((|Mapping| |#1|) |#1|)
   "\\spad{coerce A} changes its argument into a \\indented{1}{nullary function.}"))
 (|nullary|
  (((|Mapping| |#1|) |#1|)
   "\\spad{nullary A} changes its argument into a \\indented{1}{nullary function.}"))) 
NIL 
(|MappingPackage2| A C) 
((|constructor| (NIL "various Currying operations."))
 (|diag|
  (((|Mapping| |#2| |#1|) (|Mapping| |#2| |#1| |#1|))
   "\\spad{diag(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g a = f(a,{} a)}.}"))
 (|constant|
  (((|Mapping| |#2| |#1|) (|Mapping| |#2|))
   "\\spad{constant(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g a= f ()}.}"))
 (|curry|
  (((|Mapping| |#2|) (|Mapping| |#2| |#1|) |#1|)
   "\\spad{curry(f,{} a)} is the function \\spad{g} \\indented{1}{such that \\spad{g ()= f a}.}"))
 (|const|
  (((|Mapping| |#2| |#1|) |#2|)
   "\\spad{const c} is a function which produces \\spad{c} when \\indented{1}{applied to its argument.}"))) 
NIL 
(|MappingPackage3| A B C) 
((|constructor| (NIL "various Currying operations."))
 (*
  (((|Mapping| |#3| |#1|) (|Mapping| |#3| |#2|) (|Mapping| |#2| |#1|))
   "\\spad{f*g} is the function \\spad{h} \\indented{1}{such that \\spad{h x= f(g x)}.}"))
 (|twist|
  (((|Mapping| |#3| |#2| |#1|) (|Mapping| |#3| |#1| |#2|))
   "\\spad{twist(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,{} b)= f(b,{} a)}.}"))
 (|constantLeft|
  (((|Mapping| |#3| |#1| |#2|) (|Mapping| |#3| |#2|))
   "\\spad{constantLeft(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,{} b)= f b}.}"))
 (|constantRight|
  (((|Mapping| |#3| |#1| |#2|) (|Mapping| |#3| |#1|))
   "\\spad{constantRight(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,{} b)= f a}.}"))
 (|curryLeft|
  (((|Mapping| |#3| |#2|) (|Mapping| |#3| |#1| |#2|) |#1|)
   "\\spad{curryLeft(f,{} a)} is the function \\spad{g} \\indented{1}{such that \\spad{g b = f(a,{} b)}.}"))
 (|curryRight|
  (((|Mapping| |#3| |#1|) (|Mapping| |#3| |#1| |#2|) |#2|)
   "\\spad{curryRight(f,{} b)} is the function \\spad{g} such that \\indented{1}{\\spad{g a = f(a,{} b)}.}"))) 
NIL 
(|MatrixCategory&| S R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa."))
 (|kronecker_prod1|
  (((|Void|) $ (|Integer|) (|List| (|List| (|NonNegativeInteger|))) (|List| $)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|Union| |#2| "one"))
   "Should be local but conditional."))
 (|inverse|
  (((|Union| $ "failed") $)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m}. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square."))
 (|Pfaffian|
  ((|#2| $)
   "\\spad{Pfaffian(m)} returns the Pfaffian of the matrix \\spad{m}. Error: if the matrix is not antisymmetric."))
 (|minordet|
  ((|#2| $)
   "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors. Error: if the matrix is not square."))
 (|determinant|
  ((|#2| $)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}. Error: if the matrix is not square."))
 (|nullSpace|
  (((|List| |#4|) $)
   "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) $)
   "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|columnSpace|
  (((|List| |#4|) $)
   "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} forming a basis of its column space"))
 (|rowEchelon|
  (($ $)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))
 (/
  (($ $ |#2|)
   "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r}. Error: if \\spad{r = 0}."))
 (|exquo|
  (((|Union| $ "failed") $ |#2|)
   "\\spad{exquo(m,{} r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r},{} returning \\spad{\"failed\"} if this is not possible."))
 (^
  (($ $ (|Integer|))
   "\\spad{m^n} computes an integral power of the matrix \\spad{m}. Error: if matrix is not square or if the matrix is square but not invertible.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{x ^ n} computes a non-negative integral power of the matrix \\spad{x}. Error: if the matrix is not square."))
 (|positivePower|
  (($ $ (|Integer|))
   "\\spad{positivePower(x,{} n)} computes a positive integral power of the matrix \\spad{x}. Error: if the matrix is not square."))
 (*
  ((|#3| |#3| $)
   "\\spad{r * x} is the product of the row vector \\spad{r} and the matrix \\spad{x}. Error: if the dimensions are incompatible.")
  ((|#4| $ |#4|)
   "\\spad{x * c} is the product of the matrix \\spad{x} and the column vector \\spad{c}. Error: if the dimensions are incompatible.")
  (($ $ |#2|)
   "\\spad{x * r} is the right scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ |#2| $)
   "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ $ $)
   "\\spad{x * y} is the product of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible.")
  (($ (|Integer|) $) "\\spad{n * x} is an integer multiple."))
 (- (($ $) "\\spad{-x} returns the negative of the matrix \\spad{x}.")
    (($ $ $)
     "\\spad{x - y} is the difference of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible."))
 (+
  (($ $ $)
   "\\spad{x + y} is the sum of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible."))
 (|transpose|
  (($ |#3|)
   "\\spad{transpose(r)} converts the row \\spad{r} to a row matrix."))
 (|coerce|
  (($ |#4|)
   "\\spad{coerce(col)} converts the column \\spad{col} to a column matrix."))
 (|kroneckerSum|
  (($ (|List| $))
   "\\spad{kroneckerSum([a1,{} a2,{} ...,{} an])} calculates the Kronecker sum of the matrices \\spad{a1},{} \\spad{a2},{} ...,{} an.")
  (($ $ $)
   "\\spad{kroneckerSum(a,{} b)} calculates the Kronecker sum of the matrices a and \\spad{b}."))
 (|kroneckerProduct|
  (($ (|List| $))
   "\\spad{kroneckerProduct([a1,{} a2,{} ...,{} an])} calculates the Kronecker product of the matrices \\spad{a1},{} \\spad{a2},{} ...,{} an. This corresponds to tensor product of corresponding operators.")
  (($ $ $)
   "\\spad{kroneckerProduct(a,{} b)} calculates the Kronecker product of the matrices a and \\spad{b}. This corresponds to tensor product of corresponding operators."))
 (|diagonalMatrix|
  (($ (|List| $))
   "\\spad{diagonalMatrix([m1,{} ...,{} mk])} creates a block diagonal matrix \\spad{M} with block matrices {\\em m1},{} ...,{} {\\em mk} down the diagonal,{} with 0 block matrices elsewhere. More precisly: if \\spad{\\spad{ri} := nrows \\spad{mi}},{} \\spad{\\spad{ci} := ncols \\spad{mi}},{} then \\spad{m} is an (\\spad{r1+}..\\spad{+rk}) by (\\spad{c1+}..\\spad{+ck}) - matrix with entries \\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))},{} if \\spad{(r1+..+r(l-1)) < i <= r1+..+rl} and \\spad{(c1+..+c(l-1)) < i <= c1+..+cl},{} \\spad{m.i.j} = 0 otherwise.")
  (($ (|List| |#2|))
   "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal."))
 (|scalarMatrix|
  (($ (|NonNegativeInteger|) |#2|)
   "\\spad{scalarMatrix(n,{} r)} returns an \\spad{n}-by-\\spad{n} matrix with \\spad{r}\\spad{'s} on the diagonal and zeroes elsewhere."))
 (|matrix|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|Mapping| |#2| (|Integer|) (|Integer|)))
   "\\spad{matrix(n,{}m,{}f)} constructs an \\spad{n * m} matrix with the \\spad{(i,{}j)} entry equal to \\spad{f(i,{}j)}.")
  (($ (|List| (|List| |#2|)))
   "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix."))
 (|zero|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{zero(m,{} n)} returns an \\spad{m}-by-\\spad{n} zero matrix."))
 (|zero?|
  (((|Boolean|) $)
   "\\spad{zero?(m)} returns \\spad{true} if \\spad{m} is a zero matrix and \\spad{false} otherwise."))
 (|antisymmetric?|
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|symmetric?|
  (((|Boolean|) $)
   "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|diagonal?|
  (((|Boolean|) $)
   "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."))
 (|square?|
  (((|Boolean|) $)
   "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."))) 
((|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|EuclideanDomain|)) (|HasCategory| |#2| '(|Field|))
 (|HasCategory| |#2| '(|IntegralDomain|)) (|HasCategory| |#2| '(|Monoid|))
 (|HasCategory| |#2| '(|SemiRng|)) (|HasCategory| |#2| '(|AbelianGroup|))) 
(|MatrixCategory| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa."))
 (|kronecker_prod1|
  (((|Void|) $ (|Integer|) (|List| (|List| (|NonNegativeInteger|))) (|List| $)
    (|NonNegativeInteger|) (|NonNegativeInteger|) (|Union| |#1| "one"))
   "Should be local but conditional."))
 (|inverse|
  (((|Union| $ "failed") $)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m}. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square."))
 (|Pfaffian|
  ((|#1| $)
   "\\spad{Pfaffian(m)} returns the Pfaffian of the matrix \\spad{m}. Error: if the matrix is not antisymmetric."))
 (|minordet|
  ((|#1| $)
   "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors. Error: if the matrix is not square."))
 (|determinant|
  ((|#1| $)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}. Error: if the matrix is not square."))
 (|nullSpace|
  (((|List| |#3|) $)
   "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) $)
   "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|columnSpace|
  (((|List| |#3|) $)
   "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} forming a basis of its column space"))
 (|rowEchelon|
  (($ $)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))
 (/
  (($ $ |#1|)
   "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r}. Error: if \\spad{r = 0}."))
 (|exquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{exquo(m,{} r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r},{} returning \\spad{\"failed\"} if this is not possible."))
 (^
  (($ $ (|Integer|))
   "\\spad{m^n} computes an integral power of the matrix \\spad{m}. Error: if matrix is not square or if the matrix is square but not invertible.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{x ^ n} computes a non-negative integral power of the matrix \\spad{x}. Error: if the matrix is not square."))
 (|positivePower|
  (($ $ (|Integer|))
   "\\spad{positivePower(x,{} n)} computes a positive integral power of the matrix \\spad{x}. Error: if the matrix is not square."))
 (*
  ((|#2| |#2| $)
   "\\spad{r * x} is the product of the row vector \\spad{r} and the matrix \\spad{x}. Error: if the dimensions are incompatible.")
  ((|#3| $ |#3|)
   "\\spad{x * c} is the product of the matrix \\spad{x} and the column vector \\spad{c}. Error: if the dimensions are incompatible.")
  (($ $ |#1|)
   "\\spad{x * r} is the right scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ |#1| $)
   "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the matrix \\spad{x}.")
  (($ $ $)
   "\\spad{x * y} is the product of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible.")
  (($ (|Integer|) $) "\\spad{n * x} is an integer multiple."))
 (- (($ $) "\\spad{-x} returns the negative of the matrix \\spad{x}.")
    (($ $ $)
     "\\spad{x - y} is the difference of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible."))
 (+
  (($ $ $)
   "\\spad{x + y} is the sum of the matrices \\spad{x} and \\spad{y}. Error: if the dimensions are incompatible."))
 (|transpose|
  (($ |#2|)
   "\\spad{transpose(r)} converts the row \\spad{r} to a row matrix."))
 (|coerce|
  (($ |#3|)
   "\\spad{coerce(col)} converts the column \\spad{col} to a column matrix."))
 (|kroneckerSum|
  (($ (|List| $))
   "\\spad{kroneckerSum([a1,{} a2,{} ...,{} an])} calculates the Kronecker sum of the matrices \\spad{a1},{} \\spad{a2},{} ...,{} an.")
  (($ $ $)
   "\\spad{kroneckerSum(a,{} b)} calculates the Kronecker sum of the matrices a and \\spad{b}."))
 (|kroneckerProduct|
  (($ (|List| $))
   "\\spad{kroneckerProduct([a1,{} a2,{} ...,{} an])} calculates the Kronecker product of the matrices \\spad{a1},{} \\spad{a2},{} ...,{} an. This corresponds to tensor product of corresponding operators.")
  (($ $ $)
   "\\spad{kroneckerProduct(a,{} b)} calculates the Kronecker product of the matrices a and \\spad{b}. This corresponds to tensor product of corresponding operators."))
 (|diagonalMatrix|
  (($ (|List| $))
   "\\spad{diagonalMatrix([m1,{} ...,{} mk])} creates a block diagonal matrix \\spad{M} with block matrices {\\em m1},{} ...,{} {\\em mk} down the diagonal,{} with 0 block matrices elsewhere. More precisly: if \\spad{\\spad{ri} := nrows \\spad{mi}},{} \\spad{\\spad{ci} := ncols \\spad{mi}},{} then \\spad{m} is an (\\spad{r1+}..\\spad{+rk}) by (\\spad{c1+}..\\spad{+ck}) - matrix with entries \\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))},{} if \\spad{(r1+..+r(l-1)) < i <= r1+..+rl} and \\spad{(c1+..+c(l-1)) < i <= c1+..+cl},{} \\spad{m.i.j} = 0 otherwise.")
  (($ (|List| |#1|))
   "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal."))
 (|scalarMatrix|
  (($ (|NonNegativeInteger|) |#1|)
   "\\spad{scalarMatrix(n,{} r)} returns an \\spad{n}-by-\\spad{n} matrix with \\spad{r}\\spad{'s} on the diagonal and zeroes elsewhere."))
 (|matrix|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|Mapping| |#1| (|Integer|) (|Integer|)))
   "\\spad{matrix(n,{}m,{}f)} constructs an \\spad{n * m} matrix with the \\spad{(i,{}j)} entry equal to \\spad{f(i,{}j)}.")
  (($ (|List| (|List| |#1|)))
   "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix."))
 (|zero|
  (($ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{zero(m,{} n)} returns an \\spad{m}-by-\\spad{n} zero matrix."))
 (|zero?|
  (((|Boolean|) $)
   "\\spad{zero?(m)} returns \\spad{true} if \\spad{m} is a zero matrix and \\spad{false} otherwise."))
 (|antisymmetric?|
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|symmetric?|
  (((|Boolean|) $)
   "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|diagonal?|
  (((|Boolean|) $)
   "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."))
 (|square?|
  (((|Boolean|) $)
   "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."))) 
NIL 
(|MatrixCategoryFunctions2| R1 |Row1| |Col1| M1 R2 |Row2| |Col2| M2) 
((|constructor|
  (NIL
   "\\spadtype{MatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \\spadfun{map} and \\spadfun{reduce}."))
 (|reduce|
  ((|#5| (|Mapping| |#5| |#1| |#5|) |#4| |#5|)
   "\\spad{reduce(f,{} m,{} r)} traverses \\spad{m} row by row passing \\spad{m}(\\spad{i},{} \\spad{j}) as first argument to \\spad{f}. The second argument to \\spad{f} works as accumulator,{} value from previous call is passed to next call. On first call \\spad{r} is passed as second argument to \\spad{f}. Return value is the last result returned by \\spad{f}."))
 (|map|
  (((|Union| |#8| "failed") (|Mapping| (|Union| |#5| "failed") |#1|) |#4|)
   "\\spad{map(f,{} m)} applies the function \\spad{f} to the elements of the matrix \\spad{m}.")
  ((|#8| (|Mapping| |#5| |#1|) |#4|)
   "\\spad{map(f,{} m)} applies the function \\spad{f} to the elements of the matrix \\spad{m}."))) 
NIL 
(|MatrixLinearAlgebraFunctions| R |Row| |Col| M) 
((|constructor|
  (NIL
   "\\spadtype{MatrixLinearAlgebraFunctions} provides functions to compute inverses and canonical forms."))
 (|inverse|
  (((|Union| |#4| "failed") |#4|)
   "\\spad{inverse(m)} returns the inverse of the matrix. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square."))
 (|normalizedDivide|
  (((|Record| (|:| |quotient| |#1|) (|:| |remainder| |#1|)) |#1| |#1|)
   "\\spad{normalizedDivide(n,{} d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \\spadignore{e.g.} positive remainders"))
 (|rowEchelon|
  ((|#4| |#4|)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))
 (|adjoint|
  (((|Record| (|:| |adjMat| |#4|) (|:| |detMat| |#1|)) |#4|)
   "\\spad{adjoint(m)} returns the ajoint matrix of \\spad{m} (\\spadignore{i.e.} the matrix \\spad{n} such that \\spad{m*n} = determinant(\\spad{m})*id) and the detrminant of \\spad{m}."))
 (|invertIfCan|
  (((|Union| |#4| "failed") |#4|)
   "\\spad{invertIfCan(m)} returns the inverse of \\spad{m} over \\spad{R}"))
 (|fractionFreeGauss!|
  ((|#4| |#4|)
   "\\spad{fractionFreeGauss(m)} performs the fraction free gaussian elimination on the matrix \\spad{m}."))
 (|nullSpace|
  (((|List| |#3|) |#4|)
   "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) |#4|)
   "\\spad{nullity(m)} returns the mullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) |#4|)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|elColumn2!|
  ((|#4| |#4| |#1| (|Integer|) (|Integer|))
   "\\spad{elColumn2!(m,{} a,{} i,{} j)} adds to column \\spad{i} a*column(\\spad{m},{} \\spad{j}) : elementary operation of second kind. (\\spad{i} \\spad{~=j})"))
 (|elRow2!|
  ((|#4| |#4| |#1| (|Integer|) (|Integer|))
   "\\spad{elRow2!(m,{} a,{} i,{} j)} adds to row \\spad{i} a*row(\\spad{m},{} \\spad{j}) : elementary operation of second kind. (\\spad{i} \\spad{~=j})"))
 (|elRow1!|
  ((|#4| |#4| (|Integer|) (|Integer|))
   "\\spad{elRow1!(m,{} i,{} j)} swaps rows \\spad{i} and \\spad{j} of matrix \\spad{m} : elementary operation of first kind"))
 (|minordet|
  ((|#1| |#4|)
   "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors. Error: if the matrix is not square."))
 (|determinant|
  ((|#1| |#4|)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}. an error message is returned if the matrix is not square."))) 
((|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|IntegralDomain|))) 
(|Matrix| R) 
((|constructor|
  (NIL
   "\\spadtype{Matrix} is a matrix domain where 1-based indexing is used for both rows and columns."))
 (|invertIfCan|
  (((|Union| $ "failed") $)
   "\\spad{invertIfCan(m)} returns the inverse of the matrix \\spad{m}. If the matrix is not invertible,{} \"failed\" is returned. Error: if the matrix is not square."))
 (|diagonalMatrix|
  (($ (|Vector| |#1|))
   "\\spad{diagonalMatrix(v)} returns a diagonal matrix where the elements of \\spad{v} appear on the diagonal."))) 
((|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRng|))
 (AND (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))
 (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|IntegralDomain|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|StorageEfficientMatrixOperations| R) 
((|constructor|
  (NIL
   "This package provides standard arithmetic operations on matrices. The functions in this package store the results of computations in existing matrices,{} rather than creating new matrices. This package works only for matrices of type Matrix and uses the internal representation of this type."))
 (^
  (((|Matrix| |#1|) (|Matrix| |#1|) (|NonNegativeInteger|))
   "\\spad{x ^ n} computes the \\spad{n}-th power of a square matrix. The power \\spad{n} is assumed greater than 1."))
 (|power!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)
    (|Matrix| |#1|) (|NonNegativeInteger|))
   "\\spad{power!(a,{} b,{} c,{} m,{} n)} computes \\spad{m} ^ \\spad{n} and stores the result in \\spad{a}. The matrices \\spad{b} and \\spad{c} are used to store intermediate results. Error: if \\spad{a},{} \\spad{b},{} \\spad{c},{} and \\spad{m} are not square and of the same dimensions."))
 (|times!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{times!(c,{} a,{} b)} computes the matrix product \\spad{a * b} and stores the result in the matrix \\spad{c}. Error: if \\spad{a},{} \\spad{b},{} and \\spad{c} do not have compatible dimensions."))
 (|rightScalarTimes!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) |#1|)
   "\\spad{rightScalarTimes!(c,{} a,{} r)} computes the scalar product \\spad{a * r} and stores the result in the matrix \\spad{c}. Error: if \\spad{a} and \\spad{c} do not have the same dimensions."))
 (|leftScalarTimes!|
  (((|Matrix| |#1|) (|Matrix| |#1|) |#1| (|Matrix| |#1|))
   "\\spad{leftScalarTimes!(c,{} r,{} a)} computes the scalar product \\spad{r * a} and stores the result in the matrix \\spad{c}. Error: if \\spad{a} and \\spad{c} do not have the same dimensions."))
 (|minus!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{!minus!(c,{} a,{} b)} computes the matrix difference \\spad{a - b} and stores the result in the matrix \\spad{c}. Error: if \\spad{a},{} \\spad{b},{} and \\spad{c} do not have the same dimensions.")
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{minus!(c,{} a)} computes \\spad{-a} and stores the result in the matrix \\spad{c}. Error: if a and \\spad{c} do not have the same dimensions."))
 (|plus!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{plus!(c,{} a,{} b)} computes the matrix sum \\spad{a + b} and stores the result in the matrix \\spad{c}. Error: if \\spad{a},{} \\spad{b},{} and \\spad{c} do not have the same dimensions."))
 (|copy!|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{copy!(c,{} a)} copies the matrix \\spad{a} into the matrix \\spad{c}. Error: if \\spad{a} and \\spad{c} do not have the same dimensions."))) 
NIL 
(|MultiVariableCalculusFunctions| S F FLAF FLAS) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{MultiVariableCalculusFunctions} Package provides several} \\indented{1}{functions for multivariable calculus.} These include gradient,{} hessian and jacobian,{} divergence and laplacian. Various forms for banded and sparse storage of matrices are included."))
 (|bandedJacobian|
  (((|Matrix| |#2|) |#3| |#4| (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{bandedJacobian(vf,{} xlist,{} kl,{} ku)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \\spad{vf},{} \\spad{vf} a vector function of the variables listed in \\spad{xlist},{} \\spad{kl} is the number of nonzero subdiagonals,{} ku is the number of nonzero superdiagonals,{} \\spad{kl+ku+1} being actual bandwidth. Stores the nonzero band in a matrix,{} dimensions \\spad{kl+ku+1} by \\#xlist. The upper triangle is in the top ku rows,{} the diagonal is in row \\spad{ku+1},{} the lower triangle in the last \\spad{kl} rows. Entries in a column in the band store correspond to entries in same column of full store. (The notation conforms to LAPACK/NAG-\\spad{F07} conventions.)"))
 (|jacobian|
  (((|Matrix| |#2|) |#3| |#4|)
   "\\spad{jacobian(vf,{} xlist)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \\spad{vf},{} \\spad{vf} a vector function of the variables listed in xlist."))
 (|bandedHessian|
  (((|Matrix| |#2|) |#2| |#4| (|NonNegativeInteger|))
   "\\spad{bandedHessian(v,{} xlist,{} k)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \\spad{v},{} \\spad{v} a function of the variables listed in \\spad{xlist},{} \\spad{k} is the semi-bandwidth,{} the number of nonzero subdiagonals,{} 2*k+1 being actual bandwidth. Stores the nonzero band in lower triangle in a matrix,{} dimensions \\spad{k+1} by \\#xlist,{} whose rows are the vectors formed by diagonal,{} subdiagonal,{} etc. of the real,{} full-matrix,{} hessian. (The notation conforms to LAPACK/NAG-\\spad{F07} conventions.)"))
 (|hessian|
  (((|Matrix| |#2|) |#2| |#4|)
   "\\spad{hessian(v,{} xlist)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \\spad{v},{} \\spad{v} a function of the variables listed in xlist."))
 (|laplacian|
  ((|#2| |#2| |#4|)
   "\\spad{laplacian(v,{} xlist)} computes the laplacian of the scalar field \\spad{v},{} \\spad{v} a function of the variables listed in xlist."))
 (|divergence|
  ((|#2| |#3| |#4|)
   "\\spad{divergence(vf,{} xlist)} computes the divergence of the vector field \\spad{vf},{} \\spad{vf} a vector function of the variables listed in xlist."))
 (|gradient|
  (((|Vector| |#2|) |#2| |#4|)
   "\\spad{gradient(v,{} xlist)} computes the gradient,{} the vector of first partial derivatives,{} of the scalar field \\spad{v},{} \\spad{v} a function of the variables listed in xlist."))) 
NIL 
(|MatrixCommonDenominator| R Q) 
((|constructor|
  (NIL
   "MatrixCommonDenominator provides functions to compute the common denominator of a matrix of elements of the quotient field of an integral domain."))
 (|splitDenominator|
  (((|Record| (|:| |num| (|Matrix| |#1|)) (|:| |den| |#1|)) (|Matrix| |#2|))
   "\\spad{splitDenominator(q)} returns \\spad{[p,{} d]} such that \\spad{q = p/d} and \\spad{d} is a common denominator for the elements of \\spad{q}."))
 (|clearDenominator|
  (((|Matrix| |#1|) (|Matrix| |#2|))
   "\\spad{clearDenominator(q)} returns \\spad{p} such that \\spad{q = p/d} where \\spad{d} is a common denominator for the elements of \\spad{q}."))
 (|commonDenominator|
  ((|#1| (|Matrix| |#2|))
   "\\spad{commonDenominator(q)} returns a common denominator \\spad{d} for the elements of \\spad{q}."))) 
NIL 
(|MachineComplex|) 
((|constructor|
  (NIL
   "A domain which models the complex number representation used by machines in the AXIOM-NAG link."))
 (|coerce|
  (((|Complex| (|Float|)) $)
   "\\spad{coerce(u)} transforms \\spad{u} into a COmplex Float")
  (($ (|Complex| (|MachineInteger|)))
   "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex")
  (($ (|Complex| (|MachineFloat|)))
   "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex")
  (($ (|Complex| (|Integer|)))
   "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex")
  (($ (|Complex| (|Float|)))
   "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex"))) 
((|HasCategory| (|MachineFloat|) '(|CharacteristicZero|))
 (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|))
 (|HasCategory| (|MachineFloat|) '(|Field|))
 (OR (|HasCategory| (|MachineFloat|) '(|Field|))
     (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|)))
 (|HasCategory| (|MachineFloat|) '(|CharacteristicNonZero|))
 (|HasCategory| (|MachineFloat|) '(|Finite|))
 (|HasCategory| (|MachineFloat|)
                (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| (|MachineFloat|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|MachineFloat|) '(|TranscendentalFunctionCategory|))
 (AND (|HasCategory| (|MachineFloat|) '(|RadicalCategory|))
      (|HasCategory| (|MachineFloat|) '(|TranscendentalFunctionCategory|)))
 (|HasCategory| (|MachineFloat|) '(|arbitraryPrecision|))
 (|HasCategory| (|MachineFloat|) '(|RealConstant|))
 (|HasCategory| (|MachineFloat|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|MachineFloat|) '(|IntegerNumberSystem|))
 (OR (|HasCategory| (|MachineFloat|) '(|Field|))
     (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|))
     (|HasCategory| (|MachineFloat|) '(|IntegerNumberSystem|)))
 (|HasCategory| (|MachineFloat|) (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|MachineFloat|) '(|DifferentialRing|))
 (|HasCategory| (|MachineFloat|)
                (LIST '|InnerEvalable| '(|Symbol|) '(|MachineFloat|)))
 (|HasCategory| (|MachineFloat|) (LIST '|Evalable| '(|MachineFloat|)))
 (|HasCategory| (|MachineFloat|)
                (LIST '|Eltable| '(|MachineFloat|) '(|MachineFloat|)))
 (|HasCategory| (|MachineFloat|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|MachineFloat|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|MachineFloat|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|MachineFloat|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (OR (|HasCategory| (|MachineFloat|) '(|Field|))
     (|HasCategory| (|MachineFloat|) '(|IntegerNumberSystem|)))
 (OR
  (|HasCategory| (|MachineFloat|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| (|MachineFloat|) '(|Field|)))
 (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
 (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|))
 (OR
  (AND (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
       (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|)))
 (OR
  (AND (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
       (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|MachineFloat|) '(|Field|))
  (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|))
  (|HasCategory| (|MachineFloat|) '(|IntegerNumberSystem|)))
 (OR
  (AND (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
       (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|MachineFloat|) '(|Field|))
  (|HasCategory| (|MachineFloat|) '(|IntegerNumberSystem|)))
 (|HasCategory| (|MachineFloat|) '(|RealNumberSystem|))
 (AND (|HasCategory| (|MachineFloat|) '(|RealNumberSystem|))
      (|HasCategory| (|MachineFloat|) '(|TranscendentalFunctionCategory|)))
 (|HasCategory| (|MachineFloat|) '(|IntegralDomain|))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
       (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|MachineFloat|) '(|CharacteristicNonZero|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|MachineFloat|) '(|EuclideanDomain|))
       (|HasCategory| (|MachineFloat|) '(|PolynomialFactorizationExplicit|)))
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|MachineFloat|) '(|FiniteFieldCategory|))))) 
(|MultiDictionary| S) 
((|constructor|
  (NIL
   "A multi-dictionary is a dictionary which may contain duplicates. As for any dictionary,{} its size is assumed large so that copying (non-destructive) operations are generally to be avoided."))
 (|duplicates|
  (((|List| (|Record| (|:| |entry| |#1|) (|:| |count| (|NonNegativeInteger|))))
    $)
   "\\spad{duplicates(d)} returns a list of values which have duplicates in \\spad{d}"))
 (|removeDuplicates!|
  (($ $)
   "\\spad{removeDuplicates!(d)} destructively removes any duplicate values in dictionary \\spad{d}."))
 (|insert!|
  (($ |#1| $ (|NonNegativeInteger|))
   "\\spad{insert!(x,{} d,{} n)} destructively inserts \\spad{n} copies of \\spad{x} into dictionary \\spad{d}."))) 
NIL 
(|ModularDistinctDegreeFactorizer| U) 
((|constructor|
  (NIL
   "This package supports factorization and gcds of univariate polynomials over the integers modulo different primes. The inputs are given as polynomials over the integers with the prime passed explicitly as an extra argument."))
 (|separateFactors|
  (((|List| |#1|)
    (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|))))
    (|Integer|))
   "\\spad{separateFactors(ddl,{} p)} refines the distinct degree factorization produced by \\spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} to give a complete list of factors."))
 (|ddFact|
  (((|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|)))) |#1|
    (|Integer|))
   "\\spad{ddFact(f,{} p)} computes a distinct degree factorization of the polynomial \\spad{f} modulo the prime \\spad{p},{} \\spadignore{i.e.} such that each factor is a product of irreducibles of the same degrees. The input polynomial \\spad{f} is assumed to be square-free modulo \\spad{p}."))
 (|gcd|
  ((|#1| |#1| |#1| (|Integer|))
   "\\spad{gcd(f1,{} f2,{} p)} computes the \\spad{gcd} of the univariate polynomials \\spad{f1} and \\spad{f2} modulo the integer prime \\spad{p}."))) 
NIL 
(|MeetSemilattice|) 
((|constructor|
  (NIL
   "meet semilattice \\indented{2}{Implementations in set,{} logic and orders} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}}"))
 (|/\\| (($ $ $) "returns the logical 'meet',{} \\spadignore{e.g.} 'and'."))) 
NIL 
(|MeshCreationRoutinesForThreeDimensions|) 
((|constructor|
  (NIL "\\indented{1}{Author: Jim Wen} Keywords: Examples: References:"))
 (|ptFunc|
  (((|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
               (|DoubleFloat|)))
   "\\spad{ptFunc(a,{} b,{} c,{} d)} is an internal function exported in order to compile packages."))
 (|meshPar1Var|
  (((|ThreeSpace| (|DoubleFloat|)) (|Expression| (|Integer|))
    (|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|List| (|DrawOption|)))
   "\\spad{meshPar1Var(s,{} t,{} u,{} f,{} s1,{} l)} \\undocumented"))
 (|meshFun2Var|
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Union|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
                (|DoubleFloat|))
     #1="undefined")
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|List| (|DrawOption|)))
   "\\spad{meshFun2Var(f,{} g,{} s1,{} s2,{} l)} \\undocumented"))
 (|meshPar2Var|
  (((|ThreeSpace| (|DoubleFloat|)) (|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|List| (|DrawOption|)))
   "\\spad{meshPar2Var(sp,{} f,{} s1,{} s2,{} l)} \\undocumented")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|List| (|DrawOption|)))
   "\\spad{meshPar2Var(f,{} s1,{} s2,{} l)} \\undocumented")
  (((|ThreeSpace| (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Union|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
                (|DoubleFloat|))
     #1#)
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|List| (|DrawOption|)))
   "\\spad{meshPar2Var(f,{} g,{} h,{} j,{} s1,{} s2,{} l)} \\undocumented"))) 
NIL 
(|ModularEvaluation1|) 
NIL 
NIL 
(|ModularEvaluation2|) 
NIL 
NIL 
(|ModularEvaluationCategory| PT MP) 
((|constructor|
  (NIL
   "ModularEvaluationCategory(\\spad{PT},{} \\spad{MP}) defines interface \\indented{1}{to evaluation functions for \\spad{ModularAlgebraicGcd2}.}"))
 (|trial_division|
  (((|Boolean|) |#2| (|Polynomial| (|Integer|)) (|List| |#2|) (|Symbol|)
    (|List| (|Symbol|)))
   "\\spad{trial_division(p,{} q,{} lm,{} v,{} lz)} checks if \\spad{p} is divisible by \\spad{q}. \\spad{lm} is a list of defining equations for algebraic parameters,{} \\spad{v} is main variable,{} \\spad{lz} is the list of algebraic parameters."))
 (|subst_vars|
  ((|#2| |#1| (|List| (|Symbol|)) (|List| (|Symbol|)))
   "\\spad{subst_vars(p,{} lv1,{} lv2)} substitutes variables from list \\spad{lv2} for corresponding variables from \\spad{lv1}."))
 (|modpreduction|
  (((|Union| |#2| "failed") |#2| (|Integer|))
   "\\spad{modpreduction(p,{} q)} reduces all coefficients of \\spad{p} modulo \\spad{q}."))
 (|eval1|
  (((|Union| |#2| "failed") |#2| (|Symbol|) (|Integer|)
    (|Record| (|:| |prime| (|Integer|)) (|:| |eval1coeffbuf| (|U32Vector|))
              (|:| |eval1expbuf| (|SortedExponentVector|))))
   "\\spad{eval1(p,{} v,{} r,{} pss)} evaluates \\spad{p} with respect to single variable \\spad{v} at \\spad{r}. \\spad{pss} is global state."))
 (|ldegree|
  (((|NonNegativeInteger|) |#1| (|Symbol|))
   "\\spad{ldegree(p,{} v)} computes degree of \\spad{p} with respect to \\spad{v}. \\spad{v} must be one of auxiliary variables and must be lexicographically first variable which appears in \\spad{p}. Moreover,{} \\spad{p} must be a polynomial in \\spad{v} (not a rational function)."))
 (|degree|
  (((|NonNegativeInteger|) |#2| (|Symbol|))
   "\\spad{degree(p,{} v)} computes degree of \\spad{p} with respect to \\spad{v}."))) 
NIL 
(|MultifunctionGraph| S) 
((|constructor| (NIL "allows us to model graph theory \\blankline"))
 (|toPermutation|
  (((|PermutationGroup| (|NonNegativeInteger|)) $)
   "generates a permutation group from this graph assumes this graph represents a valid group"))
 (|toCayleyGraph|
  (((|MultifunctionGraph| (|String|)) (|PermutationGroup| |#1|))
   "convert PermutationGroup to a Cayley graph")
  (((|MultifunctionGraph| (|String|)) (|List| (|Permutation| |#1|))
    (|Boolean|))
   "convert permutation generators to a Cayley graph permList should contain generator permutations and should not contain identity permutation. if permutationNames then names generated represent permutation"))
 (|coerce|
  (($ (|PermutationGroup| |#1|))
   "\\spad{coerce PermutationGroup} to graph which represents the generators of the group"))
 (~
  (($ $)
   "The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http://en.wikipedia.org/wiki/Complement_graph"))
 (|limit|
  (((|Loop|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "apply 'function' represented by this graph to 'a' repeatedly until we reach a loop which is returned as a sequence of vertex indexes."))
 (|apply|
  (((|NonNegativeInteger|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{apply '}function' represented by this graph to vertex index 'a'"))
 (|contraAdjoint|
  (((|Union| (|List| (|NonNegativeInteger|)) #1="failed") $
    (|List| (|NonNegativeInteger|)))
   "given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph"))
 (|coAdjoint|
  (((|Union| (|List| (|NonNegativeInteger|)) #1#) $
    (|List| (|NonNegativeInteger|)))
   "given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph"))
 (|closedCartesian|
  (($ $ $ (|Mapping| |#1| |#1| |#1|))
   "Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node"))
 (|closedTensor|
  (($ $ $ (|Mapping| |#1| |#1| |#1|)) "as tensor product but returns \\%."))
 (|cartesian|
  (((|MultifunctionGraph| (|Product| |#1| |#1|)) $ $)
   "Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node"))
 (*
  (((|MultifunctionGraph| (|Product| |#1| |#1|)) $ $)
   "tensor product : the tensor product \\spad{G*H} of graphs \\spad{G} and \\spad{H} is a graph such that the vertex set of \\spad{G*H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}); and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) are adjacent in \\spad{G} \\times \\spad{H} if and only if u' is adjacent with \\spad{v'} and \\spad{u} is adjacent with \\spad{v}."))
 (|multifunctionGraph|
  (($ (|List| (|Permutation| |#1|)))
   "construct graph from a list of permutations.")
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "constructor for graph with given objects and adjacency matrix.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "constructor for graph with given objects and arrows more objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))
               (|:| |next| (|List| (|NonNegativeInteger|)))
               (|:| |map| (|List| (|List| (|NonNegativeInteger|)))))))
   "constructor for graph with given objects more objects and arrows can be added later if required.")
  (($ (|List| |#1|))
   "constructor for graph with given list of object names. Use this version of the constructor if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates. more objects and arrows can be added later if required."))) 
NIL 
(|MultFiniteFactorize| OV E F PG) 
((|constructor|
  (NIL
   "Package for factorization of multivariate polynomials over finite fields."))
 (|factor|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{factor(p)} produces the complete factorization of the multivariate polynomial \\spad{p} over a finite field. \\spad{p} is represented as a univariate polynomial with multivariate coefficients over a finite field.")
  (((|Factored| |#4|) |#4|)
   "\\spad{factor(p)} produces the complete factorization of the multivariate polynomial \\spad{p} over a finite field."))) 
NIL 
(|MachineFloat|) 
((|constructor|
  (NIL
   "A domain which models the floating point representation used by machines in the AXIOM-NAG link."))
 (|changeBase|
  (($ (|Integer|) (|Integer|) (|PositiveInteger|))
   "\\spad{changeBase(exp,{} man,{} base)} \\undocumented{}"))
 (|exponent|
  (((|Integer|) $) "\\spad{exponent(u)} returns the exponent of \\spad{u}"))
 (|mantissa|
  (((|Integer|) $) "\\spad{mantissa(u)} returns the mantissa of \\spad{u}"))
 (|coerce|
  (($ (|MachineInteger|))
   "\\spad{coerce(u)} transforms a MachineInteger into a MachineFloat")
  (((|Float|) $)
   "\\spad{coerce(u)} transforms a MachineFloat to a standard Float"))
 (|minimumExponent|
  (((|Integer|))
   "\\spad{minimumExponent()} returns the minimum exponent in the model")
  (((|Integer|) (|Integer|))
   "\\spad{minimumExponent(e)} sets the minimum exponent in the model to \\spad{e}"))
 (|maximumExponent|
  (((|Integer|))
   "\\spad{maximumExponent()} returns the maximum exponent in the model")
  (((|Integer|) (|Integer|))
   "\\spad{maximumExponent(e)} sets the maximum exponent in the model to \\spad{e}"))
 (|base| (((|PositiveInteger|)) "\\spad{base()} returns the base of the model")
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{base(b)} sets the base of the model to \\spad{b}"))
 (|precision|
  (((|PositiveInteger|))
   "\\spad{precision()} returns the number of digits in the model")
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{precision(p)} sets the number of digits in the model to \\spad{p}"))) 
((|HasCategory| $ '(|arbitraryPrecision|))
 (AND (|not| (|HasCategory| $ '(|arbitraryExponent|)))
      (|not| (|HasCategory| $ '(|arbitraryPrecision|))))) 
(|ModularHermitianRowReduction| R) 
((|constructor|
  (NIL
   "\\indented{1}{Modular hermitian row reduction.} Author: Manuel Bronstein Date Created: 22 February 1989 Keywords: matrix,{} reduction."))
 (|normalizedDivide|
  (((|Record| (|:| |quotient| |#1|) (|:| |remainder| |#1|)) |#1| |#1|)
   "\\spad{normalizedDivide(n,{} d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \\spadignore{e.g.} positive remainders"))
 (|rowEchelonLocal|
  (((|Matrix| |#1|) (|Matrix| |#1|) |#1| |#1|)
   "\\spad{rowEchelonLocal(m,{} d,{} p)} computes the row-echelon form of \\spad{m} concatenated with \\spad{d} times the identity matrix over a local ring where \\spad{p} is the only prime."))
 (|rowEchLocal|
  (((|Matrix| |#1|) (|Matrix| |#1|) |#1|)
   "\\spad{rowEchLocal(m,{} p)} computes a modular row-echelon form of \\spad{m},{} finding an appropriate modulus over a local ring where \\spad{p} is the only prime."))
 (|rowEchelon|
  (((|Matrix| |#1|) (|Matrix| |#1|) |#1|)
   "\\spad{rowEchelon(m,{} d)} computes a modular row-echelon form mod \\spad{d} of \\indented{3}{[\\spad{d}\\space{5}]} \\indented{3}{[\\space{2}\\spad{d}\\space{3}]} \\indented{3}{[\\space{4}. ]} \\indented{3}{[\\space{5}\\spad{d}]} \\indented{3}{[\\space{3}\\spad{M}\\space{2}]} where \\spad{M = m mod d}."))
 (|rowEch|
  (((|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{rowEch(m)} computes a modular row-echelon form of \\spad{m},{} finding an appropriate modulus."))) 
NIL 
(|MachineInteger|) 
((|constructor|
  (NIL
   "A domain which models the integer representation used by machines in the AXIOM-NAG link."))
 (|coerce|
  (((|Expression| $) (|Expression| (|Integer|)))
   "\\spad{coerce(x)} returns \\spad{x} with coefficients in the domain"))
 (|maxint|
  (((|PositiveInteger|))
   "\\spad{maxint()} returns the maximum integer in the model")
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{maxint(u)} sets the maximum integer in the model to \\spad{u}"))) 
NIL 
(|MakeBinaryCompiledFunction| S D1 D2 I) 
((|constructor| (NIL "transforms top-level objects into compiled functions."))
 (|compiledFunction|
  (((|Mapping| |#4| |#2| |#3|) |#1| (|Symbol|) (|Symbol|))
   "\\spad{compiledFunction(expr,{} x,{} y)} returns a function \\spad{f: (D1,{} D2) -> I} defined by \\spad{f(x,{} y) == expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spad{(D1,{} D2)}"))
 (|binaryFunction|
  (((|Mapping| |#4| |#2| |#3|) (|Symbol|))
   "\\spad{binaryFunction(s)} is a local function"))) 
NIL 
(|MakeCachableSet| S) 
((|constructor|
  (NIL
   "MakeCachableSet(\\spad{S}) returns a cachable set which is equal to \\spad{S} as a set."))
 (|coerce|
  (($ |#1|)
   "\\spad{coerce(s)} returns \\spad{s} viewed as an element of \\%."))) 
NIL 
(|MakeFloatCompiledFunction| S) 
((|constructor|
  (NIL
   "MakeFloatCompiledFunction transforms top-level objects into compiled Lisp functions whose arguments are Lisp floats. This by-passes the \\Language{} compiler and interpreter,{} thereby gaining several orders of magnitude."))
 (|makeFloatFunction|
  (((|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) |#1| (|Symbol|)
    (|Symbol|))
   "\\spad{makeFloatFunction(expr,{} x,{} y)} returns a Lisp function \\spad{f}: (\\spadtype{DoubleFloat},{} \\spadtype{DoubleFloat}) \\spad{->} \\spadtype{DoubleFloat} defined by \\spad{f(x,{} y) == expr}. Function \\spad{f} is compiled and directly applicable to objects of type (\\spadtype{DoubleFloat},{} \\spadtype{DoubleFloat}).")
  (((|Mapping| (|DoubleFloat|) (|DoubleFloat|)) |#1| (|Symbol|))
   "\\spad{makeFloatFunction(expr,{} x)} returns a Lisp function \\spad{f}: \\spadtype{DoubleFloat} \\spad{->} \\spadtype{DoubleFloat} defined by \\spad{f(x) == expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spadtype{DoubleFloat}."))) 
NIL 
(|MakeFunction| S) 
((|constructor|
  (NIL "transforms top-level objects into interpreter functions."))
 (|function|
  (((|Symbol|) |#1| (|Symbol|) (|List| (|Symbol|)))
   "\\spad{function(e,{} foo,{} [x1,{} ...,{} xn])} creates a function \\spad{foo(x1,{} ...,{} xn) == e}.")
  (((|Symbol|) |#1| (|Symbol|) (|Symbol|) (|Symbol|))
   "\\spad{function(e,{} foo,{} x,{} y)} creates a function \\spad{foo(x,{} y) = e}.")
  (((|Symbol|) |#1| (|Symbol|) (|Symbol|))
   "\\spad{function(e,{} foo,{} x)} creates a function \\spad{foo(x) == e}.")
  (((|Symbol|) |#1| (|Symbol|))
   "\\spad{function(e,{} foo)} creates a function \\spad{foo() == e}."))) 
NIL 
(|MakeRecord| S T$) 
((|constructor|
  (NIL
   "MakeRecord is used internally by the interpreter to create record types which are used for doing parallel iterations on streams."))
 (|makeRecord|
  (((|Record| (|:| |part1| |#1|) (|:| |part2| |#2|)) |#1| |#2|)
   "\\spad{makeRecord(a,{} b)} creates a record object with type Record(\\spad{part1} : \\spad{S},{} \\spad{part2} : \\spad{T}),{} where \\spad{part1} is \\spad{a} and \\spad{part2} is \\spad{b}."))) 
NIL 
(|MakeUnaryCompiledFunction| S D I) 
((|constructor| (NIL "transforms top-level objects into compiled functions."))
 (|compiledFunction|
  (((|Mapping| |#3| |#2|) |#1| (|Symbol|))
   "\\spad{compiledFunction(expr,{} x)} returns a function \\spad{f: D -> I} defined by \\spad{f(x) == expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spad{D}."))
 (|unaryFunction|
  (((|Mapping| |#3| |#2|) (|Symbol|))
   "\\spad{unaryFunction(a)} is a local function"))) 
NIL 
(|MultivariateLifting| E OV R P) 
((|constructor|
  (NIL
   "This package provides the functions for the multivariate \"lifting\",{} using an algorithm of Paul Wang. This package will work for every euclidean domain \\spad{R} which has property \\spad{F},{} \\spadignore{i.e.} there exists a factor operation in \\spad{R[x]}."))
 (|lifting|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|SparseUnivariatePolynomial| |#4|) (|List| |#2|)
    (|List| (|SparseUnivariatePolynomial| |#3|)) (|List| |#3|) (|List| |#4|)
    (|List| (|NonNegativeInteger|)) |#3|)
   "\\spad{lifting(u,{} lv,{} lu,{} lr,{} lp,{} ln,{} r)} is lifting(\\spad{u},{} \\spad{lv},{} \\spad{lu},{} \\spad{lr},{} \\spad{lp},{} \\spad{ln},{} solv(\\spad{r})) where solv(\\spad{r}) is solver using reduction modulo \\spad{r} and lifting. Memberes of \\spad{lu} must be relatively prime modulo \\spad{r}")
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|SparseUnivariatePolynomial| |#4|) (|List| |#2|)
    (|List| (|SparseUnivariatePolynomial| |#3|)) (|List| |#3|) (|List| |#4|)
    (|List| (|NonNegativeInteger|))
    (|Mapping|
     (|Union|
      (|Mapping|
       (|Union| (|List| (|SparseUnivariatePolynomial| |#3|)) #1="failed")
       (|SparseUnivariatePolynomial| |#3|))
      "failed")
     (|List| (|SparseUnivariatePolynomial| |#3|))))
   "\\spad{lifting(u,{} lv,{} lu,{} lr,{} lp,{} ln,{} gen_solv)} lifts univariate factorization,{} returning recovered factors or \"failed\" in case of bad reduction. \\spad{u} is multivariate polynomial to factor,{} \\spad{lu} is list of univariate factors,{} \\spad{lv} is list of variables,{} \\spad{ln} is list of degrees corresponding to variables,{} \\spad{lr} is list of evaluation points,{} \\spad{lp} is list of leading coefficients of factors if known,{} empty otherwise,{} gen_solv delivers solver for polynomial equations"))
 (|corrPoly|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| |#3|)
    (|List| (|NonNegativeInteger|))
    (|List| (|SparseUnivariatePolynomial| |#4|))
    (|Mapping| (|Union| (|List| (|SparseUnivariatePolynomial| |#3|)) #1#)
               (|SparseUnivariatePolynomial| |#3|)))
   "\\spad{corrPoly(u,{} lv,{} lr,{} ln,{} lu,{} bsolv)} solves polynomial equation system u/f = sum(ai/lu(\\spad{i})) where \\spad{f} is product of \\spad{lu}(\\spad{i}) and deg(\\spad{ai}) < deg(\\spad{lu}(\\spad{i})) using modular method. corrPoly returns \"failed\" if there are no solution. \\spad{lv} is list of variables,{} \\spad{lr} is list of corresponding evaluation points,{} bsolv is solver over \\spad{R} specialized for modular images of \\spad{lu}."))) 
((|HasCategory| |#3| '(|EuclideanDomain|))) 
(|MultipleMap| R1 UP1 UPUP1 R2 UP2 UPUP2) 
((|constructor| (NIL "Lifting of a map through 2 levels of polynomials."))
 (|map|
  ((|#6| (|Mapping| |#4| |#1|) |#3|)
   "\\spad{map(f,{} p)} lifts \\spad{f} to the domain of \\spad{p} then applies it to \\spad{p}."))) 
NIL 
(|MathMLFormat|) 
((|constructor|
  (NIL
   "\\spadtype{MathMLFormat} provides a coercion from \\spadtype{OutputForm} to MathML format."))
 (|display|
  (((|Void|) (|String|))
   "prints the string returned by coerce,{} adding <math ...> tags."))
 (|coerceL|
  (((|String|) (|OutputForm|))
   "\\spad{coerceL(o)} changes \\spad{o} in the standard output format to MathML format and displays result as one long string."))
 (|coerceS|
  (((|String|) (|OutputForm|))
   "\\spad{coerceS(o)} changes \\spad{o} in the standard output format to MathML format and displays formatted result."))
 (|coerce|
  (((|String|) (|OutputForm|))
   "\\spad{coerce(o)} changes \\spad{o} in the standard output format to MathML format."))) 
NIL 
(|ModularFactorization|) 
((|constructor|
  (NIL
   "This package implements factorization of polynomials over \\spad{Z_p} using a variant of Kaltofen-Shoup method."))
 (|red_pol|
  (((|Void|) (|U32Vector|)
    (|List|
     (|Record| (|:| |ind| (|NonNegativeInteger|)) (|:| |poly| (|U32Vector|)))))
   "\\spad{red_pol(pv,{} rd)} computes remainder of \\spad{pv} using reduction data \\spad{rd} produced by earlier call to \\spad{ini_rdata}."))
 (|ini_rdata|
  (((|List|
     (|Record| (|:| |ind| (|NonNegativeInteger|)) (|:| |poly| (|U32Vector|))))
    (|U32Vector|) (|Integer|))
   "\\spad{ini_rdata(pv,{} p)} generates data allowing faster computation of remainders from division by \\spad{pv} modulo \\spad{p}. Result is used by other function in this package,{} in particular \\spad{red_pol}."))
 (|modular_compose|
  (((|U32Vector|) (|U32Vector|) (|U32Matrix|) (|U32Vector|)
    (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|List|
     (|Record| (|:| |ind| (|NonNegativeInteger|)) (|:| |poly| (|U32Vector|)))))
   "\\spad{modular_compose(pol,{} pm,{} p1,{} l1,{} l2,{} rd)} computes composion of \\spad{pol} with \\spad{p0} modulo reduction data \\spad{rd}. \\spad{pm} and \\spad{p1} are as from call to \\spad{power_matrix(p0,{} l1,{} rd)}. \\spad{l2} must be such that \\spad{l1*l2} is bigger or equal to degree from \\spad{rd}."))
 (|power_matrix|
  (((|Record| (|:| |matr| (|U32Matrix|)) (|:| |poly| (|U32Vector|)))
    (|U32Vector|) (|NonNegativeInteger|)
    (|List|
     (|Record| (|:| |ind| (|NonNegativeInteger|)) (|:| |poly| (|U32Vector|)))))
   "\\spad{power_matrix(s,{} l,{} rd)} computes [\\spad{m},{} \\spad{p}] such that \\spad{p = s^l} modulo reduction data \\spad{rd} and column \\spad{j} of \\spad{m} contain \\spad{s^j} modulo reduction data \\spad{rd}. Note that lowest column index is \\spad{j = 0} and highest index is \\spad{j=l-1}. \\spad{rd} should be obtained by earlier call to \\spad{ini_rdata}."))
 (|mod_exp|
  (((|U32Vector|) (|U32Vector|) (|Integer|)
    (|List|
     (|Record| (|:| |ind| (|NonNegativeInteger|)) (|:| |poly| (|U32Vector|)))))
   "\\spad{mod_exp(pv,{} d,{} rd)} computes \\spad{pv^d} modulo reduction data in \\spad{rd}."))
 (|mmul|
  (((|U32Matrix|) (|U32Matrix|) (|U32Matrix|) (|Integer|))
   "\\spad{mmul(m1,{} m2,{} p)} multiplies \\spad{m1} by transpose of \\spad{m2} modulo \\spad{p}."))
 (|ddfact|
  (((|List|
     (|Record| (|:| |poly| (|U32Vector|)) (|:| |degree| (|NonNegativeInteger|))
               (|:| |separate_factors| (|Mapping| (|List| (|U32Vector|))))))
    (|U32Vector|) (|Integer|))
   "\\spad{ddfact(pv,{} p)} computes distint degree factorization of \\spad{pv}. \\spad{pv} is assumed square-free,{} \\spad{p} is assumed prime."))
 (|mfactor|
  (((|List| (|U32Vector|)) (|U32Vector|) (|Integer|))
   "\\spad{mfactor(pv,{} p)} computes factorization of \\spad{pv} into irreducibles modulo \\spad{p}. \\spad{pv} is assumed square-free,{} \\spad{p} is assumed prime."))) 
NIL 
(|ModularField| R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor|
  (NIL
   "\\indented{1}{These domains are used for the factorization and gcds} of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{ModularRing},{} \\spadtype{EuclideanModularRing}"))
 (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,{} y)} \\undocumented"))
 (|reduce| (($ |#1| |#2|) "\\spad{reduce(r,{} m)} \\undocumented"))
 (|coerce| ((|#1| $) "\\spad{coerce(x)} \\undocumented"))
 (|modulus| ((|#2| $) "\\spad{modulus(x)} \\undocumented"))) 
NIL 
(|ModularHermitePade|) 
((|constructor|
  (NIL
   "This package provides modular Hermite-Pade solvers \\indented{1}{for a few rings.\\space{2}Solver over integers is implemented in this} \\indented{1}{package.\\space{2}Also it contains interfaces to solver over \\$\\spad{Z_p}\\$ and} \\indented{1}{solver over ring of integer polynomials.}"))
 (|unpack_poly|
  (((|SparseUnivariatePolynomial| (|Polynomial| (|Integer|)))
    (|List| (|Symbol|)) (|SortedExponentVector|) (|PrimitiveArray| (|Integer|))
    (|Integer|) (|Integer|))
   "\\spad{unpack_poly(vars,{} exps,{} coeffs,{} lo,{} \\spad{hi})} converts polynomial from packed to sparse representation. Coefficients of packed polynomial are stored in \\spad{coeffs}(\\spad{l0}) up to \\spad{coeffs}(\\spad{hi}) Exponents are stored in corresponding elements of \\spad{exps}."))
 (|LLFPI_to_LPA|
  (((|Union| (|List| (|U32Vector|)) "failed")
    (|List| (|List| (|Fraction| (|Polynomial| (|Integer|))))) (|Integer|)
    (|List| (|Symbol|)) (|List| (|Integer|)) (|Integer|))
   "evaluation routine"))
 (|LLFI_to_LPA|
  (((|Union| (|List| (|U32Vector|)) "failed")
    (|List| (|List| (|Fraction| (|Integer|)))) (|Integer|) (|Integer|))
   "evaluation routine"))
 (|VSUPPI_to_VPA|
  (((|Vector| (|U32Vector|))
    (|Vector| (|SparseUnivariatePolynomial| (|Polynomial| (|Integer|))))
    (|List| (|Symbol|)) (|List| (|Integer|)) (|Integer|))
   "evaluation routine"))
 (|VSUPI_to_VPA|
  (((|Vector| (|U32Vector|))
    (|Vector| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|))
   "evaluation routine"))
 (|check_sol1a|
  (((|U32Vector|) (|Vector| (|U32Vector|)) (|List| (|U32Vector|))
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Integer|) (|Integer|) (|Integer|))
   "one round of modular Monte Carlo check for solutions."))
 (|HP_solve_M|
  (((|Union| (|Matrix| (|SparseUnivariatePolynomial| (|Integer|))) (|Boolean|))
    (|List| (|List| (|Integer|))) (|List| (|Integer|)) (|Symbol|) (|Integer|)
    (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1="good" #2="reject" #3="no_solution")
               (|List| (|SparseUnivariatePolynomial| (|Integer|)))))
   "implements HP_solve over \\$\\spad{Z_p}\\$ with machine-sized \\$\\spad{p}\\$."))
 (|HP_solve_PA|
  (((|Union|
     (|Matrix|
      (|SparseUnivariatePolynomial| (|Polynomial| (|AlgebraicNumber|))))
     (|Boolean|))
    (|List| (|List| (|Fraction| (|Polynomial| (|AlgebraicNumber|)))))
    (|List| (|Integer|)) (|Symbol|) (|Symbol|) (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List|
                (|SparseUnivariatePolynomial|
                 (|Polynomial| (|AlgebraicNumber|))))))
   "Fake solver over polynomials having algebraic coefficients."))
 (|HP_solve_P|
  (((|Union|
     (|Matrix| (|SparseUnivariatePolynomial| (|Polynomial| (|Integer|))))
     (|Boolean|))
    (|List| (|List| (|Fraction| (|Polynomial| (|Integer|)))))
    (|List| (|Integer|)) (|Symbol|) (|Symbol|) (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List|
                (|SparseUnivariatePolynomial| (|Polynomial| (|Integer|))))))
   "implements HP_solve over integer polynomials."))
 (|HP_solve_A|
  (((|Union| (|Matrix| (|SparseUnivariatePolynomial| (|AlgebraicNumber|)))
             (|Boolean|))
    (|List| (|List| (|AlgebraicNumber|))) (|List| (|Integer|)) (|Symbol|)
    (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List| (|SparseUnivariatePolynomial| (|AlgebraicNumber|)))))
   "Fake solver over algebraic numbers."))
 (|HP_solve_I|
  (((|Union| (|Matrix| (|SparseUnivariatePolynomial| (|Integer|))) (|Boolean|))
    (|List| (|List| (|Fraction| (|Integer|)))) (|List| (|Integer|)) (|Symbol|)
    (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List| (|SparseUnivariatePolynomial| (|Integer|)))))
   "implements HP_solve over integers."))) 
NIL 
(|ModularHermitePadeSolver| F S) 
((|constructor|
  (NIL
   "This package provides generic interface to modular \\indented{1}{Hermite-Pade solver.}"))
 (|VSUPS_to_VPA|
  (((|Vector| (|U32Vector|)) (|Vector| (|SparseUnivariatePolynomial| |#2|))
    (|List| (|Symbol|)) (|List| (|Integer|)) (|Integer|))
   "modular reduction"))
 (|LLF_to_LPA|
  (((|Union| (|List| (|U32Vector|)) "failed") (|List| (|List| |#1|))
    (|Integer|) (|List| (|Symbol|)) (|List| (|Integer|)) (|Integer|))
   "modular reduction"))
 (|gen_Monte_Carlo_check|
  (((|Mapping| (|Union| #1="good" #2="reject" #3="no_solution")
               (|List| (|SparseUnivariatePolynomial| |#2|)))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List| (|SparseUnivariatePolynomial| |#2|)))
    (|List| (|List| |#1|)) (|Symbol|) (|Symbol|) (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|)))
   "\\spad{gen_Monte_Carlo_check(check,{} l,{} kind,{} qvar,{} sigma,{} gen)} returns Monte Carlo \\spad{check} for solutions to guessing problem. If Monte Carlo \\spad{check} is unavailable returns \\spad{check}."))
 (|HP_solve|
  (((|Union| (|Matrix| (|SparseUnivariatePolynomial| |#2|)) (|Boolean|))
    (|List| (|List| |#1|)) (|List| (|Integer|)) (|Symbol|) (|Symbol|)
    (|NonNegativeInteger|)
    (|Mapping| (|Vector| (|U32Vector|)) (|List| (|U32Vector|)) (|Integer|)
               (|Integer|))
    (|Mapping| (|Union| #1# #2# #3#)
               (|List| (|SparseUnivariatePolynomial| |#2|))))
   "\\spad{HP_solve(l,{} degs,{} kind,{} sigma,{} gen check)} finds a \\spad{sigma} basis with degree bounds given by \\spad{degs}. It returns \\spad{false} if there is no interpolating vector that is correct up to (and including) \\spad{z^}(\\spad{sigma}-1) with \\spad{sigma} \\spad{>=} |degs+[1,{} 1,{} ...,{} 1]| or if check rejects all solutions. It returns \\spad{true} if it can not handle given problem."))) 
NIL 
(|ModMonic| R |Rep|) 
((|constructor| (NIL "This package \\undocumented"))
 (|frobenius|
  (($ $)
   "\\spad{frobenius(x)} computes \\spad{x^q} where \\spad{q} is the size of \\spad{R}"))
 (|computePowers|
  (((|PrimitiveArray| $)) "\\spad{computePowers()} \\undocumented"))
 (|pow| (((|PrimitiveArray| $)) "\\spad{pow()} \\undocumented"))
 (|An| (((|Vector| |#1|) $) "\\spad{An(x)} \\undocumented"))
 (|UnVectorise| (($ (|Vector| |#1|)) "\\spad{UnVectorise(v)} \\undocumented"))
 (|Vectorise| (((|Vector| |#1|) $) "\\spad{Vectorise(x)} \\undocumented"))
 (|coerce| (($ |#2|) "\\spad{coerce(x)} \\undocumented"))
 (|lift| ((|#2| $) "\\spad{lift(x)} \\undocumented"))
 (|reduce| (($ |#2|) "\\spad{reduce(x)} \\undocumented"))
 (|modulus| ((|#2|) "\\spad{modulus()} \\undocumented"))
 (|setPoly| ((|#2| |#2|) "\\spad{setPoly(x)} \\undocumented"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|EntireRing|))
 (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|StepThrough|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|Finite|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| '(|InputForm|))))
  (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|SingletonAsOrderedSet|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#1| '(|FiniteFieldCategory|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|FiniteFieldCategory|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|FiniteFieldCategory|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|FiniteFieldCategory|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|FiniteFieldCategory|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|FiniteFieldCategory|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|FiniteFieldCategory|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|ModuleMonomial| IS E |ff|) 
((|constructor| (NIL "This package \\undocumented"))
 (|construct| (($ |#1| |#2|) "\\spad{construct(i,{} e)} \\undocumented"))
 (|coerce|
  (((|Record| (|:| |index| |#1|) (|:| |exponent| |#2|)) $)
   "\\spad{coerce(x)} \\undocumented")
  (($ (|Record| (|:| |index| |#1|) (|:| |exponent| |#2|)))
   "\\spad{coerce(x)} \\undocumented"))
 (|index| ((|#1| $) "\\spad{index(x)} \\undocumented"))
 (|exponent| ((|#2| $) "\\spad{exponent(x)} \\undocumented"))) 
NIL 
(|ModuleOperator| R M) 
((|constructor| (NIL "Algebra of ADDITIVE operators on a module."))
 (|makeop|
  (($ |#1| (|FreeGroup| (|BasicOperator|)))
   "\\spad{makeop should} be local but conditional"))
 (|opeval|
  ((|#2| (|BasicOperator|) |#2|)
   "\\spad{opeval should} be local but conditional"))
 (^ (($ $ (|Integer|)) "\\spad{op^n} \\undocumented"))
 (|evaluateInverse|
  (($ $ (|Mapping| |#2| |#2|))
   "\\spad{evaluateInverse(x,{} f)} \\undocumented"))
 (|evaluate|
  (($ $ (|Mapping| |#2| |#2|))
   "\\spad{evaluate(f,{} u +-> g u)} attaches the map \\spad{g} to \\spad{f}. \\spad{f} must be a basic operator \\spad{g} MUST be additive,{} \\spadignore{i.e.} \\spad{g(a + b) = g(a) + g(b)} for any \\spad{a},{} \\spad{b} in \\spad{M}. This implies that \\spad{g(n a) = n g(a)} for any \\spad{a} in \\spad{M} and integer \\spad{n > 0}."))
 (|conjug| ((|#1| |#1|) "\\spad{conjug(x)}should be local but conditional"))
 (|adjoint|
  (($ $ $)
   "\\spad{adjoint(op1,{} op2)} sets the adjoint of \\spad{op1} to be \\spad{op2}. \\spad{op1} must be a basic operator")
  (($ $)
   "\\spad{adjoint(op)} returns the adjoint of the operator \\spad{op}."))) 
((|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))) 
(|ModularRing| R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor|
  (NIL
   "These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{EuclideanModularRing} ,{} \\spadtype{ModularField}"))
 (|inv| (($ $) "\\spad{inv(x)} \\undocumented"))
 (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} \\undocumented"))
 (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,{} y)} \\undocumented"))
 (|reduce| (($ |#1| |#2|) "\\spad{reduce(r,{} m)} \\undocumented"))
 (|coerce| ((|#1| $) "\\spad{coerce(x)} \\undocumented"))
 (|modulus| ((|#2| $) "\\spad{modulus(x)} \\undocumented"))) 
NIL 
(|Module&| S R) 
((|constructor|
  (NIL "The category of modules over a commutative ring. \\blankline"))) 
NIL 
(|Module| R) 
((|constructor|
  (NIL "The category of modules over a commutative ring. \\blankline"))) 
NIL 
(|MoebiusTransform| F) 
((|constructor|
  (NIL
   "\\indented{1}{MoebiusTransform(\\spad{F}) is the domain of fractional linear (Moebius)} transformations over \\spad{F}."))
 (|eval|
  (((|OnePointCompletion| |#1|) $ (|OnePointCompletion| |#1|))
   "\\spad{eval(m,{} x)} returns \\spad{(a*x + b)/(c*x + d)} where \\spad{m = moebius(a,{} b,{} c,{} d)} (see \\spadfunFrom{moebius}{MoebiusTransform}).")
  ((|#1| $ |#1|)
   "\\spad{eval(m,{} x)} returns \\spad{(a*x + b)/(c*x + d)} where \\spad{m = moebius(a,{} b,{} c,{} d)} (see \\spadfunFrom{moebius}{MoebiusTransform})."))
 (|recip| (($ $) "\\spad{recip(m)} = recip() * \\spad{m}")
  (($)
   "\\spad{recip()} returns \\spad{matrix [[0,{} 1],{} [1,{} 0]]} representing the map \\spad{x -> 1 / x}."))
 (|scale|
  (($ $ |#1|)
   "\\spad{scale(m,{} h)} returns \\spad{scale(h) * m} (see \\spadfunFrom{shift}{MoebiusTransform}).")
  (($ |#1|)
   "\\spad{scale(k)} returns \\spad{matrix [[k,{} 0],{} [0,{} 1]]} representing the map \\spad{x -> k * x}."))
 (|shift|
  (($ $ |#1|)
   "\\spad{shift(m,{} h)} returns \\spad{shift(h) * m} (see \\spadfunFrom{shift}{MoebiusTransform}).")
  (($ |#1|)
   "\\spad{shift(k)} returns \\spad{matrix [[1,{} k],{} [0,{} 1]]} representing the map \\spad{x -> x + k}."))
 (|moebius|
  (($ |#1| |#1| |#1| |#1|)
   "\\spad{moebius(a,{} b,{} c,{} d)} returns \\spad{matrix [[a,{} b],{} [c,{} d]]}."))) 
NIL 
(|MomentPackage| R) 
((|constructor|
  (NIL
   "An auxiliary package for various moment and cumulant transformations used in \\spad{Distribution}."))
 (|moment2Stransform|
  (((|Record| (|:| |puiseux| (|Fraction| (|Integer|)))
              (|:| |laurent| (|Fraction| (|Integer|)))
              (|:| |coef| (|Sequence| |#1|)))
    (|Sequence| |#1|))
   "\\spad{moment2Stransform(x)} returns the Puiseux and Laurent order and coefficients of the \\spad{S} transform of \\spad{x}"))
 (|jacobi2poly|
  (((|Stream| (|SparseUnivariatePolynomial| |#1|)) (|Stream| |#1|)
    (|Stream| |#1|))
   "\\spad{jacobi2poly(aa,{} bb)} returns the stream of orthogonal polynomials corresponding to the Jacobi parameters \\spad{a_n} and \\spad{b_n}."))
 (|hankelDeterminant|
  ((|#1| (|Sequence| |#1|) (|NonNegativeInteger|))
   "\\spad{hankelDeterminant(x,{} n)} returns the \\spad{n}th Hankel determinant of the sequence \\spad{x}."))
 (|moment2monotoneCumulant|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{moment2monotoneCumulant(x)} returns the sequence of monotone cumulants of the moment sequence \\spad{x}")
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{moment2monotoneCumulant(mm)} computes the sequence of monotone cumulants from the sequence of moments \\spad{mm}"))
 (|monotoneCumulant2momentPoly|
  (((|Sequence| (|SparseUnivariatePolynomial| |#1|)) (|Sequence| |#1|))
   "\\spad{monotoneCumulant2momentPoly(hh)} computes the sequence of moment polynomials \\$\\spad{m_n}(\\spad{t})\\$ from the sequence of monotone cumulants \\spad{hh}"))
 (|monotoneCumulant2moment|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{monotoneCumulant2moment(hh)} computes the sequence of moments from the sequence of monotone cumulants \\spad{hh}"))
 (|moment2booleanCumulant|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{moment2booleanCumulant(mm)} computes the sequence of boolean cumulants from the sequence of moments \\spad{mm}"))
 (|booleanCumulant2moment|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{booleanCumulant2moment(cc)} computes the sequence of moments from the sequence of boolean cumulants \\spad{cc}"))
 (|moment2freeCumulant|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{moment2freeCumulant(mm)} computes the sequence of free cumulants from the sequence of moments \\spad{mm}"))
 (|freeCumulant2moment|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{freeCumulant2moment(cc)} computes the sequence of moments from the sequence of free cumulants \\spad{cc}"))
 (|moment2jacobi2|
  (((|Stream| (|Record| (|:| |an| |#1|) (|:| |bn| |#1|))) (|Sequence| |#1|))
   "\\spad{moment2jacobi2(mm)} computes the Jacobi parameters as stream of pairs \\$(an,{} \\spad{bn})\\$."))
 (|moment2jacobi|
  (((|Record| (|:| |an| (|Stream| |#1|)) (|:| |bn| (|Stream| |#1|)))
    (|Sequence| |#1|))
   "\\spad{moment2jacobi(mm)} computes the Jacobi parameters as pair of streams."))
 (|moment2nthJacobi|
  (((|Record| (|:| |an| (|List| |#1|)) (|:| |bn| (|List| |#1|))) (|List| |#1|))
   "\\spad{moment2nthJacobi(mm)} computes the list of Jacobi parameters from the list of moments \\spad{mm} as far as possible."))
 (|moment2cumulant|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{moment2cumulant(mm)} computes the sequence of classical cumulants from the sequence of moments \\spad{mm}"))
 (|cumulant2moment|
  (((|Sequence| |#1|) (|Sequence| |#1|))
   "\\spad{cumulant2moment(cc)} computes the sequence of moments from the sequence of classical cumulants \\spad{cc}"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))) 
(|MonogenicAlgebra&| S R UP) 
((|constructor|
  (NIL
   "A \\spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element."))
 (|derivationCoordinates|
  (((|Matrix| |#2|) (|Vector| $) (|Mapping| |#2| |#2|))
   "\\spad{derivationCoordinates(b,{} ')} returns \\spad{M} such that \\spad{b' = M b}."))
 (|lift|
  ((|#3| $)
   "\\spad{lift(z)} returns a minimal degree univariate polynomial up such that \\spad{z=reduce up}."))
 (|convert|
  (($ |#3|)
   "\\spad{convert(up)} converts the univariate polynomial \\spad{up} to an algebra element,{} reducing by the \\spad{definingPolynomial()} if necessary."))
 (|reduce|
  (((|Union| $ "failed") (|Fraction| |#3|))
   "\\spad{reduce(frac)} converts the fraction \\spad{frac} to an algebra element.")
  (($ |#3|)
   "\\spad{reduce(up)} converts the univariate polynomial \\spad{up} to an algebra element,{} reducing by the \\spad{definingPolynomial()} if necessary."))
 (|definingPolynomial|
  ((|#3|)
   "\\spad{definingPolynomial()} returns the minimal polynomial which \\spad{generator()} satisfies."))
 (|generator|
  (($) "\\spad{generator()} returns the generator for this domain."))) 
((|HasCategory| |#2| '(|FiniteFieldCategory|)) (|HasCategory| |#2| '(|Field|))) 
(|MonogenicAlgebra| R UP) 
((|constructor|
  (NIL
   "A \\spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element."))
 (|derivationCoordinates|
  (((|Matrix| |#1|) (|Vector| $) (|Mapping| |#1| |#1|))
   "\\spad{derivationCoordinates(b,{} ')} returns \\spad{M} such that \\spad{b' = M b}."))
 (|lift|
  ((|#2| $)
   "\\spad{lift(z)} returns a minimal degree univariate polynomial up such that \\spad{z=reduce up}."))
 (|convert|
  (($ |#2|)
   "\\spad{convert(up)} converts the univariate polynomial \\spad{up} to an algebra element,{} reducing by the \\spad{definingPolynomial()} if necessary."))
 (|reduce|
  (((|Union| $ "failed") (|Fraction| |#2|))
   "\\spad{reduce(frac)} converts the fraction \\spad{frac} to an algebra element.")
  (($ |#2|)
   "\\spad{reduce(up)} converts the univariate polynomial \\spad{up} to an algebra element,{} reducing by the \\spad{definingPolynomial()} if necessary."))
 (|definingPolynomial|
  ((|#2|)
   "\\spad{definingPolynomial()} returns the minimal polynomial which \\spad{generator()} satisfies."))
 (|generator|
  (($) "\\spad{generator()} returns the generator for this domain."))) 
NIL 
(|Monoid|) 
((|constructor|
  (NIL
   "The class of multiplicative monoids,{} \\spadignore{i.e.} semigroups with a multiplicative identity element. \\blankline"))) 
NIL 
(|MonomialExtensionTools| F UP) 
((|constructor| (NIL "Tools for handling monomial extensions."))
 (|decompose|
  (((|Record| (|:| |poly| |#2|) (|:| |normal| (|Fraction| |#2|))
              (|:| |special| (|Fraction| |#2|)))
    (|Fraction| |#2|) (|Mapping| |#2| |#2|))
   "\\spad{decompose(f,{} D)} returns \\spad{[p,{} n,{} s]} such that \\spad{f = p+n+s},{} all the squarefree factors of \\spad{denom(n)} are normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} \\spad{denom(s)} is special \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} and \\spad{n} and \\spad{s} are proper fractions (no pole at infinity). \\spad{D} is the derivation to use."))
 (|normalDenom|
  ((|#2| (|Fraction| |#2|) (|Mapping| |#2| |#2|))
   "\\spad{normalDenom(f,{} D)} returns the product of all the normal factors of \\spad{denom(f)}. \\spad{D} is the derivation to use."))
 (|splitSquarefree|
  (((|Record| (|:| |normal| (|Factored| |#2|))
              (|:| |special| (|Factored| |#2|)))
    |#2| (|Mapping| |#2| |#2|))
   "\\spad{splitSquarefree(p,{} D)} returns \\spad{[n_1 n_2\\^2 ... n_m\\^m,{} s_1 s_2\\^2 ... s_q\\^q]} such that \\spad{p = n_1 n_2\\^2 ... n_m\\^m s_1 s_2\\^2 ... s_q\\^q},{} each \\spad{n_i} is normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D} and each \\spad{s_i} is special \\spad{w}.\\spad{r}.\\spad{t} \\spad{D}. \\spad{D} is the derivation to use."))
 (|split|
  (((|Record| (|:| |normal| |#2|) (|:| |special| |#2|)) |#2|
    (|Mapping| |#2| |#2|))
   "\\spad{split(p,{} D)} returns \\spad{[n,{} s]} such that \\spad{p = n s},{} all the squarefree factors of \\spad{n} are normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} and \\spad{s} is special \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D}. \\spad{D} is the derivation to use."))) 
NIL 
(|MultivariateSkewPolynomialCategory| R E |Var|) 
NIL 
NIL 
(|MPolyCatFunctions2| |VarSet| E1 E2 R S PR PS) 
((|constructor|
  (NIL
   "\\indented{1}{Utilities for MPolyCat} Author: Manuel Bronstein Date Created: 1987"))
 (|map|
  ((|#7| (|Mapping| |#5| |#4|) |#6|) "\\spad{map(f,{} p)} \\undocumented"))) 
NIL 
(|MPolyCatFunctions3| |Vars1| |Vars2| E1 E2 R PR1 PR2) 
((|constructor| (NIL "This package \\undocumented"))
 (|map|
  ((|#7| (|Mapping| |#2| |#1|) |#6|) "\\spad{map(f,{} x)} \\undocumented"))) 
NIL 
(|MPolyCatPolyFactorizer| E OV R PPR) 
((|constructor|
  (NIL
   "\\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are polynomials over some ring \\spad{R} over which we can factor. It is used internally by packages such as the solve package which need to work with polynomials in a specific set of variables with coefficients which are polynomials in all the other variables."))
 (|factor|
  (((|Factored| |#4|) |#4|)
   "\\spad{factor(p)} factors a polynomial with polynomial coefficients."))
 (|convert|
  (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
(|MultivariatePolynomial| |vl| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are from a user specified list of symbols. The ordering is specified by the position of the variable in the list. The coefficient ring may be non commutative,{} but the variables are assumed to commute."))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|)))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| (|IndexedExponents| (|OrderedVariableList| |#1|))
                '(|Comparable|))
 (|HasCategory| |#2| '(|Field|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|OrderedVariableList| |#1|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#2| '(|Ring|))
  (|HasCategory| (|OrderedVariableList| |#1|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|OrderedVariableList| |#1|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|OrderedVariableList| |#1|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|GcdDomain|))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|MPolyCatRationalFunctionFactorizer| E OV R PRF) 
((|constructor|
  (NIL
   "\\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are rational functions over some ring \\spad{R} over which we can factor. It is used internally by packages such as primary decomposition which need to work with polynomials with rational function coefficients,{} \\spadignore{i.e.} themselves fractions of polynomials."))
 (|factor|
  (((|Factored| |#4|) |#4|)
   "\\spad{factor(prf)} factors a polynomial with rational function coefficients."))
 (|pushuconst|
  ((|#4| (|Fraction| (|Polynomial| |#3|)) |#2|)
   "\\spad{pushuconst(r,{} var)} takes a rational function and raises all occurrences of the variable var to the polynomial level."))
 (|pushucoef|
  ((|#4| (|SparseUnivariatePolynomial| (|Polynomial| |#3|)) |#2|)
   "\\spad{pushucoef(upoly,{} var)} converts the anonymous univariate polynomial \\spad{upoly} to a polynomial in var over rational functions."))
 (|pushup|
  ((|#4| |#4| |#2|)
   "\\spad{pushup(prf,{} var)} raises all occurrences of the variable var in the coefficients of the polynomial \\spad{prf} back to the polynomial level."))
 (|pushdterm|
  ((|#4| (|SparseUnivariatePolynomial| |#4|) |#2|)
   "\\spad{pushdterm(monom,{} var)} pushes all top level occurrences of the variable var into the coefficient domain for the monomial \\spad{monom}."))
 (|pushdown|
  ((|#4| |#4| |#2|)
   "\\spad{pushdown(prf,{} var)} pushes all top level occurrences of the variable var into the coefficient domain for the polynomial \\spad{prf}."))
 (|totalfract|
  (((|Record| (|:| |sup| (|Polynomial| |#3|)) (|:| |inf| (|Polynomial| |#3|)))
    |#4|)
   "\\spad{totalfract(prf)} takes a polynomial whose coefficients are themselves fractions of polynomials and returns a record containing the numerator and denominator resulting from putting \\spad{prf} over a common denominator."))
 (|convert|
  (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
(|MRationalFactorize| E OV R P) 
((|constructor|
  (NIL
   "\\indented{1}{MRationalFactorize contains the factor function for multivariate} polynomials over the quotient field of a ring \\spad{R} such that the package MultivariateFactorize can factor multivariate polynomials over \\spad{R}."))
 (|factor|
  (((|Factored| |#4|) |#4|)
   "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} with coefficients which are fractions of elements of \\spad{R}."))) 
NIL 
(|MonoidRingCategory| R M) 
((|constructor|
  (NIL
   "\\spadtype{MonoidRingCategory}(\\spad{R},{} \\spad{M}) defines the algebra of all maps from the monoid \\spad{M} to the commutative ring \\spad{R} with finite support."))
 (|terms|
  (((|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))) $)
   "\\spad{terms(f)} gives the list of non-zero coefficients combined with their corresponding basis element as records. This is the internal representation."))
 (|coerce|
  (($ (|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))))
   "\\spad{coerce(lt)} converts a list of terms and coefficients to a member of the domain."))) 
NIL 
(|MonoidRingFunctions2| R S M) 
((|constructor|
  (NIL
   "\\spad{MonoidRingFunctions2} implements functions between two monoid rings defined with the same monoid over different rings."))
 (|map|
  (((|MonoidRing| |#2| |#3|) (|Mapping| |#2| |#1|) (|MonoidRing| |#1| |#3|))
   "\\spad{map(f,{} u)} maps \\spad{f} onto the coefficients \\spad{f} the element \\spad{u} of the monoid ring to create an element of a monoid ring with the same monoid \\spad{b}."))) 
NIL 
(|MonoidRing| R M) 
((|constructor|
  (NIL
   "\\spadtype{MonoidRing}(\\spad{R},{} \\spad{M}),{} implements the algebra of all maps from the monoid \\spad{M} to the commutative ring \\spad{R} with finite support. Multiplication of two maps \\spad{f} and \\spad{g} is defined to map an element \\spad{c} of \\spad{M} to the (convolution) sum over {\\em f(a)g(b)} such that {\\em ab = c}. Thus \\spad{M} can be identified with a canonical basis and the maps can also be considered as formal linear combinations of the elements in \\spad{M}. Scalar multiples of a basis element are called monomials. A prominent example is the class of polynomials where the monoid is a direct product of the natural numbers with pointwise addition. When \\spad{M} is \\spadtype{FreeMonoid Symbol},{} one gets polynomials in infinitely many non-commuting variables. Another application area is representation theory of finite groups \\spad{G},{} where modules over \\spadtype{MonoidRing}(\\spad{R},{} \\spad{G}) are studied."))) 
((AND (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#2| '(|Finite|)))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| |#2| '(|CommutativeStar|)))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#2| '(|Comparable|))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#2| '(|Finite|))))) 
(|MrvLimitPackage|) 
((|constructor|
  (NIL "Compute limits using Gruntz-Gonnet \\spad{MRV} algorithm"))
 (|mrv_rewrite0|
  (((|Expression| (|Integer|)) (|Expression| (|Integer|))
    (|List| (|Kernel| (|Expression| (|Integer|))))
    (|List| (|Expression| (|Integer|))) (|Expression| (|Integer|)))
   "\\spad{mrv_rewrite0}"))
 (|mrv_rewrite|
  (((|Union|
     (|Record| (|:| |degree| (|OrderedExpression|))
               (|:| |coeff| (|Expression| (|Integer|))))
     #1="failed")
    (|Expression| (|Integer|)) (|List| (|Kernel| (|Expression| (|Integer|))))
    (|List| (|Expression| (|Integer|))) (|Symbol|)
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "rewrite"))
 (|expr_to_series|
  (((|Union|
     (|Record| (|:| |degree| (|OrderedExpression|))
               (|:| |coeff| (|Expression| (|Integer|))))
     #1#)
    (|Expression| (|Integer|)) (|Kernel| (|Expression| (|Integer|)))
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "Compute degree and leading coefficinet of series expansion"))
 (|mrv_set|
  (((|Union|
     (|Record| (|:| |lk| (|List| (|Kernel| (|Expression| (|Integer|)))))
               (|:| |lc| (|List| (|Expression| (|Integer|)))))
     "failed")
    (|Expression| (|Integer|)) (|Symbol|)
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "Compute \\spad{MRV} set"))
 (|mrv_cmp|
  (((|Union|
     (|Record| (|:| |sign| (|Integer|))
               (|:| |coeff| (|Expression| (|Integer|))))
     "failed")
    (|Kernel| (|Expression| (|Integer|))) (|Kernel| (|Expression| (|Integer|)))
    (|Symbol|)
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "Compare kernels"))
 (|mrv_limit1|
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|))) #2="failed")
    (|Expression| (|Integer|)) (|Symbol|))
   "normalize and compute limit."))
 (|mrv_normalize|
  (((|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Symbol|)
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "\\spad{mrv_normalize(f,{} x)} transform \\spad{f} to the form acceptable by core variant of mrv_limit."))
 (|mrv_limit|
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|))) #2#)
    (|Expression| (|Integer|)) (|Symbol|)
    (|Record| (|:| |tan_syms| (|List| (|Symbol|)))
              (|:| |atan_syms| (|List| (|Symbol|)))
              (|:| |tan_kers| (|List| (|Kernel| (|Expression| (|Integer|)))))
              (|:| |atan_kers|
                   (|List| (|Kernel| (|Expression| (|Integer|)))))))
   "Compute limit.")
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|))) #2#)
    (|Expression| (|Integer|)) (|Symbol|) (|Expression| (|Integer|))
    (|String|))
   "\\spad{mrv_limit(f,{} x,{} a,{} str)} is like mrv_limit(\\spad{f},{} \\spad{x} = a,{} \\spad{str})")
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|))) #2#)
    (|Expression| (|Integer|)) (|Equation| (|Expression| (|Integer|)))
    (|String|))
   "Compute limit(\\spad{f}(\\spad{x}),{} x=a) for a strictly finite limit point a This function computes one-sided limits from the left or right")
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
             (|Record|
              (|:| |leftHandLimit|
                   (|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
                            #2#))
              (|:| |rightHandLimit|
                   (|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
                            #2#)))
             #3="failed")
    (|Expression| (|Integer|)) (|Symbol|)
    (|OrderedCompletion| (|Expression| (|Integer|))))
   "\\spad{mrv_limit(f,{} x,{} a)} is like mrv_limit(\\spad{f},{} \\spad{x} = a)")
  (((|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
             (|Record|
              (|:| |leftHandLimit|
                   (|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
                            #2#))
              (|:| |rightHandLimit|
                   (|Union| (|OrderedCompletion| (|Expression| (|Integer|)))
                            #2#)))
             #3#)
    (|Expression| (|Integer|))
    (|Equation| (|OrderedCompletion| (|Expression| (|Integer|)))))
   "Compute limit(\\spad{f}(\\spad{x}),{} x=a) for a finite or infinite limit point a"))) 
NIL 
(|Multiset| S) 
((|constructor| (NIL "A multiset is a set with multiplicities."))
 (|remove!|
  (($ (|Mapping| (|Boolean|) |#1|) $ (|Integer|))
   "\\spad{remove!(p,{} ms,{} number)} removes destructively at most \\spad{number} copies of elements \\spad{x} such that \\spad{p(x)} is \\spadfun{\\spad{true}} if \\spad{number} is positive,{} all of them if \\spad{number} equals zero,{} and all but at most \\spad{-number} if \\spad{number} is negative.")
  (($ |#1| $ (|Integer|))
   "\\spad{remove!(x,{} ms,{} number)} removes destructively at most \\spad{number} copies of element \\spad{x} if \\spad{number} is positive,{} all of them if \\spad{number} equals zero,{} and all but at most \\spad{-number} if \\spad{number} is negative."))
 (|remove|
  (($ (|Mapping| (|Boolean|) |#1|) $ (|Integer|))
   "\\spad{remove(p,{} ms,{} number)} removes at most \\spad{number} copies of elements \\spad{x} such that \\spad{p(x)} is \\spadfun{\\spad{true}} if \\spad{number} is positive,{} all of them if \\spad{number} equals zero,{} and all but at most \\spad{-number} if \\spad{number} is negative.")
  (($ |#1| $ (|Integer|))
   "\\spad{remove(x,{} ms,{} number)} removes at most \\spad{number} copies of element \\spad{x} if \\spad{number} is positive,{} all of them if \\spad{number} equals zero,{} and all but at most \\spad{-number} if \\spad{number} is negative."))
 (|multiset|
  (($ (|List| |#1|))
   "\\spad{multiset(ls)} creates a multiset with elements from \\spad{ls}.")
  (($ |#1|) "\\spad{multiset(s)} creates a multiset with singleton \\spad{s}.")
  (($)
   "\\spad{multiset()}\\$\\spad{D} creates an empty multiset of domain \\spad{D}."))) 
((AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|MultisetAggregate| S) 
((|constructor|
  (NIL
   "A multi-set aggregate is a set which keeps track of the multiplicity of its elements."))) 
NIL 
(|MoreSystemCommands|) 
((|constructor|
  (NIL
   "\\spadtype{MoreSystemCommands} implements an interface with the system command facility. These are the commands that are issued from source files or the system interpreter and they start with a close parenthesis,{} \\spadignore{e.g.} \\spadsys{)what} commands."))
 (|systemCommand|
  (((|Void|) (|String|))
   "\\spad{systemCommand(cmd)} takes the string \\spadvar{\\spad{cmd}} and passes it to the runtime environment for execution as a system command. Although various things may be printed,{} no usable value is returned."))) 
NIL 
(|MergeThing| S) 
((|constructor| (NIL "This package exports tools for merging lists"))
 (|mergeDifference|
  (((|List| |#1|) (|List| |#1|) (|List| |#1|))
   "\\spad{mergeDifference(l1,{} l2)} returns a list of elements in \\spad{l1} not present in \\spad{l2}. Assumes lists are ordered and all \\spad{x} in \\spad{l2} are also in \\spad{l1}."))) 
NIL 
(|MultivariateTaylorSeriesCategory&| S |Coef| |Var|) 
((|constructor|
  (NIL
   "\\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category."))
 (|integrate|
  (($ $ |#3|)
   "\\spad{integrate(f,{} x)} returns the anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{x} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers."))
 (|polynomial|
  (((|Polynomial| |#2|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Polynomial| |#2|) $ (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|order|
  (((|NonNegativeInteger|) $ |#3| (|NonNegativeInteger|))
   "\\spad{order(f,{} x,{} n)} returns \\spad{min(n,{} order(f,{} x))}.")
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{order(f,{} x)} returns the order of \\spad{f} viewed as a series in \\spad{x} may result in an infinite loop if \\spad{f} has no non-zero terms."))
 (|monomial|
  (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|)))
   "\\spad{monomial(a,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns \\spad{a * x1^n1 * ... * xk^nk}.")
  (($ $ |#3| (|NonNegativeInteger|))
   "\\spad{monomial(a,{} x,{} n)} returns \\spad{a*x^n}."))
 (|extend|
  (($ $ (|NonNegativeInteger|))
   "\\spad{extend(f,{} n)} causes all terms of \\spad{f} of degree \\spad{<= n} to be computed."))
 (|coefficient|
  (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|)))
   "\\spad{coefficient(f,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns the coefficient of \\spad{x1^n1 * ... * xk^nk} in \\spad{f}.")
  (($ $ |#3| (|NonNegativeInteger|))
   "\\spad{coefficient(f,{} x,{} n)} returns the coefficient of \\spad{x^n} in \\spad{f}."))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|MultivariateTaylorSeriesCategory| |Coef| |Var|) 
((|constructor|
  (NIL
   "\\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category."))
 (|integrate|
  (($ $ |#2|)
   "\\spad{integrate(f,{} x)} returns the anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{x} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers."))
 (|polynomial|
  (((|Polynomial| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Polynomial| |#1|) $ (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|order|
  (((|NonNegativeInteger|) $ |#2| (|NonNegativeInteger|))
   "\\spad{order(f,{} x,{} n)} returns \\spad{min(n,{} order(f,{} x))}.")
  (((|NonNegativeInteger|) $ |#2|)
   "\\spad{order(f,{} x)} returns the order of \\spad{f} viewed as a series in \\spad{x} may result in an infinite loop if \\spad{f} has no non-zero terms."))
 (|monomial|
  (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|)))
   "\\spad{monomial(a,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns \\spad{a * x1^n1 * ... * xk^nk}.")
  (($ $ |#2| (|NonNegativeInteger|))
   "\\spad{monomial(a,{} x,{} n)} returns \\spad{a*x^n}."))
 (|extend|
  (($ $ (|NonNegativeInteger|))
   "\\spad{extend(f,{} n)} causes all terms of \\spad{f} of degree \\spad{<= n} to be computed."))
 (|coefficient|
  (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|)))
   "\\spad{coefficient(f,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns the coefficient of \\spad{x1^n1 * ... * xk^nk} in \\spad{f}.")
  (($ $ |#2| (|NonNegativeInteger|))
   "\\spad{coefficient(f,{} x,{} n)} returns the coefficient of \\spad{x^n} in \\spad{f}."))) 
NIL 
(|MultiplicativeDependence|) 
((|logDependenceQ|
  (((|Union| (|Vector| (|Fraction| (|Integer|))) "failed")
    (|List| (|Fraction| (|Integer|))) (|Fraction| (|Integer|)))
   "\\spad{logDependenceQ([q1,{} ...,{} qn],{} q0)} finds rational constants \\spad{c1,{} ...cn} such that \\spad{q1^c1*...*qn^cn=u*q0} where \\spad{u} is a unit"))) 
NIL 
(|MultivariateFactorize| OV E R P) 
((|constructor|
  (NIL
   "\\indented{2}{This is the top level package for doing multivariate factorization} over basic domains like \\spadtype{Integer} or \\spadtype{Fraction Integer}."))
 (|factor|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain where \\spad{p} is represented as a univariate polynomial with multivariate coefficients")
  (((|Factored| |#4|) |#4|)
   "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain"))) 
NIL 
(|MultivariateSquareFree| E OV R P) 
((|constructor|
  (NIL
   "Author : \\spad{P}.Gianni This package provides the functions for the computation of the square free decomposition of a multivariate polynomial. It uses modular reduction and the package \\spad{MultivariateLifting} for the \"multivariate\" lifting."))
 (|normDeriv2|
  (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#3|)
    (|Integer|))
   "\\spad{normDeriv2 should} be local"))
 (|myDegree|
  (((|List| (|NonNegativeInteger|)) (|SparseUnivariatePolynomial| |#4|)
    (|List| |#2|) (|NonNegativeInteger|))
   "\\spad{myDegree should} be local"))
 (|lift|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|)
    (|SparseUnivariatePolynomial| |#3|) |#4| (|List| |#2|)
    (|List| (|NonNegativeInteger|)) (|List| |#3|) |#3|)
   "\\spad{lift should} be local"))
 (|check|
  (((|Boolean|)
    (|List|
     (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|))
               (|:| |exponent| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|))
               (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{check should} be local"))
 (|coefChoose|
  ((|#4| (|Integer|) |#4|
    (|List|
     (|Record| (|:| |factor| |#4|) (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{coefChoose should} be local"))
 (|intChoose|
  (((|Record| (|:| |upol| (|SparseUnivariatePolynomial| |#3|))
              (|:| |Lval| (|List| |#3|))
              (|:| |Lfact|
                   (|List|
                    (|Record|
                     (|:| |factor| (|SparseUnivariatePolynomial| |#3|))
                     (|:| |exponent| (|NonNegativeInteger|)))))
              (|:| |ctpol| |#3|))
    (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|List| |#3|)))
   "\\spad{intChoose should} be local"))
 (|nsqfree|
  (((|Record| (|:| |unitPart| |#4|)
              (|:| |suPart|
                   (|List|
                    (|Record|
                     (|:| |factor| (|SparseUnivariatePolynomial| |#4|))
                     (|:| |exponent| (|NonNegativeInteger|))))))
    (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|List| |#3|)))
   "\\spad{nsqfree should} be local"))
 (|consnewpol|
  (((|Record| (|:| |pol| (|SparseUnivariatePolynomial| |#4|))
              (|:| |polval| (|SparseUnivariatePolynomial| |#3|)))
    (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|)
    (|Integer|))
   "\\spad{consnewpol should} be local"))
 (|univcase|
  (((|Factored| |#4|) |#4| |#2|) "\\spad{univcase should} be local"))
 (|compdegd|
  (((|Integer|)
    (|List|
     (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|))
               (|:| |exponent| (|NonNegativeInteger|)))))
   "\\spad{compdegd should} be local"))
 (|squareFree|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \\spad{p} presented as a univariate polynomial with multivariate coefficients.")
  (((|Factored| |#4|) |#4|)
   "\\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \\spad{p}."))) 
NIL 
(|NonAssociativeAlgebra&| S R) 
((|constructor|
  (NIL
   "NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \\indented{3}{\\spad{r*}(a*b) = (r*a)\\spad{*b} = a*(\\spad{r*b})}"))
 (|plenaryPower|
  (($ $ (|PositiveInteger|))
   "\\spad{plenaryPower(a,{} n)} is recursively defined to be \\spad{plenaryPower(a,{} n-1)*plenaryPower(a,{} n-1)} for \\spad{n>1} and \\spad{a} for \\spad{n=1}."))) 
NIL 
(|NonAssociativeAlgebra| R) 
((|constructor|
  (NIL
   "NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \\indented{3}{\\spad{r*}(a*b) = (r*a)\\spad{*b} = a*(\\spad{r*b})}"))
 (|plenaryPower|
  (($ $ (|PositiveInteger|))
   "\\spad{plenaryPower(a,{} n)} is recursively defined to be \\spad{plenaryPower(a,{} n-1)*plenaryPower(a,{} n-1)} for \\spad{n>1} and \\spad{a} for \\spad{n=1}."))) 
NIL 
(|NonAssociativeRing&| S) 
((|constructor|
  (NIL
   "A NonAssociativeRing is a non associative \\spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative."))
 (|coerce|
  (($ (|Integer|))
   "\\spad{coerce(n)} coerces the integer \\spad{n} to an element of the ring."))
 (|characteristic|
  (((|NonNegativeInteger|))
   "\\spad{characteristic()} returns the characteristic of the ring."))) 
NIL 
(|NonAssociativeRing|) 
((|constructor|
  (NIL
   "A NonAssociativeRing is a non associative \\spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative."))
 (|coerce|
  (($ (|Integer|))
   "\\spad{coerce(n)} coerces the integer \\spad{n} to an element of the ring."))
 (|characteristic|
  (((|NonNegativeInteger|))
   "\\spad{characteristic()} returns the characteristic of the ring."))) 
NIL 
(|NonAssociativeRng&| S) 
((|constructor|
  (NIL
   "NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \\indented{2}{\\spad{x*}(\\spad{y+z}) = x*y + \\spad{x*z}} \\indented{2}{(x+y)\\spad{*z} = \\spad{x*z} + \\spad{y*z}} Common Additional Axioms \\indented{2}{noZeroDivisors\\space{2}ab = 0 \\spad{=>} \\spad{a=0} or \\spad{b=0}}"))
 (|commutator| (($ $ $) "\\spad{commutator(a,{} b)} returns \\spad{a*b-b*a}."))
 (|associator|
  (($ $ $ $)
   "\\spad{associator(a,{} b,{} c)} returns \\spad{(a*b)*c-a*(b*c)}."))) 
NIL 
(|NonAssociativeRng|) 
((|constructor|
  (NIL
   "NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \\indented{2}{\\spad{x*}(\\spad{y+z}) = x*y + \\spad{x*z}} \\indented{2}{(x+y)\\spad{*z} = \\spad{x*z} + \\spad{y*z}} Common Additional Axioms \\indented{2}{noZeroDivisors\\space{2}ab = 0 \\spad{=>} \\spad{a=0} or \\spad{b=0}}"))
 (|commutator| (($ $ $) "\\spad{commutator(a,{} b)} returns \\spad{a*b-b*a}."))
 (|associator|
  (($ $ $ $)
   "\\spad{associator(a,{} b,{} c)} returns \\spad{(a*b)*c-a*(b*c)}."))) 
NIL 
(|NonAssociativeSemiRing|) 
((|constructor|
  (NIL
   "The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} with 0 and 1."))) 
NIL 
(|NonAssociativeSemiRng&| S) 
((|constructor|
  (NIL
   "The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} and not necessarily with a 1."))
 (|antiCommutator|
  (($ $ $) "\\spad{antiCommutator(a,{} b)} returns \\spad{a*b+b*a}."))) 
NIL 
(|NonAssociativeSemiRng|) 
((|constructor|
  (NIL
   "The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} and not necessarily with a 1."))
 (|antiCommutator|
  (($ $ $) "\\spad{antiCommutator(a,{} b)} returns \\spad{a*b+b*a}."))) 
NIL 
(|NaiveBeckermannLabahnModular|) 
((|constructor|
  (NIL
   "This package solves (multipoint) Hermite-Pade \\indented{1}{interpolation problem over \\$\\spad{Z_p}\\$,{} where \\$\\spad{p}\\$ is machine} \\indented{1}{sized prime.\\space{2}We use quadratic algorithm from 94} \\indented{1}{Beckermann and Labahn paper (with modification to handle} \\indented{1}{multipoint case).}"))
 (|reduceBasis|
  (((|Record| (|:| |basis| (|TwoDimensionalArray| (|U32Vector|)))
              (|:| |defects| (|Vector| (|Integer|)))
              (|:| |cinds| (|Vector| (|Integer|))))
    (|Vector| (|U32Vector|)) (|Vector| (|Integer|)) (|Vector| (|Integer|))
    (|Integer|))
   "Skips elements of sigma basis which does not satisfy degree bounds and puts sigma-basis into canonical form."))
 (|naiveBeckermannLabahn0|
  (((|Void|) (|Vector| (|U32Vector|)) (|Vector| (|U32Vector|))
    (|Vector| (|Integer|)) (|NonNegativeInteger|) (|Integer|)
    (|Mapping| (|Integer|) (|Integer|))
    (|Mapping| (|Void|) (|U32Vector|) (|Integer|) (|Integer|))
    (|Mapping| (|Void|) (|U32Vector|) (|Integer|) (|Integer|)))
   "main solver routine"))
 (|naiveBeckermannLabahnMultipoint|
  (((|List| (|Any|)) (|Vector| (|SparseUnivariatePolynomial| (|Integer|)))
    (|Vector| (|Integer|)) (|U32Vector|) (|Integer|))
   "\\spad{naiveBeckermannLabahnMultipoint(f,{} degs,{} sigma,{} p)} solves modulo \\$\\spad{p}\\$ multipoint Hermite-Pade interpolation problem of order \\$\\spad{sigma}\\$. \\$\\spad{degs}\\$ specifies degree bounds for solution. The first element of result contains \\spad{sigma}-basis. The second gives defects of elements of \\spad{sigma}-basis. The third one contains residuals \\spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \\spad{sigma}-basis which are within bounds,{} but non-zero otherwise.")
  (((|List| (|Any|)) (|Vector| (|U32Vector|)) (|Vector| (|Integer|))
    (|U32Vector|) (|Integer|))
   "\\spad{naiveBeckermannLabahnMultipoint(f,{} degs,{} sigma,{} p)} solves modulo \\$\\spad{p}\\$ multipoint Hermite-Pade interpolation problem of order \\$\\spad{sigma}\\$. \\$\\spad{degs}\\$ specifies degree bounds for solution. The first element of result contains \\spad{sigma}-basis. The second gives defects of elements of \\spad{sigma}-basis. The third one contains residuals \\spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \\spad{sigma}-basis which are within bounds,{} but non-zero otherwise."))
 (|naiveBeckermannLabahn|
  (((|List| (|Any|)) (|Vector| (|SparseUnivariatePolynomial| (|Integer|)))
    (|Vector| (|Integer|)) (|NonNegativeInteger|) (|Integer|))
   "\\spad{naiveBeckermannLabahn(f,{} degs,{} sigma,{} p)} solves modulo \\$\\spad{p}\\$ Hermite-Pade interpolation problem of order \\$\\spad{sigma}\\$. \\$\\spad{degs}\\$ specifies degree bounds for solution. The first element of result contains \\spad{sigma}-basis. The second gives defects of elements of \\spad{sigma}-basis. The third one contains residuals \\spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \\spad{sigma}-basis which are within bounds,{} but non-zero otherwise.")
  (((|List| (|Any|)) (|Vector| (|U32Vector|)) (|Vector| (|Integer|))
    (|NonNegativeInteger|) (|Integer|))
   "\\spad{naiveBeckermannLabahn(f,{} degs,{} sigma,{} p)} solves modulo \\$\\spad{p}\\$ Hermite-Pade interpolation problem of order \\$\\spad{sigma}\\$. \\$\\spad{degs}\\$ specifies degree bounds for solution. The first element of result contains \\spad{sigma}-basis. The second gives defects of elements of \\spad{sigma}-basis. The third one contains residuals \\spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \\spad{sigma}-basis which are within bounds,{} but non-zero otherwise."))) 
NIL 
(|NumericComplexEigenPackage| |Par|) 
((|constructor|
  (NIL
   "This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the complex rational numbers. The results are expressed either as complex floating numbers or as complex rational numbers depending on the type of the precision parameter."))
 (|complexEigenvectors|
  (((|List|
     (|Record| (|:| |outval| (|Complex| |#1|)) (|:| |outmult| (|Integer|))
               (|:| |outvect| (|List| (|Matrix| (|Complex| |#1|))))))
    (|Matrix| (|Complex| (|Fraction| (|Integer|)))) |#1|)
   "\\spad{complexEigenvectors(m,{} eps)} returns a list of records each one containing a complex eigenvalue,{} its algebraic multiplicity,{} and a list of associated eigenvectors. All these results are computed to precision eps and are expressed as complex floats or complex rational numbers depending on the type of eps (float or rational)."))
 (|complexEigenvalues|
  (((|List| (|Complex| |#1|)) (|Matrix| (|Complex| (|Fraction| (|Integer|))))
    |#1|)
   "\\spad{complexEigenvalues(m,{} eps)} computes the eigenvalues of the matrix \\spad{m} to precision eps. The eigenvalues are expressed as complex floats or complex rational numbers depending on the type of eps (float or rational)."))
 (|characteristicPolynomial|
  (((|Polynomial| (|Complex| (|Fraction| (|Integer|))))
    (|Matrix| (|Complex| (|Fraction| (|Integer|)))) (|Symbol|))
   "\\spad{characteristicPolynomial(m,{} x)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over Complex Rationals with variable \\spad{x}.")
  (((|Polynomial| (|Complex| (|Fraction| (|Integer|))))
    (|Matrix| (|Complex| (|Fraction| (|Integer|)))))
   "\\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over complex rationals with a new symbol as variable."))) 
NIL 
(|NumericContinuedFraction| F) 
((|constructor|
  (NIL
   "\\spadtype{NumericContinuedFraction} provides functions \\indented{2}{for converting floating point numbers to continued fractions.}"))
 (|continuedFraction|
  (((|ContinuedFraction| (|Integer|)) |#1|)
   "\\spad{continuedFraction(f)} converts the floating point number \\spad{f} to a reduced continued fraction."))) 
NIL 
(|NewtonInterpolation| F) 
((|constructor|
  (NIL
   "This package exports Newton interpolation for the special case where the result is known to be in the original integral domain"))
 (|newton|
  (((|SparseUnivariatePolynomial| |#1|) (|List| |#1|))
   "\\spad{newton}(\\spad{l}) returns the interpolating polynomial for the values \\spad{l},{} where the \\spad{x}-coordinates are assumed to be [1,{} 2,{} 3,{} ...,{} \\spad{n}] and the coefficients of the interpolating polynomial are known to be in the domain \\spad{F}. \\spad{I}.\\spad{e}.,{} it is a very streamlined version for a special case of interpolation."))) 
NIL 
(|NumberFieldIntegralBasis| UP F) 
((|constructor|
  (NIL
   "In this package \\spad{F} is a framed algebra over the integers (typically \\spad{F = Z[a]} for some algebraic integer a). The package provides functions to compute the integral closure of \\spad{Z} in the quotient field of \\spad{F}."))
 (|localIntegralBasis|
  (((|Record| (|:| |basis| (|Matrix| (|Integer|))) (|:| |basisDen| (|Integer|))
              (|:| |basisInv| (|Matrix| (|Integer|))))
    (|Integer|))
   "\\spad{integralBasis(p)} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \\spad{Z} at the prime \\spad{p} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{Z}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|integralBasis|
  (((|Record| (|:| |basis| (|Matrix| (|Integer|))) (|:| |basisDen| (|Integer|))
              (|:| |basisInv| (|Matrix| (|Integer|)))))
   "\\spad{integralBasis()} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \\spad{Z} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{Z}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|discriminant|
  (((|Integer|))
   "\\spad{discriminant()} returns the discriminant of the integral closure of \\spad{Z} in the quotient field of the framed algebra \\spad{F}."))) 
NIL 
(|NGroebnerPackage| |Dom| |Expon| |Dpol|) 
((|constructor|
  (NIL
   "This is package computes noncommutative Groebner basis. Based on commutative version. Note that this package accepts rings as base domain,{} however computed basis is over left fraction field. Computations are done in fraction free way (coefficients stay in base ring)."))
 (|sPol|
  ((|#3|
    (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|))
              (|:| |poli| |#3|) (|:| |polj| |#3|)))
   "sPol"))
 (|virtualDegree| (((|NonNegativeInteger|) |#3|) "virtualDegree"))
 (|hMonic|
  ((|#3| |#3|) "\\spad{hMonic(p)} tries to remove content from \\spad{p}"))
 (|redPol|
  ((|#3| |#3| (|List| |#3|))
   "normalForm(poly,{} \\spad{gb}) reduces the polynomial poly modulo the precomputed groebner basis \\spad{gb} giving up to a constant factor a canonical representative of the residue class."))
 (|groebner|
  (((|List| |#3|) (|List| |#3|))
   "\\spad{groebner(lp)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \\spad{lp}."))) 
NIL 
(|NonLinearSolvePackage| R) 
((|constructor|
  (NIL
   "NonLinearSolvePackage is an interface to \\spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving. The solutions are given in the algebraic closure of \\spad{R} whenever possible."))
 (|solve|
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{solve(lp)} finds the solution in the algebraic closure of \\spad{R} of the list \\spad{lp} of rational functions with respect to all the symbols appearing in \\spad{lp}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)))
   "\\spad{solve(lp,{} lv)} finds the solutions in the algebraic closure of \\spad{R} of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv}."))
 (|solveInField|
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{solveInField(lp)} finds the solution of the list \\spad{lp} of rational functions with respect to all the symbols appearing in \\spad{lp}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)))
   "\\spad{solveInField(lp,{} lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv}."))) 
NIL 
(|NonNegativeInteger|) 
((|constructor|
  (NIL
   "\\spadtype{NonNegativeInteger} provides functions for non \\indented{2}{negative integers.}"))
 (|qcoerce|
  (($ (|Integer|))
   "\\spad{qcoerce(n)} coerces \\spad{n} to \\spad{\\%} trusting that \\spad{n} is nonnegative"))
 (|random|
  (($ $) "\\spad{random(n)} returns a random integer from 0 to \\spad{n-1}."))
 (|shift|
  (($ $ (|Integer|))
   "\\spad{shift(a,{} i)} shift \\spad{a} by \\spad{i} bits."))
 (|exquo|
  (((|Union| $ "failed") $ $)
   "\\spad{exquo(a,{}b)} returns the quotient of \\spad{a} and \\spad{b},{} or \"failed\" if \\spad{b} is zero or \\spad{a} rem \\spad{b} is zero."))
 (|divide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{divide(a,{} b)} returns a record containing both remainder and quotient."))
 (|gcd|
  (($ $ $)
   "\\spad{gcd(a,{} b)} computes the greatest common divisor of two non negative integers \\spad{a} and \\spad{b}."))
 (|rem|
  (($ $ $)
   "\\spad{a rem b} returns the remainder of \\spad{a} and \\spad{b}."))
 (|quo|
  (($ $ $)
   "\\spad{a quo b} returns the quotient of \\spad{a} and \\spad{b},{} forgetting the remainder."))) 
((|HasCategory| $ '(|AbelianGroup|))) 
(|NonNegativeRational|) 
((|constructor|
  (NIL
   "\\spadtype{NonNegativeRational} is domain of \\indented{1}{nonnegative rational numbers.}"))) 
((|HasCategory| $ '(|AbelianGroup|))) 
(|NonLinearFirstOrderODESolver| R F) 
((|constructor|
  (NIL
   "NonLinearFirstOrderODESolver provides a function for finding closed form first integrals of nonlinear ordinary differential equations of order 1."))
 (|solve|
  (((|Union| |#2| "failed") |#2| |#2| (|BasicOperator|) (|Symbol|))
   "\\spad{solve(M(x,{} y),{} N(x,{} y),{} y,{} x)} returns \\spad{F(x,{} y)} such that \\spad{F(x,{} y) = c} for a constant \\spad{c} is a first integral of the equation \\spad{M(x,{} y) dx + N(x,{} y) dy = 0},{} or \"failed\" if no first-integral can be found."))) 
NIL 
(|None|) 
((|constructor|
  (NIL
   "\\spadtype{None} implements an universal type,{} that is type which can represent values of any normal type. It is mainly used in technical situations where such a thing is needed (\\spadignore{e.g.} the interpreter and some of the internal \\spadtype{Expression} code)."))) 
NIL 
(|NoneFunctions1| S) 
((|constructor|
  (NIL
   "\\spadtype{NoneFunctions1} implements functions on \\spadtype{None}. It includes a particularly dangerous coercion from any other type to \\spadtype{None}."))
 (|coerce|
  (((|None|) |#1|)
   "\\spad{coerce(x)} changes \\spad{x} into an object of type \\spadtype{None}."))) 
NIL 
(|NormInMonogenicAlgebra| R |PolR| E |PolE|) 
((|constructor|
  (NIL
   "This package implements the norm of a polynomial with coefficients in a monogenic algebra (using resultants)"))
 (|norm|
  ((|#2| |#4|)
   "\\spad{norm q} returns the norm of \\spad{q},{} \\spadignore{i.e.} the product of all the conjugates of \\spad{q}."))) 
NIL 
(|NormalizationPackage| R E V P TS) 
((|constructor|
  (NIL
   "A package for computing normalized assocites of univariate polynomials with coefficients in a tower of simple extensions of a field."))
 (|normInvertible?|
  (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| |#5|))) |#4| |#5|)
   "\\spad{normInvertible?(p,{} ts)} is an internal subroutine,{} exported only for developement."))
 (|outputArgs|
  (((|Void|) (|String|) (|String|) |#4| |#5|)
   "\\spad{outputArgs(s1,{} s2,{} p,{} ts)} is an internal subroutine,{} exported only for developement."))
 (|normalize|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#5|)
   "\\spad{normalize(p,{} ts)} normalizes \\spad{p} \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts}."))
 (|normalizedAssociate|
  ((|#4| |#4| |#5|)
   "\\spad{normalizedAssociate(p,{} ts)} returns a normalized polynomial \\spad{n} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts} such that \\spad{n} and \\spad{p} are associates \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts} and assuming that \\spad{p} is invertible \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts}."))
 (|recip|
  (((|Record| (|:| |num| |#4|) (|:| |den| |#4|)) |#4| |#5|)
   "\\spad{recip(p,{} ts)} returns the inverse of \\spad{p} \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts} assuming that \\spad{p} is invertible \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts}."))) 
NIL 
(|NormRetractPackage| F |ExtF| |SUEx| |ExtP| |n|) 
((|constructor| (NIL "This package \\undocumented"))
 (|Frobenius| ((|#4| |#4|) "\\spad{Frobenius(x)} \\undocumented"))
 (|retractIfCan|
  (((|Union| (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))
             "failed")
    |#4|)
   "\\spad{retractIfCan(x)} \\undocumented"))
 (|normFactors| (((|List| |#4|) |#4|) "\\spad{normFactors(x)} \\undocumented"))) 
NIL 
(|NPCoef| BP E OV R P) 
((|constructor|
  (NIL
   "Package for the determination of the coefficients in the lifting process. Used by \\spadtype{MultivariateLifting}. This package will work for every integral domain \\spad{R}. The same method is described in [1] section 2.3.4."))
 (|npcoef|
  (((|Record| (|:| |deter| (|List| (|SparseUnivariatePolynomial| |#5|)))
              (|:| |dterm|
                   (|List|
                    (|List|
                     (|Record| (|:| |expt| (|NonNegativeInteger|))
                               (|:| |pcoef| |#5|)))))
              (|:| |nfacts| (|List| |#1|)) (|:| |nlead| (|List| |#5|)))
    (|SparseUnivariatePolynomial| |#5|) (|List| |#1|) (|List| |#5|))
   "\\spad{npcoef(p,{} lmf,{} lcf)} tries to determine some coefficients of factors of \\spad{p} assuming that \\spad{lcf} gives \\spad{true} leading coefficients of the factors and that sparsity pattern of modular factors \\spad{lmf} is the same as sparsity pattern of \\spad{true} factors. If \\spad{res} is the result,{} then \\spad{res.deter} gives fully determined factors,{} \\spad{res.dterm} gives determined terms of partially determinaed factors,{} \\spad{res.nfacts} and \\spad{res.nlead} give modular factors and leading coefficients corresponding to undetermined factors."))) 
NIL 
(|NumericRealEigenPackage| |Par|) 
((|constructor|
  (NIL
   "This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the Rational Numbers. The results are expressed as floating numbers or as rational numbers depending on the type of the parameter Par."))
 (|realEigenvectors|
  (((|List|
     (|Record| (|:| |outval| |#1|) (|:| |outmult| (|Integer|))
               (|:| |outvect| (|List| (|Matrix| |#1|)))))
    (|Matrix| (|Fraction| (|Integer|))) |#1|)
   "\\spad{realEigenvectors(m,{} eps)} returns a list of records each one containing a real eigenvalue,{} its algebraic multiplicity,{} and a list of associated eigenvectors. All these results are computed to precision eps as floats or rational numbers depending on the type of eps ."))
 (|realEigenvalues|
  (((|List| |#1|) (|Matrix| (|Fraction| (|Integer|))) |#1|)
   "\\spad{realEigenvalues(m,{} eps)} computes the eigenvalues of the matrix \\spad{m} to precision eps. The eigenvalues are expressed as floats or rational numbers depending on the type of eps (float or rational)."))
 (|characteristicPolynomial|
  (((|Polynomial| (|Fraction| (|Integer|))) (|Matrix| (|Fraction| (|Integer|)))
    (|Symbol|))
   "\\spad{characteristicPolynomial(m,{} x)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over \\spad{RN} with variable \\spad{x}.")
  (((|Polynomial| (|Fraction| (|Integer|)))
    (|Matrix| (|Fraction| (|Integer|))))
   "\\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over \\spad{RN} with a new symbol as variable."))) 
NIL 
(|NewSparseMultivariatePolynomial| R |VarSet|) 
((|constructor|
  (NIL
   "A post-facto extension for \\spadtype{SMP} in order to speed up operations related to pseudo-division and \\spad{gcd}. This domain is based on the \\spadtype{NSUP} constructor which is itself a post-facto extension of the \\spadtype{SUP} constructor."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|Symbol|)))
 (AND (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|Symbol|))))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2|
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|Symbol|))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| '(|Integer|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|Symbol|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|NewSparseUnivariatePolynomial| R) 
((|constructor|
  (NIL
   "A post-facto extension for \\spadtype{SUP} in order to speed up operations related to pseudo-division and \\spad{gcd} for both \\spadtype{SUP} and,{} consequently,{} \\spadtype{NSMP}."))
 (|halfExtendedResultant2|
  (((|Record| (|:| |resultant| |#1|) (|:| |coef2| $)) $ $)
   "\\spad{halfExtendedResultant2(a,{} b)} returns \\spad{[r,{} ca]} such that \\spad{extendedResultant(a,{} b)} returns \\spad{[r,{} ca,{} cb]}"))
 (|halfExtendedResultant1|
  (((|Record| (|:| |resultant| |#1|) (|:| |coef1| $)) $ $)
   "\\spad{halfExtendedResultant1(a,{} b)} returns \\spad{[r,{} ca]} such that \\spad{extendedResultant(a,{} b)} returns \\spad{[r,{} ca,{} cb]}"))
 (|extendedResultant|
  (((|Record| (|:| |resultant| |#1|) (|:| |coef1| $) (|:| |coef2| $)) $ $)
   "\\spad{extendedResultant(a,{} b)} returns \\spad{[r,{} ca,{} cb]} such that \\spad{r} is the resultant of \\spad{a} and \\spad{b} and \\spad{r = ca * a + cb * b}"))
 (|halfExtendedSubResultantGcd2|
  (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd2(a,{} b)} returns \\spad{[g,{} cb]} such that \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]}"))
 (|halfExtendedSubResultantGcd1|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd1(a,{} b)} returns \\spad{[g,{} ca]} such that \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]}"))
 (|extendedSubResultantGcd|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $)
   "\\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} such that \\spad{g} is a \\spad{gcd} of \\spad{a} and \\spad{b} in \\spad{R^(-1) P} and \\spad{g = ca * a + cb * b}"))
 (|lastSubResultant|
  (($ $ $)
   "\\spad{lastSubResultant(a,{} b)} returns \\spad{resultant(a,{} b)} if \\spad{a} and \\spad{b} has no non-trivial \\spad{gcd} in \\spad{R^(-1) P} otherwise the non-zero sub-resultant with smallest index."))
 (|subResultantsChain|
  (((|List| $) $ $)
   "\\spad{subResultantsChain(a,{} b)} returns the list of the non-zero sub-resultants of \\spad{a} and \\spad{b} sorted by increasing degree."))
 (|lazyPseudoQuotient|
  (($ $ $)
   "\\spad{lazyPseudoQuotient(a,{} b)} returns \\spad{q} if \\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]}"))
 (|lazyPseudoDivide|
  (((|Record| (|:| |coef| |#1|) (|:| |gap| (|NonNegativeInteger|))
              (|:| |quotient| $) (|:| |remainder| $))
    $ $)
   "\\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]} such that \\spad{c^n * a = q*b +r} and \\spad{lazyResidueClass(a,{} b)} returns \\spad{[r,{} c,{} n]} where \\spad{n + g = max(0,{} degree(b) - degree(a) + 1)}."))
 (|lazyPseudoRemainder|
  (($ $ $)
   "\\spad{lazyPseudoRemainder(a,{} b)} returns \\spad{r} if \\spad{lazyResidueClass(a,{} b)} returns \\spad{[r,{} c,{} n]}. This lazy pseudo-remainder is computed by means of the \\spadopFrom{fmecg}{NewSparseUnivariatePolynomial} operation."))
 (|lazyResidueClass|
  (((|Record| (|:| |polnum| $) (|:| |polden| |#1|)
              (|:| |power| (|NonNegativeInteger|)))
    $ $)
   "\\spad{lazyResidueClass(a,{} b)} returns \\spad{[r,{} c,{} n]} such that \\spad{r} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and \\spad{b} divides \\spad{c^n * a - r} where \\spad{c} is \\spad{leadingCoefficient(b)} and \\spad{n} is as small as possible with the previous properties."))
 (|monicModulo|
  (($ $ $)
   "\\spad{monicModulo(a,{} b)} returns \\spad{r} such that \\spad{r} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and \\spad{b} divides \\spad{a - r} where \\spad{b} is monic."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|EntireRing|))
 (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|StepThrough|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|SingletonAsOrderedSet|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|NewSparseUnivariatePolynomialFunctions2| R S) 
((|constructor|
  (NIL
   "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from sparse univariate polynomial over \\spad{R} to a sparse univariate polynomial over \\spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial."))
 (|map|
  (((|NewSparseUnivariatePolynomial| |#2|) (|Mapping| |#2| |#1|)
    (|NewSparseUnivariatePolynomial| |#1|))
   "\\spad{map(func,{} poly)} creates a new polynomial by applying \\spad{func} to every non-zero coefficient of the polynomial poly."))) 
NIL 
(|NumberTheoreticPolynomialFunctions| R) 
((|constructor|
  (NIL "This package provides polynomials as functions on a ring."))
 (|eulerE|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{eulerE(n,{} r)} returns value of the \\spad{n}th Euler polynomial at \\spad{r}."))
 (|bernoulliB|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{bernoulliB(n,{} r)} returns value of the \\spad{n}th Bernoulli polynomial at \\spad{r}."))
 (|cyclotomic|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{cyclotomic(n,{} r)} returns value of the \\spad{n}th cyclotomic polynomial at \\spad{r}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|NormalizedTriangularSetCategory| R E V P) 
((|constructor|
  (NIL
   "The category of normalized triangular sets. A triangular set \\spad{ts} is said normalized if for every algebraic variable \\spad{v} of \\spad{ts} the polynomial \\spad{select(ts,{} v)} is normalized \\spad{w}.\\spad{r}.\\spad{t}. every polynomial in \\spad{collectUnder(ts,{} v)}. A polynomial \\spad{p} is said normalized \\spad{w}.\\spad{r}.\\spad{t}. a non-constant polynomial \\spad{q} if \\spad{p} is constant or \\spad{degree(p,{} mdeg(q)) = 0} and \\spad{init(p)} is normalized \\spad{w}.\\spad{r}.\\spad{t}. \\spad{q}. One of the important features of normalized triangular sets is that they are regular sets."))) 
NIL 
(|Numeric| S) 
((|constructor|
  (NIL
   "Numeric provides real and complex numerical evaluation functions for various symbolic types."))
 (|numericIfCan|
  (((|Union| (|Float|) "failed") (|Expression| |#1|) (|PositiveInteger|))
   "\\spad{numericIfCan(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Float|) "failed") (|Expression| |#1|))
   "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Float|) "failed") (|Fraction| (|Polynomial| |#1|))
    (|PositiveInteger|))
   "\\spad{numericIfCan(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Float|) "failed") (|Fraction| (|Polynomial| |#1|)))
   "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Float|) "failed") (|Polynomial| |#1|) (|PositiveInteger|))
   "\\spad{numericIfCan(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Float|) "failed") (|Polynomial| |#1|))
   "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant."))
 (|complexNumericIfCan|
  (((|Union| (|Complex| (|Float|)) "failed") (|Expression| (|Complex| |#1|))
    (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Expression| (|Complex| |#1|)))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Expression| |#1|)
    (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Expression| |#1|))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed")
    (|Fraction| (|Polynomial| (|Complex| |#1|))) (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed")
    (|Fraction| (|Polynomial| (|Complex| |#1|))))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| |#1|))
    (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| |#1|)))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| |#1|)
    (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| |#1|))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| (|Complex| |#1|))
    (|PositiveInteger|))
   "\\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places,{} or \"failed\" if \\spad{x} is not a constant.")
  (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| (|Complex| |#1|)))
   "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x},{} or \"failed\" if \\spad{x} is not constant."))
 (|complexNumeric|
  (((|Complex| (|Float|)) (|Expression| (|Complex| |#1|)) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Expression| (|Complex| |#1|)))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Expression| |#1|) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Expression| |#1|))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Fraction| (|Polynomial| (|Complex| |#1|)))
    (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Fraction| (|Polynomial| (|Complex| |#1|))))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x}")
  (((|Complex| (|Float|)) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Polynomial| |#1|) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Polynomial| |#1|))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Polynomial| (|Complex| |#1|)) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Polynomial| (|Complex| |#1|)))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) (|Complex| |#1|) (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) (|Complex| |#1|))
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}.")
  (((|Complex| (|Float|)) |#1| (|PositiveInteger|))
   "\\spad{complexNumeric(x,{} n)} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Complex| (|Float|)) |#1|)
   "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x}."))
 (|numeric|
  (((|Float|) (|Expression| |#1|) (|PositiveInteger|))
   "\\spad{numeric(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Float|) (|Expression| |#1|))
   "\\spad{numeric(x)} returns a real approximation of \\spad{x}.")
  (((|Float|) (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|))
   "\\spad{numeric(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Float|) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{numeric(x)} returns a real approximation of \\spad{x}.")
  (((|Float|) (|Polynomial| |#1|) (|PositiveInteger|))
   "\\spad{numeric(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Float|) (|Polynomial| |#1|))
   "\\spad{numeric(x)} returns a real approximation of \\spad{x}.")
  (((|Float|) |#1| (|PositiveInteger|))
   "\\spad{numeric(x,{} n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.")
  (((|Float|) |#1|)
   "\\spad{numeric(x)} returns a real approximation of \\spad{x}."))) 
((|HasCategory| |#1| '(|IntegralDomain|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|Ring|)) (|HasCategory| |#1| '(|CommutativeRing|))) 
(|NumberFormats|) 
((|constructor|
  (NIL
   "NumberFormats provides function to format and read arabic and roman numbers,{} to convert numbers to strings and to read floating-point numbers."))
 (|FormatRadix|
  (((|String|) (|Integer|) (|Integer|))
   "\\spad{FormatRadix(n,{} r)} forms a string from an integer \\spad{n} in radix \\spad{r}."))
 (|ScanFloatIgnoreSpacesIfCan|
  (((|Union| (|Float|) "failed") (|String|))
   "\\spad{ScanFloatIgnoreSpacesIfCan(s)} tries to form a floating point number from the string \\spad{s} ignoring any spaces."))
 (|ScanFloatIgnoreSpaces|
  (((|Float|) (|String|))
   "\\spad{ScanFloatIgnoreSpaces(s)} forms a floating point number from the string \\spad{s} ignoring any spaces. Error is generated if the string is not recognised as a floating point number."))
 (|ScanRoman|
  (((|PositiveInteger|) (|String|))
   "\\spad{ScanRoman(s)} forms an integer from a Roman numeral string \\spad{s}."))
 (|FormatRoman|
  (((|String|) (|PositiveInteger|))
   "\\spad{FormatRoman(n)} forms a Roman numeral string from an integer \\spad{n}."))
 (|ScanArabic|
  (((|PositiveInteger|) (|String|))
   "\\spad{ScanArabic(s)} forms an integer from an Arabic numeral string \\spad{s}."))
 (|FormatArabic|
  (((|String|) (|PositiveInteger|))
   "\\spad{FormatArabic(n)} forms an Arabic numeral string from an integer \\spad{n}."))) 
NIL 
(|NumericalOrdinaryDifferentialEquations|) 
((|constructor|
  (NIL
   "This package is a suite of functions for the numerical integration of an ordinary differential equation of \\spad{n} variables: \\blankline \\indented{8}{\\center{dy/dx = \\spad{f}(\\spad{y},{} \\spad{x})\\space{5}\\spad{y} is an \\spad{n}-vector}} \\blankline \\par All the routines are based on a 4-th order Runge-Kutta kernel. These routines generally have as arguments: \\spad{n},{} the number of dependent variables; \\spad{x1},{} the initial point; \\spad{h},{} the step size; \\spad{y},{} a vector of initial conditions of length \\spad{n} which upon exit contains the solution at \\spad{x1 + h}; \\spad{derivs},{} a function which computes the right hand side of the ordinary differential equation: \\spad{derivs(dydx,{} y,{} x)} computes \\spad{dydx},{} a vector which contains the derivative information. \\blankline \\par In order of increasing complexity: \\begin{items} \\blankline \\item \\spad{rk4(y,{} n,{} x1,{} h,{} derivs)} advances the solution vector to \\spad{x1 + h} and return the values in \\spad{y}. \\blankline \\item \\spad{rk4(y,{} n,{} x1,{} h,{} derivs,{} t1,{} t2,{} t3,{} t4)} is the same as \\spad{rk4(y,{} n,{} x1,{} h,{} derivs)} except that you must provide 4 scratch arrays \\spad{t1}-\\spad{t4} of size \\spad{n}. \\blankline \\item Starting with \\spad{y} at \\spad{x1},{} \\spad{rk4f(y,{} n,{} x1,{} x2,{} ns,{} derivs)} uses \\spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance the solution vector to \\spad{x2} and return the values in \\spad{y}. Argument \\spad{x2},{} is the final point,{} and \\spad{ns},{} the number of steps to take. \\blankline \\item \\spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs)} takes a 5-th order Runge-Kutta step with monitoring of local truncation to ensure accuracy and adjust stepsize. The function takes two half steps and one full step and scales the difference in solutions at the final point. If the error is within \\spad{eps},{} the step is taken and the result is returned. If the error is not within \\spad{eps},{} the stepsize if decreased and the procedure is tried again until the desired accuracy is reached. Upon input,{} an trial step size must be given and upon return,{} an estimate of the next step size to use is returned as well as the step size which produced the desired accuracy. The scaled error is computed as \\center{\\spad{error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))}} and this is compared against \\spad{eps}. If this is greater than \\spad{eps},{} the step size is reduced accordingly to \\center{\\spad{hnew = 0.9 * hdid * (error/eps)^(-1/4)}} If the error criterion is satisfied,{} then we check if the step size was too fine and return a more efficient one. If \\spad{error} > \\spad{eps} * (6.0E-04) then the next step size should be \\center{\\spad{hnext} = 0.9 * hdid * (\\spad{error}/\\spad{eps})^(\\spad{-1/5})} Otherwise \\spad{hnext = 4.0 * hdid} is returned. A more detailed discussion of this and related topics can be found in the book \"Numerical Recipies\" by \\spad{W}.Press,{} \\spad{B}.\\spad{P}. Flannery,{} \\spad{S}.A. Teukolsky,{} \\spad{W}.\\spad{T}. Vetterling published by Cambridge University Press. Argument \\spad{step} is a record of 3 floating point numbers \\spad{(to_try ,{} did ,{} next)},{} \\spad{eps} is the required accuracy,{} \\spad{yscal} is the scaling vector for the difference in solutions. On input,{} \\spad{step.to_try} should be the guess at a step size to achieve the accuracy. On output,{} \\spad{step.did} contains the step size which achieved the accuracy and \\spad{step.next} is the next step size to use. \\blankline \\item \\spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs,{} t1,{} t2,{} t3,{} t4,{} t5,{} t6,{} t7)} is the same as \\spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs)} except that the user must provide the 7 scratch arrays \\spad{t1-t7} of size \\spad{n}. \\blankline \\item \\spad{rk4a(y,{} n,{} x1,{} x2,{} eps,{} h,{} ns,{} derivs)} is a driver program which uses \\spad{rk4qc} to integrate \\spad{n} ordinary differential equations starting at \\spad{x1} to \\spad{x2},{} keeping the local truncation error to within \\spad{eps} by changing the local step size. The scaling vector is defined as \\center{\\spad{yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny}} where \\spad{y(i)} is the solution at location \\spad{x},{} \\spad{dydx} is the ordinary differential equation\\spad{'s} right hand side,{} \\spad{h} is the current step size and \\spad{tiny} is 10 times the smallest positive number representable. The user must supply an estimate for a trial step size and the maximum number of calls to \\spad{rk4qc} to use. Argument \\spad{x2} is the final point,{} \\spad{eps} is local truncation,{} \\spad{ns} is the maximum number of call to \\spad{rk4qc} to use. \\end{items}"))
 (|rk4f|
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Integer|)
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)))
   "\\spad{rk4f(y,{} n,{} x1,{} x2,{} ns,{} derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation {\\em dy/dx = f(y,{} x)} of \\spad{n} variables,{} where \\spad{y} is an \\spad{n}-vector. Starting with \\spad{y} at \\spad{x1},{} this function uses \\spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance the solution vector to \\spad{x2} and return the values in \\spad{y}. For details,{} see \\con{NumericalOrdinaryDifferentialEquations}."))
 (|rk4qc|
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|)
    (|Record| (|:| |to_try| (|Float|)) (|:| |did| (|Float|))
              (|:| |next| (|Float|)))
    (|Float|) (|Vector| (|Float|))
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))
    (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|))
    (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|))
    (|Vector| (|Float|)))
   "\\spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs,{} t1,{} t2,{} t3,{} t4,{} t5,{} t6,{} t7)} is a subfunction for the numerical integration of an ordinary differential equation {\\em dy/dx = f(y,{} x)} of \\spad{n} variables,{} where \\spad{y} is an \\spad{n}-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \\spad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details,{} see \\con{NumericalOrdinaryDifferentialEquations}.")
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|)
    (|Record| (|:| |to_try| (|Float|)) (|:| |did| (|Float|))
              (|:| |next| (|Float|)))
    (|Float|) (|Vector| (|Float|))
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)))
   "\\spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs)} is a subfunction for the numerical integration of an ordinary differential equation {\\em dy/dx = f(y,{} x)} of \\spad{n} variables,{} where \\spad{y} is an \\spad{n}-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \\spad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details,{} see \\con{NumericalOrdinaryDifferentialEquations}."))
 (|rk4a|
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Float|)
    (|Float|) (|Integer|)
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)))
   "\\spad{rk4a(y,{} n,{} x1,{} x2,{} eps,{} h,{} ns,{} derivs)} is a driver function for the numerical integration of an ordinary differential equation {\\em dy/dx = f(y,{} x)} of \\spad{n} variables,{} where \\spad{y} is an \\spad{n}-vector using a 4-th order Runge-Kutta method. For details,{} see \\con{NumericalOrdinaryDifferentialEquations}."))
 (|rk4|
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|)
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))
    (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|))
    (|Vector| (|Float|)))
   "\\spad{rk4(y,{} n,{} x1,{} h,{} derivs,{} t1,{} t2,{} t3,{} t4)} is the same as \\spad{rk4(y,{} n,{} x1,{} h,{} derivs)} except that you must provide 4 scratch arrays \\spad{t1}-\\spad{t4} of size \\spad{n}. For details,{} see \\con{NumericalOrdinaryDifferentialEquations}.")
  (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|)
    (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)))
   "\\spad{rk4(y,{} n,{} x1,{} h,{} derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation {\\em dy/dx = f(y,{} x)} of \\spad{n} variables,{} where \\spad{y} is an \\spad{n}-vector. Argument \\spad{y} is a vector of initial conditions of length \\spad{n} which upon exit contains the solution at \\spad{x1 + h},{} \\spad{n} is the number of dependent variables,{} \\spad{x1} is the initial point,{} \\spad{h} is the step size,{} and \\spad{derivs} is a function which computes the right hand side of the ordinary differential equation. For details,{} see \\spadtype{NumericalOrdinaryDifferentialEquations}."))) 
NIL 
(|NumericalQuadrature| F) 
((|constructor|
  (NIL
   "This suite of routines performs numerical quadrature using algorithms derived from the basic trapezoidal rule. Because the error term of this rule contains only even powers of the step size (for open and closed versions),{} fast convergence can be obtained if the integrand is sufficiently smooth. \\blankline Each routine returns a Record of type TrapAns,{} which contains\\indent{3} \\newline value (\\spadtype{Float}): \\tab{20} estimate of the integral \\newline error (\\spadtype{Float}): \\tab{20} estimate of the error in the computation \\newline totalpts (\\spadtype{Integer}): \\tab{20} total number of function evaluations \\newline success (\\spadtype{Boolean}): \\tab{20} if the integral was computed within the user specified error criterion \\indent{0}\\indent{0} To produce this estimate,{} each routine generates an internal sequence of sub-estimates,{} denoted by {\\em S(i)},{} depending on the routine,{} to which the various convergence criteria are applied. The user must supply a relative accuracy,{} \\spad{eps_r},{} and an absolute accuracy,{} \\spad{eps_a}. Convergence is obtained when either \\center{\\spad{ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))}} \\center{or \\spad{ABS(S(i) - S(i-1)) < eps_a}} are \\spad{true} statements. \\blankline The routines come in three families and three flavors: \\newline\\tab{3} closed: \\tab{20}romberg,{} \\tab{30}simpson,{} \\tab{42}trapezoidal \\newline\\tab{3} open: \\tab{20}rombergo,{} \\tab{30}simpsono,{} \\tab{42}trapezoidalo \\newline\\tab{3} adaptive closed: \\tab{20}aromberg,{} \\tab{30}asimpson,{} \\tab{42}atrapezoidal \\par The {\\em S(i)} for the trapezoidal family is the value of the integral using an equally spaced absicca trapezoidal rule for that level of refinement. \\par The {\\em S(i)} for the simpson family is the value of the integral using an equally spaced absicca simpson rule for that level of refinement. \\par The {\\em S(i)} for the romberg family is the estimate of the integral using an equally spaced absicca romberg method. For the \\spad{i}\\spad{-}th level,{} this is an appropriate combination of all the previous trapezodial estimates so that the error term starts with the \\spad{2*(i+1)} power only. \\par The three families come in a closed version,{} where the formulas include the endpoints,{} an open version where the formulas do not include the endpoints and an adaptive version,{} where the user is required to input the number of subintervals over which the appropriate closed family integrator will apply with the usual convergence parameters for each subinterval. This is useful where a large number of points are needed only in a small fraction of the entire domain. \\par Each routine takes as arguments: \\newline \\spad{f}\\tab{10} integrand \\newline a\\tab{10} starting point \\newline \\spad{b}\\tab{10} ending point \\newline \\spad{eps_r}\\tab{10} relative error \\newline \\spad{eps_a}\\tab{10} absolute error \\newline \\spad{nmin} \\tab{10} refinement level when to start checking for convergence (> 1) \\newline \\spad{nmax} \\tab{10} maximum level of refinement \\par The adaptive routines take as an additional parameter \\newline \\spad{nint}\\tab{10} the number of independent intervals to apply a closed \\indented{1}{family integrator of the same name.} \\par Notes: \\newline Closed family level \\spad{i} uses \\spad{1 + 2^i} points. \\newline Open family level \\spad{i} uses \\spad{1 + 3^i} points."))
 (|trapezoidalo|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{trapezoidalo(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the trapezoidal method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|simpsono|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{simpsono(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the simpson method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|rombergo|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{rombergo(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the romberg method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|trapezoidal|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{trapezoidal(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the trapezoidal method to numerically integrate function \\spadvar{\\spad{fn}} over the closed interval \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|simpson|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{simpson(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the simpson method to numerically integrate function \\spad{fn} over the closed interval \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|romberg|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|))
   "\\spad{romberg(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax)} uses the romberg method to numerically integrate function \\spadvar{\\spad{fn}} over the closed interval \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|atrapezoidal|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{atrapezoidal(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive trapezoidal method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax},{} and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|asimpson|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{asimpson(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive simpson method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax},{} and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))
 (|aromberg|
  (((|Record| (|:| |value| |#1|) (|:| |error| |#1|)
              (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|)))
    (|Mapping| |#1| |#1|) |#1| |#1| |#1| |#1| (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{aromberg(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive romberg method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b},{} with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs},{} with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax},{} and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))) 
NIL 
(|NumericTubePlot| |Curve|) 
((|constructor|
  (NIL
   "\\indented{1}{Author: Clifton \\spad{J}. Williamson} Date Created: Bastille Day 1989 Keywords: Examples: Package for constructing tubes around 3-dimensional parametric curves."))
 (|tube|
  (((|TubePlot| |#1|) |#1| (|DoubleFloat|) (|Integer|))
   "\\spad{tube(c,{} r,{} n)} creates a tube of radius \\spad{r} around the curve \\spad{c}."))) 
NIL 
(|OrderedAbelianGroup|) 
((|constructor|
  (NIL
   "Ordered sets which are also abelian groups,{} such that the addition preserves the ordering."))) 
NIL 
(|OrderedAbelianMonoid|) 
((|constructor|
  (NIL
   "Ordered sets which are also abelian monoids,{} such that the addition preserves the ordering."))) 
NIL 
(|OrderedAbelianMonoidSup|) 
((|constructor|
  (NIL
   "This domain is an OrderedAbelianMonoid with a \\spadfun{sup} operation added. The purpose of the \\spadfun{sup} operator in this domain is to act as a supremum with respect to the partial order imposed by \\spadop{-},{} rather than with respect to the total \\spad{>} order (since that is \"max\"). \\blankline"))
 (|inf|
  (($ $ $)
   "\\spad{inf(x,{} y)} returns the largest element which can be subtracted from \\spad{x} and \\spad{y}."))
 (|sup|
  (($ $ $)
   "\\spad{sup(x,{} y)} returns the least element from which both \\spad{x} and \\spad{y} can be subtracted."))) 
NIL 
(|OrderedAbelianSemiGroup|) 
((|constructor|
  (NIL
   "Ordered sets which are also abelian semigroups,{} such that the addition preserves the ordering. \\indented{2}{\\spad{ x < y => x+z < y+z}}"))) 
NIL 
(|OctonionCategory&| S R) 
((|constructor|
  (NIL
   "OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the Complex numbers to get the quaternions."))
 (|inv|
  (($ $) "\\spad{inv(o)} returns the inverse of \\spad{o} if it exists."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(o)} returns the real part if all seven imaginary parts are 0,{} and \"failed\" otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(o)} returns the real part if all seven imaginary parts are 0. Error: if \\spad{o} is not rational."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(o)} tests if \\spad{o} is rational,{} \\spadignore{i.e.} that all seven imaginary parts are 0."))
 (|abs|
  ((|#2| $)
   "\\spad{abs(o)} computes the absolute value of an octonion,{} equal to the square root of the \\spadfunFrom{norm}{Octonion}."))
 (|octon|
  (($ |#2| |#2| |#2| |#2| |#2| |#2| |#2| |#2|)
   "\\spad{octon(re,{} \\spad{ri},{} rj,{} rk,{} rE,{} rI,{} rJ,{} rK)} constructs an octonion from scalars."))
 (|norm|
  ((|#2| $)
   "\\spad{norm(o)} returns the norm of an octonion,{} equal to the sum of the squares of its coefficients."))
 (|imagK|
  ((|#2| $)
   "\\spad{imagK(o)} extracts the imaginary \\spad{K} part of octonion \\spad{o}."))
 (|imagJ|
  ((|#2| $)
   "\\spad{imagJ(o)} extracts the imaginary \\spad{J} part of octonion \\spad{o}."))
 (|imagI|
  ((|#2| $)
   "\\spad{imagI(o)} extracts the imaginary \\spad{I} part of octonion \\spad{o}."))
 (|imagE|
  ((|#2| $)
   "\\spad{imagE(o)} extracts the imaginary \\spad{E} part of octonion \\spad{o}."))
 (|imagk|
  ((|#2| $)
   "\\spad{imagk(o)} extracts the \\spad{k} part of octonion \\spad{o}."))
 (|imagj|
  ((|#2| $)
   "\\spad{imagj(o)} extracts the \\spad{j} part of octonion \\spad{o}."))
 (|imagi|
  ((|#2| $)
   "\\spad{imagi(o)} extracts the \\spad{i} part of octonion \\spad{o}."))
 (|real|
  ((|#2| $) "\\spad{real(o)} extracts real part of octonion \\spad{o}."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(o)} negates the imaginary parts \\spad{i},{} \\spad{j},{} \\spad{k},{} \\spad{E},{} \\spad{I},{} \\spad{J},{} \\spad{K} of octonian \\spad{o}."))) 
((|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|IntegerNumberSystem|))
 (|HasCategory| |#2| '(|RealNumberSystem|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|OrderedSet|))) 
(|OctonionCategory| R) 
((|constructor|
  (NIL
   "OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the Complex numbers to get the quaternions."))
 (|inv|
  (($ $) "\\spad{inv(o)} returns the inverse of \\spad{o} if it exists."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(o)} returns the real part if all seven imaginary parts are 0,{} and \"failed\" otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(o)} returns the real part if all seven imaginary parts are 0. Error: if \\spad{o} is not rational."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(o)} tests if \\spad{o} is rational,{} \\spadignore{i.e.} that all seven imaginary parts are 0."))
 (|abs|
  ((|#1| $)
   "\\spad{abs(o)} computes the absolute value of an octonion,{} equal to the square root of the \\spadfunFrom{norm}{Octonion}."))
 (|octon|
  (($ |#1| |#1| |#1| |#1| |#1| |#1| |#1| |#1|)
   "\\spad{octon(re,{} \\spad{ri},{} rj,{} rk,{} rE,{} rI,{} rJ,{} rK)} constructs an octonion from scalars."))
 (|norm|
  ((|#1| $)
   "\\spad{norm(o)} returns the norm of an octonion,{} equal to the sum of the squares of its coefficients."))
 (|imagK|
  ((|#1| $)
   "\\spad{imagK(o)} extracts the imaginary \\spad{K} part of octonion \\spad{o}."))
 (|imagJ|
  ((|#1| $)
   "\\spad{imagJ(o)} extracts the imaginary \\spad{J} part of octonion \\spad{o}."))
 (|imagI|
  ((|#1| $)
   "\\spad{imagI(o)} extracts the imaginary \\spad{I} part of octonion \\spad{o}."))
 (|imagE|
  ((|#1| $)
   "\\spad{imagE(o)} extracts the imaginary \\spad{E} part of octonion \\spad{o}."))
 (|imagk|
  ((|#1| $)
   "\\spad{imagk(o)} extracts the \\spad{k} part of octonion \\spad{o}."))
 (|imagj|
  ((|#1| $)
   "\\spad{imagj(o)} extracts the \\spad{j} part of octonion \\spad{o}."))
 (|imagi|
  ((|#1| $)
   "\\spad{imagi(o)} extracts the \\spad{i} part of octonion \\spad{o}."))
 (|real|
  ((|#1| $) "\\spad{real(o)} extracts real part of octonion \\spad{o}."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(o)} negates the imaginary parts \\spad{i},{} \\spad{j},{} \\spad{k},{} \\spad{E},{} \\spad{I},{} \\spad{J},{} \\spad{K} of octonian \\spad{o}."))) 
NIL 
(|OrderedCancellationAbelianMonoid|) 
((|constructor|
  (NIL
   "Ordered sets which are also abelian cancellation monoids,{} such that the addition preserves the ordering."))) 
NIL 
(|Octonion| R) 
((|constructor|
  (NIL
   "Octonion implements octonions (Cayley-Dixon algebra) over a commutative ring,{} an eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the complex numbers to get the quaternions the main constructor function is {\\em octon} which takes 8 arguments: the real part,{} the \\spad{i} imaginary part,{} the \\spad{j} imaginary part,{} the \\spad{k} imaginary part,{} (as with quaternions) and in addition the imaginary parts \\spad{E},{} \\spad{I},{} \\spad{J},{} \\spad{K}."))
 (|octon|
  (($ (|Quaternion| |#1|) (|Quaternion| |#1|))
   "\\spad{octon(qe,{} qE)} constructs an octonion from two quaternions using the relation {\\em O = Q + QE}."))) 
((|HasCategory| |#1| '(|Finite|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| (|Quaternion| |#1|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (|HasCategory| (|Quaternion| |#1|) (LIST '|RetractableTo| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|RealNumberSystem|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| (|Quaternion| |#1|) (LIST '|RetractableTo| '(|Integer|))))) 
(|OctonionCategoryFunctions2| OR R OS S) 
((|constructor|
  (NIL
   "\\spad{OctonionCategoryFunctions2} implements functions between two octonion domains defined over different rings. The function map is used to coerce between octonion types."))
 (|map|
  ((|#3| (|Mapping| |#4| |#2|) |#1|)
   "\\spad{map(f,{} u)} maps \\spad{f} onto the component parts of the octonion \\spad{u}."))) 
NIL 
(|ConstantLODE| R F L) 
((|constructor|
  (NIL
   "Solution of linear ordinary differential equations,{} constant coefficient case."))
 (|constDsolve|
  (((|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|))) |#3| |#2|
    (|Symbol|))
   "\\spad{constDsolve(op,{} g,{} x)} returns \\spad{[f,{} [y1,{} ...,{} ym]]} where \\spad{f} is a particular solution of the equation \\spad{op y = g},{} and the \\spad{\\spad{yi}}\\spad{'s} form a basis for the solutions of \\spad{op y = 0}."))) 
NIL 
(|ElementaryFunctionODESolver| R F) 
((|constructor|
  (NIL
   "\\spad{ElementaryFunctionODESolver} provides the top-level functions for finding closed form solutions of ordinary differential equations and initial value problems."))
 (|solve|
  (((|Union| |#2| #1="failed") |#2| (|BasicOperator|) (|Equation| |#2|)
    (|List| |#2|))
   "\\spad{solve(eq,{} y,{} x = a,{} [y0,{} ...,{} ym])} returns either the solution of the initial value problem \\spad{eq,{} y(a) = y0,{} y'(a) = y1,{} ...} or \"failed\" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \\spad{dy/dx = f(x,{} y)}.")
  (((|Union| |#2| #1#) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|)
    (|List| |#2|))
   "\\spad{solve(eq,{} y,{} x = a,{} [y0,{} ...,{} ym])} returns either the solution of the initial value problem \\spad{eq,{} y(a) = y0,{} y'(a) = y1,{} ...} or \"failed\" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \\spad{dy/dx = f(x,{} y)}.")
  (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|)))
             |#2| #2="failed")
    |#2| (|BasicOperator|) (|Symbol|))
   "\\spad{solve(eq,{} y,{} x)} returns either a solution of the ordinary differential equation \\spad{eq} or \"failed\" if no non-trivial solution can be found; If the equation is linear ordinary,{} a solution is of the form \\spad{[h,{} [b1,{} ...,{} bm]]} where \\spad{h} is a particular solution and and \\spad{[b1,{} ...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{f(x,{} y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; If the equation is of the form {dy/dx = \\spad{f}(\\spad{x},{} \\spad{y})},{} a solution is of the form \\spad{h(x,{} y)} where \\spad{h(x,{} y) = c} is a first integral of the equation for any constant \\spad{c}.")
  (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|)))
             |#2| #2#)
    (|Equation| |#2|) (|BasicOperator|) (|Symbol|))
   "\\spad{solve(eq,{} y,{} x)} returns either a solution of the ordinary differential equation \\spad{eq} or \"failed\" if no non-trivial solution can be found; If the equation is linear ordinary,{} a solution is of the form \\spad{[h,{} [b1,{} ...,{} bm]]} where \\spad{h} is a particular solution and \\spad{[b1,{} ...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{f(x,{} y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; If the equation is of the form {dy/dx = \\spad{f}(\\spad{x},{} \\spad{y})},{} a solution is of the form \\spad{h(x,{} y)} where \\spad{h(x,{} y) = c} is a first integral of the equation for any constant \\spad{c}; error if the equation is not one of those 2 forms.")
  (((|Union|
     (|Record| (|:| |particular| (|Vector| |#2|))
               (|:| |basis| (|List| (|Vector| |#2|))))
     "failed")
    (|List| |#2|) (|List| (|BasicOperator|)) (|Symbol|))
   "\\spad{solve([eq_1,{}...,{}eq_n],{} [y_1,{}...,{}y_n],{} x)} returns either \"failed\" or,{} if the equations form a fist order linear system,{} a solution of the form \\spad{[y_p,{} [b_1,{} ...,{} b_n]]} where \\spad{h_p} is a particular solution and \\spad{[b_1,{} ...b_m]} are linearly independent solutions of the associated homogenuous system. error if the equations do not form a first order linear system")
  (((|Union|
     (|Record| (|:| |particular| (|Vector| |#2|))
               (|:| |basis| (|List| (|Vector| |#2|))))
     "failed")
    (|List| (|Equation| |#2|)) (|List| (|BasicOperator|)) (|Symbol|))
   "\\spad{solve([eq_1,{}...,{}eq_n],{} [y_1,{}...,{}y_n],{} x)} returns either \"failed\" or,{} if the equations form a fist order linear system,{} a solution of the form \\spad{[y_p,{} [b_1,{} ...,{} b_n]]} where \\spad{h_p} is a particular solution and \\spad{[b_1,{} ...b_m]} are linearly independent solutions of the associated homogenuous system. error if the equations do not form a first order linear system")
  (((|Union| (|List| (|Vector| |#2|)) "failed") (|Matrix| |#2|) (|Symbol|))
   "\\spad{solve(m,{} x)} returns a basis for the solutions of \\spad{D y = m y}. \\spad{x} is the dependent variable.")
  (((|Union|
     (|Record| (|:| |particular| (|Vector| |#2|))
               (|:| |basis| (|List| (|Vector| |#2|))))
     "failed")
    (|Matrix| |#2|) (|Vector| |#2|) (|Symbol|))
   "\\spad{solve(m,{} v,{} x)} returns \\spad{[v_p,{} [v_1,{} ...,{} v_m]]} such that the solutions of the system \\spad{D y = m y + v} are \\spad{v_p + c_1 v_1 + ... + c_m v_m} where the \\spad{c_i's} are constants,{} and the \\spad{v_i's} form a basis for the solutions of \\spad{D y = m y}. \\spad{x} is the dependent variable."))) 
NIL 
(|ODEIntegration| R F) 
((|constructor|
  (NIL
   "\\spadtype{ODEIntegration} provides an interface to the integrator. This package is intended for use by the differential equations solver but not at top-level."))
 (|diff|
  (((|Mapping| |#2| |#2|) (|Symbol|))
   "\\spad{diff(x)} returns the derivation with respect to \\spad{x}."))
 (|expint|
  ((|#2| |#2| (|Symbol|))
   "\\spad{expint(f,{} x)} returns e^{the integral of \\spad{f} with respect to \\spad{x}}."))
 (|int|
  ((|#2| |#2| (|Symbol|))
   "\\spad{int(f,{} x)} returns the integral of \\spad{f} with respect to \\spad{x}."))) 
NIL 
(|PureAlgebraicLODE| F UP UPUP R) 
((|constructor|
  (NIL
   "In-field solution of an linear ordinary differential equation,{} pure algebraic case."))
 (|algDsolve|
  (((|Record|
     (|:| |particular|
          (|List|
           (|Record| (|:| |ratpart| |#4|) (|:| |coeffs| (|Vector| |#1|)))))
     (|:| |basis| (|List| |#4|)))
    (|LinearOrdinaryDifferentialOperator1| |#4|) (|List| |#4|))
   "\\spad{algDsolve(op,{} lg)} is a parametric version of algDsolve(\\spad{op},{} \\spad{g})")
  (((|Record| (|:| |particular| (|Union| |#4| "failed"))
              (|:| |basis| (|List| |#4|)))
    (|LinearOrdinaryDifferentialOperator1| |#4|) |#4|)
   "\\spad{algDsolve(op,{} g)} returns \\spad{[\"failed\",{} []]} if the equation \\spad{op y = g} has no solution in \\spad{R}. Otherwise,{} it returns \\spad{[f,{} [y1,{} ...,{} ym]]} where \\spad{f} is a particular rational solution and the \\spad{y_i's} form a basis for the solutions in \\spad{R} of the homogeneous equation."))) 
NIL 
(|PrimitiveRatDE| F UP L LQ) 
((|constructor|
  (NIL
   "\\spad{PrimitiveRatDE} provides functions for in-field solutions of linear \\indented{1}{ordinary differential equations,{} in the transcendental case.} \\indented{1}{The derivation to use is given by the parameter \\spad{L}.}"))
 (|splitDenominator|
  (((|Record| (|:| |eq| |#3|) (|:| |rh| (|List| (|Fraction| |#2|)))) |#4|
    (|List| (|Fraction| |#2|)))
   "\\spad{splitDenominator(op,{} [g1,{} ...,{} gm])} returns \\spad{op0,{} [h1,{} ...,{} hm]} such that the equations \\spad{op y = c1 g1 + ... + cm gm} and \\spad{op0 y = c1 h1 + ... + cm hm} have the same solutions."))
 (|indicialEquation|
  ((|#2| |#4| |#1|)
   "\\spad{indicialEquation(op,{} a)} returns the indicial equation of \\spad{op} at \\spad{a}.")
  ((|#2| |#3| |#1|)
   "\\spad{indicialEquation(op,{} a)} returns the indicial equation of \\spad{op} at \\spad{a}."))
 (|indicialEquations|
  (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#4| |#2|)
   "\\spad{indicialEquations(op,{} p)} returns \\spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \\spad{d_i}\\spad{'s} are the affine singularities of \\spad{op} above the roots of \\spad{p},{} and the \\spad{e_i}\\spad{'s} are the indicial equations at each \\spad{d_i}.")
  (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#4|)
   "\\spad{indicialEquations op} returns \\spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \\spad{d_i}\\spad{'s} are the affine singularities of \\spad{op},{} and the \\spad{e_i}\\spad{'s} are the indicial equations at each \\spad{d_i}.")
  (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#3| |#2|)
   "\\spad{indicialEquations(op,{} p)} returns \\spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \\spad{d_i}\\spad{'s} are the affine singularities of \\spad{op} above the roots of \\spad{p},{} and the \\spad{e_i}\\spad{'s} are the indicial equations at each \\spad{d_i}.")
  (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#3|)
   "\\spad{indicialEquations op} returns \\spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \\spad{d_i}\\spad{'s} are the affine singularities of \\spad{op},{} and the \\spad{e_i}\\spad{'s} are the indicial equations at each \\spad{d_i}."))
 (|denomLODE|
  ((|#2| |#3| (|List| (|Fraction| |#2|)))
   "\\spad{denomLODE(op,{} [g1,{} ...,{} gm])} returns a polynomial \\spad{d} such that any rational solution of \\spad{op y = c1 g1 + ... + cm gm} is of the form \\spad{p/d} for some polynomial \\spad{p}.")
  (((|Union| |#2| "failed") |#3| (|Fraction| |#2|))
   "\\spad{denomLODE(op,{} g)} returns a polynomial \\spad{d} such that any rational solution of \\spad{op y = g} is of the form \\spad{p/d} for some polynomial \\spad{p},{} and \"failed\",{} if the equation has no rational solution."))) 
NIL 
(|PrimitiveRatRicDE| F UP L LQ) 
((|constructor|
  (NIL "In-field solution of Riccati equations,{} primitive case."))
 (|changeVar|
  ((|#3| |#3| (|Fraction| |#2|))
   "\\spad{changeVar(+/[\\spad{ai} D^i],{} a)} returns the operator \\spad{+/[\\spad{ai} (D+a)\\spad{^i}]}.")
  ((|#3| |#3| |#2|)
   "\\spad{changeVar(+/[\\spad{ai} D^i],{} a)} returns the operator \\spad{+/[\\spad{ai} (D+a)\\spad{^i}]}."))
 (|singRicDE|
  (((|List| (|Record| (|:| |frac| (|Fraction| |#2|)) (|:| |eq| |#3|))) |#3|
    (|Mapping| (|List| |#2|) |#2| (|SparseUnivariatePolynomial| |#2|))
    (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{singRicDE(op,{} zeros,{} ezfactor)} returns \\spad{[[f1,{} L1],{} [f2,{} L2],{} ... ,{} [fk,{} Lk]]} such that the singular part of any rational solution of the associated Riccati equation of \\spad{op y=0} must be one of the \\spad{fi}\\spad{'s} (up to the constant coefficient),{} in which case the equation for \\spad{z=y e^{-int p}} is \\spad{\\spad{Li} z=0}. \\spad{zeros(C(x),{} H(x,{} y))} returns all the \\spad{P_i(x)}\\spad{'s} such that \\spad{H(x,{} P_i(x)) = 0 modulo C(x)}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles."))
 (|polyRicDE|
  (((|List| (|Record| (|:| |poly| |#2|) (|:| |eq| |#3|))) |#3|
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{polyRicDE(op,{} zeros)} returns \\spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{} Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op y=0} must be one of the \\spad{pi}\\spad{'s} (up to the constant coefficient),{} in which case the equation for \\spad{z=y e^{-int p}} is \\spad{\\spad{Li} z =0}. \\spad{zeros} is a zero finder in \\spad{UP}."))
 (|constantCoefficientRicDE|
  (((|List| (|Record| (|:| |constant| |#1|) (|:| |eq| |#3|))) |#3|
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{constantCoefficientRicDE(op,{} ric)} returns \\spad{[[a1,{} L1],{} [a2,{} L2],{} ... ,{} [ak,{} Lk]]} such that any rational solution with no polynomial part of the associated Riccati equation of \\spad{op y = 0} must be one of the \\spad{ai}\\spad{'s} in which case the equation for \\spad{z = y e^{-int \\spad{ai}}} is \\spad{\\spad{Li} z = 0}. \\spad{ric} is a Riccati equation solver over \\spad{F},{} whose input is the associated linear equation."))
 (|leadingCoefficientRicDE|
  (((|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |eq| |#2|)))
    |#3|)
   "\\spad{leadingCoefficientRicDE(op)} returns \\spad{[[m1,{} p1],{} [m2,{} p2],{} ... ,{} [mk,{} pk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op y = 0} must have degree \\spad{mj} for some \\spad{j},{} and its leading coefficient is then a zero of \\spad{pj}. In addition,{} \\spad{m1>m2> ... >mk}."))
 (|denomRicDE|
  ((|#2| |#3|)
   "\\spad{denomRicDE(op)} returns a polynomial \\spad{d} such that any rational solution of the associated Riccati equation of \\spad{op y = 0} is of the form \\spad{p/d + q'/q + r} for some polynomials \\spad{p} and \\spad{q} and a reduced \\spad{r}. Also,{} \\spad{deg(p) < deg(d)} and {\\spad{gcd}(\\spad{d},{} \\spad{q}) = 1}."))) 
NIL 
(|RationalLODE| F UP) 
((|constructor|
  (NIL
   "\\spad{RationalLODE} provides functions for in-field solutions of linear \\indented{1}{ordinary differential equations,{} in the rational case.}"))
 (|integrate_sols|
  (((|Record|
     (|:| |ltilde| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
     (|:| |r|
          (|Union| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
                   "failed")))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
   "\\spad{integrate_sols(l)} integrates the solutions of an operator \\spad{l}."))
 (|indicialEquationAtInfinity|
  ((|#2| (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)))
   "\\spad{indicialEquationAtInfinity op} returns the indicial equation of \\spad{op} at infinity.")
  ((|#2| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
   "\\spad{indicialEquationAtInfinity op} returns the indicial equation of \\spad{op} at infinity."))
 (|ratDsolve|
  (((|Record| (|:| |basis| (|List| (|Fraction| |#2|)))
              (|:| |mat| (|Matrix| |#1|)))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|List| (|Fraction| |#2|)))
   "\\spad{ratDsolve(op,{} [g1,{} ...,{} gm])} returns \\spad{[[h1,{} ...,{} hq],{} M]} such that any rational solution of \\spad{op y = c1 g1 + ... + cm gm} is of the form \\spad{c1 h1 + ... + cq hq} where \\spad{M [c1,{} ...,{} cq] = 0} and \\spad{q >= m}.")
  (((|Record| (|:| |particular| (|Union| (|Fraction| |#2|) #1="failed"))
              (|:| |basis| (|List| (|Fraction| |#2|))))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Fraction| |#2|))
   "\\spad{ratDsolve(op,{} g)} returns \\spad{[\"failed\",{} []]} if the equation \\spad{op y = g} has no rational solution. Otherwise,{} it returns \\spad{[f,{} [y1,{} ...,{} ym]]} where \\spad{f} is a particular rational solution and the \\spad{yi}\\spad{'s} form a basis for the rational solutions of the homogeneous equation.")
  (((|Record| (|:| |basis| (|List| (|Fraction| |#2|)))
              (|:| |mat| (|Matrix| |#1|)))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|List| (|Fraction| |#2|)))
   "\\spad{ratDsolve(op,{} [g1,{} ...,{} gm])} returns \\spad{[[h1,{} ...,{} hq],{} M]} such that any rational solution of \\spad{op y = c1 g1 + ... + cm gm} is of the form \\spad{c1 h1 + ... + cq hq} where \\spad{M [c1,{} ...,{} cq] = 0} and \\spad{q >= m}.")
  (((|Record| (|:| |particular| (|Union| (|Fraction| |#2|) #1#))
              (|:| |basis| (|List| (|Fraction| |#2|))))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|Fraction| |#2|))
   "\\spad{ratDsolve(op,{} g)} returns \\spad{[\"failed\",{} []]} if the equation \\spad{op y = g} has no rational solution. Otherwise,{} it returns \\spad{[f,{} [y1,{} ...,{} ym]]} where \\spad{f} is a particular rational solution and the \\spad{yi}\\spad{'s} form a basis for the rational solutions of the homogeneous equation."))) 
NIL 
(|ReduceLODE| F L UP A LO) 
((|constructor|
  (NIL
   "Elimination of an algebraic from the coefficients of a linear ordinary differential equation."))
 (|reduceLODE|
  (((|Record| (|:| |mat| (|Matrix| |#2|))
              (|:| |vecs| (|List| (|Vector| |#1|))))
    |#5| (|List| |#4|))
   "\\spad{reduceLODE(op,{} [g1,{} ...,{} gn])} returns \\spad{[m,{} [v1,{} ...,{} vn]]} such that any solution in \\spad{A} of \\spad{op z = c1*g1 + ... + cn*gn} where \\spad{ci} are constants satisfy the differential system \\spad{M.z = c1*v1 + ... + cn*vn}")
  (((|Record| (|:| |mat| (|Matrix| |#2|)) (|:| |vec| (|Vector| |#1|))) |#5|
    |#4|)
   "\\spad{reduceLODE(op,{} g)} returns \\spad{[m,{} v]} such that any solution in \\spad{A} of \\spad{op z = g} is of the form \\spad{z = (z_1,{} ...,{} z_m) . (b_1,{} ...,{} b_m)} where the \\spad{b_i's} are the basis of \\spad{A} over \\spad{F} returned by \\spadfun{basis}() from \\spad{A},{} and the \\spad{z_i's} satisfy the differential system \\spad{M.z = v}."))) 
NIL 
(|RationalRicDE| F UP) 
((|constructor|
  (NIL "In-field solution of Riccati equations,{} rational case."))
 (|polyRicDE|
  (((|List|
     (|Record| (|:| |poly| |#2|)
               (|:| |eq|
                    (|LinearOrdinaryDifferentialOperator2| |#2|
                                                           (|Fraction|
                                                            |#2|)))))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{polyRicDE(op,{} zeros)} returns \\spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{} Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op y = 0} must be one of the \\spad{pi}\\spad{'s} (up to the constant coefficient),{} in which case the equation for \\spad{z = y e^{-int p}} is \\spad{\\spad{Li} z = 0}. \\spad{zeros} is a zero finder in \\spad{UP}."))
 (|singRicDE|
  (((|List|
     (|Record| (|:| |frac| (|Fraction| |#2|))
               (|:| |eq|
                    (|LinearOrdinaryDifferentialOperator2| |#2|
                                                           (|Fraction|
                                                            |#2|)))))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{singRicDE(op,{} ezfactor)} returns \\spad{[[f1,{} L1],{} [f2,{} L2],{} ...,{} [fk,{} Lk]]} such that the singular \\spad{++} part of any rational solution of the associated Riccati equation of \\spad{op y = 0} must be one of the \\spad{fi}\\spad{'s} (up to the constant coefficient),{} in which case the equation for \\spad{z = y e^{-int \\spad{ai}}} is \\spad{\\spad{Li} z = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles."))
 (|ricDsolve|
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{ricDsolve(op,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)))
   "\\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{ricDsolve(op,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)))
   "\\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|) (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{ricDsolve(op,{} zeros,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. \\spad{zeros} is a zero finder in \\spad{UP}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{ricDsolve(op,{} zeros)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. \\spad{zeros} is a zero finder in \\spad{UP}.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|) (|Mapping| (|Factored| |#2|) |#2|))
   "\\spad{ricDsolve(op,{} zeros,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. \\spad{zeros} is a zero finder in \\spad{UP}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP},{} not necessarily into irreducibles.")
  (((|List| (|Fraction| |#2|))
    (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))
    (|Mapping| (|List| |#1|) |#2|))
   "\\spad{ricDsolve(op,{} zeros)} returns the rational solutions of the associated Riccati equation of \\spad{op y = 0}. \\spad{zeros} is a zero finder in \\spad{UP}."))) 
((|HasCategory| |#1| '(|AlgebraicallyClosedField|))) 
(|SystemODESolver| F LO) 
((|constructor|
  (NIL
   "SystemODESolver provides tools for triangulating and solving some systems of linear ordinary differential equations."))
 (|solveInField|
  (((|Record|
     (|:| |particular|
          (|List|
           (|Record| (|:| |ratpart| (|Vector| |#1|))
                     (|:| |coeffs| (|Vector| |#1|)))))
     (|:| |basis| (|List| (|Vector| |#1|))))
    (|Matrix| |#2|) (|List| (|Vector| |#1|))
    (|Mapping|
     (|Record|
      (|:| |particular|
           (|List|
            (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|)))))
      (|:| |basis| (|List| |#1|)))
     |#2| (|List| |#1|)))
   "\\spad{solveInField(m,{} lv,{} solve)} is a parametric version of solveInField(\\spad{m},{} \\spad{v},{} solve)")
  (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed"))
              (|:| |basis| (|List| (|Vector| |#1|))))
    (|Matrix| |#2|) (|Vector| |#1|)
    (|Mapping|
     (|Record| (|:| |particular| (|Union| |#1| "failed"))
               (|:| |basis| (|List| |#1|)))
     |#2| |#1|))
   "\\spad{solveInField(m,{} v,{} solve)} returns \\spad{[[v_1,{} ...,{} v_m],{} v_p]} such that the solutions in \\spad{F} of the system \\spad{m x = v} are \\spad{v_p + c_1 v_1 + ... + c_m v_m} where the \\spad{c_i's} are constants,{} and the \\spad{v_i's} form a basis for the solutions of \\spad{m x = 0}. Argument \\spad{solve} is a function for solving a single linear ordinary differential equation in \\spad{F}."))
 (|solve|
  (((|Record|
     (|:| |particular|
          (|List|
           (|Record| (|:| |ratpart| (|Vector| |#1|))
                     (|:| |coeffs| (|Vector| |#1|)))))
     (|:| |basis| (|List| (|Vector| |#1|))))
    (|Matrix| |#1|) (|List| (|Vector| |#1|))
    (|Mapping|
     (|Record|
      (|:| |particular|
           (|List|
            (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|)))))
      (|:| |basis| (|List| |#1|)))
     |#2| (|List| |#1|)))
   "\\spad{solve(m,{} lv,{} solve)} is a parametric version of solve(\\spad{m},{} \\spad{v},{} solve)")
  (((|Union|
     (|Record| (|:| |particular| (|Vector| |#1|))
               (|:| |basis| (|Matrix| |#1|)))
     "failed")
    (|Matrix| |#1|) (|Vector| |#1|)
    (|Mapping|
     (|Union| (|Record| (|:| |particular| |#1|) (|:| |basis| (|List| |#1|)))
              "failed")
     |#2| |#1|))
   "\\spad{solve(m,{} v,{} solve)} returns \\spad{[v_p,{} bm]} such that the solutions in \\spad{F} of the system \\spad{D x = m x + v} are \\spad{v_p + c_1 v_1 + ... + c_m v_m} where the \\spad{c_i's} are constants,{} and the \\spad{v_i's} are columns of \\spad{bm} and form a basis for the solutions of \\spad{D x = m x}. Argument \\spad{solve} is a function for solving a single linear ordinary differential equation in \\spad{F}."))
 (|triangulate|
  (((|Record| (|:| |mat| (|Matrix| |#2|))
              (|:| |vecs| (|List| (|Vector| |#1|))))
    (|Matrix| |#2|) (|List| (|Vector| |#1|)))
   "\\spad{triangulate(m,{} [v1,{} ...,{} vn])} returns \\spad{[m_0,{} [w1,{} ...,{} wn]]} such that for any constant \\spad{c1,{} ...,{} cn} the system \\spad{m_0 x = c1*w1 + ... + cn*wn} is equivalent to to \\spad{m x = c1*v1 + ... + cn*vn}")
  (((|Record| (|:| |mat| (|Matrix| |#2|)) (|:| |vec| (|Vector| |#1|)))
    (|Matrix| |#2|) (|Vector| |#1|))
   "\\spad{triangulate(m,{} v)} returns \\spad{[m_0,{} v_0]} such that \\spad{m_0} is upper triangular and the system \\spad{m_0 x = v_0} is equivalent to \\spad{m x = v}.")
  (((|Record| (|:| A (|Matrix| |#1|))
              (|:| |eqs|
                   (|List|
                    (|Record| (|:| C (|Matrix| |#1|))
                              (|:| |lg| (|List| (|Vector| |#1|)))
                              (|:| |eq| |#2|) (|:| |lrh| (|List| |#1|))))))
    (|Matrix| |#1|) (|List| (|Vector| |#1|)))
   "\\spad{triangulate(A,{} lv)} is a parametric version of triangulate(A,{} \\spad{v}).")
  (((|Record| (|:| A (|Matrix| |#1|))
              (|:| |eqs|
                   (|List|
                    (|Record| (|:| C (|Matrix| |#1|)) (|:| |g| (|Vector| |#1|))
                              (|:| |eq| |#2|) (|:| |rh| |#1|)))))
    (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{triangulate(M,{} v)} returns \\spad{A,{} [[C_1,{} g_1,{} L_1,{} h_1],{} ...,{} [C_k,{} g_k,{} L_k,{} h_k]]} such that under the change of variable \\spad{y = A z},{} the first order linear system \\spad{D y = M y + v} is uncoupled as \\spad{D z_i = C_i z_i + g_i} and each \\spad{C_i} is a companion matrix corresponding to the scalar equation \\spad{L_i z_j = h_i}."))) 
NIL 
(|ODETools| F LODO) 
((|constructor|
  (NIL "\\spad{ODETools} provides tools for the linear ODE solver."))
 (|particularSolution|
  (((|Union| |#1| "failed") |#2| |#1| (|List| |#1|) (|Mapping| |#1| |#1|))
   "\\spad{particularSolution(op,{} g,{} [f1,{} ...,{} fm],{} I)} returns a particular solution \\spad{h} of the equation \\spad{op y = g} where \\spad{[f1,{} ...,{} fm]} are linearly independent and \\spad{op(\\spad{fi})=0}. The value \"failed\" is returned if no particular solution is found. Note: the method of variations of parameters is used."))
 (|variationOfParameters|
  (((|Union| (|Vector| |#1|) "failed") |#2| |#1| (|List| |#1|))
   "\\spad{variationOfParameters(op,{} g,{} [f1,{} ...,{} fm])} returns \\spad{[u1,{} ...,{} um]} such that a particular solution of the equation \\spad{op y = g} is \\spad{f1 int(u1) + ... + fm int(um)} where \\spad{[f1,{} ...,{} fm]} are linearly independent and \\spad{op(\\spad{fi})=0}. The value \"failed\" is returned if \\spad{m < n} and no particular solution is found."))
 (|wronskianMatrix|
  (((|Matrix| |#1|) (|List| |#1|) (|NonNegativeInteger|))
   "\\spad{wronskianMatrix([f1,{} ...,{} fn],{} q)} returns the \\spad{q x n} matrix \\spad{m} whose i^th row is \\spad{[f1^(i-1),{} ...,{} fn^(i-1)]}.")
  (((|Matrix| |#1|) (|List| |#1|))
   "\\spad{wronskianMatrix([f1,{} ...,{} fn])} returns the \\spad{n x n} matrix \\spad{m} whose i^th row is \\spad{[f1^(i-1),{} ...,{} fn^(i-1)]}."))) 
NIL 
(|OrderedDirectProduct| |dim| S |f|) 
((|constructor|
  (NIL
   "\\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The ordering on the type is determined by its third argument which represents the less than function on vectors. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#2| '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| '(|unitsKnown|)) (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRng|))
 (|HasCategory| |#2| '(|Ring|)) (|HasCategory| |#2| '(|Monoid|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|Finite|))
 (OR (|HasCategory| |#2| '(|Finite|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| |#2| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|OrderedSet|)))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| '(|DifferentialRing|))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|Monoid|)))
 (AND (|HasCategory| |#2| '(|AbelianMonoid|))
      (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| '(|SemiGroup|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR (|HasCategory| |#2| '(|Monoid|)) (|HasCategory| |#2| '(|SemiGroup|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|BasicType|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|))
     (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Monoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Ring|))
     (|HasCategory| |#2| '(|SemiGroup|)) (|HasCategory| |#2| '(|SemiRng|))
     (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|)) (|HasCategory| |#2| '(|SemiRng|)))
 (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
 (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|OrderedSet|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiGroup|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SemiRng|)))
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#2| '(|SetCategory|)))
  (|HasCategory| |#2| '(|Ring|)))
 (AND
  (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#2| '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND
      (|HasCategory| |#2|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
          (|HasCategory| |#2| '(|SetCategory|)))
     (AND (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| |#2| '(|SemiRng|)))
     (AND (|HasCategory| |#2| '(|AbelianMonoid|))
          (|HasCategory| |#2| '(|SemiRng|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Finite|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Monoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SemiRng|)))
  (AND
   (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#2| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|SemiRng|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|SemiRng|)) (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|)))) 
(|OrderlyDifferentialPolynomial| R) 
((|constructor|
  (NIL
   "\\spadtype{OrderlyDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates,{} with coefficients in a ring. The ranking on the differential indeterminate is orderly. This is analogous to the domain \\spadtype{Polynomial}. \\blankline"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|IndexedExponents| (|OrderlyDifferentialVariable| (|Symbol|)))
                '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|OrdinaryDifferentialRing| |Kernels| R |var|) 
((|constructor|
  (NIL
   "This constructor produces an ordinary differential ring from a partial differential ring by specifying a variable."))
 (|coerce|
  ((|#2| $)
   "\\spad{coerce(p)} views \\spad{p} as a valie in the partial differential ring.")
  (($ |#2|)
   "\\spad{coerce(r)} views \\spad{r} as a value in the ordinary differential ring."))) 
((|HasCategory| |#2| '(|Field|))) 
(|OrderlyDifferentialVariable| S) 
((|constructor|
  (NIL
   "\\spadtype{OrderlyDifferentialVariable} adds a commonly used orderly ranking to the set of derivatives of an ordered list of differential indeterminates. An orderly ranking is a ranking \\spadfun{<} of the derivatives with the property that for two derivatives \\spad{u} and \\spad{v},{} \\spad{u} \\spadfun{<} \\spad{v} if the \\spadfun{order} of \\spad{u} is less than that of \\spad{v}. This domain belongs to \\spadtype{DifferentialVariableCategory}. It defines \\spadfun{weight} to be just \\spadfun{order},{} and it defines an orderly ranking \\spadfun{<} on derivatives \\spad{u} via the lexicographic order on the pair (\\spadfun{order}(\\spad{u}),{} \\spadfun{variable}(\\spad{u}))."))) 
NIL 
(|OrderedExpression|) 
NIL 
NIL 
(|OrientedFacet|) 
((|constructor|
  (NIL
   "\\indented{2}{A single vertex,{} edge,{} triangle...} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/} Date Created: March 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:"))
 (|refactorIndexes|
  (($ $ (|NonNegativeInteger|))
   "adds \\spad{'n'} to each index. Used to refactor simplexes so that they don\\spad{'t} overlap."))
 (|addVertex|
  (($ $ (|NonNegativeInteger|)) "used by cone. Adds a vertex to face."))
 (|product|
  (((|List| (|ProductFacet|)) $ $)
   "This function returns the product of two facets. For more detailed explanation of simplex product code see: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Also see Hatcher [9]. page 277 - The simplicial cross product. page 278 - The cohomology cross product. Returns list,{} each entry is a 'lattice path' from (0,{} 0) to (\\spad{x},{} \\spad{y}) where \\spad{x} is number of entries in sa and \\spad{y} is number of entries in \\spad{sb}."))
 (|boolWordPermute|
  (((|List| (|List| (|Boolean|))) (|List| (|List| (|Boolean|)))
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "recursive part of boolWordPermute")
  (((|List| (|List| (|Boolean|))) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "boolean word permutation find all permutations of numZeros and numOnes used by product to calculate all paths through lattice"))
 (|reindex|
  (($ $) "re-index so that indexes start at 1 and are then consecutive."))
 (|subtract|
  (($ $ $)
   "used by link. Returns face 'a' minus the vertices in face \\spad{'b'}."))
 (|join|
  (($ $ $)
   "used by simplicialJoin. Returns join (union) of 'a' and \\spad{'b'}. That is: returns a facet containing indexes in both 'a' and \\spad{'b'}."))
 (|sameFace?|
  (((|Boolean|) $ $)
   "\\spad{true} if this is the same face although the orientation may be different"))
 (|position|
  (((|Integer|) $ (|List| $))
   "return index of \\spad{e} in \\spad{lst}. Index will be negative if \\spad{e} has negative multiplier."))
 (|isSubsetOf?|
  (((|Boolean|) $ $)
   "returns \\spad{true} if face 'a' is contained in face \\spad{'b'}. \\spad{true} subset only : returns \\spad{false} if a=b"))
 (|allSubsets|
  (((|List| $) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{allSubsets of} a given length returned in reverse order subsets returned are not oriented")
  (((|List| $) $ (|NonNegativeInteger|))
   "\\spad{allSubsets of} a given facet returned in reverse order subsets returned are not oriented"))
 (|boundary|
  (((|List| $) $)
   "construct the boundary. This is like hollowing out the facet."))
 (|setMult!| (($ $ (|Integer|)) "sets multiplier of face"))
 (|getIndexesSigned|
  (((|List| (|Integer|)) $)
   "returns indexes in face with sign to give orientation"))
 (|maxIndex| (((|NonNegativeInteger|) $) "returns maximum index"))
 (|minIndex| (((|NonNegativeInteger|) $) "returns minimum index"))
 (|getIndexes| (((|List| (|NonNegativeInteger|)) $) "returns indexes in face"))
 (|orientedFacetIfCan|
  (((|Union| $ "failed") (|List| $))
   "Constructor for oriented face from its boundary. This is like filling-in the boundary,{} in that sense it is the inverse of 'boundary'. May fail,{} for instance in 'implied' loops,{} where both ends of an edge are the same point. Also similar cases for higher order facets."))
 (|orientedFacetSigned|
  (($ (|List| (|Integer|)))
   "Constructor for oriented face which removes duplicates If the face is positive then we expect the sequence to be: + - + - ..."))
 (|orientedFacetUnsigned|
  (($ (|List| (|Integer|)))
   "Constructor for oriented face which removes duplicates and ignores orientation"))
 (|orientedFacet|
  (($ (|Integer|) (|OrientedFacet|)) "Copy constructor which can change mul")
  (($ (|Integer|) (|List| (|NonNegativeInteger|)))
   "Constructor for oriented facet oriented facet is always stored in vertex order orientation is calculated by the number of edges that have to be flipped to put it in order."))) 
NIL 
(|OutputFormTools|) 
((|precondition|
  (((|OutputForm|) (|OutputForm|))
   "\\spad{precondition(f)} prepares form for formatting."))
 (|construct|
  (((|OutputForm|) (|OutputForm|) (|List| (|OutputForm|)))
   "\\spad{construct(op,{} la)} creates OutputForm with operator \\spad{op} and arguments la"))
 (|is_symbol?|
  (((|Boolean|) (|OutputForm|) (|Symbol|))
   "\\spad{is_symbol?(f,{} s)} returns \\spad{true} if form is symbol \\spad{s},{} otherwise returns \\spad{false}"))
 (|has_op?|
  (((|Boolean|) (|OutputForm|) (|Symbol|))
   "\\spad{has_op?(f,{} s)} returns \\spad{true} is \\spad{f} is a composite from with operator \\spad{s},{} otherwise returns \\spad{false}"))
 (|arguments|
  (((|List| (|OutputForm|)) (|OutputForm|))
   "\\spad{arguments(f)} gives arguments of form \\spad{f}. Valid only when atom?(\\spad{f}) is \\spad{false}"))
 (|operator|
  (((|OutputForm|) (|OutputForm|))
   "\\spad{operator(f)} gives operator (head) of form \\spad{f}. Valid only when atom?(\\spad{f}) is \\spad{false}"))
 (|string|
  (((|String|) (|OutputForm|))
   "\\spad{string(f)} gives string corresponding to \\spad{f}. Valid only when string?(\\spad{f}) is \\spad{true}"))
 (|string?|
  (((|Boolean|) (|OutputForm|))
   "\\spad{string?(f)} checks if \\spad{f} is a string,{} this implies atom?(\\spad{f})"))
 (|symbol|
  (((|Symbol|) (|OutputForm|))
   "\\spad{symbol(f)} gives symbol corresponding to \\spad{f}. Valid only when symbol?(\\spad{f}) is \\spad{true}"))
 (|symbol?|
  (((|Boolean|) (|OutputForm|))
   "\\spad{symbol?(f)} checks if \\spad{f} is a symbol,{} this implies atom?(\\spad{f})"))
 (|integer|
  (((|Integer|) (|OutputForm|))
   "\\spad{integer(f)} gives integer corresponding to \\spad{f}. Valid only when integer?(\\spad{f}) is \\spad{true}"))
 (|integer?|
  (((|Boolean|) (|OutputForm|))
   "\\spad{integer?(f)} checks if \\spad{f} is an integer,{} this implies atom?(\\spad{f})"))
 (|empty?|
  (((|Boolean|) (|OutputForm|))
   "\\spad{empty?(f)} checks if form \\spad{f} is empty."))
 (|atom_to_string|
  (((|String|) (|OutputForm|))
   "\\spad{atom_to_string(f)} converts \\spad{f} to string form."))
 (|atom?|
  (((|Boolean|) (|OutputForm|))
   "\\spad{atom?(f)} checks if form \\spad{f} is atomic,{} \\spad{false} means composite"))) 
NIL 
(|OrderedIntegralDomain|) 
((|constructor|
  (NIL
   "The category of ordered commutative integral domains,{} where ordering and the arithmetic operations are compatible."))) 
NIL 
(|OpenMath&| S) 
((|constructor|
  (NIL
   "\\spadtype{OpenMath} provides operations for exporting an object in OpenMath format."))
 (|OMwrite|
  (((|Void|) (|OpenMathDevice|) $ (|Boolean|))
   "\\spad{OMwrite(dev,{} u,{} true)} writes the OpenMath form of \\spad{u} to the OpenMath device \\spad{dev} as a complete OpenMath object; OMwrite(\\spad{dev},{} \\spad{u},{} \\spad{false}) writes the object as an OpenMath fragment.")
  (((|Void|) (|OpenMathDevice|) $)
   "\\spad{OMwrite(dev,{} u)} writes the OpenMath form of \\spad{u} to the OpenMath device \\spad{dev} as a complete OpenMath object.")
  (((|String|) $ (|Boolean|))
   "\\spad{OMwrite(u,{} true)} returns the OpenMath \\spad{XML} encoding of \\spad{u} as a complete OpenMath object; OMwrite(\\spad{u},{} \\spad{false}) returns the OpenMath \\spad{XML} encoding of \\spad{u} as an OpenMath fragment.")
  (((|String|) $)
   "\\spad{OMwrite(u)} returns the OpenMath \\spad{XML} encoding of \\spad{u} as a complete OpenMath object."))) 
NIL 
(|OpenMath|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMath} provides operations for exporting an object in OpenMath format."))
 (|OMwrite|
  (((|Void|) (|OpenMathDevice|) $ (|Boolean|))
   "\\spad{OMwrite(dev,{} u,{} true)} writes the OpenMath form of \\spad{u} to the OpenMath device \\spad{dev} as a complete OpenMath object; OMwrite(\\spad{dev},{} \\spad{u},{} \\spad{false}) writes the object as an OpenMath fragment.")
  (((|Void|) (|OpenMathDevice|) $)
   "\\spad{OMwrite(dev,{} u)} writes the OpenMath form of \\spad{u} to the OpenMath device \\spad{dev} as a complete OpenMath object.")
  (((|String|) $ (|Boolean|))
   "\\spad{OMwrite(u,{} true)} returns the OpenMath \\spad{XML} encoding of \\spad{u} as a complete OpenMath object; OMwrite(\\spad{u},{} \\spad{false}) returns the OpenMath \\spad{XML} encoding of \\spad{u} as an OpenMath fragment.")
  (((|String|) $)
   "\\spad{OMwrite(u)} returns the OpenMath \\spad{XML} encoding of \\spad{u} as a complete OpenMath object."))) 
NIL 
(|OpenMathConnection|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMathConnection} provides low-level functions for handling connections to and from \\spadtype{OpenMathDevice}\\spad{s}."))
 (|OMbindTCP| (((|Boolean|) $ (|SingleInteger|)) "\\spad{OMbindTCP}"))
 (|OMconnectTCP|
  (((|Boolean|) $ (|String|) (|SingleInteger|)) "\\spad{OMconnectTCP}"))
 (|OMconnOutDevice| (((|OpenMathDevice|) $) "\\spad{OMconnOutDevice : }"))
 (|OMconnInDevice| (((|OpenMathDevice|) $) "\\spad{OMconnInDevice : }"))
 (|OMcloseConn| (((|Void|) $) "\\spad{OMcloseConn}"))
 (|OMmakeConn| (($ (|SingleInteger|)) "\\spad{OMmakeConn}"))) 
NIL 
(|OpenMathDevice|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMathDevice} provides support for reading and writing openMath objects to files,{} strings etc. It also provides access to low-level operations from within the interpreter."))
 (|OMgetType|
  (((|Symbol|) $)
   "\\spad{OMgetType(dev)} returns the type of the next object on \\spad{dev}."))
 (|OMgetSymbol|
  (((|Record| (|:| |cd| (|String|)) (|:| |name| (|String|))) $)
   "\\spad{OMgetSymbol(dev)} reads a symbol from \\spad{dev}."))
 (|OMgetString|
  (((|String|) $) "\\spad{OMgetString(dev)} reads a string from \\spad{dev}."))
 (|OMgetVariable|
  (((|Symbol|) $)
   "\\spad{OMgetVariable(dev)} reads a variable from \\spad{dev}."))
 (|OMgetFloat|
  (((|DoubleFloat|) $)
   "\\spad{OMgetFloat(dev)} reads a float from \\spad{dev}."))
 (|OMgetInteger|
  (((|Integer|) $)
   "\\spad{OMgetInteger(dev)} reads an integer from \\spad{dev}."))
 (|OMgetEndObject|
  (((|Void|) $)
   "\\spad{OMgetEndObject(dev)} reads an end object token from \\spad{dev}."))
 (|OMgetEndError|
  (((|Void|) $)
   "\\spad{OMgetEndError(dev)} reads an end error token from \\spad{dev}."))
 (|OMgetEndBVar|
  (((|Void|) $)
   "\\spad{OMgetEndBVar(dev)} reads an end bound variable list token from \\spad{dev}."))
 (|OMgetEndBind|
  (((|Void|) $)
   "\\spad{OMgetEndBind(dev)} reads an end binder token from \\spad{dev}."))
 (|OMgetEndAttr|
  (((|Void|) $)
   "\\spad{OMgetEndAttr(dev)} reads an end attribute token from \\spad{dev}."))
 (|OMgetEndAtp|
  (((|Void|) $)
   "\\spad{OMgetEndAtp(dev)} reads an end attribute pair token from \\spad{dev}."))
 (|OMgetEndApp|
  (((|Void|) $)
   "\\spad{OMgetEndApp(dev)} reads an end application token from \\spad{dev}."))
 (|OMgetObject|
  (((|Void|) $)
   "\\spad{OMgetObject(dev)} reads a begin object token from \\spad{dev}."))
 (|OMgetError|
  (((|Void|) $)
   "\\spad{OMgetError(dev)} reads a begin error token from \\spad{dev}."))
 (|OMgetBVar|
  (((|Void|) $)
   "\\spad{OMgetBVar(dev)} reads a begin bound variable list token from \\spad{dev}."))
 (|OMgetBind|
  (((|Void|) $)
   "\\spad{OMgetBind(dev)} reads a begin binder token from \\spad{dev}."))
 (|OMgetAttr|
  (((|Void|) $)
   "\\spad{OMgetAttr(dev)} reads a begin attribute token from \\spad{dev}."))
 (|OMgetAtp|
  (((|Void|) $)
   "\\spad{OMgetAtp(dev)} reads a begin attribute pair token from \\spad{dev}."))
 (|OMgetApp|
  (((|Void|) $)
   "\\spad{OMgetApp(dev)} reads a begin application token from \\spad{dev}."))
 (|OMputSymbol|
  (((|Void|) $ (|String|) (|String|))
   "\\spad{OMputSymbol(dev,{} cd,{} s)} writes the symbol \\spad{s} from \\spad{CD} \\spad{cd} to \\spad{dev}."))
 (|OMputString|
  (((|Void|) $ (|String|))
   "\\spad{OMputString(dev,{} i)} writes the string \\spad{i} to \\spad{dev}."))
 (|OMputVariable|
  (((|Void|) $ (|Symbol|))
   "\\spad{OMputVariable(dev,{} i)} writes the variable \\spad{i} to \\spad{dev}."))
 (|OMputFloat|
  (((|Void|) $ (|DoubleFloat|))
   "\\spad{OMputFloat(dev,{} i)} writes the float \\spad{i} to \\spad{dev}."))
 (|OMputInteger|
  (((|Void|) $ (|Integer|))
   "\\spad{OMputInteger(dev,{} i)} writes the integer \\spad{i} to \\spad{dev}."))
 (|OMputEndObject|
  (((|Void|) $)
   "\\spad{OMputEndObject(dev)} writes an end object token to \\spad{dev}."))
 (|OMputEndError|
  (((|Void|) $)
   "\\spad{OMputEndError(dev)} writes an end error token to \\spad{dev}."))
 (|OMputEndBVar|
  (((|Void|) $)
   "\\spad{OMputEndBVar(dev)} writes an end bound variable list token to \\spad{dev}."))
 (|OMputEndBind|
  (((|Void|) $)
   "\\spad{OMputEndBind(dev)} writes an end binder token to \\spad{dev}."))
 (|OMputEndAttr|
  (((|Void|) $)
   "\\spad{OMputEndAttr(dev)} writes an end attribute token to \\spad{dev}."))
 (|OMputEndAtp|
  (((|Void|) $)
   "\\spad{OMputEndAtp(dev)} writes an end attribute pair token to \\spad{dev}."))
 (|OMputEndApp|
  (((|Void|) $)
   "\\spad{OMputEndApp(dev)} writes an end application token to \\spad{dev}."))
 (|OMputObject|
  (((|Void|) $)
   "\\spad{OMputObject(dev)} writes a begin object token to \\spad{dev}."))
 (|OMputError|
  (((|Void|) $)
   "\\spad{OMputError(dev)} writes a begin error token to \\spad{dev}."))
 (|OMputBVar|
  (((|Void|) $)
   "\\spad{OMputBVar(dev)} writes a begin bound variable list token to \\spad{dev}."))
 (|OMputBind|
  (((|Void|) $)
   "\\spad{OMputBind(dev)} writes a begin binder token to \\spad{dev}."))
 (|OMputAttr|
  (((|Void|) $)
   "\\spad{OMputAttr(dev)} writes a begin attribute token to \\spad{dev}."))
 (|OMputAtp|
  (((|Void|) $)
   "\\spad{OMputAtp(dev)} writes a begin attribute pair token to \\spad{dev}."))
 (|OMputApp|
  (((|Void|) $)
   "\\spad{OMputApp(dev)} writes a begin application token to \\spad{dev}."))
 (|OMsetEncoding|
  (((|Void|) $ (|OpenMathEncoding|))
   "\\spad{OMsetEncoding(dev,{} enc)} sets the encoding used for reading or writing OpenMath objects to or from \\spad{dev} to \\spad{enc}."))
 (|OMclose|
  (((|Void|) $)
   "\\spad{OMclose(dev)} closes \\spad{dev},{} flushing output if necessary."))
 (|OMopenString|
  (($ (|String|) (|OpenMathEncoding|))
   "\\spad{OMopenString(s,{} mode)} opens the string \\spad{s} for reading or writing OpenMath objects in encoding \\spad{enc}."))
 (|OMopenFile|
  (($ (|String|) (|String|) (|OpenMathEncoding|))
   "\\spad{OMopenFile(f,{} mode,{} enc)} opens file \\spad{f} for reading or writing OpenMath objects (depending on \\spad{mode} which can be \\spad{\"r\"},{} \\spad{\"w\"} or \"a\" for read,{} write and append respectively),{} in the encoding \\spad{enc}."))) 
NIL 
(|OpenMathEncoding|) 
((|constructor|
  (NIL "\\spadtype{OpenMathEncoding} is the set of valid OpenMath encodings."))
 (|OMencodingBinary|
  (($)
   "\\spad{OMencodingBinary()} is the constant for the OpenMath binary encoding."))
 (|OMencodingSGML|
  (($)
   "\\spad{OMencodingSGML()} is the constant for the deprecated OpenMath SGML encoding."))
 (|OMencodingXML|
  (($)
   "\\spad{OMencodingXML()} is the constant for the OpenMath \\spad{XML} encoding."))
 (|OMencodingUnknown|
  (($)
   "\\spad{OMencodingUnknown()} is the constant for unknown encoding types. If this is used on an input device,{} the encoding will be autodetected. It is invalid to use it on an output device."))) 
NIL 
(|OpenMathError|) 
((|constructor|
  (NIL "\\spadtype{OpenMathError} is the domain of OpenMath errors."))
 (|omError|
  (($ (|OpenMathErrorKind|) (|List| (|Symbol|)))
   "\\spad{omError(k,{} l)} creates an instance of OpenMathError."))
 (|errorInfo|
  (((|List| (|Symbol|)) $)
   "\\spad{errorInfo(u)} returns information about the error \\spad{u}."))
 (|errorKind|
  (((|OpenMathErrorKind|) $)
   "\\spad{errorKind(u)} returns the type of error which \\spad{u} represents."))) 
NIL 
(|OpenMathErrorKind|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMathErrorKind} represents different kinds of OpenMath errors: specifically parse errors,{} unknown \\spad{CD} or symbol errors,{} and read errors."))
 (|OMReadError?|
  (((|Boolean|) $)
   "\\spad{OMReadError?(u)} tests whether \\spad{u} is an OpenMath read error."))
 (|OMUnknownSymbol?|
  (((|Boolean|) $)
   "\\spad{OMUnknownSymbol?(u)} tests whether \\spad{u} is an OpenMath unknown symbol error."))
 (|OMUnknownCD?|
  (((|Boolean|) $)
   "\\spad{OMUnknownCD?(u)} tests whether \\spad{u} is an OpenMath unknown \\spad{CD} error."))
 (|OMParseError?|
  (((|Boolean|) $)
   "\\spad{OMParseError?(u)} tests whether \\spad{u} is an OpenMath parsing error."))
 (|coerce|
  (($ (|Symbol|))
   "\\spad{coerce(u)} creates an OpenMath error object of an appropriate type if \\spad{u} is one of \\spad{OMParseError},{} \\spad{OMReadError},{} \\spad{OMUnknownCD} or \\spad{OMUnknownSymbol},{} otherwise it raises a runtime error."))) 
NIL 
(|ExpressionToOpenMath| R) 
((|constructor|
  (NIL
   "\\spadtype{ExpressionToOpenMath} provides support for converting objects of type \\spadtype{Expression} into OpenMath."))) 
NIL 
(|OpenMathPackage|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMathPackage} provides some simple utilities to make reading OpenMath objects easier."))
 (|OMunhandledSymbol|
  (((|Exit|) (|String|) (|String|))
   "\\spad{OMunhandledSymbol(s,{} cd)} raises an error if FriCAS reads a symbol which it is unable to handle. Note that this is different from an unexpected symbol."))
 (|OMsupportsSymbol?|
  (((|Boolean|) (|String|) (|String|))
   "\\spad{OMsupportsSymbol?(s,{} cd)} returns \\spad{true} if FriCAS supports symbol \\spad{s} from \\spad{CD} \\spad{cd},{} \\spad{false} otherwise."))
 (|OMsupportsCD?|
  (((|Boolean|) (|String|))
   "\\spad{OMsupportsCD?(cd)} returns \\spad{true} if FriCAS supports \\spad{cd},{} \\spad{false} otherwise."))
 (|OMlistSymbols|
  (((|List| (|String|)) (|String|))
   "\\spad{OMlistSymbols(cd)} lists all the symbols in \\spad{cd}."))
 (|OMlistCDs|
  (((|List| (|String|)))
   "\\spad{OMlistCDs()} lists all the \\spad{CDs} supported by FriCAS."))
 (|OMreadStr|
  (((|Any|) (|String|))
   "\\spad{OMreadStr(f)} reads an OpenMath object from \\spad{f} and passes it to FriCAS."))
 (|OMreadFile|
  (((|Any|) (|String|))
   "\\spad{OMreadFile(f)} reads an OpenMath object from \\spad{f} and passes it to FriCAS."))
 (|OMread|
  (((|Any|) (|OpenMathDevice|))
   "\\spad{OMread(dev)} reads an OpenMath object from \\spad{dev} and passes it to FriCAS."))) 
NIL 
(|OrderedMultisetAggregate| S) 
((|constructor|
  (NIL
   "An ordered-multiset aggregate is a multiset built over an ordered set \\spad{S} so that the relative sizes of its entries can be assessed. These aggregates serve as models for priority queues."))
 (|min|
  ((|#1| $)
   "\\spad{min(u)} returns the smallest entry in the multiset aggregate \\spad{u}."))) 
NIL 
(|OpenMathServerPackage|) 
((|constructor|
  (NIL
   "\\spadtype{OpenMathServerPackage} provides the necessary operations to run FriCAS as an OpenMath server,{} reading/writing objects to/from a port. Please note the facilities available here are very basic. The idea is that a user calls \\spadignore{e.g.} \\spad{Omserve(4000,{} 60)} and then another process sends OpenMath objects to port 4000 and reads the result."))
 (|OMserve|
  (((|Void|) (|SingleInteger|) (|SingleInteger|))
   "\\spad{OMserve(portnum,{} timeout)} puts FriCAS into server mode on port number \\spad{portnum}. The parameter \\spad{timeout} specifies the timeout period for the connection."))
 (|OMsend|
  (((|Void|) (|OpenMathConnection|) (|Any|))
   "\\spad{OMsend(c,{} u)} attempts to output \\spad{u} on \\aciom{\\spad{c}} in OpenMath."))
 (|OMreceive|
  (((|Any|) (|OpenMathConnection|))
   "\\spad{OMreceive(c)} reads an OpenMath object from connection \\spad{c} and returns the appropriate FriCAS object."))) 
NIL 
(|OnePointCompletion| R) 
((|constructor|
  (NIL "Adjunction of a complex infinity to a set. Date Created: 4 Oct 1989"))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(x)} returns \\spad{x} as a finite rational number if it is one,{} \"failed\" otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(x)} returns \\spad{x} as a finite rational number. Error: if \\spad{x} is not a rational number."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(x)} tests if \\spad{x} is a finite rational number."))
 (|infinite?|
  (((|Boolean|) $) "\\spad{infinite?(x)} tests if \\spad{x} is infinite."))
 (|finite?|
  (((|Boolean|) $) "\\spad{finite?(x)} tests if \\spad{x} is finite."))
 (|infinity| (($) "\\spad{infinity()} returns infinity."))) 
((|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))) 
(|OnePointCompletionFunctions2| R S) 
((|constructor|
  (NIL "Lifting of maps to one-point completions. Date Created: 4 Oct 1989"))
 (|map|
  (((|OnePointCompletion| |#2|) (|Mapping| |#2| |#1|)
    (|OnePointCompletion| |#1|) (|OnePointCompletion| |#2|))
   "\\spad{map(f,{} r,{} i)} lifts \\spad{f} and applies it to \\spad{r},{} assuming that \\spad{f}(infinity) = \\spad{i}.")
  (((|OnePointCompletion| |#2|) (|Mapping| |#2| |#1|)
    (|OnePointCompletion| |#1|))
   "\\spad{map(f,{} r)} lifts \\spad{f} and applies it to \\spad{r},{} assuming that \\spad{f}(infinity) = infinity."))) 
NIL 
(|Operator| R) 
((|constructor| (NIL "Algebra of ADDITIVE operators over a ring."))) 
((|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))) 
(|OperatorHandlers| HANDLER) 
((|constructor|
  (NIL
   "\\indented{1}{OperatorHandlers is an auxiliary domain. It is used holds functions} for each operator of \\spad{OutputForm},{} classified by the arity and the name of that operator."))
 (|removeHandler!|
  (((|Void|) $ (|Integer|) (|String|))
   "\\spad{removeHandler!(n,{} op)} removes any handler from an internal data structure (for the pair \\spad{(n,{} op)} such that afterwards \\spad{knownHandler?(x,{} n,{} op)} returns \\spad{false}."))
 (|setHandler!|
  ((|#1| $ (|Integer|) (|String|) |#1|)
   "\\spad{setHandler!(x,{} n,{} op,{} hdl)} puts \\spad{hdl} into the data structure \\spad{x} such that it can be queried afterwards."))
 (|handler|
  ((|#1| $ (|Integer|) (|String|))
   "\\spad{handler(x,{} n,{} op)} is only valid if \\spad{knownHandler?(n,{} op)} is \\spad{true}. It returns the respective handler stored in \\spad{x}."))
 (|knownHandler?|
  (((|Boolean|) $ (|Integer|) (|String|))
   "\\spad{knownHandler?(x,{} n,{} op)} checks whether a handler for operator \\spad{op} is known. The number \\spad{n} denotes the number of arguments that the operator can take. It is OK if both \\spad{knownOperator?(m,{} op)} and \\spad{knownOperator?(n,{} op)} return \\spad{true} for different \\spad{m} and \\spad{n}."))
 (|new| (($) "\\spad{new()} creates an empty structure of handlers."))) 
NIL 
(|OperationsQuery|) 
((|constructor|
  (NIL
   "This package exports tools to create FriCAS Library information databases."))
 (|getDatabase|
  (((|Database| (|IndexCard|)) (|String|))
   "\\spad{getDatabase(\"char\")} returns a list of appropriate entries in the browser database. The legal values for \\spad{\"char\"} are \"o\" (operations),{} \\spad{\"k\"} (constructors),{} \\spad{\"d\"} (domains),{} \\spad{\"c\"} (categories) or \\spad{\"p\"} (packages)."))) 
NIL 
(|OrderedCompletion| R) 
((|constructor|
  (NIL
   "Adjunction of two real infinites quantities to a set. Date Created: 4 Oct 1989"))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(x)} returns \\spad{x} as a finite rational number if it is one and \"failed\" otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(x)} returns \\spad{x} as a finite rational number. Error: if \\spad{x} cannot be so converted."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(x)} tests if \\spad{x} is a finite rational number."))
 (|whatInfinity|
  (((|SingleInteger|) $)
   "\\spad{whatInfinity(x)} returns 0 if \\spad{x} is finite,{} 1 if \\spad{x} is +infinity,{} and \\spad{-1} if \\spad{x} is -infinity."))
 (|infinite?|
  (((|Boolean|) $)
   "\\spad{infinite?(x)} tests if \\spad{x} is +infinity or -infinity,{}"))
 (|finite?|
  (((|Boolean|) $) "\\spad{finite?(x)} tests if \\spad{x} is finite."))
 (|minusInfinity| (($) "\\spad{minusInfinity()} returns -infinity."))
 (|plusInfinity| (($) "\\spad{plusInfinity()} returns +infinity."))) 
((|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))) 
(|OrderedCompletionFunctions2| R S) 
((|constructor|
  (NIL "Lifting of maps to ordered completions. Date Created: 4 Oct 1989"))
 (|map|
  (((|OrderedCompletion| |#2|) (|Mapping| |#2| |#1|) (|OrderedCompletion| |#1|)
    (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|))
   "\\spad{map(f,{} r,{} p,{} m)} lifts \\spad{f} and applies it to \\spad{r},{} assuming that \\spad{f}(plusInfinity) = \\spad{p} and that \\spad{f}(minusInfinity) = \\spad{m}.")
  (((|OrderedCompletion| |#2|) (|Mapping| |#2| |#1|)
    (|OrderedCompletion| |#1|))
   "\\spad{map(f,{} r)} lifts \\spad{f} and applies it to \\spad{r},{} assuming that \\spad{f}(plusInfinity) = plusInfinity and that \\spad{f}(minusInfinity) = minusInfinity."))) 
NIL 
(|OrderedFinite|) 
((|constructor| (NIL "Ordered finite sets."))) 
NIL 
(|OrderingFunctions| |dim| S) 
((|constructor|
  (NIL
   "\\indented{3}{This package provides ordering functions on vectors which} are suitable parameters for OrderedDirectProduct."))
 (|reverseLex|
  (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|))
   "\\spad{reverseLex(v1,{} v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the ordering which is total degree refined by the reverse lexicographic ordering."))
 (|totalLex|
  (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|))
   "\\spad{totalLex(v1,{} v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the ordering which is total degree refined by lexicographic ordering."))
 (|pureLex|
  (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|))
   "\\spad{pureLex(v1,{} v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the lexicographic ordering."))) 
NIL 
(|OrderedMonoid|) 
((|constructor|
  (NIL
   "Ordered sets which are also monoids,{} such that multiplication preserves the ordering. \\blankline"))) 
NIL 
(|OrderedRing&| S) 
((|constructor|
  (NIL
   "Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \\blankline"))
 (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x}."))
 (|sign|
  (((|Integer|) $)
   "\\spad{sign(x)} is 1 if \\spad{x} is positive,{} \\spad{-1} if \\spad{x} is negative,{} 0 if \\spad{x} equals 0."))
 (|negative?|
  (((|Boolean|) $)
   "\\spad{negative?(x)} tests whether \\spad{x} is strictly less than 0."))
 (|positive?|
  (((|Boolean|) $)
   "\\spad{positive?(x)} tests whether \\spad{x} is strictly greater than 0."))) 
NIL 
(|OrderedRing|) 
((|constructor|
  (NIL
   "Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \\blankline"))
 (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x}."))
 (|sign|
  (((|Integer|) $)
   "\\spad{sign(x)} is 1 if \\spad{x} is positive,{} \\spad{-1} if \\spad{x} is negative,{} 0 if \\spad{x} equals 0."))
 (|negative?|
  (((|Boolean|) $)
   "\\spad{negative?(x)} tests whether \\spad{x} is strictly less than 0."))
 (|positive?|
  (((|Boolean|) $)
   "\\spad{positive?(x)} tests whether \\spad{x} is strictly greater than 0."))) 
NIL 
(|OrderedSet&| S) 
((|constructor|
  (NIL
   "The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \\spad{(a,{} b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive,{} \\spadignore{i.e.} \\spad{a<b and b<c => a<c}. This order should be the natural order on given structure."))
 (|min|
  (($ $ $)
   "\\spad{min(x,{}y)} returns the minimum of \\spad{x} and \\spad{y} relative to \\spad{\"<\"}."))
 (|max|
  (($ $ $)
   "\\spad{max(x,{}y)} returns the maximum of \\spad{x} and \\spad{y} relative to \\spad{\"<\"}."))) 
NIL 
(|OrderedSet|) 
((|constructor|
  (NIL
   "The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \\spad{(a,{} b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive,{} \\spadignore{i.e.} \\spad{a<b and b<c => a<c}. This order should be the natural order on given structure."))
 (|min|
  (($ $ $)
   "\\spad{min(x,{}y)} returns the minimum of \\spad{x} and \\spad{y} relative to \\spad{\"<\"}."))
 (|max|
  (($ $ $)
   "\\spad{max(x,{}y)} returns the maximum of \\spad{x} and \\spad{y} relative to \\spad{\"<\"}."))) 
NIL 
(|OrePolynomialMatrixOperations| F LO) 
((|solve|
  (((|Union|
     (|Record|
      (|:| |particular|
           (|List|
            (|Record| (|:| |ratpart| (|Vector| |#1|))
                      (|:| |coeffs| (|Vector| |#1|)))))
      (|:| |basis| (|List| (|Vector| |#1|))))
     "failed")
    (|Matrix| |#2|) |#1| (|List| (|Vector| |#1|))
    (|Mapping|
     (|Record|
      (|:| |particular|
           (|List|
            (|Record| (|:| |ratpart| |#1|) (|:| |coeffs| (|Vector| |#1|)))))
      (|:| |basis| (|List| |#1|)))
     |#2| (|List| |#1|)))
   "\\spad{solve(m,{} c,{} lv,{} solf)} returns \"failed\" of [[\\spad{vp1},{} ...,{} vp_m],{} [\\spad{b1},{} ...,{} \\spad{bl}]] such that \\spad{bi}-\\spad{s} are basis of solutions of homogeneous system \\spad{m} \\spad{bi} = 0. Each vpi = [\\spad{r},{} [\\spad{c1},{} ...,{} \\spad{cn}]] is a particular solution of a parametric matrix equation \\spad{m} \\spad{r} = \\sum \\spad{ci} \\spad{vi} where \\spad{lv} = [\\spad{v1},{} ...,{} \\spad{vn}]. solf is scalar solver,{} \\spad{c} is a parameter to \\spad{apply} (needed for action of LO on \\spad{F}). \"failed\" means that system is underdetermined."))
 (|rowEchelon|
  (((|Record| (|:| |mat| (|Matrix| |#2|))
              (|:| |vecs| (|List| (|Vector| |#1|))))
    (|Matrix| |#2|) |#1| (|List| (|Vector| |#1|)))
   "\\spad{rowEchelon(m,{} c,{} lv)} returns [\\spad{m2},{} \\spad{lv2}] such that \\spad{m2} is the row echelon form of the matrix \\spad{m}. \\spad{lv2} is transformed \\spad{lv} using \\spad{c} as parameter to \\spad{apply}.")
  (((|Matrix| |#2|) (|Matrix| |#2|))
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))) 
NIL 
(|UnivariateSkewPolynomialCategory&| S R) 
((|constructor|
  (NIL
   "This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \\spad{x a = \\sigma(a) x + \\delta a}. This category is an evolution of the types \\indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \\indented{2}{NonCommutativeOperatorDivision} developed by Jean Della Dora and Stephen \\spad{M}. Watt."))
 (|leftLcm|
  (($ $ $)
   "\\spad{leftLcm(a,{} b)} computes the value \\spad{m} of lowest degree such that \\spad{m = aa*a = bb*b} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using right-division."))
 (|right_ext_ext_GCD|
  (((|Record| (|:| |generator| $) (|:| |coef1| $) (|:| |coef2| $)
              (|:| |coefu| $) (|:| |coefv| $))
    $ $)
   "\\spad{right_ext_ext_GCD(a,{} b)} returns \\spad{g,{} c,{} d,{} u,{} v} such that \\spad{g = c * a + d * b = rightGcd(a,{} b)},{} \\spad{u * a = - v * b = leftLcm(a,{} b)} and matrix \\spad{matrix([[c,{} d],{} [u,{} v]])} is invertible."))
 (|rightExtendedGcd|
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{rightExtendedGcd(a,{} b)} returns \\spad{[c,{} d,{} g]} such that \\spad{g = c * a + d * b = rightGcd(a,{} b)}."))
 (|rightGcd|
  (($ $ $)
   "\\spad{rightGcd(a,{} b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = aa*g}} \\indented{3}{\\spad{b = bb*g}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using right-division."))
 (|rightExactQuotient|
  (((|Union| $ "failed") $ $)
   "\\spad{rightExactQuotient(a,{} b)} computes the value \\spad{q},{} if it exists such that \\spad{a = q*b}."))
 (|rightRemainder|
  (($ $ $)
   "\\spad{rightRemainder(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned."))
 (|rightQuotient|
  (($ $ $)
   "\\spad{rightQuotient(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned."))
 (|rightDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{rightDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division\\spad{''}."))
 (|rightLcm|
  (($ $ $)
   "\\spad{rightLcm(a,{} b)} computes the value \\spad{m} of lowest degree such that \\spad{m = a*aa = b*bb} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using left-division."))
 (|leftExtendedGcd|
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{leftExtendedGcd(a,{} b)} returns \\spad{[c,{} d,{} g]} such that \\spad{g = a * c + b * d = leftGcd(a,{} b)}."))
 (|leftGcd|
  (($ $ $)
   "\\spad{leftGcd(a,{} b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = g*aa}} \\indented{3}{\\spad{b = g*bb}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using left-division."))
 (|leftExactQuotient|
  (((|Union| $ "failed") $ $)
   "\\spad{leftExactQuotient(a,{} b)} computes the value \\spad{q},{} if it exists,{} \\indented{1}{such that \\spad{a = b*q}.}"))
 (|leftRemainder|
  (($ $ $)
   "\\spad{leftRemainder(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned."))
 (|leftQuotient|
  (($ $ $)
   "\\spad{leftQuotient(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned."))
 (|leftDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{leftDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division\\spad{''}."))
 (|monicRightDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicRightDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division\\spad{''}."))
 (|monicLeftDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicLeftDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division\\spad{''}."))
 (|exquo|
  (((|Union| $ "failed") $ |#2|)
   "\\spad{exquo(l,{} a)} returns the exact quotient of \\spad{l} by a,{} returning \\spad{\"failed\"} if this is not possible."))
 (|apply|
  ((|#2| $ |#2| |#2|)
   "\\spad{apply(p,{} c,{} m)} returns \\spad{p(m)} where the action is given by \\spad{x m = c sigma(m) + delta(m)}."))) 
((|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|IntegralDomain|))
 (|HasCategory| |#2| '(|CommutativeRing|))) 
(|UnivariateSkewPolynomialCategory| R) 
((|constructor|
  (NIL
   "This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \\spad{x a = \\sigma(a) x + \\delta a}. This category is an evolution of the types \\indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \\indented{2}{NonCommutativeOperatorDivision} developed by Jean Della Dora and Stephen \\spad{M}. Watt."))
 (|leftLcm|
  (($ $ $)
   "\\spad{leftLcm(a,{} b)} computes the value \\spad{m} of lowest degree such that \\spad{m = aa*a = bb*b} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using right-division."))
 (|right_ext_ext_GCD|
  (((|Record| (|:| |generator| $) (|:| |coef1| $) (|:| |coef2| $)
              (|:| |coefu| $) (|:| |coefv| $))
    $ $)
   "\\spad{right_ext_ext_GCD(a,{} b)} returns \\spad{g,{} c,{} d,{} u,{} v} such that \\spad{g = c * a + d * b = rightGcd(a,{} b)},{} \\spad{u * a = - v * b = leftLcm(a,{} b)} and matrix \\spad{matrix([[c,{} d],{} [u,{} v]])} is invertible."))
 (|rightExtendedGcd|
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{rightExtendedGcd(a,{} b)} returns \\spad{[c,{} d,{} g]} such that \\spad{g = c * a + d * b = rightGcd(a,{} b)}."))
 (|rightGcd|
  (($ $ $)
   "\\spad{rightGcd(a,{} b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = aa*g}} \\indented{3}{\\spad{b = bb*g}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using right-division."))
 (|rightExactQuotient|
  (((|Union| $ "failed") $ $)
   "\\spad{rightExactQuotient(a,{} b)} computes the value \\spad{q},{} if it exists such that \\spad{a = q*b}."))
 (|rightRemainder|
  (($ $ $)
   "\\spad{rightRemainder(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned."))
 (|rightQuotient|
  (($ $ $)
   "\\spad{rightQuotient(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned."))
 (|rightDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{rightDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division\\spad{''}."))
 (|rightLcm|
  (($ $ $)
   "\\spad{rightLcm(a,{} b)} computes the value \\spad{m} of lowest degree such that \\spad{m = a*aa = b*bb} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using left-division."))
 (|leftExtendedGcd|
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $)
   "\\spad{leftExtendedGcd(a,{} b)} returns \\spad{[c,{} d,{} g]} such that \\spad{g = a * c + b * d = leftGcd(a,{} b)}."))
 (|leftGcd|
  (($ $ $)
   "\\spad{leftGcd(a,{} b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = g*aa}} \\indented{3}{\\spad{b = g*bb}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using left-division."))
 (|leftExactQuotient|
  (((|Union| $ "failed") $ $)
   "\\spad{leftExactQuotient(a,{} b)} computes the value \\spad{q},{} if it exists,{} \\indented{1}{such that \\spad{a = b*q}.}"))
 (|leftRemainder|
  (($ $ $)
   "\\spad{leftRemainder(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned."))
 (|leftQuotient|
  (($ $ $)
   "\\spad{leftQuotient(a,{} b)} computes the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned."))
 (|leftDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{leftDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division\\spad{''}."))
 (|monicRightDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicRightDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division\\spad{''}."))
 (|monicLeftDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicLeftDivide(a,{} b)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division\\spad{''}."))
 (|exquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{exquo(l,{} a)} returns the exact quotient of \\spad{l} by a,{} returning \\spad{\"failed\"} if this is not possible."))
 (|apply|
  ((|#1| $ |#1| |#1|)
   "\\spad{apply(p,{} c,{} m)} returns \\spad{p(m)} where the action is given by \\spad{x m = c sigma(m) + delta(m)}."))) 
NIL 
(|UnivariateSkewPolynomialCategoryOps| R C) 
((|constructor|
  (NIL
   "\\spad{UnivariateSkewPolynomialCategoryOps} provides products and \\indented{1}{divisions of univariate skew polynomials.}"))
 (|rightDivide|
  (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|
    (|Automorphism| |#1|))
   "\\spad{rightDivide(a,{} b,{} sigma)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division\\spad{''}. \\spad{\\sigma} is the morphism to use."))
 (|leftDivide|
  (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|
    (|Automorphism| |#1|))
   "\\spad{leftDivide(a,{} b,{} sigma)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division\\spad{''}. \\spad{\\sigma} is the morphism to use."))
 (|monicRightDivide|
  (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|
    (|Automorphism| |#1|))
   "\\spad{monicRightDivide(a,{} b,{} sigma)} returns the pair \\spad{[q,{} r]} such that \\spad{a = q*b + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division\\spad{''}. \\spad{\\sigma} is the morphism to use."))
 (|monicLeftDivide|
  (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|
    (|Automorphism| |#1|))
   "\\spad{monicLeftDivide(a,{} b,{} sigma)} returns the pair \\spad{[q,{} r]} such that \\spad{a = b*q + r} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division\\spad{''}. \\spad{\\sigma} is the morphism to use."))
 (|apply|
  ((|#1| |#2| |#1| |#1| (|Automorphism| |#1|) (|Mapping| |#1| |#1|))
   "\\spad{apply(p,{} c,{} m,{} sigma,{} delta)} returns \\spad{p(m)} where the action is given by \\spad{x m = c sigma(m) + delta(m)}."))
 (|times|
  ((|#2| |#2| |#2| (|Automorphism| |#1|) (|Mapping| |#1| |#1|))
   "\\spad{times(p,{} q,{} sigma,{} delta)} returns \\spad{p * q}. \\spad{\\sigma} and \\spad{\\delta} are the maps to use."))) 
((|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|))) 
(|SparseUnivariateSkewPolynomial| R |sigma| |delta|) 
((|constructor|
  (NIL
   "This is the domain of sparse univariate skew polynomials over an Ore coefficient field. The multiplication is given by \\spad{x a = \\sigma(a) x + \\delta a}."))
 (|outputForm|
  (((|OutputForm|) $ (|OutputForm|))
   "\\spad{outputForm(p,{} x)} returns the output form of \\spad{p} using \\spad{x} for the otherwise anonymous variable."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|UnivariateSkewPolynomial| |x| R |sigma| |delta|) 
((|constructor|
  (NIL
   "This is the domain of univariate skew polynomials over an Ore coefficient field in a named variable. The multiplication is given by \\spad{x a = \\sigma(a) x + \\delta a}."))
 (|coerce|
  (($ (|Variable| |#1|))
   "\\spad{coerce(x)} returns \\spad{x} as a skew-polynomial."))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#2| '(|GcdDomain|))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|OrthogonalPolynomialFunctions| R) 
((|constructor|
  (NIL "This package provides orthogonal polynomials as functions on a ring."))
 (|legendreP|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{legendreP(n,{} x)} is the \\spad{n}-th Legendre polynomial,{} \\spad{P[n](x)}. These are defined by \\spad{1/sqrt(1-2*x*t+t^2) = sum(P[n](x)*t^n,{} n = 0..)}."))
 (|laguerreL|
  ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|)
   "\\spad{laguerreL(m,{} n,{} x)} is the associated Laguerre polynomial,{} \\spad{L<m>[n](x)}. This is the \\spad{m}-th derivative of \\spad{L[n](x)}.")
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{laguerreL(n,{} x)} is the \\spad{n}-th Laguerre polynomial,{} \\spad{L[n](x)}. These are defined by \\spad{exp(-t*x/(1-t))/(1-t) = sum(L[n](x)*t^n/n!,{} n = 0..)}."))
 (|hermiteH|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{hermiteH(n,{} x)} is the \\spad{n}-th Hermite polynomial,{} \\spad{H[n](x)}. These are defined by \\spad{exp(2*t*x-t^2) = sum(H[n](x)*t^n/n!,{} n = 0..)}."))
 (|chebyshevU|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{chebyshevU(n,{} x)} is the \\spad{n}-th Chebyshev polynomial of the second kind,{} \\spad{U[n](x)}. These are defined by \\spad{1/(1-2*t*x+t^2) = sum(T[n](x) *t^n,{} n = 0..)}."))
 (|chebyshevT|
  ((|#1| (|NonNegativeInteger|) |#1|)
   "\\spad{chebyshevT(n,{} x)} is the \\spad{n}-th Chebyshev polynomial of the first kind,{} \\spad{T[n](x)}. These are defined by \\spad{(1-t*x)/(1-2*t*x+t^2) = sum(T[n](x) *t^n,{} n = 0..)}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|OrderedSemiGroup|) 
((|constructor| (NIL "Semigroups with compatible ordering."))) 
NIL 
(|OrdSetInts|) 
((|constructor|
  (NIL
   "\\indented{1}{Author : Larry Lambe} Date created : 14 August 1988 Description : A domain used in order to take the free \\spad{R}-module on the Integers \\spad{I}. This is actually the forgetful functor from OrderedRings to OrderedSets applied to \\spad{I}"))
 (|value|
  (((|Integer|) $)
   "\\spad{value(x)} returns the integer associated with \\spad{x}"))
 (|coerce|
  (($ (|Integer|))
   "\\spad{coerce(i)} returns the element corresponding to \\spad{i}"))) 
NIL 
(|OutputPackage|) 
((|constructor| (NIL "OutPackage allows pretty-printing from programs."))
 (|outputList|
  (((|Void|) (|List| (|Any|)))
   "\\spad{outputList(l)} displays the concatenated components of the list \\spad{l} on the ``algebra output\\spad{''} stream,{} as defined by \\spadsys{)set output algebra}; quotes are stripped from strings."))
 (|output|
  (((|Void|) (|String|) (|OutputForm|))
   "\\spad{output(s,{} x)} displays the string \\spad{s} followed by the form \\spad{x} on the ``algebra output\\spad{''} stream,{} as defined by \\spadsys{)set output algebra}.")
  (((|Void|) (|OutputForm|))
   "\\spad{output(x)} displays the output form \\spad{x} on the ``algebra output\\spad{''} stream,{} as defined by \\spadsys{)set output algebra}.")
  (((|Void|) (|String|))
   "\\spad{output(s)} displays the string \\spad{s} on the ``algebra output\\spad{''} stream,{} as defined by \\spadsys{)set output algebra}."))) 
NIL 
(|OutputBox|) 
((|constructor|
  (NIL
   "\\indented{1}{The domain \\spad{OutputBox} represents the two-dimensional form of} an expresssion by a number of strings (lines). Such a box has a baseline (at which such boxes will be horizontally aligned,{} a height (size above and including the baseline),{} a depth (size below the baseline),{} and a width (horizontal size)."))
 (|hconcat|
  (($ (|List| $))
   "\\spad{hconcat(lbox)} aligns the boxes at their baseline and concats those boxes horizontally from left to right."))
 (|vconcat|
  (($ (|List| $) (|NonNegativeInteger|))
   "\\spad{vconcat(lbox,{} h)} returns \\spad{vconcat(lbox,{}h,{} 0)},{}")
  (($ (|List| $) (|NonNegativeInteger|) (|Integer|))
   "\\spad{vconcat(lbox,{} h,{} adjust)} computes the maximal width of the boxes in the list \\spad{lbox}; then if \\spad{adjust<0},{} left adjusts,{} if \\spad{adjust>0},{} right adjusts,{} and otherwise centers each smaller box in a new box of this maximal width and returns a box by putting all the boxes vertically on top of each other. The height of the new box is given by \\spad{h},{} the depth results from the difference of the number of lines and \\spad{h}."))
 (|hcenter|
  (((|Mapping| $ $) (|NonNegativeInteger|))
   "\\spad{hcenter(w)(box)} centers the box horizontally inside a box of width \\spad{w}."))
 (|pad|
  (((|Mapping| $ $) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{pad(t,{} b,{} l,{} r)(box)} returns a new box that is padded by \\spad{t} empty lines at the top,{} \\spad{b} empty lines at the bottom,{} \\spad{l} space characters at the left,{} \\spad{r} space characters at the right. If \\spad{w},{} \\spad{h},{} \\spad{d} are the widht,{} heigth and depth of box then the resulting box will have width l+w+r and height \\spad{t+h} and depth \\spad{d+b}."))
 (|lines|
  (((|List| (|String|)) $)
   "\\spad{lines(box)} returns the contents of the \\spad{box} as strings (all of the same length (width(\\spad{box}))."))
 (|depth|
  (((|NonNegativeInteger|) $)
   "\\spad{depth(box)} returns the height of the \\spad{box} below the baseline."))
 (|width|
  (((|NonNegativeInteger|) $)
   "\\spad{width(box)} returns the width of the \\spad{box}."))
 (|height|
  (((|NonNegativeInteger|) $)
   "\\spad{height(box)} returns the height of the \\spad{box} (above the baseline) including the baseline."))
 (|box|
  (($ (|String|))
   "\\spad{box(s)} creates a box that contains the string \\spad{s}."))
 (|empty?|
  (((|Boolean|) $)
   "\\spad{empty?(b)} returns \\spad{true} of the box has height and depth equal to 0."))
 (|empty| (($) "Create an empty box of size 0."))) 
NIL 
(|OutputForm|) 
((|constructor|
  (NIL
   "This domain is used to create and manipulate mathematical expressions for output. It is intended to provide an insulating layer between the expression rendering software (\\spadignore{e.g.} TeX,{} or Script) and the output coercions in the various domains."))
 (SEGMENT (($ $) "\\spad{SEGMENT(x)} creates the prefix form: \\spad{x..}.")
  (($ $ $) "\\spad{SEGMENT(x,{} y)} creates the infix form: \\spad{x..y}."))
 (|not| (($ $) "\\spad{not f} creates the equivalent prefix form."))
 (|or| (($ $ $) "\\spad{f or g} creates the equivalent infix form."))
 (|and| (($ $ $) "\\spad{f and g} creates the equivalent infix form."))
 (|exquo| (($ $ $) "\\spad{exquo(f,{} g)} creates the equivalent infix form."))
 (|quo| (($ $ $) "\\spad{f quo g} creates the equivalent infix form."))
 (|rem| (($ $ $) "\\spad{f rem g} creates the equivalent infix form."))
 (^ (($ $ $) "\\spad{f ^ g} creates the equivalent infix form."))
 (/ (($ $ $) "\\spad{f / g} creates the equivalent infix form."))
 (* (($ $ $) "\\spad{f * g} creates the equivalent infix form."))
 (- (($ $) "\\spad{- f} creates the equivalent prefix form.")
    (($ $ $) "\\spad{f - g} creates the equivalent infix form."))
 (+ (($ $ $) "\\spad{f + g} creates the equivalent infix form."))
 (>= (($ $ $) "\\spad{f >= g} creates the equivalent infix form."))
 (<= (($ $ $) "\\spad{f <= g} creates the equivalent infix form."))
 (> (($ $ $) "\\spad{f > g} creates the equivalent infix form."))
 (< (($ $ $) "\\spad{f < g} creates the equivalent infix form."))
 (~= (($ $ $) "\\spad{f ~= g} creates the equivalent infix form."))
 (= (($ $ $) "\\spad{f = g} creates the equivalent infix form."))
 (|blankSeparate|
  (($ (|List| $))
   "\\spad{blankSeparate(l)} creates the form separating the elements of \\spad{l} by blanks."))
 (|semicolonSeparate|
  (($ (|List| $))
   "\\spad{semicolonSeparate(l)} creates the form separating the elements of \\spad{l} by semicolons."))
 (|commaSeparate|
  (($ (|List| $))
   "\\spad{commaSeparate(l)} creates the form separating the elements of \\spad{l} by commas."))
 (|pile|
  (($ (|List| $))
   "\\spad{pile(l)} creates the form consisting of the elements of \\spad{l} which displays as a pile,{} \\spadignore{i.e.} the elements begin on a new line and are indented right to the same margin."))
 (|paren|
  (($ (|List| $))
   "\\spad{paren(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in parentheses.")
  (($ $)
   "\\spad{paren(f)} creates the form enclosing \\spad{f} in parentheses."))
 (|bracket|
  (($ (|List| $))
   "\\spad{bracket(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in square brackets.")
  (($ $)
   "\\spad{bracket(f)} creates the form enclosing \\spad{f} in square brackets."))
 (|brace|
  (($ (|List| $))
   "\\spad{brace(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in curly brackets.")
  (($ $)
   "\\spad{brace(f)} creates the form enclosing \\spad{f} in braces (curly brackets)."))
 (|int|
  (($ $ $ $)
   "\\spad{int(expr,{} lowerlimit,{} upperlimit)} creates the form prefixing \\spad{expr} by an integral sign with both a \\spad{lowerlimit} and upperlimit.")
  (($ $ $)
   "\\spad{int(expr,{} lowerlimit)} creates the form prefixing \\spad{expr} by an integral sign with a lowerlimit.")
  (($ $)
   "\\spad{int(expr)} creates the form prefixing \\spad{expr} with an integral sign."))
 (|prod|
  (($ $ $ $)
   "\\spad{prod(expr,{} lowerlimit,{} upperlimit)} creates the form prefixing \\spad{expr} by a capital \\spad{pi} with both a \\spad{lowerlimit} and upperlimit.")
  (($ $ $)
   "\\spad{prod(expr,{} lowerlimit)} creates the form prefixing \\spad{expr} by a capital \\spad{pi} with a lowerlimit.")
  (($ $)
   "\\spad{prod(expr)} creates the form prefixing \\spad{expr} by a capital \\spad{pi}."))
 (|sum|
  (($ $ $ $)
   "\\spad{sum(expr,{} lowerlimit,{} upperlimit)} creates the form prefixing \\spad{expr} by a capital sigma with both a \\spad{lowerlimit} and upperlimit.")
  (($ $ $)
   "\\spad{sum(expr,{} lowerlimit)} creates the form prefixing \\spad{expr} by a capital sigma with a lowerlimit.")
  (($ $)
   "\\spad{sum(expr)} creates the form prefixing \\spad{expr} by a capital sigma."))
 (|overlabel|
  (($ $ $)
   "\\spad{overlabel(x,{}f)} creates the form \\spad{f} with \\spad{\"x} overbar\" over the top."))
 (|overbar|
  (($ $) "\\spad{overbar(f)} creates the form \\spad{f} with an overbar."))
 (|prime|
  (($ $ (|NonNegativeInteger|))
   "\\spad{prime(f,{} n)} creates the form \\spad{f} followed by \\spad{n} primes.")
  (($ $)
   "\\spad{prime(f)} creates the form \\spad{f} followed by a suffix prime (single quote)."))
 (|dot|
  (($ $ (|NonNegativeInteger|))
   "\\spad{dot(f,{} n)} creates the form \\spad{f} with \\spad{n} dots overhead.")
  (($ $) "\\spad{dot(f)} creates the form with one dot overhead."))
 (|quote|
  (($ $) "\\spad{quote(f)} creates the form \\spad{f} with a prefix quote."))
 (|supersub|
  (($ $ (|List| $))
   "\\spad{supersub(a,{} [sub1,{} super1,{} sub2,{} super2,{} ...])} creates a form with each subscript aligned under each superscript."))
 (|scripts|
  (($ $ (|List| $))
   "\\spad{scripts(f,{} l)} where \\spad{l} is \\spad{[sub,{} super,{} presuper,{} presub]} creates a form for \\spad{f} with scripts on all 4 corners. If \\spad{l} has less than 4 elements corresponding scripts are absent."))
 (|presuper|
  (($ $ $)
   "\\spad{presuper(f,{} n)} creates a form for \\spad{f} presuperscripted by \\spad{n}."))
 (|presub|
  (($ $ $)
   "\\spad{presub(f,{} n)} creates a form for \\spad{f} presubscripted by \\spad{n}."))
 (|super|
  (($ $ $)
   "\\spad{super(f,{} n)} creates a form for \\spad{f} superscripted by \\spad{n}."))
 (|sub|
  (($ $ $)
   "\\spad{sub(f,{} n)} creates a form for \\spad{f} subscripted by \\spad{n}."))
 (|tensor|
  (($ $ $) "\\spad{tensor(a,{} b)} creates a form for a tensor \\spad{b}"))
 (|binomial|
  (($ $ $)
   "\\spad{binomial(n,{} m)} creates a form for the binomial coefficient of \\spad{n} and \\spad{m}."))
 (|differentiate|
  (($ $ (|NonNegativeInteger|))
   "\\spad{differentiate(f,{} n)} creates a form for the \\spad{n}th derivative of \\spad{f},{} \\spadignore{e.g.} \\spad{f'},{} \\spad{f''},{} \\spad{f'''},{} \\spad{\"f} super \\spad{iv}\"."))
 (|rarrow|
  (($ $ $)
   "\\spad{rarrow(f,{} g)} creates a form for the mapping \\spad{f -> g}."))
 (|assign|
  (($ $ $)
   "\\spad{assign(f,{} g)} creates a form for the assignment \\spad{f := g}."))
 (|slash|
  (($ $ $)
   "\\spad{slash(f,{} g)} creates a form for the horizontal fraction of \\spad{f} over \\spad{g}."))
 (|over|
  (($ $ $)
   "\\spad{over(f,{} g)} creates a form for the vertical fraction of \\spad{f} over \\spad{g}."))
 (|root|
  (($ $ $)
   "\\spad{root(f,{} n)} creates a form for the \\spad{n}th root of form \\spad{f}.")
  (($ $)
   "\\spad{root(f)} creates a form for the square root of form \\spad{f}."))
 (|zag|
  (($ $ $)
   "\\spad{zag(f,{} g)} creates a form for the continued fraction form for \\spad{f} over \\spad{g}."))
 (|matrix|
  (($ (|List| (|List| $)))
   "\\spad{matrix(llf)} makes \\spad{llf} (a list of lists of forms) into a form which displays as a matrix."))
 (|box| (($ $) "\\spad{box(f)} encloses \\spad{f} in a box."))
 (|label|
  (($ $ $)
   "\\spad{label(n,{} f)} gives form \\spad{f} an equation label \\spad{n}."))
 (|elt|
  (($ $ (|List| $))
   "\\spad{elt(op,{} l)} creates a form for application of \\spad{op} to list of arguments \\spad{l}."))
 (|infix?|
  (((|Boolean|) $)
   "\\spad{infix?(op)} returns \\spad{true} if \\spad{op} is an infix operator,{} and \\spad{false} otherwise."))
 (|postfix|
  (($ $ $)
   "\\spad{postfix(op,{} a)} creates a form which prints as: a \\spad{op}."))
 (|infix|
  (($ $ $ $)
   "\\spad{infix(op,{} a,{} b)} creates a form which prints as: a \\spad{op} \\spad{b}.")
  (($ $ (|List| $))
   "\\spad{infix(f,{} l)} creates a form depicting the \\spad{n}-ary application of infix operation \\spad{f} to a tuple of arguments \\spad{l}."))
 (|prefix|
  (($ $ (|List| $))
   "\\spad{prefix(f,{} l)} creates a form depicting the \\spad{n}-ary prefix application of \\spad{f} to a tuple of arguments given by list \\spad{l}."))
 (|vconcat|
  (($ (|List| $))
   "\\spad{vconcat(u)} vertically concatenates all forms in list \\spad{u}.")
  (($ $ $)
   "\\spad{vconcat(f,{} g)} vertically concatenates forms \\spad{f} and \\spad{g}."))
 (|hconcat|
  (($ (|List| $))
   "\\spad{hconcat(u)} horizontally concatenates all forms in list \\spad{u}.")
  (($ $ $)
   "\\spad{hconcat(f,{} g)} horizontally concatenate forms \\spad{f} and \\spad{g}."))
 (|center| (($ $) "\\spad{center(f)} centers form \\spad{f} in total space.")
           (($ $ (|Integer|))
            "\\spad{center(f,{} n)} centers form \\spad{f} within space of width \\spad{n}."))
 (|right|
  (($ $) "\\spad{right(f)} right-justifies form \\spad{f} in total space.")
  (($ $ (|Integer|))
   "\\spad{right(f,{} n)} right-justifies form \\spad{f} within space of width \\spad{n}."))
 (|left|
  (($ $) "\\spad{left(f)} left-justifies form \\spad{f} in total space.")
  (($ $ (|Integer|))
   "\\spad{left(f,{} n)} left-justifies form \\spad{f} within space of width \\spad{n}."))
 (|rspace|
  (($ (|Integer|) (|Integer|))
   "\\spad{rspace(n,{} m)} creates rectangular white space,{} \\spad{n} wide by \\spad{m} high."))
 (|vspace|
  (($ (|Integer|))
   "\\spad{vspace(n)} creates white space of height \\spad{n}."))
 (|hspace|
  (($ (|Integer|))
   "\\spad{hspace(n)} creates white space of width \\spad{n}."))
 (|empty| (($) "\\spad{empty()} creates an empty form."))
 (|outputForm|
  (($ (|String|)) "\\spad{outputForm(s)} creates a form for a string.")
  (($ (|Symbol|)) "\\spad{outputForm(s)} creates a form for a symbol.")
  (($ (|Integer|)) "\\spad{outputForm(n)} creates a form for an integer."))
 (|messagePrint|
  (((|Void|) (|String|))
   "\\spad{messagePrint(s)} prints \\spad{s} without string quotes. Note: \\spad{messagePrint(s)} is equivalent to \\spad{print message(s)}."))
 (|message|
  (($ (|String|))
   "\\spad{message(s)} creates an form with no string quotes from string \\spad{s}."))
 (|print| (((|Void|) $) "\\spad{print(u)} prints the form \\spad{u}."))) 
NIL 
(|OrderedVariableList| |VariableList|) 
((|constructor| (NIL "This domain implements ordered variables"))
 (|variable|
  (((|Union| $ "failed") (|Symbol|))
   "\\spad{variable(s)} returns a member of the variable set or failed"))) 
NIL 
(|OrdinaryWeightedPolynomials| R |vl| |wl| |wtlevel|) 
((|constructor|
  (NIL
   "This domain represents truncated weighted polynomials over the \"Polynomial\" type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented."))) 
((|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))) 
(|PadeApproximants| R PS UP) 
((|constructor|
  (NIL
   "\\indented{1}{This package computes reliable Pad&ea. approximants using} a generalized Viskovatov continued fraction algorithm. Authors: Burge,{} Hassner & Watt. Date Created: April 1987 Keywords: Pade,{} series Examples: References: \\indented{2}{\"Pade Approximants,{} Part I: Basic Theory\",{} Baker & Graves-Morris.}"))
 (|padecf|
  (((|Union| (|ContinuedFraction| |#3|) "failed") (|NonNegativeInteger|)
    (|NonNegativeInteger|) |#2| |#2|)
   "\\spad{padecf(nd,{} dd,{} ns,{} ds)} computes the approximant as a continued fraction of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant),{} \\spad{dd} (denominator degree of approximant),{} \\spad{ns} (numerator series of function),{} and \\spad{ds} (denominator series of function)."))
 (|pade|
  (((|Union| (|Fraction| |#3|) "failed") (|NonNegativeInteger|)
    (|NonNegativeInteger|) |#2| |#2|)
   "\\spad{pade(nd,{} dd,{} ns,{} ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant),{} \\spad{dd} (denominator degree of approximant),{} \\spad{ns} (numerator series of function),{} and \\spad{ds} (denominator series of function)."))) 
NIL 
(|PadeApproximantPackage| R |x| |pt|) 
((|constructor|
  (NIL
   "\\indented{1}{This package computes reliable Pad&ea. approximants using} a generalized Viskovatov continued fraction algorithm. Authors: Trager,{} Burge,{} Hassner & Watt. Date Created: April 1987 Keywords: Pade,{} series Examples: References: \\indented{2}{\"Pade Approximants,{} Part I: Basic Theory\",{} Baker & Graves-Morris.}"))
 (|pade|
  (((|Union| (|Fraction| (|UnivariatePolynomial| |#2| |#1|)) "failed")
    (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|UnivariateTaylorSeries| |#1| |#2| |#3|))
   "\\spad{pade(nd,{} dd,{} s)} computes the quotient of polynomials (if it exists) with numerator degree at most \\spad{nd} and denominator degree at most \\spad{dd} which matches the series \\spad{s} to order \\spad{nd + dd}.")
  (((|Union| (|Fraction| (|UnivariatePolynomial| |#2| |#1|)) "failed")
    (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|UnivariateTaylorSeries| |#1| |#2| |#3|)
    (|UnivariateTaylorSeries| |#1| |#2| |#3|))
   "\\spad{pade(nd,{} dd,{} ns,{} ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant),{} \\spad{dd} (denominator degree of approximant),{} \\spad{ns} (numerator series of function),{} and \\spad{ds} (denominator series of function)."))) 
NIL 
(|PAdicInteger| |p|) 
((|constructor|
  (NIL
   "Stream-based implementation of \\spad{Zp:} \\spad{p}-adic numbers are represented as sum(\\spad{i} = 0..,{} a[\\spad{i}] * p^i),{} where the a[\\spad{i}] lie in 0,{} 1,{} ...,{} (\\spad{p} - 1)."))) 
NIL 
(|PAdicIntegerCategory| |p|) 
((|constructor|
  (NIL
   "This is the catefory of stream-based representations of \\indented{2}{the \\spad{p}-adic integers.}"))
 (|root|
  (($ (|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{root(f,{} a)} returns a root of the polynomial \\spad{f}. Argument \\spad{a} must be a root of \\spad{f} \\spad{(mod p)}."))
 (|sqrt|
  (($ $ (|Integer|))
   "\\spad{sqrt(b,{} a)} returns a square root of \\spad{b}. Argument \\spad{a} is a square root of \\spad{b} \\spad{(mod p)}."))
 (|approximate|
  (((|Integer|) $ (|Integer|))
   "\\spad{approximate(x,{} n)} returns an integer \\spad{y} such that \\spad{y = x (mod p^n)} when \\spad{n} is positive,{} and 0 otherwise."))
 (|quotientByP|
  (($ $)
   "\\spad{quotientByP(x)} returns \\spad{b},{} where \\spad{x = a + b p}."))
 (|moduloP|
  (((|Integer|) $)
   "\\spad{modulo(x)} returns a,{} where \\spad{x = a + b p}."))
 (|modulus|
  (((|Integer|)) "\\spad{modulus()} returns the value of \\spad{p}."))
 (|complete|
  (($ $) "\\spad{complete(x)} forces the computation of all digits."))
 (|extend|
  (($ $ (|Integer|))
   "\\spad{extend(x,{} n)} forces the computation of digits up to order \\spad{n}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(x)} returns the exponent of the highest power of \\spad{p} dividing \\spad{x}."))
 (|digits|
  (((|Stream| (|Integer|)) $)
   "\\spad{digits(x)} returns a stream of \\spad{p}-adic digits of \\spad{x}."))) 
NIL 
(|PAdicRational| |p|) 
((|constructor|
  (NIL
   "Stream-based implementation of \\spad{Qp:} numbers are represented as sum(\\spad{i} = \\spad{k}..,{} a[\\spad{i}] * p^i) where the a[\\spad{i}] lie in 0,{} 1,{} ...,{} (\\spad{p} - 1)."))) 
((|HasCategory| (|PAdicInteger| |#1|) '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|PAdicInteger| |#1|) (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|PAdicInteger| |#1|) '(|CharacteristicNonZero|))
 (|HasCategory| (|PAdicInteger| |#1|) '(|CharacteristicZero|))
 (|HasCategory| (|PAdicInteger| |#1|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|PAdicInteger| |#1|) '(|RealConstant|))
 (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedSet|))
 (OR (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedSet|)))
 (|HasCategory| (|PAdicInteger| |#1|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|PAdicInteger| |#1|) '(|StepThrough|))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|InnerEvalable| '(|Symbol|)
                      (LIST '|PAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|Evalable| (LIST '|PAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|Eltable| (LIST '|PAdicInteger| (|devaluate| |#1|))
                      (LIST '|PAdicInteger| (|devaluate| |#1|))))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|PAdicInteger| |#1|) '(|DifferentialRing|))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|PAdicInteger| |#1|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|PAdicInteger| |#1|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|PAdicInteger| |#1|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|PAdicInteger| |#1|) '(|EuclideanDomain|))
 (|HasCategory| (|PAdicInteger| |#1|) '(|IntegerNumberSystem|))
 (|HasCategory| (|PAdicInteger| |#1|) '(|Comparable|))
 (OR (|HasCategory| (|PAdicInteger| |#1|) '(|Comparable|))
     (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|PAdicInteger| |#1|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|PAdicInteger| |#1|)
                     '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|PAdicInteger| |#1|)
                      '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|PAdicInteger| |#1|) '(|CharacteristicNonZero|)))) 
(|PAdicRationalConstructor| |p| PADIC) 
((|constructor|
  (NIL "This is the category of stream-based representations of \\spad{Qp}."))
 (|removeZeroes|
  (($ (|Integer|) $)
   "\\spad{removeZeroes(n,{} x)} removes up to \\spad{n} leading zeroes from the \\spad{p}-adic rational \\spad{x}.")
  (($ $)
   "\\spad{removeZeroes(x)} removes leading zeroes from the representation of the \\spad{p}-adic rational \\spad{x}. A \\spad{p}-adic rational is represented by (1) an exponent and (2) a \\spad{p}-adic integer which may have leading zero digits. When the \\spad{p}-adic integer has a leading zero digit,{} a 'leading zero' is removed from the \\spad{p}-adic rational as follows: the number is rewritten by increasing the exponent by 1 and dividing the \\spad{p}-adic integer by \\spad{p}. Note: \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f}."))
 (|continuedFraction|
  (((|ContinuedFraction| (|Fraction| (|Integer|))) $)
   "\\spad{continuedFraction(x)} converts the \\spad{p}-adic rational number \\spad{x} to a continued fraction."))
 (|approximate|
  (((|Fraction| (|Integer|)) $ (|Integer|))
   "\\spad{approximate(x,{} n)} returns a rational number \\spad{y} such that \\spad{y = x (mod p^n)}."))) 
((|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|RealConstant|))
 (|HasCategory| |#2| '(|OrderedIntegralDomain|))
 (|HasCategory| |#2| '(|OrderedSet|))
 (OR (|HasCategory| |#2| '(|OrderedIntegralDomain|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|StepThrough|))
 (|HasCategory| |#2| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#2|)))
 (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
 (|HasCategory| |#2| (LIST '|Eltable| (|devaluate| |#2|) (|devaluate| |#2|)))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#2| '(|EuclideanDomain|))
 (|HasCategory| |#2| '(|IntegerNumberSystem|))
 (|HasCategory| |#2| '(|Comparable|))
 (OR (|HasCategory| |#2| '(|Comparable|))
     (|HasCategory| |#2| '(|OrderedIntegralDomain|))
     (|HasCategory| |#2| '(|OrderedSet|)))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))) 
(|Palette|) 
((|constructor|
  (NIL "This domain describes four groups of color shades (palettes)."))
 (|coerce|
  (($ (|Color|))
   "\\spad{coerce(c)} sets the average shade for the palette to that of the indicated color \\spad{c}."))
 (|shade|
  (((|Integer|) $)
   "\\spad{shade(p)} returns the shade index of the indicated palette \\spad{p}."))
 (|hue|
  (((|Color|) $)
   "\\spad{hue(p)} returns the hue field of the indicated palette \\spad{p}."))
 (|light|
  (($ (|Color|))
   "\\spad{light(c)} sets the shade of a hue,{} \\spad{c},{} to it\\spad{'s} highest value."))
 (|pastel|
  (($ (|Color|))
   "\\spad{pastel(c)} sets the shade of a hue,{} \\spad{c},{} above bright,{} but below light."))
 (|bright|
  (($ (|Color|))
   "\\spad{bright(c)} sets the shade of a hue,{} \\spad{c},{} above dim,{} but below pastel."))
 (|dim|
  (($ (|Color|))
   "\\spad{dim(c)} sets the shade of a hue,{} \\spad{c},{} above dark,{} but below bright."))
 (|dark|
  (($ (|Color|))
   "\\spad{dark(c)} sets the shade of the indicated hue of \\spad{c} to it\\spad{'s} lowest value."))) 
NIL 
(|PolynomialAN2Expression|) 
((|constructor|
  (NIL
   "This package provides a coerce from polynomials over algebraic numbers to \\spadtype{Expression Integer}."))
 (|coerce|
  (((|Expression| (|Integer|)) (|Fraction| (|Polynomial| (|AlgebraicNumber|))))
   "\\spad{coerce(rf)} converts \\spad{rf},{} a fraction of polynomial \\spad{p} with algebraic number coefficients to \\spadtype{Expression Integer}.")
  (((|Expression| (|Integer|)) (|Polynomial| (|AlgebraicNumber|)))
   "\\spad{coerce(p)} converts the polynomial \\spad{p} with algebraic number coefficients to \\spadtype{Expression Integer}."))) 
NIL 
(|ParametricPlaneCurveFunctions2| CF1 CF2) 
((|constructor| (NIL "This package \\undocumented"))
 (|map|
  (((|ParametricPlaneCurve| |#2|) (|Mapping| |#2| |#1|)
    (|ParametricPlaneCurve| |#1|))
   "\\spad{map(f,{} x)} \\undocumented"))) 
NIL 
(|ParametricPlaneCurve| |ComponentFunction|) 
((|constructor|
  (NIL
   "ParametricPlaneCurve is used for plotting parametric plane curves in the affine plane."))
 (|coordinate|
  ((|#1| $ (|NonNegativeInteger|))
   "\\spad{coordinate(c,{} i)} returns a coordinate function for \\spad{c} using 1-based indexing according to \\spad{i}. This indicates what the function for the coordinate component \\spad{i} of the plane curve is."))
 (|curve|
  (($ |#1| |#1|)
   "\\spad{curve(c1,{} c2)} creates a plane curve from 2 component functions \\spad{c1} and \\spad{c2}."))) 
NIL 
(|PathArrayPackage| R) 
((|constructor| (NIL "A package for weighted Motzkin paths over a ring."))
 (|bottom|
  (((|Stream| |#1|) (|Stream| (|List| |#1|)))
   "\\spad{bottom(x)} returns the bottom entry of each column."))
 (|jacobiPathArray|
  (((|Stream| (|List| |#1|)) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{jacobiPathArray([b0,{} b1,{} ...],{} [c1,{} c2,{} ...])} computes Flajolet\\spad{'s} Motzkin path array from the sequences [1,{} 1,{} ...],{} \\spad{bi},{} \\spad{ci}."))
 (|motzkinPathArray|
  (((|Stream| (|List| |#1|)) (|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{motzkinPathArray([a0,{} a1,{} ...],{} [b0,{} b1,{} ...],{} [c1,{} c2,{} ...])} computes Flajolet\\spad{'s} Motzkin path array from the sequences \\spad{ai},{} \\spad{bi},{} \\spad{ci}."))) 
NIL 
(|ParametricSpaceCurveFunctions2| CF1 CF2) 
((|constructor| (NIL "This package \\undocumented"))
 (|map|
  (((|ParametricSpaceCurve| |#2|) (|Mapping| |#2| |#1|)
    (|ParametricSpaceCurve| |#1|))
   "\\spad{map(f,{} x)} \\undocumented"))) 
NIL 
(|ParametricSpaceCurve| |ComponentFunction|) 
((|constructor|
  (NIL
   "ParametricSpaceCurve is used for plotting parametric space curves in affine 3-space."))
 (|coordinate|
  ((|#1| $ (|NonNegativeInteger|))
   "\\spad{coordinate(c,{} i)} returns a coordinate function of \\spad{c} using 1-based indexing according to \\spad{i}. This indicates what the function for the coordinate component,{} \\spad{i},{} of the space curve is."))
 (|curve|
  (($ |#1| |#1| |#1|)
   "\\spad{curve(c1,{} c2,{} c3)} creates a space curve from 3 component functions \\spad{c1},{} \\spad{c2},{} and \\spad{c3}."))) 
NIL 
(|ParametricSurfaceFunctions2| CF1 CF2) 
((|constructor| (NIL "This package \\undocumented"))
 (|map|
  (((|ParametricSurface| |#2|) (|Mapping| |#2| |#1|)
    (|ParametricSurface| |#1|))
   "\\spad{map(f,{} x)} \\undocumented"))) 
NIL 
(|ParametricSurface| |ComponentFunction|) 
((|constructor|
  (NIL
   "ParametricSurface is used for plotting parametric surfaces in affine 3-space."))
 (|coordinate|
  ((|#1| $ (|NonNegativeInteger|))
   "\\spad{coordinate(s,{} i)} returns a coordinate function of \\spad{s} using 1-based indexing according to \\spad{i}. This indicates what the function for the coordinate component,{} \\spad{i},{} of the surface is."))
 (|surface|
  (($ |#1| |#1| |#1|)
   "\\spad{surface(c1,{} c2,{} c3)} creates a surface from 3 parametric component functions \\spad{c1},{} \\spad{c2},{} and \\spad{c3}."))) 
NIL 
(|PartitionsAndPermutations|) 
((|constructor|
  (NIL
   "PartitionsAndPermutations contains functions for generating streams of integer partitions,{} and streams of sequences of integers composed from a multi-set."))
 (|permutations|
  (((|Stream| (|List| (|Integer|))) (|Integer|))
   "\\spad{permutations(n)} is the stream of permutations \\indented{1}{formed from \\spad{1,{} 2,{} 3,{} ...,{} n}.}"))
 (|sequences|
  (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)))
   "\\spad{sequences([l0,{} l1,{} l2,{} ..,{} ln])} is the set of \\indented{1}{all sequences formed from} \\spad{l0} 0\\spad{'s},{} \\spad{l1} 1\\spad{'s},{} \\spad{l2} 2\\spad{'s},{} ...,{} \\spad{ln} \\spad{n}\\spad{'s}.")
  (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{sequences(l1,{} l2)} is the stream of all sequences that \\indented{1}{can be composed from the multiset defined from} \\indented{1}{two lists of integers \\spad{l1} and \\spad{l2}.} \\indented{1}{For example,{} the pair \\spad{([1,{} 2,{} 4],{} [2,{} 3,{} 5])} represents} \\indented{1}{multi-set with 1 \\spad{2},{} 2 \\spad{3}\\spad{'s},{} and 4 \\spad{5}\\spad{'s}.}"))
 (|shufflein|
  (((|Stream| (|List| (|Integer|))) (|List| (|Integer|))
    (|Stream| (|List| (|Integer|))))
   "\\spad{shufflein(l,{} st)} maps shuffle(\\spad{l},{} \\spad{u}) on to all \\indented{1}{members \\spad{u} of st,{} concatenating the results.}"))
 (|shuffle|
  (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{shuffle(l1,{} l2)} forms the stream of all shuffles of \\spad{l1} \\indented{1}{and \\spad{l2},{} \\spadignore{i.e.} all sequences that can be formed from} \\indented{1}{merging \\spad{l1} and \\spad{l2}.}"))
 (|conjugates|
  (((|Stream| (|List| (|Integer|))) (|Stream| (|List| (|Integer|))))
   "\\spad{conjugates(lp)} is the stream of conjugates of a stream \\indented{1}{of partitions \\spad{lp}.}"))
 (|conjugate|
  (((|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{conjugate(pt)} is the conjugate of the partition \\spad{pt}."))
 (|distinct_partitions|
  (((|Stream| (|List| (|Integer|))) (|Integer|))
   "\\spad{distinct_partitions(n)} is the stream of all partitions \\indented{1}{of \\spad{n} into distinct numbers.}")
  (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{distinct_partitions(p,{} l,{} n)} is the stream of partitions \\indented{1}{of \\spad{n} into distinct numbers whose number of parts is no greater than \\spad{p}} \\indented{1}{and whose largest part is no greater than \\spad{l}.}"))
 (|odd_partitions|
  (((|Stream| (|List| (|Integer|))) (|Integer|))
   "\\spad{odd_partitions(n)} is the stream of all partitions \\indented{1}{of \\spad{n} into odd numbers.}")
  (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{odd_partitions(p,{} l,{} n)} is the stream of partitions \\indented{1}{of \\spad{n} into odd numbers whose number of parts is no greater than \\spad{p}} \\indented{1}{and whose largest part is no greater than \\spad{l}.}"))
 (|partitions|
  (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|))
   "\\spad{partitions(p,{} l)} is the stream of all \\indented{1}{partitions whose number of} \\indented{1}{parts and largest part are no greater than \\spad{p} and \\spad{l}.}")
  (((|Stream| (|List| (|Integer|))) (|Integer|))
   "\\spad{partitions(n)} is the stream of all partitions of \\spad{n}.")
  (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{partitions(p,{} l,{} n)} is the stream of partitions \\indented{1}{of \\spad{n} whose number of parts is no greater than \\spad{p}} \\indented{1}{and whose largest part is no greater than \\spad{l}.}"))) 
NIL 
(|Patternable| R) 
((|constructor|
  (NIL
   "An object \\spad{S} is Patternable over an object \\spad{R} if \\spad{S} can lift the conversions from \\spad{R} into \\spadtype{Pattern(Integer)} and \\spadtype{Pattern(Float)} to itself."))) 
NIL 
(|PatternMatchListResult| R S L) 
((|constructor|
  (NIL
   "A PatternMatchListResult is an object internally returned by the pattern matcher when matching on lists. It is either a failed match,{} or a pair of PatternMatchResult,{} one for atoms (elements of the list),{} and one for lists."))
 (|lists|
  (((|PatternMatchResult| |#1| |#3|) $)
   "\\spad{lists(r)} returns the list of matches that match lists."))
 (|atoms|
  (((|PatternMatchResult| |#1| |#2|) $)
   "\\spad{atoms(r)} returns the list of matches that match atoms (elements of the lists)."))
 (|makeResult|
  (($ (|PatternMatchResult| |#1| |#2|) (|PatternMatchResult| |#1| |#3|))
   "\\spad{makeResult(r1,{} r2)} makes the combined result [\\spad{r1},{} \\spad{r2}]."))
 (|new| (($) "\\spad{new()} returns a new empty match result."))
 (|failed| (($) "\\spad{failed()} returns a failed match."))
 (|failed?|
  (((|Boolean|) $) "\\spad{failed?(r)} tests if \\spad{r} is a failed match."))) 
NIL 
(|PatternMatchable| S) 
((|constructor|
  (NIL
   "A set \\spad{R} is PatternMatchable over \\spad{S} if elements of \\spad{R} can be matched to patterns over \\spad{S}."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| $) $ (|Pattern| |#1|)
    (|PatternMatchResult| |#1| $))
   "\\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \\spad{pat} to the expression \\spad{expr}. res contains the variables of \\spad{pat} which are already matched and their matches (necessary for recursion). Initially,{} res is just the result of \\spadfun{new} which is an empty list of matches."))) 
NIL 
(|PatternMatch| |Base| |Subject| |Pat|) 
((|constructor|
  (NIL "This package provides the top-level pattern macthing functions."))
 (|Is|
  (((|PatternMatchResult| |#1| |#2|) |#2| |#3|)
   "\\spad{Is(expr,{} pat)} matches the pattern pat on the expression \\spad{expr} and returns a match of the form \\spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty match if \\spad{expr} is exactly equal to pat. returns a \\spadfun{failed} match if pat does not match \\spad{expr}.")
  (((|List| (|Equation| (|Polynomial| |#2|))) |#2| |#3|)
   "\\spad{Is(expr,{} pat)} matches the pattern pat on the expression \\spad{expr} and returns a list of matches \\spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty list if either \\spad{expr} is exactly equal to pat or if pat does not match \\spad{expr}.")
  (((|List| (|Equation| |#2|)) |#2| |#3|)
   "\\spad{Is(expr,{} pat)} matches the pattern pat on the expression \\spad{expr} and returns a list of matches \\spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty list if either \\spad{expr} is exactly equal to pat or if pat does not match \\spad{expr}.")
  (((|PatternMatchListResult| |#1| |#2| (|List| |#2|)) (|List| |#2|) |#3|)
   "\\spad{Is([e1,{} ...,{} en],{} pat)} matches the pattern pat on the list of expressions \\spad{[e1,{} ...,{} en]} and returns the result."))
 (|is?|
  (((|Boolean|) (|List| |#2|) |#3|)
   "\\spad{is?([e1,{} ...,{} en],{} pat)} tests if the list of expressions \\spad{[e1,{} ...,{} en]} matches the pattern pat.")
  (((|Boolean|) |#2| |#3|)
   "\\spad{is?(expr,{} pat)} tests if the expression \\spad{expr} matches the pattern pat."))) 
((|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|)))
 (AND (|not| (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|))))
      (|not| (|HasCategory| |#2| '(|Ring|))))
 (AND (|HasCategory| |#2| '(|Ring|))
      (|not| (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|)))))) 
(|PatternMatchResult| R S) 
((|constructor|
  (NIL
   "A PatternMatchResult is an object internally returned by the pattern matcher; It is either a failed match,{} or a list of matches of the form (var,{} expr) meaning that the variable var matches the expression expr."))
 (|satisfy?|
  (((|Union| (|Boolean|) "failed") $ (|Pattern| |#1|))
   "\\spad{satisfy?(r,{} p)} returns \\spad{true} if the matches satisfy the top-level predicate of \\spad{p},{} \\spad{false} if they don\\spad{'t},{} and \"failed\" if not enough variables of \\spad{p} are matched in \\spad{r} to decide."))
 (|construct|
  (($ (|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| |#2|))))
   "\\spad{construct([v1,{} e1],{} ...,{} [vn,{} en])} returns the match result containing the matches (\\spad{v1},{} \\spad{e1}),{} ...,{} (\\spad{vn},{} en)."))
 (|destruct|
  (((|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| |#2|))) $)
   "\\spad{destruct(r)} returns the list of matches (var,{} expr) in \\spad{r}. Error: if \\spad{r} is a failed match."))
 (|addMatchRestricted|
  (($ (|Pattern| |#1|) |#2| $ |#2|)
   "\\spad{addMatchRestricted(var,{} expr,{} r,{} val)} adds the match (\\spad{var},{} \\spad{expr}) in \\spad{r},{} provided that \\spad{expr} satisfies the predicates attached to \\spad{var},{} that \\spad{var} is not matched to another expression already,{} and that either \\spad{var} is an optional pattern variable or that \\spad{expr} is not equal to val (usually an identity)."))
 (|insertMatch|
  (($ (|Pattern| |#1|) |#2| $)
   "\\spad{insertMatch(var,{} expr,{} r)} adds the match (\\spad{var},{} \\spad{expr}) in \\spad{r},{} without checking predicates or previous matches for \\spad{var}."))
 (|addMatch|
  (($ (|Pattern| |#1|) |#2| $)
   "\\spad{addMatch(var,{} expr,{} r)} adds the match (\\spad{var},{} \\spad{expr}) in \\spad{r},{} provided that \\spad{expr} satisfies the predicates attached to \\spad{var},{} and that \\spad{var} is not matched to another expression already."))
 (|getMatch|
  (((|Union| |#2| "failed") (|Pattern| |#1|) $)
   "\\spad{getMatch(var,{} r)} returns the expression that \\spad{var} matches in the result \\spad{r},{} and \"failed\" if \\spad{var} is not matched in \\spad{r}."))
 (|union|
  (($ $ $) "\\spad{union(a,{} b)} makes the set-union of two match results."))
 (|new| (($) "\\spad{new()} returns a new empty match result."))
 (|failed| (($) "\\spad{failed()} returns a failed match."))
 (|failed?|
  (((|Boolean|) $) "\\spad{failed?(r)} tests if \\spad{r} is a failed match."))) 
NIL 
(|PatternMatchResultFunctions2| R A B) 
((|constructor| (NIL "Lifts maps to pattern matching results."))
 (|map|
  (((|PatternMatchResult| |#1| |#3|) (|Mapping| |#3| |#2|)
    (|PatternMatchResult| |#1| |#2|))
   "\\spad{map(f,{} [(v1,{} a1),{} ...,{} (vn,{} an)])} returns the matching result [(\\spad{v1},{} \\spad{f}(\\spad{a1})),{} ...,{} (\\spad{vn},{} \\spad{f}(an))]."))) 
NIL 
(|Pattern| R) 
((|constructor| (NIL "Patterns for use by the pattern matcher."))
 (|optpair|
  (((|Union| (|List| $) "failed") (|List| $))
   "\\spad{optpair(l)} returns \\spad{l} has the form \\spad{[a,{} b]} and a is optional,{} and \"failed\" otherwise."))
 (|variables|
  (((|List| $) $)
   "\\spad{variables(p)} returns the list of matching variables appearing in \\spad{p}."))
 (|getBadValues|
  (((|List| (|Any|)) $)
   "\\spad{getBadValues(p)} returns the list of \"bad values\" for \\spad{p}. Note: \\spad{p} is not allowed to match any of its \"bad values\"."))
 (|addBadValue|
  (($ $ (|Any|))
   "\\spad{addBadValue(p,{} v)} adds \\spad{v} to the list of \"bad values\" for \\spad{p}. Note: \\spad{p} is not allowed to match any of its \"bad values\"."))
 (|resetBadValues|
  (($ $)
   "\\spad{resetBadValues(p)} initializes the list of \"bad values\" for \\spad{p} to \\spad{[]}. Note: \\spad{p} is not allowed to match any of its \"bad values\"."))
 (|hasTopPredicate?|
  (((|Boolean|) $)
   "\\spad{hasTopPredicate?(p)} tests if \\spad{p} has a top-level predicate."))
 (|topPredicate|
  (((|Record| (|:| |var| (|List| (|Symbol|))) (|:| |pred| (|Any|))) $)
   "\\spad{topPredicate(x)} returns \\spad{[[a1,{} ...,{} an],{} f]} where the top-level predicate of \\spad{x} is \\spad{f(a1,{} ...,{} an)}. Note: \\spad{n} is 0 if \\spad{x} has no top-level predicate."))
 (|setTopPredicate|
  (($ $ (|List| (|Symbol|)) (|Any|))
   "\\spad{setTopPredicate(x,{} [a1,{} ...,{} an],{} f)} returns \\spad{x} with the top-level predicate set to \\spad{f(a1,{} ...,{} an)}."))
 (|patternVariable|
  (($ (|Symbol|) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{patternVariable(x,{} c?,{} o?,{} m?)} creates a pattern variable \\spad{x},{} which is constant if \\spad{c? = true},{} optional if \\spad{o? = true},{} and multiple if \\spad{m? = true}."))
 (|withPredicates|
  (($ $ (|List| (|Any|)))
   "\\spad{withPredicates(p,{} [p1,{} ...,{} pn])} makes a copy of \\spad{p} and attaches the predicate \\spad{p1} and ... and \\spad{pn} to the copy,{} which is returned."))
 (|setPredicates|
  (($ $ (|List| (|Any|)))
   "\\spad{setPredicates(p,{} [p1,{} ...,{} pn])} attaches the predicate \\spad{p1} and ... and \\spad{pn} to \\spad{p}."))
 (|predicates|
  (((|List| (|Any|)) $)
   "\\spad{predicates(p)} returns \\spad{[p1,{} ...,{} pn]} such that the predicate attached to \\spad{p} is \\spad{p1} and ... and \\spad{pn}."))
 (|hasPredicate?|
  (((|Boolean|) $)
   "\\spad{hasPredicate?(p)} tests if \\spad{p} has predicates attached to it."))
 (|optional?|
  (((|Boolean|) $)
   "\\spad{optional?(p)} tests if \\spad{p} is a single matching variable which can match an identity."))
 (|multiple?|
  (((|Boolean|) $)
   "\\spad{multiple?(p)} tests if \\spad{p} is a single matching variable allowing list matching or multiple term matching in a sum or product."))
 (|generic?|
  (((|Boolean|) $)
   "\\spad{generic?(p)} tests if \\spad{p} is a single matching variable."))
 (|constant?|
  (((|Boolean|) $)
   "\\spad{constant?(p)} tests if \\spad{p} contains no matching variables."))
 (|symbol?|
  (((|Boolean|) $) "\\spad{symbol?(p)} tests if \\spad{p} is a symbol."))
 (|quoted?|
  (((|Boolean|) $)
   "\\spad{quoted?(p)} tests if \\spad{p} is of the form \\spad{'s} for a symbol \\spad{s}."))
 (|inR?|
  (((|Boolean|) $)
   "\\spad{inR?(p)} tests if \\spad{p} is an atom (\\spadignore{i.e.} an element of \\spad{R})."))
 (|copy| (($ $) "\\spad{copy(p)} returns a recursive copy of \\spad{p}."))
 (|convert|
  (($ (|List| $))
   "\\spad{convert([a1,{} ...,{} an])} returns the pattern \\spad{[a1,{} ...,{} an]}."))
 (|depth|
  (((|NonNegativeInteger|) $)
   "\\spad{depth(p)} returns the nesting level of \\spad{p}."))
 (/ (($ $ $) "\\spad{a / b} returns the pattern \\spad{a / b}."))
 (^ (($ $ $) "\\spad{a ^ b} returns the pattern \\spad{a ^ b}.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{a ^ n} returns the pattern \\spad{a ^ n}."))
 (* (($ $ $) "\\spad{a * b} returns the pattern \\spad{a * b}."))
 (+ (($ $ $) "\\spad{a + b} returns the pattern \\spad{a + b}."))
 (|elt|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{elt(op,{} [a1,{} ...,{} an])} returns \\spad{op(a1,{} ...,{} an)}."))
 (|isPower|
  (((|Union| (|Record| (|:| |val| $) (|:| |exponent| $)) "failed") $)
   "\\spad{isPower(p)} returns \\spad{[a,{} b]} if \\spad{p = a ^ b},{} and \"failed\" otherwise."))
 (|isList|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isList(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{p = [a1,{} ...,{} an]},{} \"failed\" otherwise."))
 (|isQuotient|
  (((|Union| (|Record| (|:| |num| $) (|:| |den| $)) "failed") $)
   "\\spad{isQuotient(p)} returns \\spad{[a,{} b]} if \\spad{p = a / b},{} and \"failed\" otherwise."))
 (|isExpt|
  (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|NonNegativeInteger|)))
             "failed")
    $)
   "\\spad{isExpt(p)} returns \\spad{[q,{} n]} if \\spad{n > 0} and \\spad{p = q ^ n},{} and \"failed\" otherwise."))
 (|isOp|
  (((|Union| (|Record| (|:| |op| (|BasicOperator|)) (|:| |arg| (|List| $)))
             "failed")
    $)
   "\\spad{isOp(p)} returns \\spad{[op,{} [a1,{} ...,{} an]]} if \\spad{p = op(a1,{} ...,{} an)},{} and \"failed\" otherwise.")
  (((|Union| (|List| $) "failed") $ (|BasicOperator|))
   "\\spad{isOp(p,{} op)} returns \\spad{[a1,{} ...,{} an]} if \\spad{p = op(a1,{} ...,{} an)},{} and \"failed\" otherwise."))
 (|isTimes|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{n > 1} and \\spad{p = a1 * ... * an},{} and \"failed\" otherwise."))
 (|isPlus|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isPlus(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{n > 1} \\indented{1}{and \\spad{p = a1 + ... + an},{}} and \"failed\" otherwise."))
 ((|One|) (($) "1")) ((|Zero|) (($) "0"))) 
NIL 
(|PatternFunctions1| R D) 
((|constructor| (NIL "Tools for patterns."))
 (|badValues|
  (((|List| |#2|) (|Pattern| |#1|))
   "\\spad{badValues(p)} returns the list of \"bad values\" for \\spad{p}; \\spad{p} is not allowed to match any of its \"bad values\"."))
 (|addBadValue|
  (((|Pattern| |#1|) (|Pattern| |#1|) |#2|)
   "\\spad{addBadValue(p,{} v)} adds \\spad{v} to the list of \"bad values\" for \\spad{p}; \\spad{p} is not allowed to match any of its \"bad values\"."))
 (|satisfy?|
  (((|Boolean|) (|List| |#2|) (|Pattern| |#1|))
   "\\spad{satisfy?([v1,{} ...,{} vn],{} p)} returns \\spad{f(v1,{} ...,{} vn)} where \\spad{f} is the top-level predicate attached to \\spad{p}.")
  (((|Boolean|) |#2| (|Pattern| |#1|))
   "\\spad{satisfy?(v,{} p)} returns \\spad{f}(\\spad{v}) where \\spad{f} is the predicate attached to \\spad{p}."))
 (|predicate|
  (((|Mapping| (|Boolean|) |#2|) (|Pattern| |#1|))
   "\\spad{predicate(p)} returns the predicate attached to \\spad{p},{} the constant function \\spad{true} if \\spad{p} has no predicates attached to it."))
 (|suchThat|
  (((|Pattern| |#1|) (|Pattern| |#1|) (|List| (|Symbol|))
    (|Mapping| (|Boolean|) (|List| |#2|)))
   "\\spad{suchThat(p,{} [a1,{} ...,{} an],{} f)} returns a copy of \\spad{p} with the top-level predicate set to \\spad{f(a1,{} ...,{} an)}.")
  (((|Pattern| |#1|) (|Pattern| |#1|) (|List| (|Mapping| (|Boolean|) |#2|)))
   "\\spad{suchThat(p,{} [f1,{} ...,{} fn])} makes a copy of \\spad{p} and adds the predicate \\spad{f1} and ... and \\spad{fn} to the copy,{} which is returned.")
  (((|Pattern| |#1|) (|Pattern| |#1|) (|Mapping| (|Boolean|) |#2|))
   "\\spad{suchThat(p,{} f)} makes a copy of \\spad{p} and adds the predicate \\spad{f} to the copy,{} which is returned."))) 
NIL 
(|PatternFunctions2| R S) 
((|constructor| (NIL "Lifts maps to patterns."))
 (|map|
  (((|Pattern| |#2|) (|Mapping| |#2| |#1|) (|Pattern| |#1|))
   "\\spad{map(f,{} p)} applies \\spad{f} to all the leaves of \\spad{p} and returns the result as a pattern over \\spad{S}."))) 
NIL 
(|PoincareBirkhoffWittLyndonBasis| |VarSet|) 
((|constructor|
  (NIL
   "This domain provides the internal representation of polynomials in non-commutative variables written over the Poincare-Birkhoff-Witt basis. See the \\spadtype{XPBWPolynomial} domain constructor. See Free Lie Algebras by \\spad{C}. Reutenauer (Oxford science publications). \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList([l1]*[l2]*...[ln])} returns the list of variables in the word \\spad{l1*l2*...*ln}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?([l1]*[l2]*...[ln])} returns \\spad{true} iff \\spad{n} equals \\spad{1}."))
 (|rest|
  (($ $)
   "\\spad{rest([l1]*[l2]*...[ln])} returns the list \\spad{l2,{} .... ln}."))
 (|listOfTerms|
  (((|List| (|LyndonWord| |#1|)) $)
   "\\spad{listOfTerms([l1]*[l2]*...[ln])} returns the list of words \\spad{l1,{} l2,{} .... ln}."))
 (|length|
  (((|NonNegativeInteger|) $)
   "\\spad{length([l1]*[l2]*...[ln])} returns the length of the word \\spad{l1*l2*...*ln}."))
 (|first|
  (((|LyndonWord| |#1|) $)
   "\\spad{first([l1]*[l2]*...[ln])} returns the Lyndon word \\spad{l1}."))
 (|coerce| (($ |#1|) "\\spad{coerce(v)} return \\spad{v}")
           (((|FreeMonoid| |#1|) $)
            "\\spad{coerce([l1]*[l2]*...[ln])} returns the word \\spad{l1*l2*...*ln},{} where \\spad{[l_i]} is the backeted form of the Lyndon word \\spad{l_i}."))
 ((|One|) (($) "\\spad{1} returns the empty list."))) 
NIL 
(|PolynomialCommonDenominator| R Q E |VarSet| P) 
((|constructor|
  (NIL
   "PolynomialCommonDenominator provides \\indented{1}{functions to compute and clear the common denominator of the} \\indented{1}{coefficients of polynomials over the quotient field.}"))
 (|splitDenominator|
  (((|Record| (|:| |num| |#5|) (|:| |den| |#1|)) |#5|)
   "\\spad{splitDenominator(q)} returns \\spad{[p,{} d]} such that \\spad{q = p/d} and \\spad{d} is a common denominator for the coefficients of \\spad{q}."))
 (|clearDenominator|
  ((|#5| |#5|)
   "\\spad{clearDenominator(q)} returns \\spad{p} such that \\spad{q = p/d} where \\spad{d} is a common denominator for the coefficients of \\spad{q}."))
 (|commonDenominator|
  ((|#1| |#5|)
   "\\spad{commonDenominator(q)} returns a common denominator \\spad{d} for the coefficients of \\spad{q}."))) 
NIL 
(|PartialDifferentialOperator| R |Var|) 
((|constructor|
  (NIL
   "PartialDifferentialOperator(\\spad{R},{} \\spad{V}) defines a ring of partial differential operators in variables from \\spad{V} and with coefficients in a partial differential ring \\spad{R}. Multiplication of operators corresponds to composition of operators. \\blankline"))
 (|adjoint|
  (($ $) "\\spad{adjoint(p)} returns the adjoint of operator \\spad{p}."))
 (D
  (($ |#2|)
   "\\spad{D(v)} returns the operator corresponding to derivative with respect to \\spad{v} in \\spad{R}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|LeftOreRing|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|LeftOreRing|))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|LeftOreRing|))
     (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))) 
(|PartialDifferentialOperatorHelper| R |Var|) 
NIL 
NIL 
(|PartialDifferentialRing&| A S) 
((|constructor|
  (NIL
   "A partial differential ring with differentiations indexed by a parameter type \\spad{S}. \\blankline"))
 (D
  (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|)))
   "\\spad{D(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{D(...D(x,{} s1,{} n1)...,{} sn,{} nn)}.")
  (($ $ |#2| (|NonNegativeInteger|))
   "\\spad{D(x,{} s,{} n)} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s}.")
  (($ $ (|List| |#2|))
   "\\spad{D(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \\spadignore{i.e.} \\spad{D(...D(x,{} s1)...,{} sn)}.")
  (($ $ |#2|)
   "\\spad{D(x,{} v)} computes the partial derivative of \\spad{x} with respect to \\spad{v}."))
 (|differentiate|
  (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|)))
   "\\spad{differentiate(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \\spadignore{i.e.}")
  (($ $ |#2| (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} s,{} n)} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s}.")
  (($ $ (|List| |#2|))
   "\\spad{differentiate(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \\spadignore{i.e.} \\spad{differentiate(...differentiate(x,{} s1)...,{} sn)}.")
  (($ $ |#2|)
   "\\spad{differentiate(x,{} v)} computes the partial derivative of \\spad{x} with respect to \\spad{v}."))) 
NIL 
(|PartialDifferentialRing| S) 
((|constructor|
  (NIL
   "A partial differential ring with differentiations indexed by a parameter type \\spad{S}. \\blankline"))
 (D
  (($ $ (|List| |#1|) (|List| (|NonNegativeInteger|)))
   "\\spad{D(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{D(...D(x,{} s1,{} n1)...,{} sn,{} nn)}.")
  (($ $ |#1| (|NonNegativeInteger|))
   "\\spad{D(x,{} s,{} n)} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s}.")
  (($ $ (|List| |#1|))
   "\\spad{D(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \\spadignore{i.e.} \\spad{D(...D(x,{} s1)...,{} sn)}.")
  (($ $ |#1|)
   "\\spad{D(x,{} v)} computes the partial derivative of \\spad{x} with respect to \\spad{v}."))
 (|differentiate|
  (($ $ (|List| |#1|) (|List| (|NonNegativeInteger|)))
   "\\spad{differentiate(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \\spadignore{i.e.}")
  (($ $ |#1| (|NonNegativeInteger|))
   "\\spad{differentiate(x,{} s,{} n)} computes multiple partial derivatives,{} \\spadignore{i.e.} \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s}.")
  (($ $ (|List| |#1|))
   "\\spad{differentiate(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \\spadignore{i.e.} \\spad{differentiate(...differentiate(x,{} s1)...,{} sn)}.")
  (($ $ |#1|)
   "\\spad{differentiate(x,{} v)} computes the partial derivative of \\spad{x} with respect to \\spad{v}."))) 
NIL 
(|PendantTree| S) 
((|constructor|
  (NIL
   "\\indented{1}{A PendantTree(\\spad{S}) is either a leaf? and is an \\spad{S} or has} a left and a right are both PendantTree(\\spad{S})."))
 (|coerce| (((|Tree| |#1|) $) "\\spad{coerce(x)} \\undocumented"))
 (|ptree| (($ $ $) "\\spad{ptree(x,{} y)} \\undocumented")
  (($ |#1|) "\\spad{ptree(s)} is a leaf? pendant tree"))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|Permutation| S) 
((|constructor|
  (NIL
   "Permutation(\\spad{S}) implements the group of all bijections \\indented{2}{on a set \\spad{S},{} which move only a finite number of points.} \\indented{2}{A permutation is considered as a map from \\spad{S} into \\spad{S}. In particular} \\indented{2}{multiplication is defined as composition of maps:} \\indented{2}{{\\em pi1 * pi2 = pi1 o pi2}.} \\indented{2}{The internal representation of permuatations are two lists} \\indented{2}{of equal length representing preimages and images.}"))
 (|coerceImages|
  (($ (|List| |#1|))
   "\\spad{coerceImages(ls)} coerces the list {\\em ls} to a permutation whose image is given by {\\em ls} and the preimage is fixed to be {\\em [1,{} ...,{} n]}. Note: {coerceImages(\\spad{ls})=coercePreimagesImages([1,{} ...,{} \\spad{n}],{} \\spad{ls})}. We assume that both preimage and image do not contain repetitions."))
 (|fixedPoints|
  (((|Set| |#1|) $)
   "\\spad{fixedPoints(p)} returns the points fixed by the permutation \\spad{p}."))
 (|sort|
  (((|List| $) (|List| $))
   "\\spad{sort(lp)} sorts a list of permutations {\\em lp} according to cycle structure first according to length of cycles,{} second,{} if \\spad{S} has \\spadtype{Finite} or \\spad{S} has \\spadtype{OrderedSet} according to lexicographical order of entries in cycles of equal length."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd?(p)} returns \\spad{true} if and only if \\spad{p} is an odd permutation \\spadignore{i.e.} {\\em sign(p)} is {\\em -1}."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even?(p)} returns \\spad{true} if and only if \\spad{p} is an even permutation,{} \\spadignore{i.e.} {\\em sign(p)} is 1."))
 (|sign|
  (((|Integer|) $)
   "\\spad{sign(p)} returns the signum of the permutation \\spad{p},{} \\spad{+1} or \\spad{-1}."))
 (|numberOfCycles|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfCycles(p)} returns the number of non-trivial cycles of the permutation \\spad{p}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(p)} returns the order of a permutation \\spad{p} as a group element."))
 (|cyclePartition|
  (((|Partition|) $)
   "\\spad{cyclePartition(p)} returns the cycle structure of a permutation \\spad{p} including cycles of length 1 only if \\spad{S} is finite."))
 (|movedPoints|
  (((|Set| |#1|) $)
   "\\spad{movedPoints(p)} returns the set of points moved by the permutation \\spad{p}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(p)} returns the number of points moved by the permutation \\spad{p}."))
 (|coerceListOfPairs|
  (($ (|List| (|List| |#1|)))
   "\\spad{coerceListOfPairs(lls)} coerces a list of pairs {\\em lls} to a permutation. Error: if not consistent,{} \\spadignore{i.e.} the set of the first elements coincides with the set of second elements. coerce(\\spad{p}) generates output of the permutation \\spad{p} with domain OutputForm."))
 (|coerce|
  (($ (|List| |#1|))
   "\\spad{coerce(ls)} coerces a cycle {\\em ls},{} \\spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\\em ls.i} to {\\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur.")
  (($ (|List| (|List| |#1|)))
   "\\spad{coerce(lls)} coerces a list of cycles {\\em lls} to a permutation,{} each cycle being a list with no repetitions,{} is coerced to the permutation,{} which maps {\\em ls.i} to {\\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are mutiplied. Error: if repetitions occur in one cycle."))
 (|coercePreimagesImages|
  (($ (|List| (|List| |#1|)))
   "\\spad{coercePreimagesImages(lls)} coerces the representation {\\em lls} of a permutation as a list of preimages and images to a permutation. We assume that both preimage and image do not contain repetitions."))
 (|listRepresentation|
  (((|Record| (|:| |preimage| (|List| |#1|)) (|:| |image| (|List| |#1|))) $)
   "\\spad{listRepresentation(p)} produces a representation {\\em rep} of the permutation \\spad{p} as a list of preimages and images,{} \\spad{i}.\\spad{e} \\spad{p} maps {\\em (rep.preimage).k} to {\\em (rep.image).k} for all indices \\spad{k}. Elements of \\spad{S} not in {\\em (rep.preimage).k} are fixed points,{} and these are the only fixed points of the permutation."))) 
((|HasCategory| |#1| '(|Finite|))
 (OR (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (OR (|HasCategory| |#1| '(|Finite|))
     (|HasCategory| |#1| '(|IntegerNumberSystem|)))) 
(|Permanent| |n| R) 
((|constructor|
  (NIL
   "Permanent implements the functions {\\em permanent},{} the permanent for square matrices."))
 (|permanent|
  ((|#2| (|SquareMatrix| |#1| |#2|))
   "\\spad{permanent(x)} computes the permanent of a square matrix \\spad{x}. The {\\em permanent} is equivalent to the \\spadfun{determinant} except that coefficients have no change of sign. This function is much more difficult to compute than the {\\em determinant}. The formula used is by \\spad{H}.\\spad{J}. Ryser,{} improved by [Nijenhuis and Wilf,{} \\spad{Ch}. 19]. Note: permanent(\\spad{x}) choose one of three algorithms,{} depending on the underlying ring \\spad{R} and on \\spad{n},{} the number of rows (and columns) of \\spad{x:} \\begin{items} \\item 1. if 2 has an inverse in \\spad{R} we can use the algorithm of \\indented{3}{[Nijenhuis and Wilf,{} \\spad{ch}.19,{} \\spad{p}.158]; if 2 has no inverse,{}} \\indented{3}{some modifications are necessary:} \\item 2. if {\\em n > 6} and \\spad{R} is an integral domain with characteristic \\indented{3}{different from 2 (the algorithm works if and only 2 is not a} \\indented{3}{zero-divisor of \\spad{R} and {\\em characteristic()\\$R ~= 2},{}} \\indented{3}{but how to check that for any given \\spad{R} ?),{}} \\indented{3}{the local function {\\em permanent2} is called;} \\item 3. else,{} the local function {\\em permanent3} is called \\indented{3}{(works for all commutative rings \\spad{R}).} \\end{items}"))) 
NIL 
(|PermutationCategory| S) 
((|constructor|
  (NIL
   "PermutationCategory provides a categorical environment \\indented{1}{for subgroups of bijections of a set (\\spadignore{i.e.} permutations)}"))
 (<
  (((|Boolean|) $ $)
   "\\spad{p < q} is an order relation on permutations. Note: this order is only total if and only if \\spad{S} is totally ordered or \\spad{S} is finite."))
 (|orbit|
  (((|Set| |#1|) $ |#1|)
   "\\spad{orbit(p,{} el)} returns the orbit of {\\em el} under the permutation \\spad{p},{} \\spadignore{i.e.} the set which is given by applications of the powers of \\spad{p} to {\\em el}."))
 (|elt|
  ((|#1| $ |#1|)
   "\\spad{elt(p,{} el)} returns the image of {\\em el} under the permutation \\spad{p}."))
 (|eval|
  ((|#1| $ |#1|)
   "\\spad{eval(p,{} el)} returns the image of {\\em el} under the permutation \\spad{p}."))
 (|cycles|
  (($ (|List| (|List| |#1|)))
   "\\spad{cycles(lls)} coerces a list list of cycles {\\em lls} to a permutation,{} each cycle being a list with not repetitions,{} is coerced to the permutation,{} which maps {\\em ls.i} to {\\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are mutiplied. Error: if repetitions occur in one cycle."))
 (|cycle|
  (($ (|List| |#1|))
   "\\spad{cycle(ls)} coerces a cycle {\\em ls},{} \\spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\\em ls.i} to {\\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur."))) 
NIL 
(|PermutationGroup| S) 
((|constructor|
  (NIL
   "PermutationGroup implements permutation groups acting on a set \\spad{S},{} \\spadignore{i.e.} all subgroups of the symmetric group of \\spad{S},{} represented as a list of permutations (generators). Note that therefore the objects are not members of the \\Language category \\spadtype{Group}. Using the idea of base and strong generators by Sims,{} basic routines and algorithms are implemented so that the word problem for permutation groups can be solved."))
 (|perm_to_vec|
  (((|Vector| (|NonNegativeInteger|)) (|List| |#1|) (|Permutation| |#1|)
    (|NonNegativeInteger|))
   "\\spad{perm_to_vec(supp,{} p,{} degree)} should be local but conditional"))
 (|pointList|
  (((|List| |#1|) $) "\\spad{pointList(gp)} should be local but conditional"))
 (|relationsInGenerators|
  (((|List| (|List| (|Integer|))) $)
   "\\spad{relationsInGenerators(gp)} computes relations between generators."))
 (|relationsInStrongGenerators|
  (((|List| (|List| (|Integer|))) $)
   "\\spad{relationsInStrongGenerators(gp)} computes relations between strong generators."))
 (|initializeGroupForWordProblem|
  (((|Void|) $ (|Integer|) (|Integer|))
   "\\spad{initializeGroupForWordProblem(gp,{} m,{} n)} initializes the group {\\em gp} for the word problem. Notes: (1) with a small integer you get shorter words,{} but the routine takes longer than the standard routine for longer words. (2) be careful: invoking this routine will destroy the possibly stored information about your group (but will recompute it again). (3) users need not call this function normally for the soultion of the word problem.")
  (((|Void|) $)
   "\\spad{initializeGroupForWordProblem(gp)} initializes the group {\\em gp} for the word problem. Notes: it calls the other function of this name with parameters 0 and 1: {\\em initializeGroupForWordProblem(gp,{} 0,{} 1)}. Notes: (1) be careful: invoking this routine will destroy the possibly information about your group (but will recompute it again) (2) users need not call this function normally for the soultion of the word problem."))
 (<=
  (((|Boolean|) $ $)
   "\\spad{gp1 <= gp2} returns \\spad{true} if and only if {\\em gp1} is a subgroup of {\\em gp2}. Note: because of a bug in the parser you have to call this function explicitly by {\\em gp1 <=\\$(PERMGRP S) gp2}."))
 (<
  (((|Boolean|) $ $)
   "\\spad{gp1 < gp2} returns \\spad{true} if and only if {\\em gp1} is a proper subgroup of {\\em gp2}."))
 (|movedPoints|
  (((|Set| |#1|) $)
   "\\spad{movedPoints(gp)} returns the points moved by the group {\\em gp}."))
 (|wordInGenerators|
  (((|List| (|NonNegativeInteger|)) (|Permutation| |#1|) $)
   "\\spad{wordInGenerators(p,{} gp)} returns the word for the permutation \\spad{p} in the original generators of the group {\\em gp},{} represented by the indices of the list,{} given by {\\em generators}."))
 (|wordInStrongGenerators|
  (((|List| (|NonNegativeInteger|)) (|Permutation| |#1|) $)
   "\\spad{wordInStrongGenerators(p,{} gp)} returns the word for the permutation \\spad{p} in the strong generators of the group {\\em gp},{} represented by the indices of the list,{} given by {\\em strongGenerators}."))
 (|member?|
  (((|Boolean|) (|Permutation| |#1|) $)
   "\\spad{member?(pp,{} gp)} answers the question,{} whether the permutation {\\em pp} is in the group {\\em gp} or not."))
 (|orbits|
  (((|Set| (|Set| |#1|)) $)
   "\\spad{orbits(gp)} returns the orbits of the group {\\em gp},{} \\spadignore{i.e.} it partitions the (finite) of all moved points."))
 (|orbit|
  (((|Set| (|List| |#1|)) $ (|List| |#1|))
   "\\spad{orbit(gp,{} ls)} returns the orbit of the ordered list {\\em ls} under the group {\\em gp}. Note: return type is \\spad{L} \\spad{L} \\spad{S} temporarily because FSET \\spad{L} \\spad{S} has an error.")
  (((|Set| (|Set| |#1|)) $ (|Set| |#1|))
   "\\spad{orbit(gp,{} els)} returns the orbit of the unordered set {\\em els} under the group {\\em gp}.")
  (((|Set| |#1|) $ |#1|)
   "\\spad{orbit(gp,{} el)} returns the orbit of the element {\\em el} under the group {\\em gp},{} \\spadignore{i.e.} the set of all points gained by applying each group element to {\\em el}."))
 (|permutationGroup|
  (($ (|List| (|Permutation| |#1|)))
   "\\spad{permutationGroup(ls)} coerces a list of permutations {\\em ls} to the group generated by this list."))
 (|wordsForStrongGenerators|
  (((|List| (|List| (|NonNegativeInteger|))) $)
   "\\spad{wordsForStrongGenerators(gp)} returns the words for the strong generators of the group {\\em gp} in the original generators of {\\em gp},{} represented by their indices in the list,{} given by {\\em generators}."))
 (|strongGenerators|
  (((|List| (|Permutation| |#1|)) $)
   "\\spad{strongGenerators(gp)} returns strong generators for the group {\\em gp}."))
 (|base|
  (((|List| |#1|) $)
   "\\spad{base(gp)} returns a base for the group {\\em gp}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(gp)} returns the number of points moved by all permutations of the group {\\em gp}."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(gp)} returns the order of the group {\\em gp}."))
 (|random|
  (((|Permutation| |#1|) $)
   "\\spad{random(gp)} returns a random product of maximal 20 generators of the group {\\em gp}. Note: {\\em random(gp)=random(gp,{} 20)}.")
  (((|Permutation| |#1|) $ (|Integer|))
   "\\spad{random(gp,{} i)} returns a random product of maximal \\spad{i} generators of the group {\\em gp}."))
 (|elt|
  (((|Permutation| |#1|) $ (|NonNegativeInteger|))
   "\\spad{elt(gp,{} i)} returns the \\spad{i}-th generator of the group {\\em gp}."))
 (|generators|
  (((|List| (|Permutation| |#1|)) $)
   "\\spad{generators(gp)} returns the generators of the group {\\em gp}."))
 (|coerce|
  (($ (|List| (|Permutation| |#1|)))
   "\\spad{coerce(ls)} coerces a list of permutations {\\em ls} to the group generated by this list.")
  (((|List| (|Permutation| |#1|)) $)
   "\\spad{coerce(gp)} returns the generators of the group {\\em gp}."))) 
NIL 
(|PolynomialEvaluationUtilities|) 
((|constructor|
  (NIL
   "This package implements evaluation functions \\indented{1}{useful for modular algorithms.\\space{2}Computations work} \\indented{1}{on integer polynomials,{} but most is done modulo a prime} \\indented{1}{which is provided via parameters,{} either explicitly or} \\indented{1}{through a state parameter (state also caches needed buffers).} \\indented{1}{Some functions work on fractions.\\space{2}To avoid useless \\spad{GCD}} \\indented{1}{computations during evaluation fractions may be represented} \\indented{1}{as a record.}"))
 (|modpeval|
  (((|Integer|) (|Polynomial| (|Integer|)) (|List| (|Symbol|))
    (|List| (|Integer|)) (|Integer|))
   "\\spad{modpeval(pol,{} lv,{} lpt,{} p)} evaluates polynomial \\spad{pol} in variables form \\spad{lv} at point from \\spad{lpt} modulo a prime \\spad{p}"))
 (|modpreduction|
  (((|Union|
     (|Record| (|:| |numer| (|Polynomial| (|Integer|)))
               (|:| |denom| (|Polynomial| (|Integer|))))
     "failed")
    (|Fraction| (|Polynomial| (|Integer|))) (|Integer|))
   "\\spad{modpreduction(r,{} p)} reduces a rational function \\spad{r} modulo prime \\spad{p}.")
  (((|Polynomial| (|Integer|)) (|Polynomial| (|Integer|)) (|Integer|))
   "\\spad{modpreduction(pol,{} p)} reduces polynomial \\spad{pol} modulo prime \\spad{p}."))
 (|eval1|
  (((|Union|
     (|Record| (|:| |numer| (|Polynomial| (|Integer|)))
               (|:| |denom| (|Polynomial| (|Integer|))))
     "failed")
    (|Record| (|:| |numer| (|Polynomial| (|Integer|)))
              (|:| |denom| (|Polynomial| (|Integer|))))
    (|Symbol|) (|Integer|)
    (|Record| (|:| |prime| (|Integer|)) (|:| |eval1coeffbuf| (|U32Vector|))
              (|:| |eval1expbuf| (|SortedExponentVector|))))
   "\\spad{eval1(pq,{} v,{} pt,{} pss)} evaluates fraction of polynomial \\spad{pq} in variable \\spad{v} at \\spad{pt},{} using global state form \\spad{pss}. Computations are done modulo a prime contained in \\spad{pss}.")
  (((|Polynomial| (|Integer|)) (|Polynomial| (|Integer|)) (|Symbol|)
    (|Integer|)
    (|Record| (|:| |prime| (|Integer|)) (|:| |eval1coeffbuf| (|U32Vector|))
              (|:| |eval1expbuf| (|SortedExponentVector|))))
   "\\spad{eval1(pol,{} v,{} pt,{} pss)} evaluates \\spad{pol} in variable \\spad{v} at \\spad{pt},{} using global state form \\spad{pss}. Computations are done modulo a prime contained in \\spad{pss}."))
 (|eval1a|
  (((|Integer|) (|Polynomial| (|Integer|)) (|Integer|)
    (|Record| (|:| |prime| (|Integer|)) (|:| |eval1coeffbuf| (|U32Vector|))
              (|:| |eval1expbuf| (|SortedExponentVector|))))
   "\\spad{eval1a(pol,{} pt,{} pss)} evaluates polynomial \\spad{pol} at point \\spad{pt} using global state form \\spad{pss}. Computations are done modulo a prime contained in \\spad{pss}. Note: \\spad{pol} must have at most one variable."))) 
NIL 
(|PrimeField| |p|) 
((|constructor|
  (NIL
   "PrimeField(\\spad{p}) implements the field with \\spad{p} elements if \\spad{p} is a prime number. Error: if \\spad{p} is not prime."))
 (|sqrt|
  (($ $)
   "\\spad{sqrt(x)} computes one \\spad{y} such that \\spad{y^2} = \\spad{x},{} error if there is no square root,{} \\spadignore{i.e.} jacobi(\\spad{x},{}\\spad{p}) = \\spad{-1}."))) 
((|HasCategory| $ '(|CharacteristicNonZero|)) (|HasCategory| $ '(|Field|))
 (|HasCategory| $ '(|Finite|))) 
(|ProductFacet|) 
((|constructor|
  (NIL
   "\\indented{2}{Holds the product of two simplexes} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Date Created: April 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:"))
 (|addVertex2|
  (($ $
    (|Record| (|:| |left| (|NonNegativeInteger|))
              (|:| |right| (|NonNegativeInteger|))))
   "used by cone. Adds a vertex to face."))
 (|setMult!| (($ $ (|Integer|)) "sets multiplier of face"))
 (|getMaxRight| (((|NonNegativeInteger|) $) "returns maximum right index"))
 (|getMaxLeft| (((|NonNegativeInteger|) $) "returns maximum left index"))
 (|getIndexs|
  (((|List|
     (|Record| (|:| |left| (|NonNegativeInteger|))
               (|:| |right| (|NonNegativeInteger|))))
    $)
   "returns left indexes"))
 (|productFacet|
  (($ (|Integer|) (|ProductFacet|)) "Copy constructor to allow change of sign")
  (($ (|Integer|)
    (|List|
     (|Record| (|:| |left| (|NonNegativeInteger|))
               (|:| |right| (|NonNegativeInteger|)))))
   "Constructor for product facet"))) 
NIL 
(|PolynomialFactorizationByRecursion| R E |VarSet| S) 
((|constructor|
  (NIL
   "PolynomialFactorizationByRecursion(\\spad{R},{} \\spad{E},{} \\spad{VarSet},{} \\spad{S}) is used for factorization of sparse univariate polynomials over a domain \\spad{S} of multivariate polynomials over \\spad{R}."))
 (|bivariateSLPEBR|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|List| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|) |#3|)
   "\\spad{bivariateSLPEBR(lp,{} p,{} v)} implements the bivariate case of \\spadfun{solveLinearPolynomialEquationByRecursion}; its implementation depends on \\spad{R}"))
 (|randomR|
  ((|#1| (|Integer|))
   "\\spad{randomR produces} a random element of \\spad{R}"))
 (|factorSquareFreeByRecursion|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \\spad{p}. This functions performs the recursion step for factorSquareFreePolynomial,{} as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorSquareFreePolynomial})."))
 (|factorByRecursion|
  (((|Factored| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{factorByRecursion(p)} factors polynomial \\spad{p}. This function performs the recursion step for factorPolynomial,{} as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorPolynomial})"))
 (|solveLinearPolynomialEquationByRecursion|
  (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed")
    (|List| (|SparseUnivariatePolynomial| |#4|))
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{solveLinearPolynomialEquationByRecursion([p1,{} ...,{} pn],{} p)} returns the list of polynomials \\spad{[q1,{} ...,{} qn]} such that \\spad{sum qi/pi = p / prod \\spad{pi}},{} a recursion step for solveLinearPolynomialEquation as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{solveLinearPolynomialEquation}). If no such list of \\spad{qi} exists,{} then \"failed\" is returned."))) 
NIL 
(|PolynomialFactorizationExplicit&| S) 
((|constructor|
  (NIL
   "This is the category of domains that know \"enough\" about themselves in order to factor univariate polynomials over their fraction field."))
 (|charthRoot|
  (((|Union| $ "failed") $)
   "\\spad{charthRoot(r)} returns the \\spad{p}\\spad{-}th root of \\spad{r},{} or \"failed\" if none exists in the domain."))
 (|conditionP|
  (((|Union| (|Vector| $) "failed") (|Matrix| $))
   "\\spad{conditionP(m)} returns a vector of elements,{} not all zero,{} whose \\spad{p}\\spad{-}th powers (\\spad{p} is the characteristic of the domain) are a solution of the homogenous linear system represented by \\spad{m},{} or \"failed\" is there is no such vector."))
 (|solveLinearPolynomialEquation|
  (((|Union| (|List| (|SparseUnivariatePolynomial| $)) "failed")
    (|List| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $))
   "\\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of \\spad{ai}\\spad{'s} exists."))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   "\\spad{gcdPolynomial(p,{} q)} returns the \\spad{gcd} of the univariate polynomials \\spad{p} \\spad{qnd} \\spad{q}."))
 (|factorSquareFreePolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \\spad{p} into irreducibles where \\spad{p} is known to be square free and primitive with respect to its main variable."))
 (|factorPolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \\spad{p}."))
 (|squareFreePolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{squareFreePolynomial(p)} returns the square-free factorization of the univariate polynomial \\spad{p}."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))) 
(|PolynomialFactorizationExplicit|) 
((|constructor|
  (NIL
   "This is the category of domains that know \"enough\" about themselves in order to factor univariate polynomials over their fraction field."))
 (|charthRoot|
  (((|Union| $ "failed") $)
   "\\spad{charthRoot(r)} returns the \\spad{p}\\spad{-}th root of \\spad{r},{} or \"failed\" if none exists in the domain."))
 (|conditionP|
  (((|Union| (|Vector| $) "failed") (|Matrix| $))
   "\\spad{conditionP(m)} returns a vector of elements,{} not all zero,{} whose \\spad{p}\\spad{-}th powers (\\spad{p} is the characteristic of the domain) are a solution of the homogenous linear system represented by \\spad{m},{} or \"failed\" is there is no such vector."))
 (|solveLinearPolynomialEquation|
  (((|Union| (|List| (|SparseUnivariatePolynomial| $)) "failed")
    (|List| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $))
   "\\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of \\spad{ai}\\spad{'s} exists."))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   "\\spad{gcdPolynomial(p,{} q)} returns the \\spad{gcd} of the univariate polynomials \\spad{p} \\spad{qnd} \\spad{q}."))
 (|factorSquareFreePolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \\spad{p} into irreducibles where \\spad{p} is known to be square free and primitive with respect to its main variable."))
 (|factorPolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \\spad{p}."))
 (|squareFreePolynomial|
  (((|Factored| (|SparseUnivariatePolynomial| $))
    (|SparseUnivariatePolynomial| $))
   "\\spad{squareFreePolynomial(p)} returns the square-free factorization of the univariate polynomial \\spad{p}."))) 
NIL 
(|PointsOfFiniteOrder| R0 F UP UPUP R) 
((|constructor|
  (NIL
   "This package provides function for testing whether a divisor on a curve is a torsion divisor."))
 (|simplifyCoeffs|
  (((|NonNegativeInteger|)
    (|Record| (|:| |ncurve| |#4|) (|:| |n_div_numer| (|Vector| |#4|))
              (|:| |n_div_denom| |#4|) (|:| |need_change| (|Boolean|)))
    (|List| (|Kernel| |#2|)))
   "\\spad{simplifyCoeffs(d,{} la)} should be local but conditional."))
 (|handle_imaginary|
  (((|Record| (|:| |ncurve| |#4|) (|:| |n_div_numer| (|Vector| |#4|))
              (|:| |n_div_denom| |#4|) (|:| |need_change| (|Boolean|)))
    (|FiniteDivisor| |#2| |#3| |#4| |#5|))
   "\\spad{handle_imaginary(d)} should be local but conditional."))
 (|possibleOrder|
  (((|NonNegativeInteger|) (|FiniteDivisor| |#2| |#3| |#4| |#5|))
   "\\spad{possibleOrder(d)} returns \\spad{n} such that \\spad{d} is of order \\spad{n},{} or of infinite order."))
 (|cmult|
  (((|SparseMultivariatePolynomial| |#1| (|Kernel| |#2|))
    (|List| (|SparseMultivariatePolynomial| |#1| (|Kernel| |#2|))))
   "\\spad{cmult(x)} should be local but conditional"))
 (|torsionIfCan|
  (((|Union|
     (|Record| (|:| |order| (|NonNegativeInteger|)) (|:| |function| |#5|))
     "failed")
    (|FiniteDivisor| |#2| |#3| |#4| |#5|))
   "\\spad{torsionIfCan(fd)} returns \\spad{[n,{} f]} such that \\spad{n*fd = div(f)} when \\spad{fd} is of finite order. torsionIfCan(\\spad{fd}) returns \\spad{\"failed\"} if \\spad{fd} is not of finite order."))
 (|torsion?|
  (((|Boolean|) (|FiniteDivisor| |#2| |#3| |#4| |#5|))
   "\\spad{torsion?(fd)} returns \\spad{true} if \\spad{fd} is of finite order,{} \\spad{false} otherwise."))
 (|order|
  (((|Union| (|NonNegativeInteger|) "failed")
    (|FiniteDivisor| |#2| |#3| |#4| |#5|))
   "\\spad{order(fd)} returns order of divisor \\spad{fd} or \\spad{\"failed\"} if \\spad{fd} is not of finite order."))) 
((AND (|HasCategory| |#1| '(|CharacteristicZero|))
      (|HasCategory| |#2| '(|AlgebraicallyClosedField|)))) 
(|PointsOfFiniteOrderRational| UP UPUP R) 
((|constructor|
  (NIL
   "This package provides function for testing whether a divisor on a curve is a torsion divisor."))
 (|torsionIfCan|
  (((|Union|
     (|Record| (|:| |order| (|NonNegativeInteger|)) (|:| |function| |#3|))
     "failed")
    (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|))
   "\\spad{torsionIfCan(f)} \\undocumented"))
 (|torsion?|
  (((|Boolean|) (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|))
   "\\spad{torsion?(f)} \\undocumented"))
 (|order|
  (((|Union| (|NonNegativeInteger|) "failed")
    (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|))
   "\\spad{order(f)} \\undocumented"))) 
NIL 
(|PointsOfFiniteOrderTools| UP UPUP) 
((|constructor|
  (NIL
   "\\indented{1}{Utilities for PFOQ and PFO} Author: Manuel Bronstein Date Created: 25 Aug 1988"))
 (|polyred| ((|#2| |#2|) "\\spad{polyred(u)} \\undocumented"))
 (|doubleDisc| (((|Integer|) |#2|) "\\spad{doubleDisc(u)} \\undocumented"))
 (|mix|
  (((|Integer|)
    (|List| (|Record| (|:| |den| (|Integer|)) (|:| |gcdnum| (|Integer|)))))
   "\\spad{mix(l)} \\undocumented"))
 (|badNum| (((|Integer|) |#2|) "\\spad{badNum(u)} \\undocumented")
  (((|Record| (|:| |den| (|Integer|)) (|:| |gcdnum| (|Integer|))) |#1|)
   "\\spad{badNum(p)} \\undocumented"))
 (|getGoodPrime|
  (((|PositiveInteger|) (|Integer|))
   "\\spad{getGoodPrime n} returns the smallest prime not dividing \\spad{n}"))) 
NIL 
(|PartialFraction| R) 
((|constructor|
  (NIL
   "The domain \\spadtype{PartialFraction} implements partial fractions over a euclidean domain \\spad{R}. This requirement on the argument domain allows us to normalize the fractions. Of particular interest are the 2 forms for these fractions. The ``compact\\spad{''} form has only one fractional term per prime in the denominator,{} while the \\spad{``p}-adic\\spad{''} form expands each numerator \\spad{p}-adically via the prime \\spad{p} in the denominator. For computational efficiency,{} the compact form is used,{} though the \\spad{p}-adic form may be gotten by calling the function \\spadfunFrom{padicFraction}{PartialFraction}. For a general euclidean domain,{} it is not known how to factor the denominator. Thus the function \\spadfunFrom{partialFraction}{PartialFraction} takes an element of \\spadtype{Factored(R)} as its second argument."))
 (|wholePart|
  ((|#1| $)
   "\\spad{wholePart(p)} extracts the whole part of the partial fraction \\spad{p}."))
 (|partialFraction|
  (($ (|Fraction| |#1|))
   "\\spad{partialFraction(f)} is a user friendly interface for partial fractions when \\spad{f} is a fraction of UniqueFactorizationDomain.")
  (($ |#1| (|Factored| |#1|))
   "\\spad{partialFraction(numer,{} denom)} is the main function for constructing partial fractions. The second argument is the denominator and should be factored."))
 (|padicFraction|
  (($ $)
   "\\spad{padicFraction(q)} expands the fraction \\spad{p}-adically in the primes \\spad{p} in the denominator of \\spad{q}. For example,{} \\spad{padicFraction(3/(2^2)) = 1/2 + 1/(2^2)}. Use \\spadfunFrom{compactFraction}{PartialFraction} to return to compact form."))
 (|padicallyExpand|
  (((|SparseUnivariatePolynomial| |#1|) |#1| |#1|)
   "\\spad{padicallyExpand(p,{} x)} is a utility function that expands the second argument \\spad{x} \\spad{``p}-adically\\spad{''} in the first."))
 (|fractionalTerms|
  (((|List| (|Record| (|:| |num| |#1|) (|:| |den| (|Factored| |#1|)))) $)
   "\\spad{fractionalTerms(p)} extracts the fractional part of \\spad{p} to a list of Record(num : \\spad{R},{} den : Factored \\spad{R}). This returns [] if there is no fractional part."))
 (|numberOfFractionalTerms|
  (((|Integer|) $)
   "\\spad{numberOfFractionalTerms(p)} computes the number of fractional terms in \\spad{p}. This returns 0 if there is no fractional part."))
 (|compactFraction|
  (($ $)
   "\\spad{compactFraction(p)} normalizes the partial fraction \\spad{p} to the compact representation. In this form,{} the partial fraction has only one fractional term per prime in the denominator."))
 (|coerce|
  (($ (|Fraction| (|Factored| |#1|)))
   "\\spad{coerce(f)} takes a fraction with numerator and denominator in factored form and creates a partial fraction. It is necessary for the parts to be factored because it is not known in general how to factor elements of \\spad{R} and this is needed to decompose into partial fractions.")
  (((|Fraction| |#1|) $)
   "\\spad{coerce(p)} sums up the components of the partial fraction and returns a single fraction."))) 
((|HasCategory| |#1| '(|UniqueFactorizationDomain|))) 
(|PartialFractionPackage| R) 
((|constructor|
  (NIL
   "The package \\spadtype{PartialFractionPackage} gives an easier to use interface to \\spadtype{PartialFraction}. The user gives a fraction of polynomials,{} and a variable and the package converts it to the proper datatype for the \\spadtype{PartialFraction} domain."))
 (|partialFraction|
  (((|Any|) (|Polynomial| |#1|) (|Factored| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{partialFraction(num,{} facdenom,{} var)} returns the partial fraction decomposition of the rational function whose numerator is \\spad{num} and whose factored denominator is \\spad{facdenom} with respect to the variable var.")
  (((|Any|) (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{partialFraction(rf,{} var)} returns the partial fraction decomposition of the rational function \\spad{rf} with respect to the variable var."))) 
NIL 
(|PartialFractionUtilities| F UP) 
((|decompose|
  (((|List| |#2|) |#2| (|List| |#2|))
   "\\spad{decompose(n,{} [p1,{} ...,{} pn])} returns numerators of partial fraction decomposition of \\spad{n} divided by product of \\spad{pi}-\\spad{s} Note: decomposition is assumed to have no whole part."))) 
NIL 
(|PolynomialGcdPackage| E OV R P) 
((|constructor|
  (NIL
   "\\indented{2}{This package computes multivariate polynomial \\spad{gcd}\\spad{'s} using} a hensel lifting strategy. The contraint on the coefficient domain is imposed by the lifting strategy. It is assumed that the coefficient domain has the property that almost all specializations preserve the degree of the \\spad{gcd}."))
 (|gcdPrimitive|
  ((|#4| (|List| |#4|))
   "\\spad{gcdPrimitive lp} computes the \\spad{gcd} of the list of primitive polynomials \\spad{lp}.")
  (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{gcdPrimitive(p,{} q)} computes the \\spad{gcd} of the primitive polynomials \\spad{p} and \\spad{q}.")
  ((|#4| |#4| |#4|)
   "\\spad{gcdPrimitive(p,{} q)} computes the \\spad{gcd} of the primitive polynomials \\spad{p} and \\spad{q}."))
 (|gcd|
  (((|SparseUnivariatePolynomial| |#4|)
    (|List| (|SparseUnivariatePolynomial| |#4|)))
   "\\spad{gcd(lp)} computes the \\spad{gcd} of the list of polynomials \\spad{lp}.")
  (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)
    (|SparseUnivariatePolynomial| |#4|))
   "\\spad{gcd(p,{} q)} computes the \\spad{gcd} of the two polynomials \\spad{p} and \\spad{q}.")
  ((|#4| (|List| |#4|))
   "\\spad{gcd(lp)} computes the \\spad{gcd} of the list of polynomials \\spad{lp}.")
  ((|#4| |#4| |#4|)
   "\\spad{gcd(p,{} q)} computes the \\spad{gcd} of the two polynomials \\spad{p} and \\spad{q}."))) 
NIL 
(|PermutationGroupExamples|) 
((|constructor|
  (NIL
   "PermutationGroupExamples provides permutation groups for some classes of groups: symmetric,{} alternating,{} dihedral,{} cyclic,{} direct products of cyclic,{} which are in fact the finite abelian groups of symmetric groups called Young subgroups. Furthermore,{} Rubik\\spad{'s} group as permutation group of 48 integers and a list of sporadic simple groups derived from the atlas of finite groups."))
 (|youngGroup|
  (((|PermutationGroup| (|Integer|)) (|Partition|))
   "\\spad{youngGroup(lambda)} constructs the direct product of the symmetric groups given by the parts of the partition {\\em lambda}.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{youngGroup([n1,{} ...,{} nk])} constructs the direct product of the symmetric groups {\\em Sn1},{} ...,{} {\\em Snk}."))
 (|rubiksGroup|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{rubiksGroup constructs} the permutation group representing Rubic\\spad{'s} Cube acting on integers {\\em 10*i+j} for {\\em 1 <= i <= 6},{} {\\em 1 <= j <= 8}. The faces of Rubik\\spad{'s} Cube are labelled in the obvious way Front,{} Right,{} Up,{} Down,{} Left,{} Back and numbered from 1 to 6 in this given ordering,{} the pieces on each face (except the unmoveable center piece) are clockwise numbered from 1 to 8 starting with the piece in the upper left corner. The moves of the cube are represented as permutations on these pieces,{} represented as a two digit integer {\\em ij} where \\spad{i} is the numer of theface (1 to 6) and \\spad{j} is the number of the piece on this face. The remaining ambiguities are resolved by looking at the 6 generators,{} which represent a 90 degree turns of the faces,{} or from the following pictorial description. Permutation group representing Rubic\\spad{'s} Cube acting on integers 10*i+j for 1 \\spad{<=} \\spad{i} \\spad{<=} 6,{} 1 \\spad{<=} \\spad{j} \\spad{<=8}. \\blankline\\begin{verbatim}Rubik's Cube:   +-----+ +-- B   where: marks Side # :               / U   /|/              /     / |         F(ront)    <->    1      L -->  +-----+ R|         R(ight)    <->    2             |     |  +         U(p)       <->    3             |  F  | /          D(own)     <->    4             |     |/           L(eft)     <->    5             +-----+            B(ack)     <->    6                ^                |                DThe Cube's surface:                               The pieces on each side            +---+              (except the unmoveable center            |567|              piece) are clockwise numbered            |4U8|              from 1 to 8 starting with the            |321|              piece in the upper left        +---+---+---+          corner (see figure on the        |781|123|345|          left).  The moves of the cube        |6L2|8F4|2R6|          are represented as        |543|765|187|          permutations on these pieces.        +---+---+---+          Each of the pieces is            |123|              represented as a two digit            |8D4|              integer ij where i is the            |765|              # of the side ( 1 to 6 for            +---+              F to B (see table above ))            |567|              and j is the # of the piece.            |4B8|            |321|            +---+\\end{verbatim}"))
 (|janko2|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{janko2 constructs} the janko group acting on the integers 1,{} ...,{} 100.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{janko2(\\spad{li})} constructs the janko group acting on the 100 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed. Error: if {\\em \\spad{li}} has less or more than 100 different entries"))
 (|mathieu24|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{mathieu24 constructs} the mathieu group acting on the integers 1,{} ...,{} 24.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{mathieu24(\\spad{li})} constructs the mathieu group acting on the 24 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed. Error: if {\\em \\spad{li}} has less or more than 24 different entries."))
 (|mathieu23|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{mathieu23 constructs} the mathieu group acting on the integers 1,{} ...,{} 23.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{mathieu23(\\spad{li})} constructs the mathieu group acting on the 23 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed. Error: if {\\em \\spad{li}} has less or more than 23 different entries."))
 (|mathieu22|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{mathieu22 constructs} the mathieu group acting on the integers 1,{} ...,{} 22.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{mathieu22(\\spad{li})} constructs the mathieu group acting on the 22 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed. Error: if {\\em \\spad{li}} has less or more than 22 different entries."))
 (|mathieu12|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{mathieu12 constructs} the mathieu group acting on the integers 1,{} ...,{} 12.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{mathieu12(\\spad{li})} constructs the mathieu group acting on the 12 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed Error: if {\\em \\spad{li}} has less or more than 12 different entries."))
 (|mathieu11|
  (((|PermutationGroup| (|Integer|)))
   "\\spad{mathieu11 constructs} the mathieu group acting on the integers 1,{} ...,{} 11.")
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{mathieu11(\\spad{li})} constructs the mathieu group acting on the 11 integers given in the list {\\em \\spad{li}}. Note: duplicates in the list will be removed. error,{} if {\\em \\spad{li}} has less or more than 11 different entries."))
 (|dihedralGroup|
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{dihedralGroup([i1,{} ...,{} ik])} constructs the dihedral group of order 2k acting on the integers out of {\\em i1},{} ...,{} {\\em ik}. Note: duplicates in the list will be removed.")
  (((|PermutationGroup| (|Integer|)) (|PositiveInteger|))
   "\\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,{} ...,{} \\spad{N}."))
 (|cyclicGroup|
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{cyclicGroup([i1,{} ...,{} ik])} constructs the cyclic group of order \\spad{k} acting on the integers {\\em i1},{} ...,{} {\\em ik}. Note: duplicates in the list will be removed.")
  (((|PermutationGroup| (|Integer|)) (|PositiveInteger|))
   "\\spad{cyclicGroup(n)} constructs the cyclic group of order \\spad{n} acting on the integers 1,{} ...,{} \\spad{n}."))
 (|abelianGroup|
  (((|PermutationGroup| (|Integer|)) (|List| (|PositiveInteger|)))
   "\\spad{abelianGroup([n1,{} ...,{} nk])} constructs the abelian group that is the direct product of cyclic groups with order {\\em \\spad{ni}}."))
 (|alternatingGroup|
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{alternatingGroup(\\spad{li})} constructs the alternating group acting on the integers in the list {\\em \\spad{li}},{} generators are in general the {\\em n-2}-cycle {\\em (\\spad{li}.3,{} ...,{} \\spad{li}.n)} and the 3-cycle {\\em (\\spad{li}.1,{} \\spad{li}.2,{} \\spad{li}.3)},{} if \\spad{n} is odd and product of the 2-cycle {\\em (\\spad{li}.1,{} \\spad{li}.2)} with {\\em n-2}-cycle {\\em (\\spad{li}.3,{} ...,{} \\spad{li}.n)} and the 3-cycle {\\em (\\spad{li}.1,{} \\spad{li}.2,{} \\spad{li}.3)},{} if \\spad{n} is even. Note: duplicates in the list will be removed.")
  (((|PermutationGroup| (|Integer|)) (|PositiveInteger|))
   "\\spad{alternatingGroup(n)} constructs the alternating group {\\em An} acting on the integers 1,{} ...,{} \\spad{n},{} generators are in general the {\\em n-2}-cycle {\\em (3,{} ...,{} n)} and the 3-cycle {\\em (1,{} 2,{} 3)} if \\spad{n} is odd and the product of the 2-cycle {\\em (1,{} 2)} with {\\em n-2}-cycle {\\em (3,{} ...,{} n)} and the 3-cycle {\\em (1,{} 2,{} 3)} if \\spad{n} is even."))
 (|symmetricGroup|
  (((|PermutationGroup| (|Integer|)) (|List| (|Integer|)))
   "\\spad{symmetricGroup(\\spad{li})} constructs the symmetric group acting on the integers in the list {\\em \\spad{li}},{} generators are the cycle given by {\\em \\spad{li}} and the 2-cycle {\\em (\\spad{li}.1,{} \\spad{li}.2)}. Note: duplicates in the list will be removed.")
  (((|PermutationGroup| (|Integer|)) (|PositiveInteger|))
   "\\spad{symmetricGroup(n)} constructs the symmetric group {\\em Sn} acting on the integers 1,{} ...,{} \\spad{n},{} generators are the {\\em n}-cycle {\\em (1,{} ...,{} n)} and the 2-cycle {\\em (1,{} 2)}."))) 
NIL 
(|PolyGroebner| F) 
((|constructor|
  (NIL
   "Groebner functions for \\spad{P} \\spad{F} \\indented{2}{This package is an interface package to the groebner basis} package which allows you to compute groebner bases for polynomials in either lexicographic ordering or total degree ordering refined by reverse lex. The input is the ordinary polynomial type which is internally converted to a type with the required ordering. The resulting grobner basis is converted back to ordinary polynomials. The ordering among the variables is controlled by an explicit list of variables which is passed as a second argument. The coefficient domain is allowed to be any \\spad{gcd} domain,{} but the groebner basis is computed as if the polynomials were over a field."))
 (|totalGroebner|
  (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|))
    (|List| (|Symbol|)))
   "\\spad{totalGroebner(lp,{} lv)} computes Groebner basis for the list of polynomials \\spad{lp} with the terms ordered first by total degree and then refined by reverse lexicographic ordering. The variables are ordered by their position in the list \\spad{lv}."))
 (|lexGroebner|
  (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|))
    (|List| (|Symbol|)))
   "\\spad{lexGroebner(lp,{} lv)} computes Groebner basis for the list of polynomials \\spad{lp} in lexicographic order. The variables are ordered by their position in the list \\spad{lv}."))) 
NIL 
(|PositiveInteger|) 
((|constructor|
  (NIL
   "\\spadtype{PositiveInteger} provides functions for \\indented{2}{positive integers.}"))
 (|qcoerce|
  (($ (|Integer|))
   "\\spad{qcoerce(n)} coerces \\spad{n} to \\spad{\\%} trusting that \\spad{n} is positive"))
 (|gcd|
  (($ $ $)
   "\\spad{gcd(a,{} b)} computes the greatest common divisor of two positive integers \\spad{a} and \\spad{b}."))) 
NIL 
(|PiCoercions| R) 
((|constructor|
  (NIL
   "\\indented{1}{Provides a coercion from the symbolic fractions in \\%\\spad{pi} with} integer coefficients to any Expression type. Date Created: 21 Feb 1990"))
 (|coerce|
  (((|Expression| |#1|) (|Pi|))
   "\\spad{coerce(f)} returns \\spad{f} as an Expression(\\spad{R})."))) 
NIL 
(|PrincipalIdealDomain|) 
((|constructor|
  (NIL
   "The category of constructive principal ideal domains,{} \\spadignore{i.e.} where a single generator can be constructively found for any ideal given by a finite set of generators. Note that this constructive definition only implies that finitely generated ideals are principal. It is not clear what we would mean by an infinitely generated ideal."))
 (|expressIdealMember|
  (((|Union| (|List| $) "failed") (|List| $) $)
   "\\spad{expressIdealMember([f1,{} ...,{} fn],{} h)} returns a representation of \\spad{h} as a linear combination of the \\spad{fi} or \"failed\" if \\spad{h} is not in the ideal generated by the \\spad{fi}."))
 (|principalIdeal|
  (((|Record| (|:| |coef| (|List| $)) (|:| |generator| $)) (|List| $))
   "\\spad{principalIdeal([f1,{} ...,{} fn])} returns a record whose generator component is a generator of the ideal generated by \\spad{[f1,{} ...,{} fn]} whose coef component satisfies \\spad{generator = sum (input.i * coef.i)}"))) 
NIL 
(|PolynomialInterpolation| |xx| F) 
((|constructor| (NIL "This package exports interpolation algorithms"))
 (|interpolate|
  (((|SparseUnivariatePolynomial| |#2|) (|List| |#2|) (|List| |#2|))
   "\\spad{interpolate(lf,{} lg)} \\undocumented")
  (((|UnivariatePolynomial| |#1| |#2|) (|UnivariatePolynomial| |#1| |#2|)
    (|List| |#2|) (|List| |#2|))
   "\\spad{interpolate(u,{} lf,{} lg)} \\undocumented"))) 
NIL 
(|PolynomialInterpolationAlgorithms| F P) 
((|constructor| (NIL "This package exports interpolation algorithms"))
 (|LagrangeInterpolation|
  ((|#2| (|List| |#1|) (|List| |#1|))
   "\\spad{LagrangeInterpolation(l1,{} l2)} \\undocumented"))) 
NIL 
(|ParallelIntegrationTools| R V P) 
((|split|
  (((|Record| (|:| |normal| |#3|) (|:| |special| |#3|)) |#3|
    (|Mapping| |#3| |#3|))
   "\\spad{split(p,{} D)} returns \\spad{[n,{}s]} such that \\spad{p = n s},{} all the squarefree factors of \\spad{n} are normal \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D},{} and \\spad{s} is special \\spad{w}.\\spad{r}.\\spad{t}. \\spad{D}. \\spad{D} is the derivation to use."))) 
NIL 
(|ParametricLinearEquations| R |Var| |Expon| GR) 
((|constructor|
  (NIL
   "This package completely solves a parametric linear system of equations by decomposing the set of all parametric values for which the linear system is consistent into a union of quasi-algebraic sets (which need not be irredundant,{} but most of the time is). Each quasi-algebraic set is described by a list of polynomials that vanish on the set,{} and a list of polynomials that vanish at no point of the set. For each quasi-algebraic set,{} the solution of the linear system is given,{} as a particular solution and a basis of the homogeneous system. The parametric linear system should be given in matrix form,{} with a coefficient matrix and a right hand side vector. The entries of the coefficient matrix and right hand side vector should be polynomials in the parametric variables,{} over a Euclidean domain of characteristic zero. \\blankline If the system is homogeneous,{} the right hand side need not be given. The right hand side can also be replaced by an indeterminate vector,{} in which case,{} the conditions required for consistency will also be given."))
 (|inconsistent?|
  (((|Boolean|) (|List| (|Polynomial| |#1|)))
   "\\spad{inconsistent?(pl)} returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis.")
  (((|Boolean|) (|List| |#4|))
   "\\spad{inconsistent?(pl)} returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis."))
 (|sqfree|
  ((|#4| |#4|)
   "\\spad{sqfree(p)} returns the product of square free factors of \\spad{p}"))
 (|regime|
  (((|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
              (|:| |wcond| (|List| (|Polynomial| |#1|)))
              (|:| |bsoln|
                   (|Record|
                    (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|))))
                    (|:| |basis|
                         (|List|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))))))
    (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|)))
              (|:| |cols| (|List| (|Integer|))))
    (|Matrix| |#4|) (|List| (|Fraction| (|Polynomial| |#1|)))
    (|List| (|List| |#4|)) (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|Integer|))
   "\\spad{regime(y,{} c,{} w,{} p,{} r,{} rm,{} m)} returns a regime,{} a list of polynomials specifying the consistency conditions,{} a particular solution and basis representing the general solution of the parametric linear system \\spad{c} \\spad{z} = \\spad{w} on that regime. The regime returned depends on the subdeterminant \\spad{y}.det and the row and column indices. The solutions are simplified using the assumption that the system has rank \\spad{r} and maximum rank \\spad{rm}. The list \\spad{p} represents a list of list of factors of polynomials in a groebner basis of the ideal generated by higher order subdeterminants,{} and ius used for the simplification. The mode \\spad{m} distinguishes the cases when the system is homogeneous,{} or the right hand side is arbitrary,{} or when there is no new right hand side variables."))
 (|redmat|
  (((|Matrix| |#4|) (|Matrix| |#4|) (|List| |#4|))
   "\\spad{redmat(m,{} g)} returns a matrix whose entries are those of \\spad{m} modulo the ideal generated by the groebner basis \\spad{g}"))
 (|ParCond|
  (((|List|
     (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|)))
               (|:| |cols| (|List| (|Integer|)))))
    (|Matrix| |#4|) (|NonNegativeInteger|))
   "\\spad{ParCond(m,{} k)} returns the list of all \\spad{k} by \\spad{k} subdeterminants in the matrix \\spad{m}"))
 (|overset?|
  (((|Boolean|) (|List| |#4|) (|List| (|List| |#4|)))
   "\\spad{overset?(s,{} sl)} returns \\spad{true} if \\spad{s} properly a sublist of a member of \\spad{sl}; otherwise it returns \\spad{false}"))
 (|nextSublist|
  (((|List| (|List| (|Integer|))) (|Integer|) (|Integer|))
   "\\spad{nextSublist(n,{} k)} returns a list of \\spad{k}-subsets of {1,{} ...,{} \\spad{n}}."))
 (|minset|
  (((|List| (|List| |#4|)) (|List| (|List| |#4|)))
   "\\spad{minset(sl)} returns the sublist of \\spad{sl} consisting of the minimal lists (with respect to inclusion) in the list \\spad{sl} of lists"))
 (|minrank|
  (((|NonNegativeInteger|)
    (|List|
     (|Record| (|:| |rank| (|NonNegativeInteger|))
               (|:| |eqns|
                    (|List|
                     (|Record| (|:| |det| |#4|)
                               (|:| |rows| (|List| (|Integer|)))
                               (|:| |cols| (|List| (|Integer|))))))
               (|:| |fgb| (|List| |#4|)))))
   "\\spad{minrank(r)} returns the minimum rank in the list \\spad{r} of regimes"))
 (|maxrank|
  (((|NonNegativeInteger|)
    (|List|
     (|Record| (|:| |rank| (|NonNegativeInteger|))
               (|:| |eqns|
                    (|List|
                     (|Record| (|:| |det| |#4|)
                               (|:| |rows| (|List| (|Integer|)))
                               (|:| |cols| (|List| (|Integer|))))))
               (|:| |fgb| (|List| |#4|)))))
   "\\spad{maxrank(r)} returns the maximum rank in the list \\spad{r} of regimes"))
 (|factorset|
  (((|List| |#4|) |#4|)
   "\\spad{factorset(p)} returns the set of irreducible factors of \\spad{p}."))
 (|B1solve|
  (((|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|))))
              (|:| |basis|
                   (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))
    (|Record| (|:| |mat| (|Matrix| (|Fraction| (|Polynomial| |#1|))))
              (|:| |vec| (|List| (|Fraction| (|Polynomial| |#1|))))
              (|:| |rank| (|NonNegativeInteger|))
              (|:| |rows| (|List| (|Integer|)))
              (|:| |cols| (|List| (|Integer|)))))
   "\\spad{B1solve(s)} solves the system (\\spad{s}.mat) \\spad{z} = \\spad{s}.vec for the variables given by the column indices of \\spad{s}.cols in terms of the other variables and the right hand side \\spad{s}.vec by assuming that the rank is \\spad{s}.rank,{} that the system is consistent,{} with the linearly independent equations indexed by the given row indices \\spad{s}.rows; the coefficients in \\spad{s}.mat involving parameters are treated as polynomials. B1solve(\\spad{s}) returns a particular solution to the system and a basis of the homogeneous system (\\spad{s}.mat) \\spad{z} = 0."))
 (|redpps|
  (((|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|))))
              (|:| |basis|
                   (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))
    (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|))))
              (|:| |basis|
                   (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))
    (|List| |#4|))
   "\\spad{redpps(s,{} g)} returns the simplified form of \\spad{s} after reducing modulo a groebner basis \\spad{g}"))
 (|ParCondList|
  (((|List|
     (|Record| (|:| |rank| (|NonNegativeInteger|))
               (|:| |eqns|
                    (|List|
                     (|Record| (|:| |det| |#4|)
                               (|:| |rows| (|List| (|Integer|)))
                               (|:| |cols| (|List| (|Integer|))))))
               (|:| |fgb| (|List| |#4|))))
    (|Matrix| |#4|) (|NonNegativeInteger|))
   "\\spad{ParCondList(c,{} r)} computes a list of subdeterminants of each rank \\spad{>=} \\spad{r} of the matrix \\spad{c} and returns a groebner basis for the ideal they generate"))
 (|hasoln|
  (((|Record| (|:| |sysok| (|Boolean|)) (|:| |z0| (|List| |#4|))
              (|:| |n0| (|List| |#4|)))
    (|List| |#4|) (|List| |#4|))
   "\\spad{hasoln(g,{} l)} tests whether the quasi-algebraic set defined by \\spad{p} = 0 for \\spad{p} in \\spad{g} and \\spad{q} \\spad{~=} 0 for \\spad{q} in \\spad{l} is empty or not and returns a simplified definition of the quasi-algebraic set"))
 (|pr2dmp|
  ((|#4| (|Polynomial| |#1|))
   "\\spad{pr2dmp(p)} converts \\spad{p} to target domain"))
 (|se2rfi|
  (((|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|)))
   "\\spad{se2rfi(l)} converts \\spad{l} to target domain"))
 (|dmp2rfi|
  (((|List| (|Fraction| (|Polynomial| |#1|))) (|List| |#4|))
   "\\spad{dmp2rfi(l)} converts \\spad{l} to target domain")
  (((|Matrix| (|Fraction| (|Polynomial| |#1|))) (|Matrix| |#4|))
   "\\spad{dmp2rfi(m)} converts \\spad{m} to target domain")
  (((|Fraction| (|Polynomial| |#1|)) |#4|)
   "\\spad{dmp2rfi(p)} converts \\spad{p} to target domain"))
 (|bsolve|
  (((|Record|
     (|:| |rgl|
          (|List|
           (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
                     (|:| |wcond| (|List| (|Polynomial| |#1|)))
                     (|:| |bsoln|
                          (|Record|
                           (|:| |partsol|
                                (|Vector| (|Fraction| (|Polynomial| |#1|))))
                           (|:| |basis|
                                (|List|
                                 (|Vector|
                                  (|Fraction| (|Polynomial| |#1|))))))))))
     (|:| |rgsz| (|Integer|)))
    (|Matrix| |#4|) (|List| (|Fraction| (|Polynomial| |#1|)))
    (|NonNegativeInteger|) (|String|) (|Integer|))
   "\\spad{bsolve(c,{} w,{} r,{} s,{} m)} returns a list of regimes and solutions of the system \\spad{c} \\spad{z} = \\spad{w} for ranks at least \\spad{r}; depending on the mode \\spad{m} chosen,{} it writes the output to a file given by the string \\spad{s}."))
 (|rdregime|
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|String|))
   "\\spad{rdregime(s)} reads in a list from a file with name \\spad{s}"))
 (|wrregime|
  (((|Integer|)
    (|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|String|))
   "\\spad{wrregime(l,{} s)} writes a list of regimes to a file named \\spad{s} and returns the number of regimes written"))
 (|psolve|
  (((|Integer|) (|Matrix| |#4|) (|PositiveInteger|) (|String|))
   "\\spad{psolve(c,{} k,{} s)} solves \\spad{c} \\spad{z} = 0 for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|Integer|) (|Matrix| |#4|) (|List| (|Symbol|)) (|PositiveInteger|)
    (|String|))
   "\\spad{psolve(c,{} w,{} k,{} s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and indeterminate right hand side \\spad{w},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|Integer|) (|Matrix| |#4|) (|List| |#4|) (|PositiveInteger|) (|String|))
   "\\spad{psolve(c,{} w,{} k,{} s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and given right hand side \\spad{w},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|Integer|) (|Matrix| |#4|) (|String|))
   "\\spad{psolve(c,{} s)} solves \\spad{c} \\spad{z} = 0 for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|Integer|) (|Matrix| |#4|) (|List| (|Symbol|)) (|String|))
   "\\spad{psolve(c,{} w,{} s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and indeterminate right hand side \\spad{w},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|Integer|) (|Matrix| |#4|) (|List| |#4|) (|String|))
   "\\spad{psolve(c,{} w,{} s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w},{} writes the results to a file named \\spad{s},{} and returns the number of regimes")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|) (|PositiveInteger|))
   "\\spad{psolve(c)} solves the homogeneous linear system \\spad{c} \\spad{z} = 0 for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c}")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|) (|List| (|Symbol|)) (|PositiveInteger|))
   "\\spad{psolve(c,{} w,{} k)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and indeterminate right hand side \\spad{w}")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|) (|List| |#4|) (|PositiveInteger|))
   "\\spad{psolve(c,{} w,{} k)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and given right hand side vector \\spad{w}")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|))
   "\\spad{psolve(c)} solves the homogeneous linear system \\spad{c} \\spad{z} = 0 for all possible ranks of the matrix \\spad{c}")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|) (|List| (|Symbol|)))
   "\\spad{psolve(c,{} w)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and indeterminate right hand side \\spad{w}")
  (((|List|
     (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|))
               (|:| |wcond| (|List| (|Polynomial| |#1|)))
               (|:| |bsoln|
                    (|Record|
                     (|:| |partsol|
                          (|Vector| (|Fraction| (|Polynomial| |#1|))))
                     (|:| |basis|
                          (|List|
                           (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))
    (|Matrix| |#4|) (|List| |#4|))
   "\\spad{psolve(c,{} w)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w}"))) 
NIL 
(|Plot|) 
((|constructor|
  (NIL
   "The Plot domain supports plotting of functions defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example floating point numbers and infinite continued fractions. The facilities at this point are limited to 2-dimensional plots or either a single function or a parametric function."))
 (|debug|
  (((|Boolean|) (|Boolean|))
   "\\spad{debug(true)} turns debug mode on \\spad{debug(false)} turns debug mode off"))
 (|numFunEvals|
  (((|Integer|))
   "\\spad{numFunEvals()} returns the number of points computed"))
 (|setAdaptive|
  (((|Boolean|) (|Boolean|))
   "\\spad{setAdaptive(true)} turns adaptive plotting on \\spad{setAdaptive(false)} turns adaptive plotting off"))
 (|adaptive?|
  (((|Boolean|))
   "\\spad{adaptive?()} determines whether plotting be done adaptively"))
 (|setScreenResolution|
  (((|Integer|) (|Integer|))
   "\\spad{setScreenResolution(i)} sets the screen resolution to \\spad{i}"))
 (|screenResolution|
  (((|Integer|)) "\\spad{screenResolution()} returns the screen resolution"))
 (|setMaxPoints|
  (((|Integer|) (|Integer|))
   "\\spad{setMaxPoints(i)} sets the maximum number of points in a plot to \\spad{i}"))
 (|maxPoints|
  (((|Integer|))
   "\\spad{maxPoints()} returns the maximum number of points in a plot"))
 (|setMinPoints|
  (((|Integer|) (|Integer|))
   "\\spad{setMinPoints(i)} sets the minimum number of points in a plot to \\spad{i}"))
 (|minPoints|
  (((|Integer|))
   "\\spad{minPoints()} returns the minimum number of points in a plot"))
 (|tRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{tRange(p)} returns the range of the parameter in a parametric plot \\spad{p}"))
 (|refine|
  (($ $) "\\spad{refine(p)} performs a refinement on the plot \\spad{p}")
  (($ $ (|Segment| (|DoubleFloat|))) "\\spad{refine(x,{} r)} \\undocumented"))
 (|zoom|
  (($ $ (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{zoom(x,{} r,{} s)} \\undocumented")
  (($ $ (|Segment| (|DoubleFloat|))) "\\spad{zoom(x,{} r)} \\undocumented"))
 (|parametric?|
  (((|Boolean|) $)
   "\\spad{parametric? determines} whether it is a parametric plot?"))
 (|plotPolar|
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
   "\\spad{plotPolar(f)} plots the polar curve \\spad{r = f(theta)} as theta ranges over the interval \\spad{[0,{} 2*\\%\\spad{pi}]}; this is the same as the parametric curve \\spad{x = f(t) * cos(t)},{} \\spad{y = f(t) * sin(t)}.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plotPolar(f,{} a..b)} plots the polar curve \\spad{r = f(theta)} as theta ranges over the interval \\spad{[a,{} b]}; this is the same as the parametric curve \\spad{x = f(t) * cos(t)},{} \\spad{y = f(t) * sin(t)}."))
 (|pointPlot|
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{pointPlot(t +-> (f(t),{} g(t)),{} a..b,{} c..d,{} e..f)} plots the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,{} b]}; \\spad{x}-range of \\spad{[c,{} d]} and \\spad{y}-range of \\spad{[e,{} f]} are noted in Plot object.")
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{pointPlot(t +-> (f(t),{} g(t)),{} a..b)} plots the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,{} b]}."))
 (|plot|
  (($ $ (|Segment| (|DoubleFloat|))) "\\spad{plot(x,{} r)} \\undocumented")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} g,{} a..b,{} c..d,{} e..f)} plots the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,{} b]}; \\spad{x}-range of \\spad{[c,{} d]} and \\spad{y}-range of \\spad{[e,{} f]} are noted in Plot object.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} g,{} a..b)} plots the parametric curve \\spad{x = f(t)},{} \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,{} b]}.")
  (($ (|List| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plot([f1,{} ...,{} fm],{} a..b,{} c..d)} plots the functions \\spad{y = f1(x)},{} ...,{} \\spad{y = fm(x)} on the interval \\spad{a..b}; \\spad{y}-range of \\spad{[c,{} d]} is noted in Plot object.")
  (($ (|List| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)))
   "\\spad{plot([f1,{} ...,{} fm],{} a..b)} plots the functions \\spad{y = f1(x)},{} ...,{} \\spad{y = fm(x)} on the interval \\spad{a..b}.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} a..b,{} c..d)} plots the function \\spad{f(x)} on the interval \\spad{[a,{} b]}; \\spad{y}-range of \\spad{[c,{} d]} is noted in Plot object.")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} a..b)} plots the function \\spad{f(x)} on the interval \\spad{[a,{} b]}."))) 
NIL 
(|PlotFunctions1| S) 
((|constructor|
  (NIL
   "\\spad{PlotFunctions1} provides facilities for plotting curves where functions \\spad{SF} \\spad{->} \\spad{SF} are specified by giving an expression"))
 (|plotPolar|
  (((|Plot|) |#1| (|Symbol|))
   "\\spad{plotPolar(f,{} theta)} plots the graph of \\spad{r = f(theta)} as theta ranges from 0 to 2 \\spad{pi}")
  (((|Plot|) |#1| (|Symbol|) (|Segment| (|DoubleFloat|)))
   "\\spad{plotPolar(f,{} theta,{} seg)} plots the graph of \\spad{r = f(theta)} as \\spad{theta} ranges over an interval"))
 (|plot|
  (((|Plot|) |#1| |#1| (|Symbol|) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} g,{} t,{} seg)} plots the graph of \\spad{x = f(t)},{} \\spad{y = g(t)} as \\spad{t} ranges over an interval.")
  (((|Plot|) |#1| (|Symbol|) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(fcn,{} x,{} seg)} plots the graph of \\spad{y = f(x)} on a interval"))) 
NIL 
(|Plot3D|) 
((|constructor|
  (NIL
   "Plot3D supports parametric plots defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example,{} floating point numbers and infinite continued fractions are real number systems. The facilities at this point are limited to 3-dimensional parametric plots."))
 (|debug3D|
  (((|Boolean|) (|Boolean|))
   "\\spad{debug3D(true)} turns debug mode on; debug3D(\\spad{false}) turns debug mode off."))
 (|numFunEvals3D|
  (((|Integer|))
   "\\spad{numFunEvals3D()} returns the number of points computed."))
 (|setAdaptive3D|
  (((|Boolean|) (|Boolean|))
   "\\spad{setAdaptive3D(true)} turns adaptive plotting on; setAdaptive3D(\\spad{false}) turns adaptive plotting off."))
 (|adaptive3D?|
  (((|Boolean|))
   "\\spad{adaptive3D?()} determines whether plotting be done adaptively."))
 (|setScreenResolution3D|
  (((|Integer|) (|Integer|))
   "\\spad{setScreenResolution3D(i)} sets the screen resolution for a 3d graph to \\spad{i}."))
 (|screenResolution3D|
  (((|Integer|))
   "\\spad{screenResolution3D()} returns the screen resolution for a 3d graph."))
 (|setMaxPoints3D|
  (((|Integer|) (|Integer|))
   "\\spad{setMaxPoints3D(i)} sets the maximum number of points in a plot to \\spad{i}."))
 (|maxPoints3D|
  (((|Integer|))
   "\\spad{maxPoints3D()} returns the maximum number of points in a plot."))
 (|setMinPoints3D|
  (((|Integer|) (|Integer|))
   "\\spad{setMinPoints3D(i)} sets the minimum number of points in a plot to \\spad{i}."))
 (|minPoints3D|
  (((|Integer|))
   "\\spad{minPoints3D()} returns the minimum number of points in a plot."))
 (|tValues|
  (((|List| (|List| (|DoubleFloat|))) $)
   "\\spad{tValues(p)} returns a list of lists of the values of the parameter for which a point is computed,{} one list for each curve in the plot \\spad{p}."))
 (|tRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{tRange(p)} returns the range of the parameter in a parametric plot \\spad{p}."))
 (|refine| (($ $) "\\spad{refine(x)} \\undocumented")
  (($ $ (|Segment| (|DoubleFloat|))) "\\spad{refine(x,{} r)} \\undocumented"))
 (|zoom|
  (($ $ (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{zoom(x,{} r,{} s,{} t)} \\undocumented"))
 (|plot|
  (($ $ (|Segment| (|DoubleFloat|))) "\\spad{plot(x,{} r)} \\undocumented")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f1,{} f2,{} f3,{} f4,{} x,{} y,{} z,{} w)} \\undocumented")
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|))
    (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{plot(f,{} g,{} h,{} a..b)} plots \\spad{x} = \\spad{f}(\\spad{t}),{} \\spad{y} = \\spad{g}(\\spad{t}),{} \\spad{z} = \\spad{h}(\\spad{t}) as \\spad{t} ranges over [a,{} \\spad{b}]."))
 (|pointPlot|
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)))
   "\\spad{pointPlot(f,{} x,{} y,{} z,{} w)} \\undocumented")
  (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)))
   "\\spad{pointPlot(f,{} g,{} h,{} a..b)} plots \\spad{x} = \\spad{f}(\\spad{t}),{} \\spad{y} = \\spad{g}(\\spad{t}),{} \\spad{z} = \\spad{h}(\\spad{t}) as \\spad{t} ranges over [a,{} \\spad{b}]."))) 
NIL 
(|PlotTools|) 
((|constructor| (NIL "This package exports plotting tools"))
 (|calcRanges|
  (((|List| (|Segment| (|DoubleFloat|)))
    (|List| (|List| (|Point| (|DoubleFloat|)))))
   "\\spad{calcRanges(l)} \\undocumented"))) 
NIL 
(|PatternMatchAssertions|) 
((|constructor|
  (NIL
   "Attaching assertions to symbols for pattern matching. Date Created: 21 Mar 1989"))
 (|multiple|
  (((|Expression| (|Integer|)) (|Symbol|))
   "\\spad{multiple(x)} tells the pattern matcher that \\spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\\spad{x}) tells the pattern matcher that \\spad{x} should match a list instead of an element of a list."))
 (|optional|
  (((|Expression| (|Integer|)) (|Symbol|))
   "\\spad{optional(x)} tells the pattern matcher that \\spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation)."))
 (|constant|
  (((|Expression| (|Integer|)) (|Symbol|))
   "\\spad{constant(x)} tells the pattern matcher that \\spad{x} should match only the symbol \\spad{'x} and no other quantity."))) 
NIL 
(|FunctionSpaceAssertions| R F) 
((|constructor|
  (NIL
   "Attaching assertions to symbols for pattern matching; Date Created: 21 Mar 1989"))
 (|multiple|
  ((|#2| |#2|)
   "\\spad{multiple(x)} tells the pattern matcher that \\spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\\spad{x}) tells the pattern matcher that \\spad{x} should match a list instead of an element of a list. Error: if \\spad{x} is not a symbol."))
 (|optional|
  ((|#2| |#2|)
   "\\spad{optional(x)} tells the pattern matcher that \\spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation). Error: if \\spad{x} is not a symbol."))
 (|constant|
  ((|#2| |#2|)
   "\\spad{constant(x)} tells the pattern matcher that \\spad{x} should match only the symbol \\spad{'x} and no other quantity. Error: if \\spad{x} is not a symbol."))) 
NIL 
(|PatternMatchPushDown| S A B) 
((|constructor|
  (NIL
   "This packages provides tools for matching recursively in type towers."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#3|) |#2| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#3|))
   "\\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \\spad{pat} to the expression \\spad{expr}; res contains the variables of \\spad{pat} which are already matched and their matches. Note: this function handles type towers by changing the predicates and calling the matching function provided by \\spad{A}."))
 (|fixPredicate|
  (((|Mapping| (|Boolean|) |#2|) (|Mapping| (|Boolean|) |#3|))
   "\\spad{fixPredicate(f)} returns \\spad{g} defined by \\spad{g}(a) = \\spad{f}(a::B)."))) 
NIL 
(|PatternMatchFunctionSpace| S R F) 
((|constructor|
  (NIL "This package provides pattern matching functions on function spaces."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#3|))
   "\\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \\spad{pat} to the expression \\spad{expr}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
(|PatternMatchIntegerNumberSystem| I) 
((|constructor|
  (NIL "This package provides pattern matching functions on integers."))
 (|patternMatch|
  (((|PatternMatchResult| (|Integer|) |#1|) |#1| (|Pattern| (|Integer|))
    (|PatternMatchResult| (|Integer|) |#1|))
   "\\spad{patternMatch(n,{} pat,{} res)} matches the pattern \\spad{pat} to the integer \\spad{n}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
(|PatternMatchKernel| S E) 
((|constructor|
  (NIL "This package provides pattern matching functions on kernels."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#2|) (|Kernel| |#2|) (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#2|))
   "\\spad{patternMatch(f(e1,{} ...,{} en),{} pat,{} res)} matches the pattern \\spad{pat} to \\spad{f(e1,{} ...,{} en)}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
(|PatternMatchListAggregate| S R L) 
((|constructor|
  (NIL "This package provides pattern matching functions on lists."))
 (|patternMatch|
  (((|PatternMatchListResult| |#1| |#2| |#3|) |#3| (|Pattern| |#1|)
    (|PatternMatchListResult| |#1| |#2| |#3|))
   "\\spad{patternMatch(l,{} pat,{} res)} matches the pattern \\spad{pat} to the list \\spad{l}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
(|PatternMatchPolynomialCategory| S E V R P) 
((|constructor|
  (NIL "This package provides pattern matching functions on polynomials."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#5|) |#5| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#5|))
   "\\spad{patternMatch(p,{} pat,{} res)} matches the pattern \\spad{pat} to the polynomial \\spad{p}; res contains the variables of \\spad{pat} which are already matched and their matches.")
  (((|PatternMatchResult| |#1| |#5|) |#5| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#5|)
    (|Mapping| (|PatternMatchResult| |#1| |#5|) |#3| (|Pattern| |#1|)
               (|PatternMatchResult| |#1| |#5|)))
   "\\spad{patternMatch(p,{} pat,{} res,{} vmatch)} matches the pattern \\spad{pat} to the polynomial \\spad{p}. \\spad{res} contains the variables of \\spad{pat} which are already matched and their matches; vmatch is the matching function to use on the variables."))) 
((|HasCategory| |#3| (LIST '|PatternMatchable| (|devaluate| |#1|)))) 
(|AttachPredicates| D) 
((|constructor|
  (NIL
   "Attaching predicates to symbols for pattern matching. Date Created: 21 Mar 1989"))
 (|suchThat|
  (((|Expression| (|Integer|)) (|Symbol|)
    (|List| (|Mapping| (|Boolean|) |#1|)))
   "\\spad{suchThat(x,{} [f1,{} f2,{} ...,{} fn])} attaches the predicate \\spad{f1} and \\spad{f2} and ... and \\spad{fn} to \\spad{x}.")
  (((|Expression| (|Integer|)) (|Symbol|) (|Mapping| (|Boolean|) |#1|))
   "\\spad{suchThat(x,{} foo)} attaches the predicate foo to \\spad{x}."))) 
NIL 
(|FunctionSpaceAttachPredicates| R F D) 
((|constructor|
  (NIL
   "Attaching predicates to symbols for pattern matching. Date Created: 21 Mar 1989"))
 (|suchThat|
  ((|#2| |#2| (|List| (|Mapping| (|Boolean|) |#3|)))
   "\\spad{suchThat(x,{} [f1,{} f2,{} ...,{} fn])} attaches the predicate \\spad{f1} and \\spad{f2} and ... and \\spad{fn} to \\spad{x}. Error: if \\spad{x} is not a symbol.")
  ((|#2| |#2| (|Mapping| (|Boolean|) |#3|))
   "\\spad{suchThat(x,{} foo)} attaches the predicate foo to \\spad{x}; error if \\spad{x} is not a symbol."))) 
NIL 
(|PatternMatchQuotientFieldCategory| S R Q) 
((|constructor|
  (NIL "This package provides pattern matching functions on quotients."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|)
    (|PatternMatchResult| |#1| |#3|))
   "\\spad{patternMatch(a/b,{} pat,{} res)} matches the pattern \\spad{pat} to the quotient \\spad{a/b}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
(|PatternMatchSymbol| S) 
((|constructor|
  (NIL "This package provides pattern matching functions on symbols."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| (|Symbol|)) (|Symbol|) (|Pattern| |#1|)
    (|PatternMatchResult| |#1| (|Symbol|)))
   "\\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \\spad{pat} to the expression \\spad{expr}; res contains the variables of \\spad{pat} which are already matched and their matches (necessary for recursion)."))) 
NIL 
(|PatternMatchTools| S R P) 
((|constructor| (NIL "This package provides tools for the pattern matcher."))
 (|patternMatchTimes|
  (((|PatternMatchResult| |#1| |#3|) (|List| |#3|) (|List| (|Pattern| |#1|))
    (|PatternMatchResult| |#1| |#3|)
    (|Mapping| (|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|)
               (|PatternMatchResult| |#1| |#3|)))
   "\\spad{patternMatchTimes(lsubj,{} lpat,{} res,{} match)} matches the product of patterns \\spad{reduce(*,{} lpat)} to the product of subjects \\spad{reduce(*,{} lsubj)}; \\spad{r} contains the previous matches and match is a pattern-matching function on \\spad{P}."))
 (|patternMatch|
  (((|PatternMatchResult| |#1| |#3|) (|List| |#3|) (|List| (|Pattern| |#1|))
    (|Mapping| |#3| (|List| |#3|)) (|PatternMatchResult| |#1| |#3|)
    (|Mapping| (|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|)
               (|PatternMatchResult| |#1| |#3|)))
   "\\spad{patternMatch(lsubj,{} lpat,{} op,{} res,{} match)} matches the list of patterns \\spad{lpat} to the list of subjects \\spad{lsubj},{} allowing for commutativity; \\spad{op} is the operator such that \\spad{op}(\\spad{lpat}) should match \\spad{op}(\\spad{lsubj}) at the end,{} \\spad{r} contains the previous matches,{} and match is a pattern-matching function on \\spad{P}."))) 
NIL 
(|PolynomialNumberTheoryFunctions|) 
((|constructor|
  (NIL
   "This package provides various polynomial number theoretic functions over the integers."))
 (|legendre|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{legendre(n)} returns the \\spad{n}th Legendre polynomial \\spad{P[n](x)}. Note: Legendre polynomials,{} denoted \\spad{P[n](x)},{} are computed from the two term recurrence. The generating function is: \\spad{1/sqrt(1-2*t*x+t^2) = sum(P[n](x)*t^n,{} n=0..infinity)}."))
 (|laguerre|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{laguerre(n)} returns the \\spad{n}th Laguerre polynomial \\spad{L[n](x)}. Note: Laguerre polynomials,{} denoted \\spad{L[n](x)},{} are computed from the two term recurrence. The generating function is: \\spad{exp(x*t/(t-1))/(1-t) = sum(L[n](x)*t^n/n!,{} n=0..infinity)}."))
 (|hermite|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{hermite(n)} returns the \\spad{n}th Hermite polynomial \\spad{H[n](x)}. Note: Hermite polynomials,{} denoted \\spad{H[n](x)},{} are computed from the two term recurrence. The generating function is: \\spad{exp(2*t*x-t^2) = sum(H[n](x)*t^n/n!,{} n=0..infinity)}."))
 (|fixedDivisor|
  (((|Integer|) (|SparseUnivariatePolynomial| (|Integer|)))
   "\\spad{fixedDivisor(a)} for \\spad{a(x)} in \\spad{Z[x]} is the largest integer \\spad{f} such that \\spad{f} divides \\spad{a(x=k)} for all integers \\spad{k}. Note: fixed divisor of \\spad{a} is \\spad{reduce(gcd,{} [a(x=k) for k in 0..degree(a)])}."))
 (|euler|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{euler(n)} returns the \\spad{n}th Euler polynomial \\spad{E[n](x)}. Note: Euler polynomials denoted \\spad{E(n,{} x)} are computed by solving the differential equation \\spad{differentiate(E(n,{} x),{} x) = n E(n-1,{} x)} where \\spad{E(0,{} x) = 1} and initial condition comes from \\spad{E(n) = 2^n E(n,{} 1/2)}."))
 (|cyclotomic|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{cyclotomic(n)} returns the \\spad{n}th cyclotomic polynomial \\spad{phi[n](x)}. Note: \\spad{phi[n](x)} is the factor of \\spad{x^n - 1} whose roots are the primitive \\spad{n}th roots of unity."))
 (|chebyshevU|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{chebyshevU(n)} returns the \\spad{n}th Chebyshev polynomial \\spad{U[n](x)}. Note: Chebyshev polynomials of the second kind,{} denoted \\spad{U[n](x)},{} computed from the two term recurrence. The generating function \\spad{1/(1-2*t*x+t^2) = sum(T[n](x)*t^n,{} n=0..infinity)}."))
 (|chebyshevT|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{chebyshevT(n)} returns the \\spad{n}th Chebyshev polynomial \\spad{T[n](x)}. Note: Chebyshev polynomials of the first kind,{} denoted \\spad{T[n](x)},{} computed from the two term recurrence. The generating function \\spad{(1-t*x)/(1-2*t*x+t^2) = sum(T[n](x)*t^n,{} n=0..infinity)}."))
 (|bernoulli|
  (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|))
   "\\spad{bernoulli(n)} returns the \\spad{n}th Bernoulli polynomial \\spad{B[n](x)}. Note: Bernoulli polynomials denoted \\spad{B(n,{} x)} computed by solving the differential equation \\spad{differentiate(B(n,{} x),{} x) = n B(n-1,{} x)} where \\spad{B(0,{} x) = 1} and initial condition comes from \\spad{B(n) = B(n,{} 0)}."))) 
NIL 
(|Point| R) 
((|constructor| (NIL "This domain implements points in coordinate space"))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (|HasCategory| |#1| '(|AbelianMonoid|)) (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|SemiGroup|))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|Ring|))
 (AND (|HasCategory| |#1| '(|RadicalCategory|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|PolToPol| |lv| R) 
((|constructor|
  (NIL
   "Package with the conversion functions among different kind of polynomials"))
 (|pToDmp|
  (((|DistributedMultivariatePolynomial| |#1| |#2|) (|Polynomial| |#2|))
   "\\spad{pToDmp(p)} converts \\spad{p} from a \\spadtype{POLY} to a \\spadtype{DMP}."))
 (|dmpToP|
  (((|Polynomial| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|))
   "\\spad{dmpToP(p)} converts \\spad{p} from a \\spadtype{DMP} to a \\spadtype{POLY}."))
 (|hdmpToP|
  (((|Polynomial| |#2|)
    (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
   "\\spad{hdmpToP(p)} converts \\spad{p} from a \\spadtype{HDMP} to a \\spadtype{POLY}."))
 (|pToHdmp|
  (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|Polynomial| |#2|))
   "\\spad{pToHdmp(p)} converts \\spad{p} from a \\spadtype{POLY} to a \\spadtype{HDMP}."))
 (|hdmpToDmp|
  (((|DistributedMultivariatePolynomial| |#1| |#2|)
    (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))
   "\\spad{hdmpToDmp(p)} converts \\spad{p} from a \\spadtype{HDMP} to a \\spadtype{DMP}."))
 (|dmpToHdmp|
  (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)
    (|DistributedMultivariatePolynomial| |#1| |#2|))
   "\\spad{dmpToHdmp(p)} converts \\spad{p} from a \\spadtype{DMP} to a \\spadtype{HDMP}."))) 
NIL 
(|RealPolynomialUtilitiesPackage| |TheField| |ThePols|) 
((|constructor|
  (NIL
   "\\spadtype{RealPolynomialUtilitiesPackage} provides common functions used by interval coding."))
 (|lazyVariations|
  (((|NonNegativeInteger|) (|List| |#1|) (|Integer|) (|Integer|))
   "\\spad{lazyVariations(l,{} s1,{} sn)} is the number of sign variations in the list of non null numbers [s1::l]\\spad{@sn},{}"))
 (|sturmVariationsOf|
  (((|NonNegativeInteger|) (|List| |#1|))
   "\\spad{sturmVariationsOf(l)} is the number of sign variations in the list of numbers \\spad{l},{} note that the first term counts as a sign"))
 (|boundOfCauchy|
  ((|#1| |#2|) "\\spad{boundOfCauchy(p)} bounds the roots of \\spad{p}"))
 (|sturmSequence|
  (((|List| |#2|) |#2|)
   "\\spad{sturmSequence(p) = sylvesterSequence(p,{} p')}"))
 (|sylvesterSequence|
  (((|List| |#2|) |#2| |#2|)
   "\\spad{sylvesterSequence(p,{} q)} is the negated remainder sequence of \\spad{p} and \\spad{q} divided by the last computed term"))) 
((|HasCategory| |#1| '(|OrderedRing|))) 
(|Polynomial| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are arbitrary symbols. The ordering is alphabetic determined by the Symbol type. The coefficient ring may be non commutative,{} but the variables are assumed to commute."))
 (|integrate|
  (($ $ (|Symbol|))
   "\\spad{integrate(p,{} x)} computes the integral of \\spad{p*dx},{} \\spadignore{i.e.} integrates the polynomial \\spad{p} with respect to the variable \\spad{x}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|Symbol|) (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| (|IndexedExponents| (|Symbol|)) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|Symbol|) (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|Symbol|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|Symbol|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|Symbol|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|Symbol|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|Symbol|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|PolynomialFunctions2| R S) 
((|constructor|
  (NIL
   "\\indented{2}{This package takes a mapping between coefficient rings,{} and lifts} it to a mapping between polynomials over those rings."))
 (|map|
  (((|Polynomial| |#2|) (|Mapping| |#2| |#1|) (|Polynomial| |#1|))
   "\\spad{map(f,{} p)} produces a new polynomial as a result of applying the function \\spad{f} to every coefficient of the polynomial \\spad{p}."))) 
NIL 
(|PolynomialToUnivariatePolynomial| |x| R) 
((|constructor|
  (NIL
   "This package is primarily to help the interpreter do coercions. It allows you to view a polynomial as a univariate polynomial in one of its variables with coefficients which are again a polynomial in all the other variables."))
 (|univariate|
  (((|UnivariatePolynomial| |#1| (|Polynomial| |#2|)) (|Polynomial| |#2|)
    (|Variable| |#1|))
   "\\spad{univariate(p,{} x)} converts the polynomial \\spad{p} to a one of type \\spad{UnivariatePolynomial(x,{} Polynomial(R))},{} ie. as a member of \\spad{R[...][x]}."))) 
NIL 
(|PolynomialCategory&| S R E |VarSet|) 
((|constructor|
  (NIL
   "The category for general multi-variate polynomials over a ring \\spad{R},{} in variables from VarSet,{} with exponents from the \\spadtype{OrderedAbelianMonoidSup}. Here variables commute with the coefficients."))
 (|squareFreePart|
  (($ $)
   "\\spad{squareFreePart(p)} returns product of all the irreducible factors of polynomial \\spad{p} each taken with multiplicity one."))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(p)} returns the square free factorization of the polynomial \\spad{p}."))
 (|primitivePart|
  (($ $ |#4|)
   "\\spad{primitivePart(p,{} v)} returns the unitCanonical associate of the polynomial \\spad{p} with its content with respect to the variable \\spad{v} divided out.")
  (($ $)
   "\\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \\spad{p} with its content divided out."))
 (|content|
  (($ $ |#4|)
   "\\spad{content(p,{} v)} is the \\spad{gcd} of the coefficients of the polynomial \\spad{p} when \\spad{p} is viewed as a univariate polynomial with respect to the variable \\spad{v}. Thus,{} for polynomial 7*x^2*y + 14*x*y^2,{} the \\spad{gcd} of the coefficients with respect to \\spad{x} is 7*y."))
 (|discriminant|
  (($ $ |#4|)
   "\\spad{discriminant(p,{} v)} returns the disriminant of the polynomial \\spad{p} with respect to the variable \\spad{v}."))
 (|resultant|
  (($ $ $ |#4|)
   "\\spad{resultant(p,{} q,{} v)} returns the resultant of the polynomials \\spad{p} and \\spad{q} with respect to the variable \\spad{v}."))
 (|isExpt|
  (((|Union|
     (|Record| (|:| |var| |#4|) (|:| |exponent| (|NonNegativeInteger|)))
     "failed")
    $)
   "\\spad{isExpt(p)} returns \\spad{[x,{} n]} if polynomial \\spad{p} has the form \\spad{x^n} and \\spad{n > 0}."))
 (|isTimes|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if polynomial \\spad{p = a1 ... an} and \\spad{n >= 2},{} and,{} for each \\spad{i},{} \\spad{ai} is either a nontrivial constant in \\spad{R} or else of the form \\spad{x^e},{} where \\spad{e > 0} is an integer and \\spad{x} is a member of VarSet."))
 (|isPlus|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isPlus(p)} returns \\spad{[m1,{} ...,{} mn]} if polynomial \\spad{p = m1 + ... + mn} and \\spad{n >= 2} and each \\spad{mi} is a nonzero monomial."))
 (|multivariate|
  (($ (|SparseUnivariatePolynomial| $) |#4|)
   "\\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v}.")
  (($ (|SparseUnivariatePolynomial| |#2|) |#4|)
   "\\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v}."))
 (|monicDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $ |#4|)
   "\\spad{monicDivide(a,{} b,{} v)} divides the polynomial a by the polynomial \\spad{b},{} with each viewed as a univariate polynomial in \\spad{v} returning both the quotient and remainder. Error: if \\spad{b} is not monic with respect to \\spad{v}."))
 (|minimumDegree|
  (((|List| (|NonNegativeInteger|)) $ (|List| |#4|))
   "\\spad{minimumDegree(p,{} lv)} gives the list of minimum degrees of the polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}")
  (((|NonNegativeInteger|) $ |#4|)
   "\\spad{minimumDegree(p,{} v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v},{} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}"))
 (|univariate|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{univariate(p)} converts the multivariate polynomial \\spad{p},{} which should actually involve only one variable,{} into a univariate polynomial in that variable,{} whose coefficients are in the ground ring. Error: if polynomial is genuinely multivariate")
  (((|SparseUnivariatePolynomial| $) $ |#4|)
   "\\spad{univariate(p,{} v)} converts the multivariate polynomial \\spad{p} into a univariate polynomial in \\spad{v},{} whose coefficients are still multivariate polynomials (in all the other variables)."))) 
((|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|GcdDomain|)) (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#4| (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| |#4| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|Ring|)) (|HasCategory| |#2| '(|SemiRing|))) 
(|PolynomialCategory| R E |VarSet|) 
((|constructor|
  (NIL
   "The category for general multi-variate polynomials over a ring \\spad{R},{} in variables from VarSet,{} with exponents from the \\spadtype{OrderedAbelianMonoidSup}. Here variables commute with the coefficients."))
 (|squareFreePart|
  (($ $)
   "\\spad{squareFreePart(p)} returns product of all the irreducible factors of polynomial \\spad{p} each taken with multiplicity one."))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(p)} returns the square free factorization of the polynomial \\spad{p}."))
 (|primitivePart|
  (($ $ |#3|)
   "\\spad{primitivePart(p,{} v)} returns the unitCanonical associate of the polynomial \\spad{p} with its content with respect to the variable \\spad{v} divided out.")
  (($ $)
   "\\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \\spad{p} with its content divided out."))
 (|content|
  (($ $ |#3|)
   "\\spad{content(p,{} v)} is the \\spad{gcd} of the coefficients of the polynomial \\spad{p} when \\spad{p} is viewed as a univariate polynomial with respect to the variable \\spad{v}. Thus,{} for polynomial 7*x^2*y + 14*x*y^2,{} the \\spad{gcd} of the coefficients with respect to \\spad{x} is 7*y."))
 (|discriminant|
  (($ $ |#3|)
   "\\spad{discriminant(p,{} v)} returns the disriminant of the polynomial \\spad{p} with respect to the variable \\spad{v}."))
 (|resultant|
  (($ $ $ |#3|)
   "\\spad{resultant(p,{} q,{} v)} returns the resultant of the polynomials \\spad{p} and \\spad{q} with respect to the variable \\spad{v}."))
 (|isExpt|
  (((|Union|
     (|Record| (|:| |var| |#3|) (|:| |exponent| (|NonNegativeInteger|)))
     "failed")
    $)
   "\\spad{isExpt(p)} returns \\spad{[x,{} n]} if polynomial \\spad{p} has the form \\spad{x^n} and \\spad{n > 0}."))
 (|isTimes|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if polynomial \\spad{p = a1 ... an} and \\spad{n >= 2},{} and,{} for each \\spad{i},{} \\spad{ai} is either a nontrivial constant in \\spad{R} or else of the form \\spad{x^e},{} where \\spad{e > 0} is an integer and \\spad{x} is a member of VarSet."))
 (|isPlus|
  (((|Union| (|List| $) "failed") $)
   "\\spad{isPlus(p)} returns \\spad{[m1,{} ...,{} mn]} if polynomial \\spad{p = m1 + ... + mn} and \\spad{n >= 2} and each \\spad{mi} is a nonzero monomial."))
 (|multivariate|
  (($ (|SparseUnivariatePolynomial| $) |#3|)
   "\\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v}.")
  (($ (|SparseUnivariatePolynomial| |#1|) |#3|)
   "\\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v}."))
 (|monicDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $ |#3|)
   "\\spad{monicDivide(a,{} b,{} v)} divides the polynomial a by the polynomial \\spad{b},{} with each viewed as a univariate polynomial in \\spad{v} returning both the quotient and remainder. Error: if \\spad{b} is not monic with respect to \\spad{v}."))
 (|minimumDegree|
  (((|List| (|NonNegativeInteger|)) $ (|List| |#3|))
   "\\spad{minimumDegree(p,{} lv)} gives the list of minimum degrees of the polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}")
  (((|NonNegativeInteger|) $ |#3|)
   "\\spad{minimumDegree(p,{} v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v},{} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}"))
 (|univariate|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{univariate(p)} converts the multivariate polynomial \\spad{p},{} which should actually involve only one variable,{} into a univariate polynomial in that variable,{} whose coefficients are in the ground ring. Error: if polynomial is genuinely multivariate")
  (((|SparseUnivariatePolynomial| $) $ |#3|)
   "\\spad{univariate(p,{} v)} converts the multivariate polynomial \\spad{p} into a univariate polynomial in \\spad{v},{} whose coefficients are still multivariate polynomials (in all the other variables)."))) 
NIL 
(|PolynomialCategoryQuotientFunctions| E V R P F) 
((|constructor|
  (NIL
   "This package transforms multivariate polynomials or fractions into univariate polynomials or fractions,{} and back."))
 (|isPower|
  (((|Union| (|Record| (|:| |val| |#5|) (|:| |exponent| (|Integer|))) "failed")
    |#5|)
   "\\spad{isPower(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0},{} \"failed\" otherwise."))
 (|isExpt|
  (((|Union| (|Record| (|:| |var| |#2|) (|:| |exponent| (|Integer|))) "failed")
    |#5|)
   "\\spad{isExpt(p)} returns \\spad{[x,{} n]} if \\spad{p = x^n} and \\spad{n ~= 0},{} \"failed\" otherwise."))
 (|isTimes|
  (((|Union| (|List| |#5|) "failed") |#5|)
   "\\spad{isTimes(p)} returns \\spad{[a1,{} ...,{} an]} if \\spad{p = a1 ... an} and \\spad{n > 1},{} \"failed\" otherwise."))
 (|isPlus|
  (((|Union| (|List| |#5|) "failed") |#5|)
   "\\spad{isPlus(p)} returns [\\spad{m1},{} ...,{} \\spad{mn}] if \\spad{p = m1 + ... + mn} and \\spad{n > 1},{} \"failed\" otherwise."))
 (|multivariate|
  ((|#5| (|Fraction| (|SparseUnivariatePolynomial| |#5|)) |#2|)
   "\\spad{multivariate(f,{} v)} applies both the numerator and denominator of \\spad{f} to \\spad{v}."))
 (|univariate|
  (((|SparseUnivariatePolynomial| |#5|) |#5| |#2|
    (|SparseUnivariatePolynomial| |#5|))
   "\\spad{univariate(f,{} x,{} p)} returns \\spad{f} viewed as a univariate polynomial in \\spad{x},{} using the side-condition \\spad{p(x) = 0}.")
  (((|Fraction| (|SparseUnivariatePolynomial| |#5|)) |#5| |#2|)
   "\\spad{univariate(f,{} v)} returns \\spad{f} viewed as a univariate rational function in \\spad{v}."))
 (|mainVariable|
  (((|Union| |#2| "failed") |#5|)
   "\\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \\spad{f},{} \"failed\" if \\spad{f} has no variables."))
 (|variables|
  (((|List| |#2|) |#5|)
   "\\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \\spad{f}."))) 
NIL 
(|PolynomialCategoryLifting| E |Vars| R P S) 
((|constructor|
  (NIL
   "This package provides a very general map function,{} which given a set \\spad{S} and polynomials over \\spad{R} with maps from the variables into \\spad{S} and the coefficients into \\spad{S},{} maps polynomials into \\spad{S}. \\spad{S} is assumed to support \\spad{+},{} \\spad{*} and \\spad{^}."))
 (|map|
  ((|#5| (|Mapping| |#5| |#2|) (|Mapping| |#5| |#3|) |#4|)
   "\\spad{map(varmap,{} coefmap,{} p)} takes a \\spad{varmap},{} a mapping from the variables of polynomial \\spad{p} into \\spad{S},{} \\spad{coefmap},{} a mapping from coefficients of \\spad{p} into \\spad{S},{} and \\spad{p},{} and produces a member of \\spad{S} using the corresponding arithmetic in \\spad{S}."))) 
NIL 
(|PolynomialRoots| E V R P F) 
((|constructor|
  (NIL "computes \\spad{n}-th roots of quotients of multivariate polynomials"))
 (|nthr|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#4|)
              (|:| |radicand| (|List| |#4|)))
    |#4| (|NonNegativeInteger|))
   "\\spad{nthr(p,{} n)} should be local but conditional"))
 (|froot|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|)
              (|:| |radicand| |#5|))
    |#5| (|NonNegativeInteger|))
   "\\spad{froot(f,{} n)} returns \\spad{[m,{} c,{} r]} such that \\spad{f^(1/n) = c * r^(1/m)}."))
 (|qroot|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|)
              (|:| |radicand| |#5|))
    (|Fraction| (|Integer|)) (|NonNegativeInteger|))
   "\\spad{qroot(f,{} n)} returns \\spad{[m,{} c,{} r]} such that \\spad{f^(1/n) = c * r^(1/m)}."))
 (|rroot|
  (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|)
              (|:| |radicand| |#5|))
    |#3| (|NonNegativeInteger|))
   "\\spad{rroot(f,{} n)} returns \\spad{[m,{} c,{} r]} such that \\spad{f^(1/n) = c * r^(1/m)}."))
 (|coerce| (($ |#4|) "\\spad{coerce(p)} \\undocumented"))
 (|denom| ((|#4| $) "\\spad{denom(x)} \\undocumented"))
 (|numer| ((|#4| $) "\\spad{numer(x)} \\undocumented"))) 
((|HasCategory| |#3| '(|GcdDomain|))) 
(|U32VectorPolynomialOperations|) 
((|constructor|
  (NIL
   "This is a low-level package which implements operations \\indented{1}{on vectors treated as univariate modular polynomials.\\space{2}Most} \\indented{1}{operations takes modulus as parameter.\\space{2}Modulus is machine} \\indented{1}{sized prime which should be small enough to avoid overflow} \\indented{1}{in intermediate calculations.}"))
 (|resultant|
  (((|Integer|) (|U32Vector|) (|U32Vector|) (|Integer|))
   "\\spad{resultant(v1,{} v2,{} p)} computes resultant of \\spad{v1} and \\spad{v2} modulo \\spad{p}."))
 (|extended_gcd|
  (((|List| (|U32Vector|)) (|U32Vector|) (|U32Vector|) (|Integer|))
   "\\spad{extended_gcd(v1,{} v2,{} p)} gives [\\spad{g},{} \\spad{c1},{} \\spad{c2}] such that \\spad{g} is \\spad{gcd(v1,{} v2,{} p)},{} \\spad{g = c1*v1 + c2*v2} and degree(\\spad{c1}) < max(degree(\\spad{v2}) - degree(\\spad{g}),{} 0) and degree(\\spad{c2}) < max(degree(\\spad{v1}) - degree(\\spad{g}),{} 1)"))
 (|degree|
  (((|Integer|) (|U32Vector|))
   "\\spad{degree(v)} is degree of \\spad{v} treated as polynomial"))
 (|lcm|
  (((|U32Vector|) (|PrimitiveArray| (|U32Vector|)) (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{lcm(a,{} lo,{} \\spad{hi},{} p)} computes \\spad{lcm} of elements a(\\spad{lo}),{} a(\\spad{lo+1}),{} ...,{} a(\\spad{hi})."))
 (|gcd|
  (((|U32Vector|) (|PrimitiveArray| (|U32Vector|)) (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{gcd(a,{} lo,{} \\spad{hi},{} p)} computes \\spad{gcd} of elements a(\\spad{lo}),{} a(\\spad{lo+1}),{} ...,{} a(\\spad{hi}).")
  (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|))
   "\\spad{gcd(v1,{} v2,{} p)} computes monic \\spad{gcd} of \\spad{v1} and \\spad{v2} modulo \\spad{p}."))
 (|pa_to_sup|
  (((|SparseUnivariatePolynomial| (|Integer|)) (|U32Vector|))
   "\\spad{pa_to_sup(v)} converts vector of coefficients to a polynomial"))
 (|to_mod_pa|
  (((|U32Vector|) (|SparseUnivariatePolynomial| (|Integer|)) (|Integer|))
   "\\spad{to_mod_pa(s,{} p)} reduces coefficients of polynomial \\spad{s} modulo prime \\spad{p} and converts the result to vector"))
 (|vector_combination|
  (((|Void|) (|U32Vector|) (|Integer|) (|U32Vector|) (|Integer|) (|Integer|)
    (|Integer|) (|Integer|))
   "\\spad{vector_combination(v1,{} c1,{} v2,{} c2,{} n,{} delta,{} p)} replaces first \\spad{n} + 1 entires of \\spad{v1} by corresponding entries of \\spad{c1*v1+c2*x^delta*v2} mod \\spad{p}."))
 (|remainder!|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial remainder"))
 (|divide!|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|))
   "Polynomial division."))
 (|differentiate|
  (((|U32Vector|) (|U32Vector|) (|NonNegativeInteger|) (|Integer|))
   "Polynomial differentiation.")
  (((|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial differentiation."))
 (|pow|
  (((|U32Vector|) (|U32Vector|) (|PositiveInteger|) (|NonNegativeInteger|)
    (|Integer|))
   "\\spad{pow(u,{} n,{} d,{} p)} returns u^n truncated after degree \\spad{d},{} except if \\spad{n=1},{} in which case \\spad{u} itself is returned"))
 (|truncated_mul_add2|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{truncated_mul_add2(x,{} y,{} z,{} d1,{} d2,{} p)} adds to \\spad{z} the product x*y and the variable to power \\spad{d1} truncated after degree \\spad{d}."))
 (|truncated_mul_add|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|))
   "\\spad{truncated_mul_add(x,{} y,{} z,{} d,{} p)} adds to \\spad{z} the product x*y truncated after degree \\spad{d}."))
 (|truncated_multiplication|
  (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|))
   "\\spad{truncated_multiplication(x,{} y,{} d,{} p)} computes x*y truncated after degree \\spad{d}."))
 (|mul|
  (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|))
   "Polynomial multiplication."))
 (|mul_by_scalar|
  (((|Void|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{mul_by_scalar(v,{} deg,{} c,{} p)} treats \\spad{v} as coefficients of polynomial of degree \\spad{deg} and multiplies in place this polynomial by scalar \\spad{c}"))
 (|mul_by_binomial|
  (((|Void|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{mul_by_binomial(v,{} deg,{} pt,{} p)} treats \\spad{v} as coefficients of polynomial of degree \\spad{deg} and multiplies in place this polynomial by binomial (\\spad{x} + \\spad{pt}). Highest coefficient of product is ignored.")
  (((|Void|) (|U32Vector|) (|Integer|) (|Integer|))
   "\\spad{mul_by_binomial(v,{} pt,{} p)} treats \\spad{v} a polynomial and multiplies in place this polynomial by binomial (\\spad{x} + \\spad{pt}). Highest coefficient of product is ignored."))
 (|vector_add_mul|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|)
    (|Integer|))
   "\\spad{vector_add_mul(v1,{} v2,{} m,{} n,{} c,{} p)} sets \\spad{v1}(\\spad{m}),{} ...,{} \\spad{v1}(\\spad{n}) to corresponding extries in \\spad{v1} + \\spad{c*v2} modulo \\spad{p}."))
 (|eval_at|
  (((|Integer|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{eval_at(v,{} deg,{} pt,{} p)} treats \\spad{v} as coefficients of polynomial of degree \\spad{deg} and evaluates the polynomial at point \\spad{pt} modulo \\spad{p}"))
 (|copy_slice|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|))
   "\\spad{copy_slice(v1,{} v2,{} m,{} n)} copies the slice of \\spad{v2} starting at \\spad{m} elements and having \\spad{n} elements into corresponding positions in \\spad{v1}."))
 (|copy_first|
  (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|))
   "\\spad{copy_first(v1,{} v2,{} n)} copies first \\spad{n} elements of \\spad{v2} into \\spad{n} first positions in \\spad{v1}."))) 
NIL 
(|PartialOrder&| S) 
((|constructor|
  (NIL
   "The class of partially ordered sets,{} that is sets equipped with transitive and reflexive relation \\spad{<=}."))
 (<= (((|Boolean|) $ $) "\\spad{x <= y} is a less than or equal test."))
 (>= (((|Boolean|) $ $) "\\spad{x >= y} is a greater than or equal test."))
 (> (((|Boolean|) $ $) "\\spad{x > y} is a greater than test."))
 (< (((|Boolean|) $ $) "\\spad{x < y} is a less than test."))) 
NIL 
(|PartialOrder|) 
((|constructor|
  (NIL
   "The class of partially ordered sets,{} that is sets equipped with transitive and reflexive relation \\spad{<=}."))
 (<= (((|Boolean|) $ $) "\\spad{x <= y} is a less than or equal test."))
 (>= (((|Boolean|) $ $) "\\spad{x >= y} is a greater than or equal test."))
 (> (((|Boolean|) $ $) "\\spad{x > y} is a greater than test."))
 (< (((|Boolean|) $ $) "\\spad{x < y} is a less than test."))) 
NIL 
(|Poset&| A S) 
((|constructor|
  (NIL
   "holds a complete set together with a structure to codify \\indented{2}{the partial order.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))
 (|coverMatrix|
  (((|IncidenceAlgebra| (|Integer|) |#2|) $)
   "the covering matrix of a list of elements from a comparison function the list is assumed to be topologically sorted,{} \\spadignore{i.e.} \\spad{w}.\\spad{r}. to a linear extension of the comparison function \\spad{f} This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|zetaMatrix|
  (((|IncidenceAlgebra| (|Integer|) |#2|) $)
   "\\spad{zetaMatrix(P)} returns the matrix of the zeta function This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|moebius|
  (((|IncidenceAlgebra| (|Integer|) |#2|) $)
   "\\spad{moebius incidence} matrix for this poset This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|isAntiChain?|
  (((|Boolean|) $)
   "is a subset of a partially ordered set such that any two elements in the subset are incomparable"))
 (|isChain?|
  (((|Boolean|) $)
   "is a subset of a partially ordered set such that any two elements in the subset are comparable"))
 (|isAntisymmetric?|
  (((|Boolean|) $)
   "Antisymmetric requires forall(\\spad{x},{} \\spad{y}): x<=y and y<=x iff x=y Returns \\spad{true} if this is the case for every element."))
 (|completeTransitivity|
  (($ $)
   "Transitivity requires forall(\\spad{x},{} \\spad{y},{} \\spad{z}): x<=y and y<=z implies x<=z This function enforces this by making sure that the composition of any two arrows is also an arrow."))
 (|completeReflexivity|
  (($ $)
   "Reflexivity requires forall(\\spad{x}): x<=x This function enforces this by making sure that every element has arrow to itself. That is,{} the leading diagonal is \\spad{true}."))
 (|objectToIndex|
  (((|NonNegativeInteger|) $ |#2|) "returns the index of a given object"))
 (|indexToObject|
  ((|#2| $ (|NonNegativeInteger|)) "returns the object at a given index"))
 (|lowerSet|
  (($ $)
   "a subset \\spad{U} with the property that,{} if \\spad{x} is in \\spad{U} and \\spad{x} \\spad{>=} \\spad{y},{} then \\spad{y} is in \\spad{U}"))
 (|upperSet|
  (($ $)
   "a subset \\spad{U} with the property that,{} if \\spad{x} is in \\spad{U} and \\spad{x} \\spad{<=} \\spad{y},{} then \\spad{y} is in \\spad{U}"))
 (|lub|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "'least upper bound' or 'supremum' In this version of lub nodes are represented as index values. Not every subset of a poset will have a lub in which case \"failed\" will be returned as an error indication."))
 (|glb|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "'greatest lower bound' or 'infimum' In this version of \\spad{glb} nodes are represented as index values. Not every subset of a poset will have a \\spad{glb} in which case \"failed\" will be returned as an error indication."))
 (|joinIfCan|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "returns the join of a subset of lattice given by list of elements")
  (((|Union| (|NonNegativeInteger|) "failed") $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "returns the join of 'a' and \\spad{'b'} In this version of join nodes are represented as index values. In the general case,{} not every poset will have a join in which case \"failed\" will be returned as an error indication."))
 (|meetIfCan|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "returns the meet of a subset of lattice given by list of elements")
  (((|Union| (|NonNegativeInteger|) "failed") $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "returns the meet of 'a' and \\spad{'b'} In this version of meet nodes are represented as index values. In the general case,{} not every poset will have a meet in which case \"failed\" will be returned as an error indication."))
 (|powerSetStructure|
  (($ |#2|)
   "\\spad{powerSetStructure(set)} is a constructor for a Poset where each element is a \\spad{set} (implemented as a list) and with a subset structure. requires \\spad{S} to be a list."))
 (|opposite|
  (($ $)
   "constructs the opposite in the category theory sense of reversing all the arrows"))
 (|addArrow!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \\spad{s},{} where: \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object This is done in a non-mutable way,{} that is,{} the original poset is not changed instead a new one is constructed."))
 (|addObject!|
  (($ $ |#2|)
   "\\spad{addObject!(s,{} n)} adds object with coordinates \\spad{n} to the graph \\spad{s}. This is done in a non-mutable way,{} that is,{} the original poset is not changed instead a new one is constructed."))
 (|setArr|
  (((|Void|) $ (|List| (|List| (|Boolean|))))
   "sets the list of all arrows (or edges)"))
 (|setVert|
  (((|Void|) $ (|List| |#2|)) "sets the list of all vertices (or objects)"))
 (|getArr|
  (((|List| (|List| (|Boolean|))) $)
   "\\spad{getArr(s)} returns a list of all the arrows (or edges) Note: different from getArrows(\\spad{s}) which is inherited from FiniteGraph(\\spad{S})"))
 (|getVert|
  (((|List| |#2|) $)
   "\\spad{getVert(s)} returns a list of all the vertices (or objects) of the graph \\spad{s}. Note: different from getVertices(\\spad{s}) which is inherited from FiniteGraph(\\spad{S})"))
 (|finitePoset|
  (($ (|List| |#2|) (|Mapping| (|Boolean|) |#2| |#2|))
   "constructor where the set and structure is supplied. The structure is supplied as a predicate function.")
  (($ (|List| |#2|) (|List| (|List| (|Boolean|))))
   "constructor where the set and structure is supplied."))) 
NIL 
(|Poset| S) 
((|constructor|
  (NIL
   "holds a complete set together with a structure to codify \\indented{2}{the partial order.} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Date Created: Aug 2015 Basic Operations: Related packages: UserDefinedPartialOrdering in setorder.spad Related categories: PartialOrder in catdef.spad Related Domains: DirectedGraph in graph.spad Also See: AMS Classifications:"))
 (|coverMatrix|
  (((|IncidenceAlgebra| (|Integer|) |#1|) $)
   "the covering matrix of a list of elements from a comparison function the list is assumed to be topologically sorted,{} \\spadignore{i.e.} \\spad{w}.\\spad{r}. to a linear extension of the comparison function \\spad{f} This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|zetaMatrix|
  (((|IncidenceAlgebra| (|Integer|) |#1|) $)
   "\\spad{zetaMatrix(P)} returns the matrix of the zeta function This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|moebius|
  (((|IncidenceAlgebra| (|Integer|) |#1|) $)
   "\\spad{moebius incidence} matrix for this poset This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}"))
 (|isAntiChain?|
  (((|Boolean|) $)
   "is a subset of a partially ordered set such that any two elements in the subset are incomparable"))
 (|isChain?|
  (((|Boolean|) $)
   "is a subset of a partially ordered set such that any two elements in the subset are comparable"))
 (|isAntisymmetric?|
  (((|Boolean|) $)
   "Antisymmetric requires forall(\\spad{x},{} \\spad{y}): x<=y and y<=x iff x=y Returns \\spad{true} if this is the case for every element."))
 (|completeTransitivity|
  (($ $)
   "Transitivity requires forall(\\spad{x},{} \\spad{y},{} \\spad{z}): x<=y and y<=z implies x<=z This function enforces this by making sure that the composition of any two arrows is also an arrow."))
 (|completeReflexivity|
  (($ $)
   "Reflexivity requires forall(\\spad{x}): x<=x This function enforces this by making sure that every element has arrow to itself. That is,{} the leading diagonal is \\spad{true}."))
 (|objectToIndex|
  (((|NonNegativeInteger|) $ |#1|) "returns the index of a given object"))
 (|indexToObject|
  ((|#1| $ (|NonNegativeInteger|)) "returns the object at a given index"))
 (|lowerSet|
  (($ $)
   "a subset \\spad{U} with the property that,{} if \\spad{x} is in \\spad{U} and \\spad{x} \\spad{>=} \\spad{y},{} then \\spad{y} is in \\spad{U}"))
 (|upperSet|
  (($ $)
   "a subset \\spad{U} with the property that,{} if \\spad{x} is in \\spad{U} and \\spad{x} \\spad{<=} \\spad{y},{} then \\spad{y} is in \\spad{U}"))
 (|lub|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "'least upper bound' or 'supremum' In this version of lub nodes are represented as index values. Not every subset of a poset will have a lub in which case \"failed\" will be returned as an error indication."))
 (|glb|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "'greatest lower bound' or 'infimum' In this version of \\spad{glb} nodes are represented as index values. Not every subset of a poset will have a \\spad{glb} in which case \"failed\" will be returned as an error indication."))
 (|joinIfCan|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "returns the join of a subset of lattice given by list of elements")
  (((|Union| (|NonNegativeInteger|) "failed") $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "returns the join of 'a' and \\spad{'b'} In this version of join nodes are represented as index values. In the general case,{} not every poset will have a join in which case \"failed\" will be returned as an error indication."))
 (|meetIfCan|
  (((|Union| (|NonNegativeInteger|) "failed") $
    (|List| (|NonNegativeInteger|)))
   "returns the meet of a subset of lattice given by list of elements")
  (((|Union| (|NonNegativeInteger|) "failed") $ (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "returns the meet of 'a' and \\spad{'b'} In this version of meet nodes are represented as index values. In the general case,{} not every poset will have a meet in which case \"failed\" will be returned as an error indication."))
 (|powerSetStructure|
  (($ |#1|)
   "\\spad{powerSetStructure(set)} is a constructor for a Poset where each element is a \\spad{set} (implemented as a list) and with a subset structure. requires \\spad{S} to be a list."))
 (|opposite|
  (($ $)
   "constructs the opposite in the category theory sense of reversing all the arrows"))
 (|addArrow!|
  (($ $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \\spad{s},{} where: \\spad{n1} is the index of the start object \\spad{n2} is the index of the end object This is done in a non-mutable way,{} that is,{} the original poset is not changed instead a new one is constructed."))
 (|addObject!|
  (($ $ |#1|)
   "\\spad{addObject!(s,{} n)} adds object with coordinates \\spad{n} to the graph \\spad{s}. This is done in a non-mutable way,{} that is,{} the original poset is not changed instead a new one is constructed."))
 (|setArr|
  (((|Void|) $ (|List| (|List| (|Boolean|))))
   "sets the list of all arrows (or edges)"))
 (|setVert|
  (((|Void|) $ (|List| |#1|)) "sets the list of all vertices (or objects)"))
 (|getArr|
  (((|List| (|List| (|Boolean|))) $)
   "\\spad{getArr(s)} returns a list of all the arrows (or edges) Note: different from getArrows(\\spad{s}) which is inherited from FiniteGraph(\\spad{S})"))
 (|getVert|
  (((|List| |#1|) $)
   "\\spad{getVert(s)} returns a list of all the vertices (or objects) of the graph \\spad{s}. Note: different from getVertices(\\spad{s}) which is inherited from FiniteGraph(\\spad{S})"))
 (|finitePoset|
  (($ (|List| |#1|) (|Mapping| (|Boolean|) |#1| |#1|))
   "constructor where the set and structure is supplied. The structure is supplied as a predicate function.")
  (($ (|List| |#1|) (|List| (|List| (|Boolean|))))
   "constructor where the set and structure is supplied."))) 
NIL 
(|PosetFactory| S) 
((|constructor|
  (NIL
   "Provides functions to construct various small posets including powerset. Perhaps it should be called a 'powerlist' but since we do not expect duplicates or reqire specific ordering it is essentially the same."))
 (|posetL7|
  (((|FiniteBiCPO| |#1|) (|List| |#1|))
   "generates a poset corresponding to an \\spad{L7} lattice"))
 (|posetP6|
  (((|FiniteBiCPO| |#1|) (|List| |#1|))
   "generates a poset corresponding to an \\spad{P6} lattice"))
 (|posetO6|
  (((|FiniteBiCPO| |#1|) (|List| |#1|))
   "generates a poset corresponding to an \\spad{O6} lattice"))
 (|posetM5|
  (((|FiniteBiCPO| |#1|) (|List| |#1|))
   "generates a poset corresponding to an \\spad{M5} lattice"))
 (|posetN5|
  (((|FiniteBiCPO| |#1|) (|List| |#1|))
   "generates a poset corresponding to an \\spad{N5} lattice"))
 (|completelyOrderedSet|
  (((|FiniteBiCPO| |#1|) (|List| |#1|)) "generates a completely ordered set"))
 (|powerset|
  (((|FiniteBiCPO| (|List| |#1|)) (|List| |#1|))
   "generate a poset representing all possible subsets of a given set with their subset relationships."))) 
NIL 
(|PlottablePlaneCurveCategory|) 
((|constructor|
  (NIL
   "PlottablePlaneCurveCategory is the category of curves in the plane which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \\spad{x}-coordinates and \\spad{y}-coordinates of the points on the curve."))
 (|yRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{yRange(c)} returns the range of the \\spad{y}-coordinates of the points on the curve \\spad{c}."))
 (|xRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{xRange(c)} returns the range of the \\spad{x}-coordinates of the points on the curve \\spad{c}."))
 (|listBranches|
  (((|List| (|List| (|Point| (|DoubleFloat|)))) $)
   "\\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \\spad{c}."))) 
NIL 
(|PolynomialRing| R E) 
((|constructor|
  (NIL
   "This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and terms indexed by their exponents (from an arbitrary ordered abelian monoid). This type is used,{} for example,{} by the \\spadtype{DistributedMultivariatePolynomial} domain where the exponent domain is a direct product of non negative integers."))
 (|canonicalUnitNormal|
  ((|attribute|)
   "canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|)) (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|PrecomputedAssociatedEquations| R L) 
((|constructor|
  (NIL
   "\\spadtype{PrecomputedAssociatedEquations} stores some generic precomputations which speed up the computations of the associated equations needed for factoring operators."))
 (|firstUncouplingMatrix|
  (((|Union| (|Matrix| |#1|) "failed") |#2| (|PositiveInteger|))
   "\\spad{firstUncouplingMatrix(op,{} m)} returns the matrix A such that \\spad{A w = (W',{} W'',{} ...,{} W^N)} in the corresponding associated equations for right-factors of order \\spad{m} of \\spad{op}. Returns \"failed\" if the matrix A has not been precomputed for the particular combination \\spad{degree(L),{} m}."))) 
NIL 
(|Preorder| S) 
((|constructor|
  (NIL
   "implies operation with reflexivity and transitivity \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\\spad{htm}} Related Domains: PartialOrder in catdef.spad"))
 (|le|
  (((|Boolean|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "less than or equal \\spad{I} would have liked to have used: \"<=\" instead of \"le\" \"<=\" compiles but when called gives: Internal Error: The function \\spad{<=} with signature hashcode is missing from domain"))) 
NIL 
(|PrimGCD|) 
((|constructor|
  (NIL
   "This is unfinished package for computing primitive \\indented{1}{\\spad{gcd} over algebraic extensions.\\space{2}Algebraic extension is defined} \\indented{1}{by list of polynomial forming triangular system.} \\indented{1}{Currently implemented is only trial division.}"))
 (|alg_trial_division|
  (((|Boolean|) (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|List| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
    (|List| (|Symbol|)) (|List| (|Symbol|)))
   "\\spad{alg_trial_division(x,{} y,{} lm,{} lv,{} lz)} checks if \\spad{x} is divisible by \\spad{y} in algebraic extension defined by \\spad{lm}. \\spad{lz} is list of algebraic variables,{} \\spad{lv} is list of independent (polynomial) variables. Other variables serve as parameters."))
 (|alg_reduce|
  (((|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|List| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
    (|List| (|Symbol|)) (|List| (|Symbol|)))
   "\\spad{alg_reduce(x,{} lm,{} lv,{} lz)} reduces \\spad{x} modulo elements of \\spad{lm}."))
 (|alg_reduce0|
  (((|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)) (|List| (|Symbol|))
    (|Symbol|))
   "\\spad{alg_reduce0(x,{} m,{} lv,{} z)} performs single reduction step."))
 (|coeffs1|
  (((|List| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|List| (|Symbol|)))
   "\\spad{coeffs1(x,{} lv)} computes list of coefficients of \\spad{x} with respect to variables in \\spad{lv}. Variables in \\spad{lv} must be decreasing and bigger than all other variables of \\spad{x}."))
 (|coeffs0|
  (((|List| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)) (|List| (|Symbol|))
    (|List| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))))
   "\\spad{coeffs0(x,{} lv,{} lp)} is used by \\spad{coeffs1}"))
 (|lcz|
  (((|Record|
     (|:| |lczlc| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
     (|:| |k| (|Integer|)))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)) (|Symbol|))
   "\\spad{lcz(x,{} z)} computes leading coefficient and degree of \\spad{x} with respect to variable \\spad{z}."))
 (|lcx0|
  (((|Record|
     (|:| |lcx0lc| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|)))
     (|:| |lcx0m| (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))))
    (|SparseMultivariatePolynomial| (|Integer|) (|Symbol|))
    (|List| (|Symbol|)))
   "\\spad{lcx0(x,{} lv)} computes leading coefficient of \\spad{x} and corresponding product of variables (monomial with coefficient 1) with respect to variables in \\spad{lv} Variables in \\spad{lv} must be decreasing and bigger than all other variables of \\spad{x}."))) 
NIL 
(|PrimitiveArray| S) 
((|constructor|
  (NIL
   "\\indented{1}{This provides a fast array type with no bound checking on elt\\spad{'s}.} Minimum index is 0 in this type,{} cannot be changed"))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|PrimitiveArrayFunctions2| A B) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides tools for operating on primitive arrays} with unary and binary functions involving different underlying types"))
 (|map|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|))
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of primitive array \\spad{a} resulting in a new primitive array over a possibly different underlying domain."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the primitive array \\spad{a} and an accumulant initialized to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as the identity element for the function \\spad{f}."))
 (|scan|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|)
    |#2|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-arrays \\spad{x} of primitive array \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad{[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))) 
NIL 
(|PrimitiveFunctionCategory|) 
((|constructor| (NIL "Category for the functions defined by integrals."))
 (|integral|
  (($ $ (|SegmentBinding| $))
   "\\spad{integral(f,{} x = a..b)} returns the formal definite integral of \\spad{f} \\spad{dx} for \\spad{x} between \\spad{a} and \\spad{b}.")
  (($ $ (|Symbol|))
   "\\spad{integral(f,{} x)} returns the formal integral of \\spad{f} \\spad{dx}."))) 
NIL 
(|PrimitiveElement| F) 
((|constructor|
  (NIL
   "PrimitiveElement provides functions to compute primitive elements in algebraic extensions."))
 (|primitiveElement|
  (((|Record| (|:| |coef| (|List| (|Integer|)))
              (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#1|)))
              (|:| |prim| (|SparseUnivariatePolynomial| |#1|)))
    (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)) (|Symbol|))
   "\\spad{primitiveElement([p1,{} ...,{} pn],{} [a1,{} ...,{} an],{} a)} returns \\spad{[[c1,{} ...,{} cn],{} [q1,{} ...,{} qn],{} q]} such that then \\spad{k(a1,{} ...,{} an) = k(a)},{} where \\spad{a = a1 c1 + ... + an cn},{} \\spad{\\spad{ai} = \\spad{qi}(a)},{} and \\spad{q(a) = 0}. The \\spad{pi}\\spad{'s} are the defining polynomials for the \\spad{ai}\\spad{'s}. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}.")
  (((|Record| (|:| |coef| (|List| (|Integer|)))
              (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#1|)))
              (|:| |prim| (|SparseUnivariatePolynomial| |#1|)))
    (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)))
   "\\spad{primitiveElement([p1,{} ...,{} pn],{} [a1,{} ...,{} an])} returns \\spad{[[c1,{} ...,{} cn],{} [q1,{} ...,{} qn],{} q]} such that then \\spad{k(a1,{} ...,{} an) = k(a)},{} where \\spad{a = a1 c1 + ... + an cn},{} \\spad{\\spad{ai} = \\spad{qi}(a)},{} and \\spad{q(a) = 0}. The \\spad{pi}\\spad{'s} are the defining polynomials for the \\spad{ai}\\spad{'s}. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}.")
  (((|Record| (|:| |coef1| (|Integer|)) (|:| |coef2| (|Integer|))
              (|:| |prim| (|SparseUnivariatePolynomial| |#1|)))
    (|Polynomial| |#1|) (|Symbol|) (|Polynomial| |#1|) (|Symbol|))
   "\\spad{primitiveElement(p1,{} a1,{} p2,{} a2)} returns \\spad{[c1,{} c2,{} q]} such that \\spad{k(a1,{} a2) = k(a)} where \\spad{a = c1 a1 + c2 a2,{} and q(a) = 0}. The \\spad{pi}\\spad{'s} are the defining polynomials for the \\spad{ai}\\spad{'s}. The \\spad{p2} may involve \\spad{a1},{} but \\spad{p1} must not involve \\spad{a2}. This operation uses \\spadfun{resultant}."))) 
NIL 
(|IntegerPrimesPackage| I) 
((|constructor|
  (NIL
   "The \\spadtype{IntegerPrimesPackage} implements a modification of Rabin\\spad{'s} probabilistic primality test and the utility functions \\spadfun{nextPrime},{} \\spadfun{prevPrime} and \\spadfun{primes}."))
 (|primes|
  (((|List| |#1|) |#1| |#1|)
   "\\spad{primes(a,{} b)} returns a list of all primes \\spad{p} with \\spad{a <= p <= b}"))
 (|prevPrime|
  ((|#1| |#1|)
   "\\spad{prevPrime(n)} returns the largest prime strictly smaller than \\spad{n}"))
 (|nextPrime|
  ((|#1| |#1|)
   "\\spad{nextPrime(n)} returns the smallest prime strictly larger than \\spad{n}"))
 (|prime?|
  (((|Boolean|) |#1|)
   "\\spad{prime?(n)} returns \\spad{true} if \\spad{n} is prime and \\spad{false} if not. Note that we ignore sign of \\spad{n},{} so \\spad{-5} is considered prime. The algorithm used is Rabin\\spad{'s} probabilistic primality test (reference: Knuth Volume 2 Semi Numerical Algorithms). If \\spad{prime? n} returns \\spad{false},{} \\spad{n} is proven composite. If \\spad{prime? n} returns \\spad{true},{} prime? may be in error however,{} the probability of error is very low. and is zero below 25*10^9 (due to a result of Pomerance et al),{} below 10^12 and 10^13 due to results of Pinch,{} and below 341550071728321 due to a result of Jaeschke. Specifically,{} this implementation does at least 10 pseudo prime tests and so the probability of error is \\spad{< 4^(-10)}. The running time of this method is cubic in the length of the input \\spad{n},{} that is \\spad{O( (log n)^3 )},{} for \\spad{n<10^20}. beyond that,{} the algorithm is quartic,{} \\spad{O( (log n)^4 )}. Two improvements due to Davenport have been incorporated which catches some trivial strong pseudo-primes,{} such as [Jaeschke,{} 1991] 1377161253229053 * 413148375987157,{} which the original algorithm regards as prime"))) 
NIL 
(|PrimitiveTwoDimensionalArray| S) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices \\indented{1}{(two dimensional arrays) of general values.} \\indented{1}{Indexing is 0 based,{} there is no bound checking (unless} \\indented{1}{provided by lower level).}"))) 
((|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| |#1| '(|SetCategory|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|AbelianMonoid|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|AbelianMonoid|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (AND (|HasCategory| |#1| '(|AbelianGroup|))
      (|HasCategory| |#1| '(|AbelianMonoid|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|SemiRng|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|)) (|HasCategory| |#1| '(|Monoid|))
      (|HasCategory| |#1| '(|SemiRng|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|EuclideanDomain|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|CommutativeRing|)))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|)) (|HasCategory| |#1| '(|Field|)))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|PrintPackage|) 
((|constructor|
  (NIL "PrintPackage provides a print function for output forms."))
 (|print|
  (((|Void|) (|OutputForm|))
   "\\spad{print(o)} writes the output form \\spad{o} on standard output using the two-dimensional formatter."))) 
NIL 
(|Product| A B) 
((|constructor|
  (NIL
   "This domain implements cartesian product. If the underlying domains are both Finite then the resulting Product is also Finite and can be enumerated via size(),{} index(),{} location(),{} etc. The index of the second component (\\spad{B}) varies most quickly."))
 (|second|
  ((|#2| $) "\\spad{second(x)} selects second component of the product"))
 (|first| ((|#1| $) "\\spad{first(x)} selects first component of the product"))
 (|construct|
  (($ |#1| |#2|)
   "\\spad{construct(a,{} b)} creates element of the product with components a and \\spad{b}."))) 
((AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
      (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
 (OR
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (AND (|HasCategory| |#1| '(|AbelianGroup|))
      (|HasCategory| |#2| '(|AbelianGroup|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|AbelianMonoid|))
       (|HasCategory| |#2| '(|AbelianMonoid|)))
  (AND (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))))
 (AND (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#2| '(|Group|)))
 (OR (AND (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#2| '(|Group|)))
     (AND (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#2| '(|Monoid|))))
 (AND (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#2| '(|Finite|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| |#2| '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Finite|)) (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| |#2| '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|AbelianGroup|)))
  (AND (|HasCategory| |#1| '(|AbelianMonoid|))
       (|HasCategory| |#2| '(|AbelianMonoid|)))
  (AND (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
       (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#2| '(|Group|)))
  (AND (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#2| '(|Monoid|)))
  (AND (|HasCategory| |#1| '(|OrderedAbelianMonoidSup|))
       (|HasCategory| |#2| '(|OrderedAbelianMonoidSup|))))) 
(|PriorityQueueAggregate| S) 
((|constructor|
  (NIL
   "A priority queue is a bag of items from an ordered set where the item extracted is always the maximum element."))
 (|merge!|
  (($ $ $)
   "\\spad{merge!(q,{} q1)} destructively changes priority queue \\spad{q} to include the values from priority queue \\spad{q1}."))
 (|merge|
  (($ $ $)
   "\\spad{merge(q1,{} q2)} returns combines priority queues \\spad{q1} and \\spad{q2} to return a single priority queue \\spad{q}."))
 (|max|
  ((|#1| $)
   "\\spad{max(q)} returns the maximum element of priority queue \\spad{q}."))) 
NIL 
(|PolynomialRationalRoots| F UP) 
((|integerBound|
  (((|Integer|) |#2|)
   "\\spad{integerBound(p)} returns a lower bound on the negative integer roots of \\spad{p},{} and 0 if \\spad{p} has no negative integer roots."))
 (|get_rational_roots|
  (((|List| (|Fraction| (|Integer|))) |#2|)
   "\\spad{get_rational_roots(p)} finds rational root of \\spad{p}."))) 
NIL 
(|PseudoRemainderSequence| R |polR|) 
((|constructor|
  (NIL
   "This package contains some functions: \\spadopFrom{discriminant}{PseudoRemainderSequence},{} \\spadopFrom{resultant}{PseudoRemainderSequence},{} \\spadopFrom{subResultantGcd}{PseudoRemainderSequence},{} \\spadopFrom{chainSubResultants}{PseudoRemainderSequence},{} \\spadopFrom{degreeSubResultant}{PseudoRemainderSequence},{} \\spadopFrom{lastSubResultant}{PseudoRemainderSequence},{} \\spadopFrom{resultantEuclidean}{PseudoRemainderSequence},{} \\spadopFrom{subResultantGcdEuclidean}{PseudoRemainderSequence},{} \\spadopFrom{\\spad{semiSubResultantGcdEuclidean1}}{PseudoRemainderSequence},{} \\spadopFrom{\\spad{semiSubResultantGcdEuclidean2}}{PseudoRemainderSequence},{} etc. These procedures are coming from improvements of the subresultants algorithm."))
 (|next_sousResultant2|
  ((|#2| |#2| |#2| |#2| |#1|)
   "\\spad{next_sousResultant2(P,{} Q,{} Z,{} s)} returns the subresultant \\spad{S_{e-1}} where \\spad{P ~ S_d,{} Q = S_{d-1},{} Z = S_e,{} s = lc(S_d)}"))
 (|LazardQuotient2|
  ((|#2| |#2| |#1| |#1| (|NonNegativeInteger|))
   "\\spad{LazardQuotient2(F,{} x,{} y,{} n)} computes \\spad{(x^(n-1) * F) exquo y^(n-1)}"))
 (|LazardQuotient|
  ((|#1| |#1| |#1| (|NonNegativeInteger|))
   "\\spad{LazardQuotient(x,{} y,{} n)} computes \\spad{x^n exquo y^(n-1)}"))
 (|divide|
  (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|)
   "\\spad{divide(F,{} G)} computes quotient and rest of the exact euclidean division of \\spad{F} by \\spad{G}."))
 (|gcd|
  ((|#2| |#2| |#2|)
   "\\spad{gcd(P,{} Q)} returns the \\spad{gcd} of \\spad{P} and \\spad{Q}."))
 (|semiResultantReduitEuclidean|
  (((|Record| (|:| |coef2| |#2|) (|:| |resultantReduit| |#1|)) |#2| |#2|)
   "\\spad{semiResultantReduitEuclidean(P,{} Q)} returns the \"reduce resultant\" and carries out the equality \\spad{... P + coef2*Q = resultantReduit(P,{} Q)}."))
 (|resultantReduitEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|)
              (|:| |resultantReduit| |#1|))
    |#2| |#2|)
   "\\spad{resultantReduitEuclidean(P,{} Q)} returns the \"reduce resultant\" and carries out the equality \\spad{coef1*P + coef2*Q = resultantReduit(P,{} Q)}."))
 (|resultantReduit|
  ((|#1| |#2| |#2|)
   "\\spad{resultantReduit(P,{}Q)} returns the \"reduce resultant\" of \\spad{P} and \\spad{Q}."))
 (|schema|
  (((|List| (|NonNegativeInteger|)) |#2| |#2|)
   "\\spad{schema(P,{} Q)} returns the list of degrees of non zero subresultants of \\spad{P} and \\spad{Q}."))
 (|chainSubResultants|
  (((|List| |#2|) |#2| |#2|)
   "\\spad{chainSubResultants(P,{} Q)} computes the list of non zero subresultants of \\spad{P} and \\spad{Q}."))
 (|semiDiscriminantEuclidean|
  (((|Record| (|:| |coef2| |#2|) (|:| |discriminant| |#1|)) |#2|)
   "\\spad{discriminantEuclidean(P)} carries out the equality \\spad{... P + coef2 * D(P) = discriminant(P)}. Warning: \\spad{degree(P) >= degree(Q)}."))
 (|discriminantEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |discriminant| |#1|))
    |#2|)
   "\\spad{discriminantEuclidean(P)} carries out the equality \\spad{coef1 * P + coef2 * D(P) = discriminant(P)}."))
 (|discriminant|
  ((|#1| |#2|)
   "\\spad{discriminant(P)} returns the discriminant of \\spad{P}."))
 (|semiSubResultantGcdEuclidean1|
  (((|Record| (|:| |coef1| |#2|) (|:| |gcd| |#2|)) |#2| |#2|)
   "\\spad{semiSubResultantGcdEuclidean1(P,{} Q)} carries out the equality \\spad{coef1*P + ... Q = +/- S_i(P,{} Q)} where the degree (not the indice) of the subresultant \\spad{S_i(P,{} Q)} is as small as possible."))
 (|semiSubResultantGcdEuclidean2|
  (((|Record| (|:| |coef2| |#2|) (|:| |gcd| |#2|)) |#2| |#2|)
   "\\spad{semiSubResultantGcdEuclidean2(P,{} Q)} carries out the equality \\spad{... P + coef2*Q = +/- S_i(P,{} Q)} where the degree (not the indice) of the subresultant \\spad{S_i(P,{} Q)} is as small as possible. Warning: \\spad{degree(P) >= degree(Q)}."))
 (|subResultantGcdEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |gcd| |#2|)) |#2|
    |#2|)
   "\\spad{subResultantGcdEuclidean(P,{} Q)} carries out the equality \\spad{coef1*P + coef2*Q = +/- S_i(P,{} Q)} where the degree (not the indice) of the subresultant \\spad{S_i(P,{} Q)} is as small as possible."))
 (|subResultantGcd|
  ((|#2| |#2| |#2|)
   "\\spad{subResultantGcd(P,{} Q)} returns the \\spad{gcd} of two primitive polynomials \\spad{P} and \\spad{Q}."))
 (|semiLastSubResultantEuclidean|
  (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2|)
   "\\spad{semiLastSubResultantEuclidean(P,{} Q)} computes the last non zero subresultant \\spad{S} and carries out the equality \\spad{... P + coef2*Q = S}. Warning: \\spad{degree(P) >= degree(Q)}."))
 (|lastSubResultantEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|))
    |#2| |#2|)
   "\\spad{lastSubResultantEuclidean(P,{} Q)} computes the last non zero subresultant \\spad{S} and carries out the equality \\spad{coef1*P + coef2*Q = S}."))
 (|lastSubResultant|
  ((|#2| |#2| |#2|)
   "\\spad{lastSubResultant(P,{} Q)} computes the last non zero subresultant of \\spad{P} and \\spad{Q}"))
 (|semiDegreeSubResultantEuclidean|
  (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2|
    (|NonNegativeInteger|))
   "\\spad{semiDegreeSubResultantEuclidean(P,{} Q,{} d)} returns a subresultant \\spad{S_i} of degree \\spad{d} and carries out the equality \\spad{... P + coef2*Q = S_i}. Warning: \\spad{degree(P) >= degree(Q)}."))
 (|degreeSubResultantEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|))
    |#2| |#2| (|NonNegativeInteger|))
   "\\spad{degreeSubResultantEuclidean(P,{} Q,{} d)} returns a subresultant \\spad{S_i} of degree \\spad{d} and carries out the equality \\spad{coef1*P + coef2*Q = S_i}."))
 (|degreeSubResultant|
  ((|#2| |#2| |#2| (|NonNegativeInteger|))
   "\\spad{degreeSubResultant(P,{} Q,{} d)} computes a subresultant of degree \\spad{d}."))
 (|semiIndiceSubResultantEuclidean|
  (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2|
    (|NonNegativeInteger|))
   "\\spad{semiIndiceSubResultantEuclidean(P,{} Q,{} i)} returns the subresultant \\spad{S_i(P,{} Q)} and carries out the equality \\spad{... P + coef2*Q = S_i(P,{} Q)} Warning: \\spad{degree(P) >= degree(Q)}."))
 (|indiceSubResultantEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|))
    |#2| |#2| (|NonNegativeInteger|))
   "\\spad{indiceSubResultant(P,{} Q,{} i)} returns the subresultant \\spad{S_i(P,{} Q)} and carries out the equality \\spad{coef1*P + coef2*Q = S_i(P,{} Q)}"))
 (|indiceSubResultant|
  ((|#2| |#2| |#2| (|NonNegativeInteger|))
   "\\spad{indiceSubResultant(P,{} Q,{} i)} returns the subresultant of indice \\spad{i}"))
 (|semiResultantEuclidean1|
  (((|Record| (|:| |coef1| |#2|) (|:| |resultant| |#1|)) |#2| |#2|)
   "\\spad{semiResultantEuclidean1(P,{} Q)} carries out the equality \\spad{coef1.P + ... Q = resultant(P,{} Q)}."))
 (|semiResultantEuclidean2|
  (((|Record| (|:| |coef2| |#2|) (|:| |resultant| |#1|)) |#2| |#2|)
   "\\spad{semiResultantEuclidean2(P,{} Q)} carries out the equality \\spad{... P + coef2*Q = resultant(P,{} Q)}. Warning: \\spad{degree(P) >= degree(Q)}."))
 (|resultantEuclidean|
  (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |resultant| |#1|))
    |#2| |#2|)
   "\\spad{resultantEuclidean(P,{} Q)} carries out the equality \\spad{coef1*P + coef2*Q = resultant(P,{} Q)}"))
 (|resultant|
  ((|#1| |#2| |#2|)
   "\\spad{resultant(P,{} Q)} returns the resultant of \\spad{P} and \\spad{Q}"))) 
((|HasCategory| |#1| '(|GcdDomain|))) 
(|Partition|) 
((|constructor|
  (NIL
   "\\indented{1}{Partition is an OrderedCancellationAbelianMonoid which is used} as the basis for symmetric polynomial representation of the sums of powers in SymmetricPolynomial. Thus,{} \\spad{(5 2 2 1)} will represent \\spad{s5 * s2^2 * s1}."))
 (|coerce|
  (((|List| (|Integer|)) $)
   "\\spad{coerce(p)} coerces a partition into a list of integers"))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(p)} returns the conjugate partition of a partition \\spad{p}"))
 (|pdct|
  (((|Integer|) $)
   "\\spad{pdct(a1^n1 a2^n2 ...)} returns \\spad{n1! * a1^n1 * n2! * a2^n2 * ...}. This function is used in the package \\spadtype{CycleIndicators}."))
 (|powers|
  (((|List| (|List| (|Integer|))) (|List| (|Integer|)))
   "\\spad{powers(\\spad{li})} returns a list of 2-element lists. For each 2-element list,{} the first element is an entry of \\spad{li} and the second element is the multiplicity with which the first element occurs in \\spad{li}. There is a 2-element list for each value occurring in \\spad{l}."))
 (|partition|
  (($ (|List| (|Integer|)))
   "\\spad{partition(\\spad{li})} converts a list of integers \\spad{li} to a partition"))) 
NIL 
(|PowerSeriesCategory&| S |Coef| |Expon| |Var|) 
((|constructor|
  (NIL
   "\\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid."))
 (|complete|
  (($ $)
   "\\spad{complete(f)} causes all terms of \\spad{f} to be computed. Note: this results in an infinite loop if \\spad{f} has infinitely many terms."))
 (|pole?|
  (((|Boolean|) $)
   "\\spad{pole?(f)} determines if the power series \\spad{f} has a pole."))
 (|degree|
  ((|#3| $)
   "\\spad{degree(f)} returns the exponent of the lowest order term of \\spad{f}."))
 (|leadingCoefficient|
  ((|#2| $)
   "\\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \\spad{f}"))
 (|leadingMonomial|
  (($ $)
   "\\spad{leadingMonomial(f)} returns the monomial of \\spad{f} of lowest order."))) 
NIL 
(|PowerSeriesCategory| |Coef| |Expon| |Var|) 
((|constructor|
  (NIL
   "\\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid."))
 (|complete|
  (($ $)
   "\\spad{complete(f)} causes all terms of \\spad{f} to be computed. Note: this results in an infinite loop if \\spad{f} has infinitely many terms."))
 (|pole?|
  (((|Boolean|) $)
   "\\spad{pole?(f)} determines if the power series \\spad{f} has a pole."))
 (|degree|
  ((|#2| $)
   "\\spad{degree(f)} returns the exponent of the lowest order term of \\spad{f}."))
 (|leadingCoefficient|
  ((|#1| $)
   "\\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \\spad{f}"))
 (|leadingMonomial|
  (($ $)
   "\\spad{leadingMonomial(f)} returns the monomial of \\spad{f} of lowest order."))) 
NIL 
(|PlottableSpaceCurveCategory|) 
((|constructor|
  (NIL
   "PlottableSpaceCurveCategory is the category of curves in 3-space which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \\spad{x-},{} \\spad{y-},{} and \\spad{z}-coordinates of the points on the curve."))
 (|zRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{zRange(c)} returns the range of the \\spad{z}-coordinates of the points on the curve \\spad{c}."))
 (|yRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{yRange(c)} returns the range of the \\spad{y}-coordinates of the points on the curve \\spad{c}."))
 (|xRange|
  (((|Segment| (|DoubleFloat|)) $)
   "\\spad{xRange(c)} returns the range of the \\spad{x}-coordinates of the points on the curve \\spad{c}."))
 (|listBranches|
  (((|List| (|List| (|Point| (|DoubleFloat|)))) $)
   "\\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \\spad{c}."))) 
NIL 
(|PolynomialSetCategory&| S R E |VarSet| P) 
((|constructor|
  (NIL
   "A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \\spad{R} being an integral domain,{} a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \\spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions."))
 (|iexactQuo|
  ((|#2| |#2| |#2|)
   "\\spad{iexactQuo(x,{} y)} should be local but conditional"))
 (|triangular?|
  (((|Boolean|) $)
   "\\spad{triangular?(ps)} returns \\spad{true} iff \\spad{ps} is a triangular set,{} \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\spad{ps}."))
 (|rewriteIdealWithRemainder|
  (((|List| |#5|) (|List| |#5|) $)
   "\\spad{rewriteIdealWithRemainder(lp,{} cs)} returns \\spad{lr} such that every polynomial in \\spad{lr} is fully reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{cs} and \\spad{(lp,{} cs)} and \\spad{(lr,{} cs)} generate the same ideal in \\spad{(R)^(-1) P}."))
 (|rewriteIdealWithHeadRemainder|
  (((|List| |#5|) (|List| |#5|) $)
   "\\spad{rewriteIdealWithHeadRemainder(lp,{} cs)} returns \\spad{lr} such that the leading monomial of every polynomial in \\spad{lr} is reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{cs} and \\spad{(lp,{} cs)} and \\spad{(lr,{} cs)} generate the same ideal in \\spad{(R)^(-1) P}."))
 (|remainder|
  (((|Record| (|:| |rnum| |#2|) (|:| |polnum| |#5|) (|:| |den| |#2|)) |#5| $)
   "\\spad{remainder(a,{} ps)} returns \\spad{[c,{} b,{} r]} such that \\spad{b} is fully reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ps},{} \\spad{r*a - c*b} lies in the ideal generated by \\spad{ps}. Furthermore,{} if \\spad{R} is a \\spad{gcd}-domain,{} \\spad{b} is primitive."))
 (|headRemainder|
  (((|Record| (|:| |num| |#5|) (|:| |den| |#2|)) |#5| $)
   "\\spad{headRemainder(a,{} ps)} returns \\spad{[b,{} r]} such that the leading monomial of \\spad{b} is reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ps} and \\spad{r*a - b} lies in the ideal generated by \\spad{ps}."))
 (|roughUnitIdeal?|
  (((|Boolean|) $)
   "\\spad{roughUnitIdeal?(ps)} returns \\spad{true} iff \\spad{ps} contains some non null element lying in the base ring \\spad{R}."))
 (|roughEqualIdeals?|
  (((|Boolean|) $ $)
   "\\spad{roughEqualIdeals?(ps1,{} ps2)} returns \\spad{true} iff it can proved that \\spad{ps1} and \\spad{ps2} generate the same ideal in \\spad{(R)^(-1) P} without computing Groebner bases."))
 (|roughSubIdeal?|
  (((|Boolean|) $ $)
   "\\spad{roughSubIdeal?(ps1,{} ps2)} returns \\spad{true} iff it can proved that all polynomials in \\spad{ps1} lie in the ideal generated by \\spad{ps2} in \\spad{(R)^(-1) P} without computing Groebner bases."))
 (|roughBase?|
  (((|Boolean|) $)
   "\\spad{roughBase?(ps)} returns \\spad{true} iff for every pair \\spad{{p,{} q}} of polynomials in \\spad{ps} their leading monomials are relatively prime."))
 (|trivialIdeal?|
  (((|Boolean|) $)
   "\\spad{trivialIdeal?(ps)} returns \\spad{true} iff \\spad{ps} does not contain non-zero elements."))
 (|sort|
  (((|Record| (|:| |under| $) (|:| |floor| $) (|:| |upper| $)) $ |#4|)
   "\\spad{sort(v,{} ps)} returns \\spad{us,{} vs,{} ws} such that \\spad{us} is \\spad{collectUnder(ps,{} v)},{} \\spad{vs} is \\spad{collect(ps,{} v)} and \\spad{ws} is \\spad{collectUpper(ps,{} v)}."))
 (|collectUpper|
  (($ $ |#4|)
   "\\spad{collectUpper(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with main variable greater than \\spad{v}."))
 (|collect|
  (($ $ |#4|)
   "\\spad{collect(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with \\spad{v} as main variable."))
 (|collectUnder|
  (($ $ |#4|)
   "\\spad{collectUnder(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with main variable less than \\spad{v}."))
 (|mainVariable?|
  (((|Boolean|) |#4| $)
   "\\spad{mainVariable?(v,{} ps)} returns \\spad{true} iff \\spad{v} is the main variable of some polynomial in \\spad{ps}."))
 (|mainVariables|
  (((|List| |#4|) $)
   "\\spad{mainVariables(ps)} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \\spad{ps}."))
 (|variables|
  (((|List| |#4|) $)
   "\\spad{variables(ps)} returns the decreasingly sorted list of the variables which are variables of some polynomial in \\spad{ps}."))
 (|mvar|
  ((|#4| $)
   "\\spad{mvar(ps)} returns the main variable of the non constant polynomial with the greatest main variable,{} if any,{} else an error is returned."))) 
((|HasCategory| |#2| '(|IntegralDomain|))) 
(|PolynomialSetCategory| R E |VarSet| P) 
((|constructor|
  (NIL
   "A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \\spad{R} being an integral domain,{} a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \\spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions."))
 (|iexactQuo|
  ((|#1| |#1| |#1|)
   "\\spad{iexactQuo(x,{} y)} should be local but conditional"))
 (|triangular?|
  (((|Boolean|) $)
   "\\spad{triangular?(ps)} returns \\spad{true} iff \\spad{ps} is a triangular set,{} \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\spad{ps}."))
 (|rewriteIdealWithRemainder|
  (((|List| |#4|) (|List| |#4|) $)
   "\\spad{rewriteIdealWithRemainder(lp,{} cs)} returns \\spad{lr} such that every polynomial in \\spad{lr} is fully reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{cs} and \\spad{(lp,{} cs)} and \\spad{(lr,{} cs)} generate the same ideal in \\spad{(R)^(-1) P}."))
 (|rewriteIdealWithHeadRemainder|
  (((|List| |#4|) (|List| |#4|) $)
   "\\spad{rewriteIdealWithHeadRemainder(lp,{} cs)} returns \\spad{lr} such that the leading monomial of every polynomial in \\spad{lr} is reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{cs} and \\spad{(lp,{} cs)} and \\spad{(lr,{} cs)} generate the same ideal in \\spad{(R)^(-1) P}."))
 (|remainder|
  (((|Record| (|:| |rnum| |#1|) (|:| |polnum| |#4|) (|:| |den| |#1|)) |#4| $)
   "\\spad{remainder(a,{} ps)} returns \\spad{[c,{} b,{} r]} such that \\spad{b} is fully reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ps},{} \\spad{r*a - c*b} lies in the ideal generated by \\spad{ps}. Furthermore,{} if \\spad{R} is a \\spad{gcd}-domain,{} \\spad{b} is primitive."))
 (|headRemainder|
  (((|Record| (|:| |num| |#4|) (|:| |den| |#1|)) |#4| $)
   "\\spad{headRemainder(a,{} ps)} returns \\spad{[b,{} r]} such that the leading monomial of \\spad{b} is reduced in the sense of Groebner bases \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ps} and \\spad{r*a - b} lies in the ideal generated by \\spad{ps}."))
 (|roughUnitIdeal?|
  (((|Boolean|) $)
   "\\spad{roughUnitIdeal?(ps)} returns \\spad{true} iff \\spad{ps} contains some non null element lying in the base ring \\spad{R}."))
 (|roughEqualIdeals?|
  (((|Boolean|) $ $)
   "\\spad{roughEqualIdeals?(ps1,{} ps2)} returns \\spad{true} iff it can proved that \\spad{ps1} and \\spad{ps2} generate the same ideal in \\spad{(R)^(-1) P} without computing Groebner bases."))
 (|roughSubIdeal?|
  (((|Boolean|) $ $)
   "\\spad{roughSubIdeal?(ps1,{} ps2)} returns \\spad{true} iff it can proved that all polynomials in \\spad{ps1} lie in the ideal generated by \\spad{ps2} in \\spad{(R)^(-1) P} without computing Groebner bases."))
 (|roughBase?|
  (((|Boolean|) $)
   "\\spad{roughBase?(ps)} returns \\spad{true} iff for every pair \\spad{{p,{} q}} of polynomials in \\spad{ps} their leading monomials are relatively prime."))
 (|trivialIdeal?|
  (((|Boolean|) $)
   "\\spad{trivialIdeal?(ps)} returns \\spad{true} iff \\spad{ps} does not contain non-zero elements."))
 (|sort|
  (((|Record| (|:| |under| $) (|:| |floor| $) (|:| |upper| $)) $ |#3|)
   "\\spad{sort(v,{} ps)} returns \\spad{us,{} vs,{} ws} such that \\spad{us} is \\spad{collectUnder(ps,{} v)},{} \\spad{vs} is \\spad{collect(ps,{} v)} and \\spad{ws} is \\spad{collectUpper(ps,{} v)}."))
 (|collectUpper|
  (($ $ |#3|)
   "\\spad{collectUpper(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with main variable greater than \\spad{v}."))
 (|collect|
  (($ $ |#3|)
   "\\spad{collect(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with \\spad{v} as main variable."))
 (|collectUnder|
  (($ $ |#3|)
   "\\spad{collectUnder(ps,{} v)} returns the set consisting of the polynomials of \\spad{ps} with main variable less than \\spad{v}."))
 (|mainVariable?|
  (((|Boolean|) |#3| $)
   "\\spad{mainVariable?(v,{} ps)} returns \\spad{true} iff \\spad{v} is the main variable of some polynomial in \\spad{ps}."))
 (|mainVariables|
  (((|List| |#3|) $)
   "\\spad{mainVariables(ps)} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \\spad{ps}."))
 (|variables|
  (((|List| |#3|) $)
   "\\spad{variables(ps)} returns the decreasingly sorted list of the variables which are variables of some polynomial in \\spad{ps}."))
 (|mvar|
  ((|#3| $)
   "\\spad{mvar(ps)} returns the main variable of the non constant polynomial with the greatest main variable,{} if any,{} else an error is returned."))) 
NIL 
(|PolynomialSetUtilitiesPackage| R E V P) 
((|constructor|
  (NIL
   "This package provides modest routines for polynomial system solving. The aim of many of the operations of this package is to remove certain factors in some polynomials in order to avoid unnecessary computations in algorithms involving splitting techniques by partial factorization."))
 (|removeIrreducibleRedundantFactors|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeIrreducibleRedundantFactors(lp,{} lq)} returns the same as \\spad{irreducibleFactors(concat(lp,{} lq))} assuming that \\spad{irreducibleFactors(lp)} returns \\spad{lp} up to replacing some polynomial \\spad{pj} in \\spad{lp} by some polynomial \\spad{qj} associated to \\spad{pj}."))
 (|lazyIrreducibleFactors|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{lazyIrreducibleFactors(lp)} returns \\spad{lf} such that if \\spad{lp = [p1,{} ...,{} pn]} and \\spad{lf = [f1,{} ...,{} fm]} then \\spad{p1*p2*...*pn=0} means \\spad{f1*f2*...*fm=0},{} and the \\spad{\\spad{fi}} are irreducible over \\spad{R} and are pairwise distinct. The algorithm tries to avoid factorization into irreducible factors as far as possible and makes previously use of \\spad{gcd} techniques over \\spad{R}."))
 (|irreducibleFactors|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{irreducibleFactors(lp)} returns \\spad{lf} such that if \\spad{lp = [p1,{} ...,{} pn]} and \\spad{lf = [f1,{} ...,{} fm]} then \\spad{p1*p2*...*pn=0} means \\spad{f1*f2*...*fm=0},{} and the \\spad{\\spad{fi}} are irreducible over \\spad{R} and are pairwise distinct."))
 (|removeRedundantFactorsInPols|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeRedundantFactorsInPols(lp,{} lf)} returns \\spad{newlp} where \\spad{newlp} is obtained from \\spad{lp} by removing in every polynomial \\spad{p} of \\spad{lp} any non trivial factor of any polynomial \\spad{f} in \\spad{lf}. Moreover,{} squares over \\spad{R} are first removed in every polynomial \\spad{lp}."))
 (|removeRedundantFactorsInContents|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeRedundantFactorsInContents(lp,{} lf)} returns \\spad{newlp} where \\spad{newlp} is obtained from \\spad{lp} by removing in the content of every polynomial of \\spad{lp} any non trivial factor of any polynomial \\spad{f} in \\spad{lf}. Moreover,{} squares over \\spad{R} are first removed in the content of every polynomial of \\spad{lp}."))
 (|removeRoughlyRedundantFactorsInContents|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeRoughlyRedundantFactorsInContents(lp,{} lf)} returns \\spad{newlp}where \\spad{newlp} is obtained from \\spad{lp} by removing in the content of every polynomial of \\spad{lp} any occurence of a polynomial \\spad{f} in \\spad{lf}. Moreover,{} squares over \\spad{R} are first removed in the content of every polynomial of \\spad{lp}."))
 (|univariatePolynomialsGcds|
  (((|List| |#4|) (|List| |#4|) (|Boolean|))
   "\\spad{univariatePolynomialsGcds(lp,{} opt)} returns the same as \\spad{univariatePolynomialsGcds(lp)} if \\spad{opt} is \\spad{false} and if the previous operation does not return any non null and constant polynomial,{} else return \\spad{[1]}.")
  (((|List| |#4|) (|List| |#4|))
   "\\spad{univariatePolynomialsGcds(lp)} returns \\spad{lg} where \\spad{lg} is a list of the gcds of every pair in \\spad{lp} of univariate polynomials in the same main variable."))
 (|squareFreeFactors|
  (((|List| |#4|) |#4|)
   "\\spad{squareFreeFactors(p)} returns the square-free factors of \\spad{p} over \\spad{R}"))
 (|rewriteIdealWithQuasiMonicGenerators|
  (((|List| |#4|) (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)
    (|Mapping| |#4| |#4| |#4|))
   "\\spad{rewriteIdealWithQuasiMonicGenerators(lp,{} redOp?,{} redOp)} returns \\spad{lq} where \\spad{lq} and \\spad{lp} generate the same ideal in \\spad{R^(-1) P} and \\spad{lq} has rank not higher than the one of \\spad{lp}. Moreover,{} \\spad{lq} is computed by reducing \\spad{lp} \\spad{w}.\\spad{r}.\\spad{t}. some basic set of the ideal generated by the quasi-monic polynomials in \\spad{lp}."))
 (|rewriteSetByReducingWithParticularGenerators|
  (((|List| |#4|) (|List| |#4|) (|Mapping| (|Boolean|) |#4|)
    (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|))
   "\\spad{rewriteSetByReducingWithParticularGenerators(lp,{} pred?,{} redOp?,{} redOp)} returns \\spad{lq} where \\spad{lq} is computed by the following algorithm. Chose a basic set \\spad{w}.\\spad{r}.\\spad{t}. the reduction-test \\spad{redOp?} among the polynomials satisfying property \\spad{pred?},{} if it is empty then leave,{} else reduce the other polynomials by this basic set \\spad{w}.\\spad{r}.\\spad{t}. the reduction-operation \\spad{redOp}. Repeat while another basic set with smaller rank can be computed. See code. If \\spad{pred?} is \\spad{quasiMonic?} the ideal is unchanged."))
 (|crushedSet|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{crushedSet(lp)} returns \\spad{lq} such that \\spad{lp} and and \\spad{lq} generate the same ideal and no rough basic sets reduce (in the sense of Groebner bases) the other polynomials in \\spad{lq}."))
 (|roughBasicSet|
  (((|Union|
     (|Record| (|:| |bas| (|GeneralTriangularSet| |#1| |#2| |#3| |#4|))
               (|:| |top| (|List| |#4|)))
     "failed")
    (|List| |#4|))
   "\\spad{roughBasicSet(lp)} returns the smallest (with Ritt-Wu ordering) triangular set contained in \\spad{lp}."))
 (|interReduce|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{interReduce(lp)} returns \\spad{lq} such that \\spad{lp} and \\spad{lq} generate the same ideal and no polynomial in \\spad{lq} is reducible by the others in the sense of Groebner bases. Since no assumptions are required the result may depend on the ordering the reductions are performed."))
 (|removeRoughlyRedundantFactorsInPol|
  ((|#4| |#4| (|List| |#4|))
   "\\spad{removeRoughlyRedundantFactorsInPol(p,{} lf)} returns the same as removeRoughlyRedundantFactorsInPols([\\spad{p}],{} \\spad{lf},{} \\spad{true})"))
 (|removeRoughlyRedundantFactorsInPols|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|) (|Boolean|))
   "\\spad{removeRoughlyRedundantFactorsInPols(lp,{} lf,{} opt)} returns the same as \\spad{removeRoughlyRedundantFactorsInPols(lp,{} lf)} if \\spad{opt} is \\spad{false} and if the previous operation does not return any non null and constant polynomial,{} else return \\spad{[1]}.")
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeRoughlyRedundantFactorsInPols(lp,{} lf)} returns \\spad{newlp}where \\spad{newlp} is obtained from \\spad{lp} by removing in every polynomial \\spad{p} of \\spad{lp} any occurrence of a polynomial \\spad{f} in \\spad{lf}. This may involve a lot of exact-quotients computations."))
 (|bivariatePolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| |#4|))
   "\\spad{bivariatePolynomials(lp)} returns \\spad{bps,{} nbps} where \\spad{bps} is a list of the bivariate polynomials,{} and \\spad{nbps} are the other ones."))
 (|bivariate?|
  (((|Boolean|) |#4|)
   "\\spad{bivariate?(p)} returns \\spad{true} iff \\spad{p} involves two and only two variables."))
 (|linearPolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| |#4|))
   "\\spad{linearPolynomials(lp)} returns \\spad{lps,{} nlps} where \\spad{lps} is a list of the linear polynomials in \\spad{lp},{} and \\spad{nlps} are the other ones."))
 (|linear?|
  (((|Boolean|) |#4|)
   "\\spad{linear?(p)} returns \\spad{true} iff \\spad{p} does not lie in the base ring \\spad{R} and has main degree \\spad{1}."))
 (|univariatePolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| |#4|))
   "\\spad{univariatePolynomials(lp)} returns \\spad{ups,{} nups} where \\spad{ups} is a list of the univariate polynomials,{} and \\spad{nups} are the other ones."))
 (|univariate?|
  (((|Boolean|) |#4|)
   "\\spad{univariate?(p)} returns \\spad{true} iff \\spad{p} involves one and only one variable."))
 (|quasiMonicPolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| |#4|))
   "\\spad{quasiMonicPolynomials(lp)} returns \\spad{qmps,{} nqmps} where \\spad{qmps} is a list of the quasi-monic polynomials in \\spad{lp} and \\spad{nqmps} are the other ones."))
 (|selectAndPolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| (|Mapping| (|Boolean|) |#4|)) (|List| |#4|))
   "\\spad{selectAndPolynomials(lpred?,{} ps)} returns \\spad{gps,{} bps} where \\spad{gps} is a list of the polynomial \\spad{p} in \\spad{ps} such that \\spad{pred?(p)} holds for every \\spad{pred?} in \\spad{lpred?} and \\spad{bps} are the other ones."))
 (|selectOrPolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|List| (|Mapping| (|Boolean|) |#4|)) (|List| |#4|))
   "\\spad{selectOrPolynomials(lpred?,{} ps)} returns \\spad{gps,{} bps} where \\spad{gps} is a list of the polynomial \\spad{p} in \\spad{ps} such that \\spad{pred?(p)} holds for some \\spad{pred?} in \\spad{lpred?} and \\spad{bps} are the other ones."))
 (|selectPolynomials|
  (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|)))
    (|Mapping| (|Boolean|) |#4|) (|List| |#4|))
   "\\spad{selectPolynomials(pred?,{} ps)} returns \\spad{gps,{} bps} where \\spad{gps} is a list of the polynomial \\spad{p} in \\spad{ps} such that \\spad{pred?(p)} holds and \\spad{bps} are the other ones."))
 (|probablyZeroDim?|
  (((|Boolean|) (|List| |#4|))
   "\\spad{probablyZeroDim?(lp)} returns \\spad{true} iff the number of polynomials in \\spad{lp} is not smaller than the number of variables occurring in these polynomials."))
 (|possiblyNewVariety?|
  (((|Boolean|) (|List| |#4|) (|List| (|List| |#4|)))
   "\\spad{possiblyNewVariety?(newlp,{} llp)} returns \\spad{true} iff for every \\spad{lp} in \\spad{llp} certainlySubVariety?(\\spad{newlp},{} \\spad{lp}) does not hold."))
 (|certainlySubVariety?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{certainlySubVariety?(newlp,{} lp)} returns \\spad{true} iff for every \\spad{p} in \\spad{lp} the remainder of \\spad{p} by \\spad{newlp} using the division algorithm of Groebner techniques is zero."))
 (|unprotectedRemoveRedundantFactors|
  (((|List| |#4|) |#4| |#4|)
   "\\spad{unprotectedRemoveRedundantFactors(p,{} q)} returns the same as \\spad{removeRedundantFactors(p,{} q)} but does assume that neither \\spad{p} nor \\spad{q} lie in the base ring \\spad{R} and assumes that \\spad{infRittWu?(p,{} q)} holds. Moreover,{} if \\spad{R} is \\spad{gcd}-domain,{} then \\spad{p} and \\spad{q} are assumed to be square free."))
 (|removeSquaresIfCan|
  (((|List| |#4|) (|List| |#4|))
   "\\spad{removeSquaresIfCan(lp)} returns \\spad{removeDuplicates [squareFreePart(p)\\$P for p in lp]} if \\spad{R} is \\spad{gcd}-domain else returns \\spad{lp}."))
 (|removeRedundantFactors|
  (((|List| |#4|) (|List| |#4|) (|List| |#4|)
    (|Mapping| (|List| |#4|) (|List| |#4|)))
   "\\spad{removeRedundantFactors(lp,{} lq,{} remOp)} returns the same as \\spad{concat(remOp(removeRoughlyRedundantFactorsInPols(lp,{} lq)),{} lq)} assuming that \\spad{remOp(lq)} returns \\spad{lq} up to similarity.")
  (((|List| |#4|) (|List| |#4|) (|List| |#4|))
   "\\spad{removeRedundantFactors(lp,{} lq)} returns the same as \\spad{removeRedundantFactors(concat(lp,{} lq))} assuming that \\spad{removeRedundantFactors(lp)} returns \\spad{lp} up to replacing some polynomial \\spad{pj} in \\spad{lp} by some polynomial \\spad{qj} associated to \\spad{pj}.")
  (((|List| |#4|) (|List| |#4|) |#4|)
   "\\spad{removeRedundantFactors(lp,{} q)} returns the same as \\spad{removeRedundantFactors(cons(q,{} lp))} assuming that \\spad{removeRedundantFactors(lp)} returns \\spad{lp} up to replacing some polynomial \\spad{pj} in \\spad{lp} by some some polynomial \\spad{qj} associated to \\spad{pj}.")
  (((|List| |#4|) |#4| |#4|)
   "\\spad{removeRedundantFactors(p,{} q)} returns the same as \\spad{removeRedundantFactors([p,{} q])}")
  (((|List| |#4|) (|List| |#4|))
   "\\spad{removeRedundantFactors(lp)} returns \\spad{lq} such that if \\spad{lp = [p1,{} ...,{} pn]} and \\spad{lq = [q1,{} ...,{} qm]} then the product \\spad{p1*p2*...*pn} vanishes iff the product \\spad{q1*q2*...*qm} vanishes,{} and the product of degrees of the \\spad{\\spad{qi}} is not greater than the one of the \\spad{pj},{} and no polynomial in \\spad{lq} divides another polynomial in \\spad{lq}. In particular,{} polynomials lying in the base ring \\spad{R} are removed. Moreover,{} \\spad{lq} is sorted \\spad{w}.\\spad{r}.\\spad{t} \\spad{infRittWu?}. Furthermore,{} if \\spad{R} is \\spad{gcd}-domain,{} the polynomials in \\spad{lq} are pairwise without common non trivial factor."))) 
((AND (|HasCategory| |#1| '(|CharacteristicZero|))
      (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (|HasCategory| |#1| '(|GcdDomain|))) 
(|PseudoLinearNormalForm| K) 
((|constructor|
  (NIL
   "PseudoLinearNormalForm provides a function for computing a block-companion form for pseudo-linear operators."))
 (|companionBlocks|
  (((|List|
     (|Record| (|:| C (|Matrix| |#1|)) (|:| |lg| (|List| (|Vector| |#1|)))))
    (|Matrix| |#1|) (|List| (|Vector| |#1|)))
   "\\spad{companionBlocks(m,{} lv)} returns \\spad{[[C_1,{} lg_1],{} ...,{} [C_k,{} lg_k]]} such that each \\spad{C_i} is a companion block and \\spad{m = diagonal(C_1,{} ...,{} C_k)}."))
 (|changeBase|
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Automorphism| |#1|)
    (|Mapping| |#1| |#1|))
   "\\spad{changeBase(M,{} A,{} sig,{} der)}: computes the new matrix of a pseudo-linear transform given by the matrix \\spad{M} under the change of base A"))
 (|normalForm|
  (((|Record| (|:| R (|Matrix| |#1|)) (|:| A (|Matrix| |#1|))
              (|:| |Ainv| (|Matrix| |#1|)))
    (|Matrix| |#1|) (|Automorphism| |#1|) (|Mapping| |#1| |#1|))
   "\\spad{normalForm(M,{} sig,{} der)} returns \\spad{[R,{} A,{} A^{-1}]} such that the pseudo-linear operator whose matrix in the basis \\spad{y} is \\spad{M} had matrix \\spad{R} in the basis \\spad{z = A y}. \\spad{der} is a \\spad{sig}-derivation."))) 
NIL 
(|PolynomialSquareFree| |VarSet| E RC P) 
((|constructor|
  (NIL
   "This package computes square-free decomposition of multivariate polynomials over a coefficient ring which is an arbitrary \\spad{gcd} domain. The requirement on the coefficient domain guarantees that the \\spadfun{content} can be removed so that factors will be primitive as well as square-free. Over an infinite ring of finite characteristic,{} it may not be possible to guarantee that the factors are square-free."))
 (|squareFree|
  (((|Factored| |#4|) |#4|)
   "\\spad{squareFree(p)} returns the square-free factorization of the polynomial \\spad{p}. Each factor has no repeated roots,{} and the factors are pairwise relatively prime."))) 
NIL 
(|PointCategory| R) 
((|constructor|
  (NIL
   "PointCategory is the category of points in space which may be plotted via the graphics facilities. Functions are provided for defining points and handling elements of points."))
 (|extend| (($ $ (|List| |#1|)) "\\spad{extend(x,{} l,{} r)} \\undocumented"))
 (|cross|
  (($ $ $)
   "\\spad{cross(p,{} q)} computes the cross product of the two points \\spad{p} and \\spad{q}. Error if the \\spad{p} and \\spad{q} are not 3 dimensional"))
 (|convert|
  (($ (|List| |#1|))
   "\\spad{convert(l)} takes a list of elements,{} \\spad{l},{} from the domain Ring and returns the form of point category."))
 (|dimension|
  (((|PositiveInteger|) $)
   "\\spad{dimension(s)} returns the dimension of the point category \\spad{s}."))
 (|point|
  (($ (|List| |#1|))
   "\\spad{point(l)} returns a point category defined by a list \\spad{l} of elements from the domain \\spad{R}."))) 
NIL 
(|PointFunctions2| R1 R2) 
((|constructor| (NIL "This package \\undocumented"))
 (|map|
  (((|Point| |#2|) (|Mapping| |#2| |#1|) (|Point| |#1|))
   "\\spad{map(f,{} p)} \\undocumented"))) 
NIL 
(|PointPackage| R) 
((|constructor| (NIL "This package \\undocumented"))
 (|shade|
  ((|#1| (|Point| |#1|))
   "\\spad{shade(pt)} returns the fourth element of the two dimensional point,{} \\spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} shade to express a fourth dimension."))
 (|hue|
  ((|#1| (|Point| |#1|))
   "\\spad{hue(pt)} returns the third element of the two dimensional point,{} \\spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} hue to express a third dimension."))
 (|color|
  ((|#1| (|Point| |#1|))
   "\\spad{color(pt)} returns the fourth element of the point,{} \\spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} color to express a fourth dimension."))
 (|phiCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{phiCoord(pt)} returns the third element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical coordinate system."))
 (|thetaCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{thetaCoord(pt)} returns the second element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system."))
 (|rCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{rCoord(pt)} returns the first element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system."))
 (|zCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{zCoord(pt)} returns the third element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian or a cylindrical coordinate system."))
 (|yCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{yCoord(pt)} returns the second element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system."))
 (|xCoord|
  ((|#1| (|Point| |#1|))
   "\\spad{xCoord(pt)} returns the first element of the point,{} \\spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system."))) 
NIL 
(|PartialTranscendentalFunctions| K) 
((|constructor|
  (NIL
   "This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory."))
 (|acschIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acschIfCan(z)} returns acsch(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|asechIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{asechIfCan(z)} returns asech(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|acothIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acothIfCan(z)} returns acoth(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|atanhIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{atanhIfCan(z)} returns atanh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|acoshIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acoshIfCan(z)} returns acosh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|asinhIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{asinhIfCan(z)} returns asinh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|cschIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{cschIfCan(z)} returns csch(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|sechIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{sechIfCan(z)} returns sech(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|cothIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{cothIfCan(z)} returns coth(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|tanhIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{tanhIfCan(z)} returns tanh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|coshIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{coshIfCan(z)} returns cosh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|sinhIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{sinhIfCan(z)} returns sinh(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|acscIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acscIfCan(z)} returns acsc(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|asecIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{asecIfCan(z)} returns asec(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|acotIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acotIfCan(z)} returns acot(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|atanIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{atanIfCan(z)} returns atan(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|acosIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{acosIfCan(z)} returns acos(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|asinIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{asinIfCan(z)} returns asin(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|cscIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{cscIfCan(z)} returns \\spad{csc}(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|secIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{secIfCan(z)} returns sec(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|cotIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{cotIfCan(z)} returns cot(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|tanIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{tanIfCan(z)} returns tan(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|cosIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{cosIfCan(z)} returns cos(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|sinIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{sinIfCan(z)} returns sin(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|logIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{logIfCan(z)} returns log(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|expIfCan|
  (((|Union| |#1| "failed") |#1|)
   "\\spad{expIfCan(z)} returns exp(\\spad{z}) if possible,{} and \"failed\" otherwise."))
 (|nthRootIfCan|
  (((|Union| |#1| "failed") |#1| (|NonNegativeInteger|))
   "\\spad{nthRootIfCan(z,{} n)} returns the \\spad{n}th root of \\spad{z} if possible,{} and \"failed\" otherwise."))) 
NIL 
(|PushVariables| R E OV PPR) 
((|constructor| (NIL "This package \\undocumented{}"))
 (|map|
  ((|#4| (|Mapping| |#4| (|Polynomial| |#1|)) |#4|)
   "\\spad{map(f,{} p)} \\undocumented{}"))
 (|pushup|
  ((|#4| |#4| (|List| |#3|)) "\\spad{pushup(p,{} lv)} \\undocumented{}"))
 (|pushdown|
  ((|#4| |#4| (|List| |#3|)) "\\spad{pushdown(p,{} lv)} \\undocumented{}"))
 (|variable|
  (((|Union| $ "failed") (|Symbol|))
   "\\spad{variable(s)} makes an element from symbol \\spad{s} or fails"))
 (|convert|
  (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
(|PAdicWildFunctionFieldIntegralBasis| K R UP F) 
((|constructor|
  (NIL
   "In this package \\spad{K} is a finite field,{} \\spad{R} is a ring of univariate polynomials over \\spad{K},{} and \\spad{F} is a monogenic algebra over \\spad{R}. We require that \\spad{F} is monogenic,{} \\spadignore{i.e.} that \\spad{F = K[x,{} y]/(f(x,{} y))},{} because the integral basis algorithm used will factor the polynomial \\spad{f(x,{} y)}. The package provides a function to compute the integral closure of \\spad{R} in the quotient field of \\spad{F} as well as a function to compute a \"local integral basis\" at a specific prime."))
 (|reducedDiscriminant|
  ((|#2| |#3|) "\\spad{reducedDiscriminant(up)} \\undocumented"))
 (|localIntegralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|)))
    |#2|)
   "\\spad{integralBasis(p)} returns a record \\spad{[basis,{} basisDen,{} basisInv] } containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of the framed algebra \\spad{F}. \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If 'basis' is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the local integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if 'basisInv' is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|integralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|))))
   "\\spad{integralBasis()} returns a record \\spad{[basis,{} basisDen,{} basisInv] } containing information regarding the integral closure of \\spad{R} in the quotient field of the framed algebra \\spad{F}. \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If 'basis' is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if 'basisInv' is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))) 
NIL 
(|QuasiAlgebraicSet| R |Var| |Expon| |Dpoly|) 
((|constructor|
  (NIL
   "\\spadtype{QuasiAlgebraicSet} constructs a domain representing quasi-algebraic sets,{} which is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the common zeros of a polynomial \\spad{f} (the defining polynomial for the inequation). This domain provides simplification of a user-given representation using groebner basis computations. There are two simplification routines: the first function \\spadfun{idealSimplify} uses groebner basis of ideals alone,{} while the second,{} \\spadfun{simplify} uses both groebner basis and factorization. The resulting defining equations \\spad{L} always form a groebner basis,{} and the resulting defining inequation \\spad{f} is always reduced. The function \\spadfun{simplify} may be applied several times if desired. A third simplification routine \\spadfun{radicalSimplify} is provided in \\spadtype{QuasiAlgebraicSet2} for comparison study only,{} as it is inefficient compared to the other two,{} as well as is restricted to only certain coefficient domains. For detail analysis and a comparison of the three methods,{} please consult the reference cited. \\blankline A polynomial function \\spad{q} defined on the quasi-algebraic set is equivalent to its reduced form with respect to \\spad{L}. While this may be obtained using the usual normal form algorithm,{} there is no canonical form for \\spad{q}. \\blankline The ordering in groebner basis computation is determined by the data type of the input polynomials. If it is possible we suggest to use refinements of total degree orderings."))
 (|simplify|
  (($ $)
   "\\spad{simplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using a heuristic algorithm based on factoring."))
 (|idealSimplify|
  (($ $)
   "\\spad{idealSimplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using Buchberger\\spad{'s} algorithm."))
 (|definingInequation|
  ((|#4| $)
   "\\spad{definingInequation(s)} returns a single defining polynomial for the inequation,{} that is,{} the Zariski open part of \\spad{s}."))
 (|definingEquations|
  (((|List| |#4|) $)
   "\\spad{definingEquations(s)} returns a list of defining polynomials for equations,{} that is,{} for the Zariski closed part of \\spad{s}."))
 (|empty?|
  (((|Boolean|) $)
   "\\spad{empty?(s)} returns \\spad{true} if the quasialgebraic set \\spad{s} has no points,{} and \\spad{false} otherwise."))
 (|setStatus|
  (($ $ (|Union| (|Boolean|) #1="failed"))
   "\\spad{setStatus(s,{} t)} returns the same representation for \\spad{s},{} but asserts the following: if \\spad{t} is \\spad{true},{} then \\spad{s} is empty,{} if \\spad{t} is \\spad{false},{} then \\spad{s} is non-empty,{} and if \\spad{t} = \"failed\",{} then no assertion is made (that is,{} \"don\\spad{'t} know\"). Note: for internal use only,{} with care."))
 (|status|
  (((|Union| (|Boolean|) #1#) $)
   "\\spad{status(s)} returns \\spad{true} if the quasi-algebraic set is empty,{} \\spad{false} if it is not,{} and \"failed\" if not yet known"))
 (|quasiAlgebraicSet|
  (($ (|List| |#4|) |#4|)
   "\\spad{quasiAlgebraicSet(pl,{} q)} returns the quasi-algebraic set with defining equations \\spad{p} = 0 for \\spad{p} belonging to the list \\spad{pl},{} and defining inequation \\spad{q} \\spad{~=} 0."))
 (|empty| (($) "\\spad{empty()} returns the empty quasi-algebraic set"))) 
((AND (|HasCategory| |#1| '(|CharacteristicZero|))
      (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))) 
(|QuasiAlgebraicSet2| |vl|) 
((|constructor|
  (NIL
   "\\spadtype{QuasiAlgebraicSet2} adds a function \\spadfun{radicalSimplify} which uses \\spadtype{IdealDecompositionPackage} to simplify the representation of a quasi-algebraic set. A quasi-algebraic set is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the common zeros of a polynomial \\spad{f} (the defining polynomial for the inequation). Quasi-algebraic sets are implemented in the domain \\spadtype{QuasiAlgebraicSet},{} where two simplification routines are provided: \\spadfun{idealSimplify} and \\spadfun{simplify}. The function \\spadfun{radicalSimplify} is added for comparison study only. Because the domain \\spadtype{IdealDecompositionPackage} provides facilities for computing with radical ideals,{} it is necessary to restrict the ground ring to the domain \\spadtype{Fraction Integer},{} and the polynomial ring to be of type \\spadtype{DistributedMultivariatePolynomial}. The routine \\spadfun{radicalSimplify} uses these to compute groebner basis of radical ideals and is inefficient and restricted when compared to the two in \\spadtype{QuasiAlgebraicSet}."))
 (|radicalSimplify|
  (((|QuasiAlgebraicSet| (|Fraction| (|Integer|)) (|OrderedVariableList| |#1|)
                         (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                         (|DistributedMultivariatePolynomial| |#1|
                                                              (|Fraction|
                                                               (|Integer|))))
    (|QuasiAlgebraicSet| (|Fraction| (|Integer|)) (|OrderedVariableList| |#1|)
                         (|DirectProduct| (|#| |#1|) (|NonNegativeInteger|))
                         (|DistributedMultivariatePolynomial| |#1|
                                                              (|Fraction|
                                                               (|Integer|)))))
   "\\spad{radicalSimplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using using groebner basis of radical ideals"))) 
NIL 
(|QuasiComponentPackage| R E V P TS) 
((|constructor|
  (NIL
   "A package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets. \\newline"))
 (|branchIfCan|
  (((|Union|
     (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|)
               (|:| |ineq| (|List| |#4|)))
     "failed")
    (|List| |#4|) |#5| (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|)
    (|Boolean|) (|Boolean|))
   "\\spad{branchIfCan(leq,{} ts,{} lineq,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for developement."))
 (|prepareDecompose|
  (((|List|
     (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|)
               (|:| |ineq| (|List| |#4|))))
    (|List| |#4|) (|List| |#5|) (|Boolean|) (|Boolean|))
   "\\spad{prepareDecompose(lp,{} lts,{} b1,{} b2)} is an internal subroutine,{} exported only for developement."))
 (|removeSuperfluousCases|
  (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))
    (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))))
   "\\spad{removeSuperfluousCases(llpwt)} is an internal subroutine,{} exported only for developement."))
 (|subCase?|
  (((|Boolean|) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))
    (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))
   "\\spad{subCase?(lpwt1,{} lpwt2)} is an internal subroutine,{} exported only for developement."))
 (|removeSuperfluousQuasiComponents|
  (((|List| |#5|) (|List| |#5|))
   "\\spad{removeSuperfluousQuasiComponents(lts)} removes from \\spad{lts} any \\spad{ts} such that \\spad{subQuasiComponent?(ts,{} us)} holds for another \\spad{us} in \\spad{lts}."))
 (|subQuasiComponent?|
  (((|Boolean|) |#5| (|List| |#5|))
   "\\spad{subQuasiComponent?(ts,{} lus)} returns \\spad{true} iff \\spad{subQuasiComponent?(ts,{} us)} holds for one \\spad{us} in \\spad{lus}.")
  (((|Boolean|) |#5| |#5|)
   "\\spad{subQuasiComponent?(ts,{} us)} returns \\spad{true} iff \\spadopFrom{internalSubQuasiComponent?}{QuasiComponentPackage} returns \\spad{true}."))
 (|internalSubQuasiComponent?|
  (((|Union| (|Boolean|) "failed") |#5| |#5|)
   "\\spad{internalSubQuasiComponent?(ts,{} us)} returns a boolean \\spad{b} value if the fact that the regular zero set of \\spad{us} contains that of \\spad{ts} can be decided (and in that case \\spad{b} gives this inclusion) otherwise returns \\spad{\"failed\"}."))
 (|infRittWu?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{infRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for developement."))
 (|internalInfRittWu?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{internalInfRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for developement."))
 (|internalSubPolSet?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{internalSubPolSet?(lp1,{} lp2)} returns \\spad{true} iff \\spad{lp1} is a sub-set of \\spad{lp2} assuming that these lists are sorted increasingly \\spad{w}.\\spad{r}.\\spad{t}. \\spadopFrom{infRittWu?}{RecursivePolynomialCategory}."))
 (|subPolSet?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{subPolSet?(lp1,{} lp2)} returns \\spad{true} iff \\spad{lp1} is a sub-set of \\spad{lp2}."))
 (|subTriSet?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{subTriSet?(ts,{} us)} returns \\spad{true} iff \\spad{ts} is a sub-set of \\spad{us}."))
 (|moreAlgebraic?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{moreAlgebraic?(ts,{} us)} returns \\spad{false} iff \\spad{ts} and \\spad{us} are both empty,{} or \\spad{ts} has less elements than \\spad{us},{} or some variable is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{us} and is not \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|algebraicSort|
  (((|List| |#5|) (|List| |#5|))
   "\\spad{algebraicSort(lts)} sorts \\spad{lts} \\spad{w}.\\spad{r}.\\spad{t} \\spadopFrom{supDimElseRittWu?}{QuasiComponentPackage}."))
 (|supDimElseRittWu?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{supDimElseRittWu(ts,{} us)} returns \\spad{true} iff \\spad{ts} has less elements than \\spad{us} otherwise if \\spad{ts} has higher rank than \\spad{us} \\spad{w}.\\spad{r}.\\spad{t}. Riit and Wu ordering."))
 (|stopTable!|
  (((|Void|))
   "\\spad{stopTableGcd!()} is an internal subroutine,{} exported only for developement."))
 (|startTable!|
  (((|Void|) (|String|) (|String|) (|String|))
   "\\spad{startTableGcd!(s1,{} s2,{} s3)} is an internal subroutine,{} exported only for developement."))) 
NIL 
(|QueryEquation|) 
((|constructor| (NIL "This domain implements simple database queries"))
 (|value|
  (((|String|) $)
   "\\spad{value(q)} returns the value (\\spadignore{i.e.} right hand side) of \\spad{q}."))
 (|variable|
  (((|Symbol|) $)
   "\\spad{variable(q)} returns the variable (\\spadignore{i.e.} left hand side) of \\spad{q}."))
 (|equation|
  (($ (|Symbol|) (|String|))
   "\\spad{equation(s,{}\"a\")} creates a new equation."))) 
NIL 
(|QuotientFieldCategory&| A S) 
((|constructor|
  (NIL
   "QuotientField(\\spad{S}) is the category of fractions of an Integral Domain \\spad{S}."))
 (|floor|
  ((|#2| $)
   "\\spad{floor(x)} returns the largest integral element below \\spad{x}."))
 (|ceiling|
  ((|#2| $)
   "\\spad{ceiling(x)} returns the smallest integral element above \\spad{x}."))
 (|fractionPart|
  (($ $)
   "\\spad{fractionPart(x)} returns the fractional part of \\spad{x}. \\spad{x} = wholePart(\\spad{x}) + fractionPart(\\spad{x})"))
 (|wholePart|
  ((|#2| $)
   "\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator."))
 (|denominator|
  (($ $)
   "\\spad{denominator(x)} is the denominator of the fraction \\spad{x} converted to \\%."))
 (|numerator|
  (($ $)
   "\\spad{numerator(x)} is the numerator of the fraction \\spad{x} converted to \\%."))
 (|denom|
  ((|#2| $)
   "\\spad{denom(x)} returns the denominator of the fraction \\spad{x}."))
 (|numer|
  ((|#2| $)
   "\\spad{numer(x)} returns the numerator of the fraction \\spad{x}."))
 (/
  (($ |#2| |#2|)
   "\\spad{d1 / d2} returns the fraction \\spad{d1} divided by \\spad{d2}."))) 
((|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#2| '(|IntegerNumberSystem|))
 (|HasCategory| |#2| '(|EuclideanDomain|))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|RealConstant|))
 (|HasCategory| |#2| '(|OrderedIntegralDomain|))
 (|HasCategory| |#2| '(|Comparable|)) (|HasCategory| |#2| '(|OrderedSet|))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|StepThrough|))) 
(|QuotientFieldCategory| S) 
((|constructor|
  (NIL
   "QuotientField(\\spad{S}) is the category of fractions of an Integral Domain \\spad{S}."))
 (|floor|
  ((|#1| $)
   "\\spad{floor(x)} returns the largest integral element below \\spad{x}."))
 (|ceiling|
  ((|#1| $)
   "\\spad{ceiling(x)} returns the smallest integral element above \\spad{x}."))
 (|fractionPart|
  (($ $)
   "\\spad{fractionPart(x)} returns the fractional part of \\spad{x}. \\spad{x} = wholePart(\\spad{x}) + fractionPart(\\spad{x})"))
 (|wholePart|
  ((|#1| $)
   "\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator."))
 (|denominator|
  (($ $)
   "\\spad{denominator(x)} is the denominator of the fraction \\spad{x} converted to \\%."))
 (|numerator|
  (($ $)
   "\\spad{numerator(x)} is the numerator of the fraction \\spad{x} converted to \\%."))
 (|denom|
  ((|#1| $)
   "\\spad{denom(x)} returns the denominator of the fraction \\spad{x}."))
 (|numer|
  ((|#1| $)
   "\\spad{numer(x)} returns the numerator of the fraction \\spad{x}."))
 (/
  (($ |#1| |#1|)
   "\\spad{d1 / d2} returns the fraction \\spad{d1} divided by \\spad{d2}."))) 
NIL 
(|QuotientFieldCategoryFunctions2| A B R S) 
((|constructor|
  (NIL
   "This package extends a function between integral domains to a mapping between their quotient fields."))
 (|map|
  ((|#4| (|Mapping| |#2| |#1|) |#3|)
   "\\spad{map(func,{} frac)} applies the function \\spad{func} to the numerator and denominator of frac."))) 
NIL 
(|QuadraticForm| |n| K) 
((|constructor|
  (NIL "This domain provides modest support for quadratic forms."))
 (|elt|
  ((|#2| $ (|DirectProduct| |#1| |#2|))
   "\\spad{elt(qf,{} v)} evaluates the quadratic form \\spad{qf} on the vector \\spad{v},{} producing a scalar."))
 (|matrix|
  (((|SquareMatrix| |#1| |#2|) $)
   "\\spad{matrix(qf)} creates a square matrix from the quadratic form \\spad{qf}."))
 (|quadraticForm|
  (($ (|SquareMatrix| |#1| |#2|))
   "\\spad{quadraticForm(m)} creates a quadratic form from a symmetric,{} square matrix \\spad{m}."))) 
((|HasCategory| (|SquareMatrix| |#1| |#2|)
                (LIST '|ConvertibleTo| '(|InputForm|)))) 
(|QueueAggregate| S) 
((|constructor|
  (NIL
   "A queue is a bag where the first item inserted is the first item extracted."))
 (|back|
  ((|#1| $)
   "\\spad{back(q)} returns the element at the back of the queue. The queue \\spad{q} is unchanged by this operation. Error: if \\spad{q} is empty."))
 (|front|
  ((|#1| $)
   "\\spad{front(q)} returns the element at the front of the queue. The queue \\spad{q} is unchanged by this operation. Error: if \\spad{q} is empty."))
 (|rotate!|
  (($ $)
   "\\spad{rotate!(q)} rotates queue \\spad{q} so that the element at the front of the queue goes to the back of the queue. Note: rotate!(\\spad{q}) is equivalent to enqueue!(dequeue!(\\spad{q}))."))
 (|dequeue!|
  ((|#1| $)
   "\\spad{dequeue!(q)} destructively extracts the first (top) element from queue \\spad{q}. The element previously second in the queue becomes the first element. Error: if \\spad{q} is empty."))
 (|enqueue!|
  ((|#1| |#1| $)
   "\\spad{enqueue!(x,{} q)} inserts \\spad{x} into the queue \\spad{q} at the back end."))) 
NIL 
(|Quaternion| R) 
((|constructor|
  (NIL
   "\\spadtype{Quaternion} implements Hamilton quaternions \\indented{2}{over a commutative ring.}"))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|EntireRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|RealNumberSystem|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#1| '(|Field|)))) 
(|GeneralQuaternion| R |p| |q|) 
((|constructor|
  (NIL
   "\\spadtype{GeneralQuaternion} implements general quaternions \\indented{2}{over a commutative ring. The main constructor function is} \\indented{2}{\\spadfun{quatern} which takes 4 arguments: the real part,{}} \\indented{2}{the \\spad{i} imaginary part,{} the \\spad{j} imaginary part and the \\spad{k} imaginary part.}"))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|EntireRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|Eltable| (|devaluate| |#1|) (|devaluate| |#1|)))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|RealNumberSystem|))
 (|HasCategory| |#1| '(|IntegerNumberSystem|))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#1| '(|Field|)))) 
(|QuaternionCategory&| S R) 
((|constructor|
  (NIL
   "\\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(q)} returns \\spad{q} as a rational number,{} or \"failed\" if this is not possible. Note: if \\spad{rational?(q)} is \\spad{true},{} the conversion can be done and the rational number will be returned."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(q)} tries to convert \\spad{q} into a rational number. Error: if this is not possible. If \\spad{rational?(q)} is \\spad{true},{} the conversion will be done and the rational number returned."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(q)} returns {\\it \\spad{true}} if all the imaginary parts of \\spad{q} are zero and the real part can be converted into a rational number,{} and {\\it \\spad{false}} otherwise."))
 (|abs|
  ((|#2| $)
   "\\spad{abs(q)} computes the absolute value of quaternion \\spad{q} (sqrt of norm)."))
 (|real|
  ((|#2| $) "\\spad{real(q)} extracts the real part of quaternion \\spad{q}."))
 (|quatern|
  (($ |#2| |#2| |#2| |#2|)
   "\\spad{quatern(r,{} i,{} j,{} k)} constructs a quaternion from scalars."))
 (|norm|
  ((|#2| $)
   "\\spad{norm(q)} computes the norm of \\spad{q} (the sum of the squares of the components)."))
 (|imagK|
  ((|#2| $)
   "\\spad{imagK(q)} extracts the imaginary \\spad{k} part of quaternion \\spad{q}."))
 (|imagJ|
  ((|#2| $)
   "\\spad{imagJ(q)} extracts the imaginary \\spad{j} part of quaternion \\spad{q}."))
 (|imagI|
  ((|#2| $)
   "\\spad{imagI(q)} extracts the imaginary \\spad{i} part of quaternion \\spad{q}."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(q)} negates the imaginary parts of quaternion \\spad{q}."))) 
((|HasCategory| |#2| '(|IntegerNumberSystem|))
 (|HasCategory| |#2| '(|RealNumberSystem|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|OrderedSet|))
 (|HasCategory| |#2| '(|EntireRing|))) 
(|QuaternionCategory| R) 
((|constructor|
  (NIL
   "\\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific."))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") $)
   "\\spad{rationalIfCan(q)} returns \\spad{q} as a rational number,{} or \"failed\" if this is not possible. Note: if \\spad{rational?(q)} is \\spad{true},{} the conversion can be done and the rational number will be returned."))
 (|rational|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rational(q)} tries to convert \\spad{q} into a rational number. Error: if this is not possible. If \\spad{rational?(q)} is \\spad{true},{} the conversion will be done and the rational number returned."))
 (|rational?|
  (((|Boolean|) $)
   "\\spad{rational?(q)} returns {\\it \\spad{true}} if all the imaginary parts of \\spad{q} are zero and the real part can be converted into a rational number,{} and {\\it \\spad{false}} otherwise."))
 (|abs|
  ((|#1| $)
   "\\spad{abs(q)} computes the absolute value of quaternion \\spad{q} (sqrt of norm)."))
 (|real|
  ((|#1| $) "\\spad{real(q)} extracts the real part of quaternion \\spad{q}."))
 (|quatern|
  (($ |#1| |#1| |#1| |#1|)
   "\\spad{quatern(r,{} i,{} j,{} k)} constructs a quaternion from scalars."))
 (|norm|
  ((|#1| $)
   "\\spad{norm(q)} computes the norm of \\spad{q} (the sum of the squares of the components)."))
 (|imagK|
  ((|#1| $)
   "\\spad{imagK(q)} extracts the imaginary \\spad{k} part of quaternion \\spad{q}."))
 (|imagJ|
  ((|#1| $)
   "\\spad{imagJ(q)} extracts the imaginary \\spad{j} part of quaternion \\spad{q}."))
 (|imagI|
  ((|#1| $)
   "\\spad{imagI(q)} extracts the imaginary \\spad{i} part of quaternion \\spad{q}."))
 (|conjugate|
  (($ $)
   "\\spad{conjugate(q)} negates the imaginary parts of quaternion \\spad{q}."))) 
NIL 
(|QuaternionCategoryFunctions2| QR R QS S) 
((|constructor|
  (NIL
   "\\spadtype{QuaternionCategoryFunctions2} implements functions between two quaternion domains. The function \\spadfun{map} is used by the system interpreter to coerce between quaternion types."))
 (|map|
  ((|#3| (|Mapping| |#4| |#2|) |#1|)
   "\\spad{map(f,{} u)} maps \\spad{f} onto the component parts of the quaternion \\spad{u}."))) 
NIL 
(|Queue| S) 
((|constructor| (NIL "Linked List implementation of a Queue"))
 (|queue|
  (($ (|List| |#1|))
   "\\spad{queue([x,{} y,{} ...,{} z])} creates a queue with first (top) element \\spad{x},{} second element \\spad{y},{} ...,{} and last (bottom) element \\spad{z}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|RadicalCategory&| S) 
((|constructor|
  (NIL "The \\spad{RadicalCategory} is a model for the rational numbers."))
 (^
  (($ $ (|Fraction| (|Integer|)))
   "\\spad{x ^ y} is the rational exponentiation of \\spad{x} by the power \\spad{y}."))
 (|nthRoot|
  (($ $ (|Integer|))
   "\\spad{nthRoot(x,{} n)} returns the \\spad{n}th root of \\spad{x}."))
 (|sqrt|
  (($ $)
   "\\spad{sqrt(x)} returns the square root of \\spad{x}. The branch cut lies along the negative real axis,{} continuous with quadrant II."))) 
NIL 
(|RadicalCategory|) 
((|constructor|
  (NIL "The \\spad{RadicalCategory} is a model for the rational numbers."))
 (^
  (($ $ (|Fraction| (|Integer|)))
   "\\spad{x ^ y} is the rational exponentiation of \\spad{x} by the power \\spad{y}."))
 (|nthRoot|
  (($ $ (|Integer|))
   "\\spad{nthRoot(x,{} n)} returns the \\spad{n}th root of \\spad{x}."))
 (|sqrt|
  (($ $)
   "\\spad{sqrt(x)} returns the square root of \\spad{x}. The branch cut lies along the negative real axis,{} continuous with quadrant II."))) 
NIL 
(|RadicalFunctionField| F UP UPUP |radicnd| |n|) 
((|constructor|
  (NIL "Function field defined by \\spad{y^n} = \\spad{f}(\\spad{x})."))) 
((|HasCategory| (|Fraction| |#2|) '(|CharacteristicZero|))
 (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|))
 (|HasCategory| (|Fraction| |#2|) '(|Field|))
 (OR (|HasCategory| (|Fraction| |#2|) '(|Field|))
     (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))
 (|HasCategory| (|Fraction| |#2|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Fraction| |#2|) '(|Finite|))
 (OR
  (AND (|HasCategory| (|Fraction| |#2|) '(|DifferentialRing|))
       (|HasCategory| (|Fraction| |#2|) '(|Field|)))
  (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))
 (|HasCategory| (|Fraction| |#2|)
                (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| (|Fraction| |#2|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Fraction| |#2|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (AND
  (|HasCategory| (|Fraction| |#2|)
                 (LIST '|PartialDifferentialRing| '(|Symbol|)))
  (|HasCategory| (|Fraction| |#2|) '(|Field|)))
 (OR
  (AND
   (|HasCategory| (|Fraction| |#2|)
                  (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|Fraction| |#2|) '(|Field|)))
  (AND
   (|HasCategory| (|Fraction| |#2|)
                  (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|))))
 (OR
  (|HasCategory| (|Fraction| |#2|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| (|Fraction| |#2|) '(|Field|)))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Finite|))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Fraction| |#2|) '(|FiniteFieldCategory|)))) 
(|RadixExpansion| |bb|) 
((|constructor|
  (NIL
   "This domain allows rational numbers to be presented as repeating decimal expansions or more generally as repeating expansions in any base."))
 (|fractRadix|
  (($ (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{fractRadix(pre,{} cyc)} creates a fractional radix expansion from a list of prefix ragits and a list of cyclic ragits. For example,{} \\spad{fractRadix([1],{} [6])} will return \\spad{0.16666666...}."))
 (|wholeRadix|
  (($ (|List| (|Integer|)))
   "\\spad{wholeRadix(l)} creates an integral radix expansion from a list of ragits. For example,{} \\spad{wholeRadix([1,{} 3,{} 4])} will return \\spad{134}."))
 (|cycleRagits|
  (((|List| (|Integer|)) $)
   "\\spad{cycleRagits(rx)} returns the cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \\spad{x = 3/28 = 0.10 714285 714285 ...},{} then \\spad{cycleRagits(x) = [7,{} 1,{} 4,{} 2,{} 8,{} 5]}."))
 (|prefixRagits|
  (((|List| (|Integer|)) $)
   "\\spad{prefixRagits(rx)} returns the non-cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \\spad{x = 3/28 = 0.10 714285 714285 ...},{} then \\spad{prefixRagits(x)=[1,{} 0]}."))
 (|fractRagits|
  (((|Stream| (|Integer|)) $)
   "\\spad{fractRagits(rx)} returns the ragits of the fractional part of a radix expansion."))
 (|wholeRagits|
  (((|List| (|Integer|)) $)
   "\\spad{wholeRagits(rx)} returns the ragits of the integer part of a radix expansion."))
 (|fractionPart|
  (((|Fraction| (|Integer|)) $)
   "\\spad{fractionPart(rx)} returns the fractional part of a radix expansion."))
 (|coerce|
  (((|Fraction| (|Integer|)) $)
   "\\spad{coerce(rx)} converts a radix expansion to a rational number."))) 
((|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|CharacteristicNonZero|))
 (|HasCategory| (|Integer|) '(|CharacteristicZero|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|RealConstant|))
 (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|StepThrough|))
 (|HasCategory| (|Integer|) (LIST '|InnerEvalable| '(|Symbol|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|Eltable| '(|Integer|) '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| (|Integer|) '(|DifferentialRing|))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
 (|HasCategory| (|Integer|)
                (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Float|)))
 (|HasCategory| (|Integer|) (LIST '|PatternMatchable| '(|Integer|)))
 (|HasCategory| (|Integer|) (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegerNumberSystem|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedIntegralDomain|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
 (OR
  (AND (|HasCategory| $ '(|CharacteristicNonZero|))
       (|HasCategory| (|Integer|) '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| (|Integer|) '(|CharacteristicNonZero|)))) 
(|RadixUtilities|) 
((|constructor|
  (NIL "This package provides tools for creating radix expansions."))
 (|radix|
  (((|Any|) (|Fraction| (|Integer|)) (|Integer|))
   "\\spad{radix(x,{} b)} converts \\spad{x} to a radix expansion in base \\spad{b}."))) 
NIL 
(|RandomNumberSource|) 
((|constructor|
  (NIL
   "Random number generators \\indented{1}{All random numbers used in the system should originate from} \\indented{1}{the same generator.\\space{2}This package is intended to be the source.}"))
 (|seed| (((|Integer|)) "\\spad{seed()} returns the current seed value."))
 (|reseed|
  (((|Void|) (|Integer|))
   "\\spad{reseed(n)} restarts the random number generator at \\spad{n}."))
 (|size|
  (((|Integer|)) "\\spad{size()} is the base of the random number generator"))
 (|randnum|
  (((|Integer|) (|Integer|))
   "\\spad{randnum(n)} is a random number between 0 and \\spad{n}-1.")
  (((|Integer|)) "\\spad{randnum()} is a random number between 0 and size()."))) 
NIL 
(|RationalFactorize| RP) 
((|constructor|
  (NIL
   "\\indented{1}{Author: \\spad{P}. Gianni} Factorization of extended polynomials with rational coefficients. This package implements factorization of extended polynomials whose coefficients are rational numbers. It does this by taking the \\spad{lcm} of the coefficients of the polynomial and creating a polynomial with integer coefficients. The algorithm in \\spadtype{GaloisGroupFactorizer} is then used to factor the integer polynomial. The result is normalized with respect to the original \\spad{lcm} of the denominators. Keywords: factorization,{} hensel,{} rational number"))
 (|factorSquareFree|
  (((|Factored| |#1|) |#1|)
   "\\spad{factorSquareFree(p)} factors an extended squareFree polynomial \\spad{p} over the rational numbers."))
 (|factor|
  (((|Factored| |#1|) |#1|)
   "\\spad{factor(p)} factors an extended polynomial \\spad{p} over the rational numbers."))) 
NIL 
(|UnivariateSeriesWithRationalExponents| |Coef| |Expon|) 
((|integrate|
  (($ $ (|Symbol|))
   "\\spad{integrate(f(x),{} y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.")
  (($ $)
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))) 
NIL 
(|RationalRetractions| S) 
((|constructor|
  (NIL
   "rational number testing and retraction functions. Date Created: March 1990"))
 (|rationalIfCan|
  (((|Union| (|Fraction| (|Integer|)) "failed") |#1|)
   "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number,{} \"failed\" if \\spad{x} is not a rational number."))
 (|rational?|
  (((|Boolean|) |#1|)
   "\\spad{rational?(x)} returns \\spad{true} if \\spad{x} is a rational number,{} \\spad{false} otherwise."))
 (|rational|
  (((|Fraction| (|Integer|)) |#1|)
   "\\spad{rational(x)} returns \\spad{x} as a rational number; error if \\spad{x} is not a rational number."))) 
NIL 
(|RecursiveAggregate&| A S) 
((|constructor|
  (NIL
   "A recursive aggregate over a type \\spad{S} is a model for a a directed graph containing values of type \\spad{S}. Recursively,{} a recursive aggregate is either empty or a {\\em node} consisting of a \\spadfun{value} from \\spad{S} and 0 or more \\spadfun{children} which are also nodes. A node with no children is called a \\spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop."))
 (|setvalue!|
  ((|#2| $ |#2|)
   "\\spad{setvalue!(u,{} x)} sets the value of node \\spad{u} to \\spad{x}."))
 (|setelt!|
  ((|#2| $ "value" |#2|)
   "\\spad{setelt!(u,{} \"value\",{} x)} (also written \\spad{u.value := x}) is equivalent to \\spad{setvalue!(u,{} x)}"))
 (|setchildren!|
  (($ $ (|List| $))
   "\\spad{setchildren!(u,{} v)} replaces the current children of node \\spad{u} with the members of \\spad{v} in left-to-right order."))
 (|node?|
  (((|Boolean|) $ $)
   "\\spad{node?(u,{} v)} tests if node \\spad{u} is contained in node \\spad{v} (either as a child,{} a child of a child,{} etc.)."))
 (|child?|
  (((|Boolean|) $ $)
   "\\spad{child?(u,{} v)} tests if node \\spad{u} is a child of node \\spad{v}."))
 (|distance|
  (((|Integer|) $ $)
   "\\spad{distance(u,{} v)} returns the path length (an integer) from node \\spad{u} to \\spad{v}."))
 (|leaves|
  (((|List| |#2|) $)
   "\\spad{leaves(u)} returns the list of leaves in aggregate \\spad{u}."))
 (|cyclic?|
  (((|Boolean|) $) "\\spad{cyclic?(u)} tests if \\spad{u} has a cycle."))
 (|elt|
  ((|#2| $ "value")
   "\\spad{elt(u,{} \"value\")} (also written: \\spad{u.value}) is equivalent to \\spad{value(u)}."))
 (|value|
  ((|#2| $) "\\spad{value(u)} returns the value of the node \\spad{u}."))
 (|leaf?|
  (((|Boolean|) $) "\\spad{leaf?(u)} tests if \\spad{u} is a terminal node."))
 (|nodes|
  (((|List| $) $)
   "\\spad{nodes(u)} returns a list of all of the nodes of aggregate \\spad{u}."))
 (|children|
  (((|List| $) $)
   "\\spad{children(u)} returns a list of the children of aggregate \\spad{u}. Error: if \\spad{u} is empty."))) 
((|HasCategory| |#1| '(|shallowlyMutable|)) (|HasCategory| |#2| '(|BasicType|))) 
(|RecursiveAggregate| S) 
((|constructor|
  (NIL
   "A recursive aggregate over a type \\spad{S} is a model for a a directed graph containing values of type \\spad{S}. Recursively,{} a recursive aggregate is either empty or a {\\em node} consisting of a \\spadfun{value} from \\spad{S} and 0 or more \\spadfun{children} which are also nodes. A node with no children is called a \\spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop."))
 (|setvalue!|
  ((|#1| $ |#1|)
   "\\spad{setvalue!(u,{} x)} sets the value of node \\spad{u} to \\spad{x}."))
 (|setelt!|
  ((|#1| $ "value" |#1|)
   "\\spad{setelt!(u,{} \"value\",{} x)} (also written \\spad{u.value := x}) is equivalent to \\spad{setvalue!(u,{} x)}"))
 (|setchildren!|
  (($ $ (|List| $))
   "\\spad{setchildren!(u,{} v)} replaces the current children of node \\spad{u} with the members of \\spad{v} in left-to-right order."))
 (|node?|
  (((|Boolean|) $ $)
   "\\spad{node?(u,{} v)} tests if node \\spad{u} is contained in node \\spad{v} (either as a child,{} a child of a child,{} etc.)."))
 (|child?|
  (((|Boolean|) $ $)
   "\\spad{child?(u,{} v)} tests if node \\spad{u} is a child of node \\spad{v}."))
 (|distance|
  (((|Integer|) $ $)
   "\\spad{distance(u,{} v)} returns the path length (an integer) from node \\spad{u} to \\spad{v}."))
 (|leaves|
  (((|List| |#1|) $)
   "\\spad{leaves(u)} returns the list of leaves in aggregate \\spad{u}."))
 (|cyclic?|
  (((|Boolean|) $) "\\spad{cyclic?(u)} tests if \\spad{u} has a cycle."))
 (|elt|
  ((|#1| $ "value")
   "\\spad{elt(u,{} \"value\")} (also written: \\spad{u.value}) is equivalent to \\spad{value(u)}."))
 (|value|
  ((|#1| $) "\\spad{value(u)} returns the value of the node \\spad{u}."))
 (|leaf?|
  (((|Boolean|) $) "\\spad{leaf?(u)} tests if \\spad{u} is a terminal node."))
 (|nodes|
  (((|List| $) $)
   "\\spad{nodes(u)} returns a list of all of the nodes of aggregate \\spad{u}."))
 (|children|
  (((|List| $) $)
   "\\spad{children(u)} returns a list of the children of aggregate \\spad{u}. Error: if \\spad{u} is empty."))) 
NIL 
(|RealClosedField&| S) 
((|constructor|
  (NIL
   "\\spadtype{RealClosedField} provides common access functions for all real closed fields."))
 (|approximate|
  (((|Fraction| (|Integer|)) $ $)
   "\\spad{approximate(n,{} p)} gives an approximation of \\spad{n} that has precision \\spad{p}"))
 (|rename|
  (($ $ (|OutputForm|))
   "\\spad{rename(x,{} name)} gives a new number that prints as name"))
 (|rename!|
  (($ $ (|OutputForm|))
   "\\spad{rename!(x,{} name)} changes the way \\spad{x} is printed"))
 (|sqrt| (($ (|Integer|)) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ (|Fraction| (|Integer|))) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ $) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ $ (|PositiveInteger|)) "\\spad{sqrt(x,{} n)} is \\spad{x ^ (1/n)}"))
 (|allRootsOf|
  (((|List| $) (|Polynomial| (|Integer|)))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|Polynomial| $))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| (|Integer|)))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| (|Fraction| (|Integer|))))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely"))
 (|rootOf|
  (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|))
   "\\spad{rootOf(pol,{} n)} creates the \\spad{n}th root for the order of \\spad{pol} and gives it unique name")
  (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|)
    (|OutputForm|))
   "\\spad{rootOf(pol,{} n,{} name)} creates the \\spad{n}th root for the order of \\spad{pol} and names it \\spad{name}"))
 (|mainValue|
  (((|Union| (|SparseUnivariatePolynomial| $) "failed") $)
   "\\spad{mainValue(x)} is the expression of \\spad{x} in terms of \\spad{SparseUnivariatePolynomial(\\%)}"))
 (|mainDefiningPolynomial|
  (((|Union| (|SparseUnivariatePolynomial| $) "failed") $)
   "\\spad{mainDefiningPolynomial(x)} is the defining polynomial for the main algebraic quantity of \\spad{x}"))
 (|mainForm|
  (((|Union| (|OutputForm|) "failed") $)
   "\\spad{mainForm(x)} is the main algebraic quantity name of \\spad{x}"))) 
NIL 
(|RealClosedField|) 
((|constructor|
  (NIL
   "\\spadtype{RealClosedField} provides common access functions for all real closed fields."))
 (|approximate|
  (((|Fraction| (|Integer|)) $ $)
   "\\spad{approximate(n,{} p)} gives an approximation of \\spad{n} that has precision \\spad{p}"))
 (|rename|
  (($ $ (|OutputForm|))
   "\\spad{rename(x,{} name)} gives a new number that prints as name"))
 (|rename!|
  (($ $ (|OutputForm|))
   "\\spad{rename!(x,{} name)} changes the way \\spad{x} is printed"))
 (|sqrt| (($ (|Integer|)) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ (|Fraction| (|Integer|))) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ $) "\\spad{sqrt(x)} is \\spad{x ^ (1/2)}")
  (($ $ (|PositiveInteger|)) "\\spad{sqrt(x,{} n)} is \\spad{x ^ (1/n)}"))
 (|allRootsOf|
  (((|List| $) (|Polynomial| (|Integer|)))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|Polynomial| $))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| (|Integer|)))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| (|Fraction| (|Integer|))))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely")
  (((|List| $) (|SparseUnivariatePolynomial| $))
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} naming each uniquely"))
 (|rootOf|
  (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|))
   "\\spad{rootOf(pol,{} n)} creates the \\spad{n}th root for the order of \\spad{pol} and gives it unique name")
  (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|)
    (|OutputForm|))
   "\\spad{rootOf(pol,{} n,{} name)} creates the \\spad{n}th root for the order of \\spad{pol} and names it \\spad{name}"))
 (|mainValue|
  (((|Union| (|SparseUnivariatePolynomial| $) "failed") $)
   "\\spad{mainValue(x)} is the expression of \\spad{x} in terms of \\spad{SparseUnivariatePolynomial(\\%)}"))
 (|mainDefiningPolynomial|
  (((|Union| (|SparseUnivariatePolynomial| $) "failed") $)
   "\\spad{mainDefiningPolynomial(x)} is the defining polynomial for the main algebraic quantity of \\spad{x}"))
 (|mainForm|
  (((|Union| (|OutputForm|) "failed") $)
   "\\spad{mainForm(x)} is the main algebraic quantity name of \\spad{x}"))) 
NIL 
(|RDEaux| F) 
((SPDE1
  (((|Record| (|:| |ans| (|SparseUnivariatePolynomial| |#1|))
              (|:| |remainder| (|SparseUnivariatePolynomial| |#1|)))
    (|SparseUnivariatePolynomial| |#1|) (|SparseUnivariatePolynomial| |#1|)
    (|Mapping| (|SparseUnivariatePolynomial| |#1|)
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{SPDE1(b,{} c,{} D)} solves \\spad{Q'} + \\spad{b} \\spad{Q} = \\spad{c} and returns [\\spad{Q},{} \\spad{r}] where \\spad{r} = \\spad{c} - ( \\spad{Q'} + \\spad{b} \\spad{Q}). That is when \\spad{r} is zero then \\spad{Q} is \\spad{true} solution,{} otherwise \\spad{r} represets unsolved part of \\spad{c}. Moreover def(\\spad{r}) < deg(\\spad{bQ}). Note: \\spad{SPDE1} assumes that deg(\\spad{Q'}) < deg(\\spad{bQ}) for all \\spad{Q}."))
 (|multi_SPDE|
  (((|Union|
     (|List|
      (|Record| (|:| |ans| (|SparseUnivariatePolynomial| |#1|))
                (|:| |remainder| (|SparseUnivariatePolynomial| |#1|))))
     (|Record| (|:| |ans| (|List| (|SparseUnivariatePolynomial| |#1|)))
               (|:| |acoeff| (|SparseUnivariatePolynomial| |#1|))
               (|:| |eegen| (|SparseUnivariatePolynomial| |#1|))
               (|:| |bpar| (|SparseUnivariatePolynomial| |#1|))
               (|:| |lcpar| (|List| (|SparseUnivariatePolynomial| |#1|)))
               (|:| |dpar| (|Integer|))))
    (|SparseUnivariatePolynomial| |#1|) (|SparseUnivariatePolynomial| |#1|)
    (|List| (|SparseUnivariatePolynomial| |#1|)) (|Integer|)
    (|Mapping| (|SparseUnivariatePolynomial| |#1|)
               (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{multi_SPDE(a,{} b,{} lc,{} d,{} der)}"))) 
NIL 
(|ElementaryRischDESystem| R F) 
((|constructor|
  (NIL
   "\\indented{1}{Risch differential equation,{} elementary case.} Author: Manuel Bronstein Date Created: 12 August 1992 Keywords: elementary,{} function,{} integration."))
 (|rischDEsys|
  (((|Union| (|List| |#2|) "failed") (|Integer|) |#2| |#2| |#2| (|Symbol|)
    (|Mapping|
     (|Union|
      (|Record| (|:| |mainpart| |#2|)
                (|:| |limitedlogs|
                     (|List|
                      (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|)))))
      "failed")
     |#2| (|List| |#2|))
    (|Mapping|
     (|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2|
     |#2|))
   "\\spad{rischDEsys(n,{} f,{} g_1,{} g_2,{} x,{} lim,{} ext)} returns \\spad{y_1.y_2} such that \\spad{(dy1/dx,{} dy2/dx) + ((0,{} - n df/dx),{} (n df/dx,{} 0)) (y1,{} y2) = (g1,{} g2)} if \\spad{y_1,{}y_2} exist,{} \"failed\" otherwise. \\spad{lim} is a limited integration function,{} ext is an extended integration function."))) 
NIL 
(|ElementaryRischDEX| R F) 
((|constructor|
  (NIL
   "This package generates exponential integrals corresponding to polynomial part of the integral. \\blankline"))
 (|mk_erf|
  ((|#2| |#2| |#2|) "\\spad{mk_erf(u,{} f)} should be local but conditional"))
 (|ei_int|
  (((|Record| (|:| |ans| |#2|) (|:| |right| |#2|) (|:| |primpart| |#2|)
              (|:| |sol?| (|Boolean|)))
    (|Integer|) |#2| |#2| (|Symbol|))
   "\\spad{ei_int(n,{} f,{} g,{} x)} returns \\spad{[h,{} u,{} t,{} s]} such that \\spad{u*exp(n*f) = (h*exp(n*f))' + t'} where \\spad{t} involves special functions. When \\spad{s} is \\spad{true} then \\spad{g = u},{} otherwise ei_int returns partial answer,{}"))) 
NIL 
(|ElementaryRischDEX2| R F) 
((|constructor|
  (NIL "Risch differential equation,{} wrapper for extended version."))
 (|do_param_RDE|
  (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|)))
             "failed")
    |#2| |#2| (|List| |#2|) (|Symbol|) (|List| (|Kernel| |#2|)))
   "\\spad{do_param_RDE(f,{} h,{} lg,{} x,{} lk)} solves parametric Risch differential equation,{} that is returns \\spad{[y,{} [c1,{} ...,{} ck]]} such that dy/dx + \\spad{n} df/dx \\spad{y} + \\spad{c1} \\spad{g1} + ... \\spad{cn} \\spad{gn} = \\spad{h} where \\spad{y} is in the is in field generated by \\spad{lk} and \\spad{ci} are constants or \"failed\" if there is no solution."))
 (|do_risch_DE|
  (((|Record| (|:| |ans| |#2|) (|:| |right| |#2|) (|:| |primpart| |#2|)
              (|:| |sol?| (|Boolean|)))
    |#2| |#2| (|Symbol|) (|List| (|Kernel| |#2|)))
   "\\spad{do_risch_DE(f,{} g,{} x,{} lk)} returns \\spad{[y,{} h,{} 0,{} b]} such that \\spad{dy/dx + df/dx y = h} and \\spad{b := h = g}. The equation \\spad{dy/dx + df/dx y = g} has no solution in the field generated by \\spad{lk} if \\spad{h \\~~= g} (\\spad{y} is a partial solution in that case)."))
 (|risch_de_ext|
  (((|Record| (|:| |ans| |#2|) (|:| |right| |#2|) (|:| |primpart| |#2|)
              (|:| |sol?| (|Boolean|)))
    (|Integer|) |#2| |#2| (|Symbol|))
   "\\spad{risch_de_ext(n,{} f,{} g,{} x)} returns \\spad{[y,{} h,{} p,{} b]} such that \\spad{dy/dx + n df/dx y + exp(-nf)dp/dx = h} and \\spad{b := h = g}. The equation \\spad{dy/dx + n df/dx y = g} has no solution if \\spad{h \\~~= g} (\\spad{y} is a partial solution in that case)."))) 
NIL 
(|ParametricRischDE| R F) 
((|exp_lower_bound|
  (((|Integer|) (|SparseUnivariatePolynomial| |#2|)
    (|LaurentPolynomial| |#2| (|SparseUnivariatePolynomial| |#2|)) (|Integer|)
    (|Integer|) (|List| (|Kernel| |#2|)) |#2|
    (|Mapping|
     (|Record| (|:| |logands| (|List| |#2|))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| (|Kernel| |#2|)) (|List| |#2|)))
   "\\spad{exp_lower_bound(a,{} b,{} ob,{} nc0,{} lk,{} eta,{} logi)} computes lower degree bound for solution of \\spad{a*D(y) + b*y = c} in exponential case. \\spad{ob} is order of \\spad{b},{} \\spad{nc0} is lower bound on order of \\spad{c},{} \\spad{eta} is derivative of the argument of exponential."))
 (|param_rde2|
  (((|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
    |#2| (|List| |#2|) (|Symbol|) (|List| (|Kernel| |#2|))
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
     (|List| (|Kernel| |#2|)) (|List| |#2|))
    (|Mapping|
     (|Record| (|:| |logands| (|List| |#2|))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| (|Kernel| |#2|)) (|List| |#2|)))
   "\\spad{param_rde2(fp,{} lg,{} x,{} lk,{} ext,{} logi)} finds basis of solution to the equation dy/dx + \\spad{fp} \\spad{y} + \\spad{c1} \\spad{g1} + ... \\spad{cn} \\spad{gn} = 0 where \\spad{y} is in field generated by \\spad{lk} and \\spad{ci} are constants."))
 (|param_rde|
  (((|Record|
     (|:| |particular|
          (|Union|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|)))
           "failed"))
     (|:| |basis|
          (|List|
           (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))))
    (|Integer|) |#2| |#2| (|List| |#2|) (|Symbol|) (|List| (|Kernel| |#2|))
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
     (|List| (|Kernel| |#2|)) (|List| |#2|))
    (|Mapping|
     (|Record| (|:| |logands| (|List| |#2|))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| (|Kernel| |#2|)) (|List| |#2|)))
   "\\spad{param_rde(n,{} f,{} h,{} lg,{} x,{} lk,{} ext,{} logi)} finds a particular solution and basis of solutions to homogeneous equation for equation dy/dx + \\spad{n} df/dx \\spad{y} + \\spad{c1} \\spad{g1} + ... \\spad{cn} \\spad{gn} = \\spad{h} where \\spad{y} is in field generated by \\spad{lk} and \\spad{ci} are constants.")
  (((|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
    (|Integer|) |#2| (|List| |#2|) (|Symbol|) (|List| (|Kernel| |#2|))
    (|Mapping|
     (|List| (|Record| (|:| |ratpart| |#2|) (|:| |coeffs| (|Vector| |#2|))))
     (|List| (|Kernel| |#2|)) (|List| |#2|))
    (|Mapping|
     (|Record| (|:| |logands| (|List| |#2|))
               (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
     (|List| (|Kernel| |#2|)) (|List| |#2|)))
   "\\spad{param_rde(n,{} f,{} lg,{} x,{} lk,{} ext,{} logi)} finds basis of solution to the equation dy/dx + \\spad{n} df/dx \\spad{y} + \\spad{c1} \\spad{g1} + ... \\spad{cn} \\spad{gn} = 0 where \\spad{y} is in field generated by \\spad{lk} and \\spad{ci} are constants."))) 
NIL 
(|TranscendentalRischDESystem| F UP) 
((|constructor|
  (NIL
   "\\indented{1}{Risch differential equation system,{} transcendental case.} Author: Manuel Bronstein Date Created: 17 August 1992"))
 (|baseRDEsys|
  (((|Union| (|List| (|Fraction| |#2|)) "failed") (|Fraction| |#2|)
    (|Fraction| |#2|) (|Fraction| |#2|))
   "\\spad{baseRDEsys(f,{} g1,{} g2)} returns fractions \\spad{y_1.y_2} such that \\spad{(y1',{} y2') + ((0,{} -f),{} (f,{} 0)) (y1,{} y2) = (g1,{} g2)} if \\spad{y_1,{}y_2} exist,{} \"failed\" otherwise."))
 (|monomRDEsys|
  (((|Union|
     (|Record| (|:| |a| |#2|) (|:| |b| (|Fraction| |#2|)) (|:| |h| |#2|)
               (|:| |c1| (|Fraction| |#2|)) (|:| |c2| (|Fraction| |#2|))
               (|:| |t| |#2|))
     "failed")
    (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|)
    (|Mapping| |#2| |#2|))
   "\\spad{monomRDEsys(f,{} g1,{} g2,{} D)} returns \\spad{[A,{} B,{} H,{} C1,{} C2,{} T]} such that \\spad{(y1',{} y2') + ((0,{} -f),{} (f,{} 0)) (y1,{} y2) = (g1,{} g2)} has a solution if and only if \\spad{y1 = Q1 / T,{} y2 = Q2 / T},{} where \\spad{B,{} C1,{} C2,{} Q1,{} Q2} have no normal poles and satisfy A \\spad{(Q1',{} Q2') + ((H,{} -B),{} (B,{} H)) (Q1,{} Q2) = (C1,{} C2)} \\spad{D} is the derivation to use."))) 
NIL 
(|RandomDistributions| S) 
((|constructor| (NIL "This package exports random distributions"))
 (|rdHack1|
  (((|Mapping| |#1|) (|Vector| |#1|) (|Vector| (|Integer|)) (|Integer|))
   "\\spad{rdHack1(v,{} u,{} n)} \\undocumented"))
 (|weighted|
  (((|Mapping| |#1|)
    (|List| (|Record| (|:| |value| |#1|) (|:| |weight| (|Integer|)))))
   "\\spad{weighted(l)} \\undocumented"))
 (|uniform|
  (((|Mapping| |#1|) (|Set| |#1|)) "\\spad{uniform(s)} \\undocumented"))) 
NIL 
(|ReducedDivisor| F1 UP UPUP R F2) 
((|constructor|
  (NIL
   "\\indented{1}{Finds the order of a divisor over a finite field} Author: Manuel Bronstein Date Created: 1988"))
 (|order|
  (((|NonNegativeInteger|) (|FiniteDivisor| |#1| |#2| |#3| |#4|) |#3|
    (|Mapping| |#5| |#1|))
   "\\spad{order(f,{} u,{} g)} \\undocumented"))) 
NIL 
(|RealConstant|) 
((|constructor|
  (NIL
   "The category of real numeric domains,{} \\spadignore{i.e.} convertible to floats."))) 
NIL 
(|RealZeroPackage| |Pol|) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the integers to arbitrary user-specified precision. The results are returned as a list of isolating intervals which are expressed as records with \"left\" and \"right\" rational number components."))
 (|midpoints|
  (((|List| (|Fraction| (|Integer|)))
    (|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|))))))
   "\\spad{midpoints(isolist)} returns the list of midpoints for the list of intervals \\spad{isolist}."))
 (|midpoint|
  (((|Fraction| (|Integer|))
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|)))))
   "\\spad{midpoint(int)} returns the midpoint of the interval \\spad{int}."))
 (|refine|
  (((|Union|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|))))
     "failed")
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|)))))
   "\\spad{refine(pol,{} int,{} range)} takes a univariate polynomial \\spad{pol} and and isolating interval \\spad{int} containing exactly one real root of \\spad{pol}; the operation returns an isolating interval which is contained within range,{} or \"failed\" if no such isolating interval exists.")
  (((|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Fraction| (|Integer|)))
   "\\spad{refine(pol,{} int,{} eps)} refines the interval \\spad{int} containing exactly one root of the univariate polynomial \\spad{pol} to size less than the rational number eps."))
 (|realZeros|
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Fraction| (|Integer|)))
   "\\spad{realZeros(pol,{} int,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol} which lie in the interval expressed by the record \\spad{int}.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1| (|Fraction| (|Integer|)))
   "\\spad{realZeros(pol,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol}.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|)))))
   "\\spad{realZeros(pol,{} range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol} which lie in the interval expressed by the record range.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|)
   "\\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol}."))) 
NIL 
(|RealZeroPackageQ| |Pol|) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the rational numbers to arbitrary user-specified precision. The results are returned as a list of isolating intervals,{} expressed as records with \"left\" and \"right\" rational number components."))
 (|refine|
  (((|Union|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|))))
     "failed")
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|)))))
   "\\spad{refine(pol,{} int,{} range)} takes a univariate polynomial \\spad{pol} and and isolating interval \\spad{int} which must contain exactly one real root of \\spad{pol},{} and returns an isolating interval which is contained within range,{} or \"failed\" if no such isolating interval exists.")
  (((|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Fraction| (|Integer|)))
   "\\spad{refine(pol,{} int,{} eps)} refines the interval \\spad{int} containing exactly one root of the univariate polynomial \\spad{pol} to size less than the rational number eps."))
 (|realZeros|
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|))))
    (|Fraction| (|Integer|)))
   "\\spad{realZeros(pol,{} int,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol} which lie in the interval expressed by the record \\spad{int}.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1| (|Fraction| (|Integer|)))
   "\\spad{realZeros(pol,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol}.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|
    (|Record| (|:| |left| (|Fraction| (|Integer|)))
              (|:| |right| (|Fraction| (|Integer|)))))
   "\\spad{realZeros(pol,{} range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol} which lie in the interval expressed by the record range.")
  (((|List|
     (|Record| (|:| |left| (|Fraction| (|Integer|)))
               (|:| |right| (|Fraction| (|Integer|)))))
    |#1|)
   "\\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol}."))) 
NIL 
(|RealSolvePackage|) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides numerical solutions of systems of polynomial} equations for use in ACPLOT."))
 (|realSolve|
  (((|List| (|List| (|Float|))) (|List| (|Polynomial| (|Integer|)))
    (|List| (|Symbol|)) (|Float|))
   "\\spad{realSolve(lp,{} lv,{} eps)} = compute the list of the real solutions of the list \\spad{lp} of polynomials with integer coefficients with respect to the variables in \\spad{lv},{} with precision eps."))
 (|solve|
  (((|List| (|Float|)) (|Polynomial| (|Integer|)) (|Float|))
   "\\spad{solve(p,{} eps)} finds the real zeroes of a univariate integer polynomial \\spad{p} with precision eps.")
  (((|List| (|Float|)) (|Polynomial| (|Fraction| (|Integer|))) (|Float|))
   "\\spad{solve(p,{} eps)} finds the real zeroes of a univariate rational polynomial \\spad{p} with precision eps."))) 
NIL 
(|RealClosure| |TheField|) 
((|constructor|
  (NIL "This domain implements the real closure of an ordered field."))
 (|relativeApprox|
  (((|Fraction| (|Integer|)) $ $)
   "\\spad{relativeApprox(n,{} p)} gives a relative approximation of \\spad{n} that has precision \\spad{p}"))
 (|mainCharacterization|
  (((|Union|
     (|RightOpenIntervalRootCharacterization| $
                                              (|SparseUnivariatePolynomial| $))
     "failed")
    $)
   "\\spad{mainCharacterization(x)} is the main algebraic quantity of \\spad{x} (\\spad{SEG})"))
 (|algebraicOf|
  (($
    (|RightOpenIntervalRootCharacterization| $
                                             (|SparseUnivariatePolynomial| $))
    (|OutputForm|))
   "\\spad{algebraicOf(char)} is the external number"))) 
((OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (|HasCategory| (|Fraction| (|Integer|))
                    (LIST '|RetractableTo| '(|Integer|))))
 (|HasCategory| (|Fraction| (|Integer|))
                (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))) 
(|RecurrenceOperator| R F) 
((|constructor|
  (NIL
   "This package provides an operator for the \\spad{n}-th term of a recurrence and an operator for the coefficient of \\spad{x^n} in a function specified by a functional equation."))
 (|eltable?|
  (((|Boolean|) |#2|)
   "\\spad{eltable? r} returns whether the operator determines (most likely) the sequence completely."))
 (|values|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{values N} sets the number of initial values to display at most.")
  (((|NonNegativeInteger|))
   "\\spad{values()} returns the number of initial values to display at most."))
 (|getEq|
  ((|#2| |#2|)
   "\\spad{getEq f} returns the defining equation,{} if \\spad{f} represents the coefficient of an ADE or a recurrence."))
 (|makeFEq|
  ((|#2| (|BasicOperator|) (|Symbol|) (|Symbol|) |#2| (|List| |#2|)
    (|Stream| |#2|))
   "\\spad{evalADE(f,{} x,{} n,{} eq,{} parameters,{} values)} creates an expression that stands for the coefficient of \\spad{x^n} in the Taylor expansion of \\spad{f}(\\spad{x}),{} where \\spad{f}(\\spad{x}) is given by the functional equation \\spad{eq}. The argument values specifies the first few Taylor coefficients."))
 (|makeRec|
  ((|#2| (|BasicOperator|) (|Symbol|) |#2| (|List| |#2|) (|Stream| |#2|))
   "\\spad{makeRec(u,{} n,{} eq,{} parameters,{} values)} creates an expression that stands for \\spad{u}(\\spad{n}),{} where \\spad{u}(\\spad{n}) is given by the equation \\spad{eq}. The argument \\spad{parameters} has to contain all variables (or kernels) that appear eventually in the stream of values. The argument values specifies the initial values of the recurrence \\spad{u}(0),{} \\spad{u}(1),{} ... For the moment we don\\spad{'t} allow recursions that contain \\spad{u} inside of another operator."))) 
NIL 
(|ReductionOfOrder| F L) 
((|constructor|
  (NIL
   "\\spadtype{ReductionOfOrder} provides functions for reducing the order of linear ordinary differential equations once some solutions are known."))
 (|ReduceOrder|
  (((|Record| (|:| |eq| |#2|) (|:| |op| (|List| |#1|))) |#2| (|List| |#1|))
   "\\spad{ReduceOrder(op,{} [f1,{} ...,{} fk])} returns \\spad{[op1,{} [g1,{} ...,{} gk]]} such that for any solution \\spad{z} of \\spad{op1 z = 0},{} \\spad{y = gk \\int(g_{k-1} \\int(... \\int(g1 \\int z)...))} is a solution of \\spad{op y = 0}. Each \\spad{\\spad{fi}} must satisfy \\spad{op \\spad{fi} = 0}.")
  ((|#2| |#2| |#1|)
   "\\spad{ReduceOrder(op,{} s)} returns \\spad{op1} such that for any solution \\spad{z} of \\spad{op1 z = 0},{} \\spad{y = s \\int z} is a solution of \\spad{op y = 0}. \\spad{s} must satisfy \\spad{op s = 0}."))) 
NIL 
(|Reference| S) 
((|constructor|
  (NIL
   "\\indented{1}{\\spadtype{Reference} is for making a changeable instance} of something."))
 (=
  (((|Boolean|) $ $)
   "\\spad{a=b} tests if \\spad{a} and \\spad{b} are the same pointer/reference."))
 (|setref|
  ((|#1| $ |#1|) "\\spad{setref(n,{} m)} same as \\spad{setelt!(n,{} m)}."))
 (|deref| ((|#1| $) "\\spad{deref(n)} is equivalent to \\spad{elt(n)}."))
 (|setelt!|
  ((|#1| $ |#1|)
   "\\spad{setelt!(n,{} m)} changes the value of the object \\spad{n} to \\spad{m}."))
 (|elt| ((|#1| $) "\\spad{elt(n)} returns the object \\spad{n}."))
 (|ref|
  (($ |#1|)
   "\\spad{ref(n)} creates a pointer (reference) to the object \\spad{n}."))) 
((|HasCategory| |#1| '(|SetCategory|))) 
(|RegularTriangularSet| R E V P) 
((|constructor|
  (NIL
   "This domain provides an implementation of regular chains. Moreover,{} the operation \\spadopFrom{zeroSetSplit}{RegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\\newline"))
 (|pre_process|
  (((|Record| (|:| |val| (|List| |#4|)) (|:| |towers| (|List| $)))
    (|List| |#4|) (|Boolean|) (|Boolean|))
   "\\spad{pre_process(lp,{} b1,{} b2)} is an internal subroutine,{} exported only for developement."))
 (|internalZeroSetSplit|
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{internalZeroSetSplit(lp,{} b1,{} b2,{} b3)} is an internal subroutine,{} exported only for developement."))
 (|zeroSetSplit|
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} b1,{} b2.b3,{} b4)} is an internal subroutine,{} exported only for developement.")
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?,{} info?)} has the same specifications as \\spadopFrom{zeroSetSplit}{RegularTriangularSetCategory}. Moreover,{} if \\spad{clos?} then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \\spad{info?} then do print messages during the computations."))
 (|internalAugment|
  (((|List| $) |#4| $ (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)
    (|Boolean|))
   "\\spad{internalAugment(p,{} ts,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for developement."))) 
((AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#4| '(|BasicType|)) (|HasCategory| |#4| '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#3| '(|Finite|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|RadicalEigenPackage|) 
((|constructor|
  (NIL
   "Package for the computation of eigenvalues and eigenvectors. This package works for matrices with coefficients which are rational functions over the integers. (see \\spadtype{Fraction Polynomial Integer}). The eigenvalues and eigenvectors are expressed in terms of radicals."))
 (|orthonormalBasis|
  (((|List| (|Matrix| (|Expression| (|Integer|))))
    (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{orthonormalBasis(m)} returns the orthogonal matrix \\spad{b} such that \\spad{b*m*(inverse b)} is diagonal. Error: if \\spad{m} is not a symmetric matrix."))
 (|gramschmidt|
  (((|List| (|Matrix| (|Expression| (|Integer|))))
    (|List| (|Matrix| (|Expression| (|Integer|)))))
   "\\spad{gramschmidt(lv)} converts the list of column vectors \\spad{lv} into a set of orthogonal column vectors of euclidean length 1 using the Gram-Schmidt algorithm."))
 (|normalise|
  (((|Matrix| (|Expression| (|Integer|)))
    (|Matrix| (|Expression| (|Integer|))))
   "\\spad{normalise(v)} returns the column vector \\spad{v} divided by its euclidean norm; when possible,{} the vector \\spad{v} is expressed in terms of radicals."))
 (|eigenMatrix|
  (((|Union| (|Matrix| (|Expression| (|Integer|))) "failed")
    (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{eigenMatrix(m)} returns the matrix \\spad{b} such that \\spad{b*m*(inverse b)} is diagonal,{} or \"failed\" if no such \\spad{b} exists."))
 (|radicalEigenvalues|
  (((|List| (|Expression| (|Integer|)))
    (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{radicalEigenvalues(m)} computes the eigenvalues of the matrix \\spad{m}; when possible,{} the eigenvalues are expressed in terms of radicals."))
 (|radicalEigenvector|
  (((|List| (|Matrix| (|Expression| (|Integer|)))) (|Expression| (|Integer|))
    (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{radicalEigenvector(c,{} m)} computes the eigenvector(\\spad{s}) of the matrix \\spad{m} corresponding to the eigenvalue \\spad{c}; when possible,{} values are expressed in terms of radicals."))
 (|radicalEigenvectors|
  (((|List|
     (|Record| (|:| |radval| (|Expression| (|Integer|)))
               (|:| |radmult| (|Integer|))
               (|:| |radvect| (|List| (|Matrix| (|Expression| (|Integer|)))))))
    (|Matrix| (|Fraction| (|Polynomial| (|Integer|)))))
   "\\spad{radicalEigenvectors(m)} computes the eigenvalues and the corresponding eigenvectors of the matrix \\spad{m}; when possible,{} values are expressed in terms of radicals."))) 
NIL 
(|RepresentationPackage1| R) 
((|constructor|
  (NIL
   "\\spad{RepresentationPackage1} provides functions for representation theory for finite groups and algebras. The package creates permutation representations and uses tensor products and its symmetric and antisymmetric components to create new representations of larger degree from given ones. Note: instead of having parameters from \\spadtype{Permutation} this package allows list notation of permutations as well: \\spadignore{e.g.} \\spad{[1,{} 4,{} 3,{} 2]} denotes permutes 2 and 4 and fixes 1 and 3."))
 (|permutationRepresentation|
  (((|List| (|Matrix| (|Integer|))) (|List| (|List| (|Integer|))))
   "\\spad{permutationRepresentation([pi1,{} ...,{} pik],{} n)} returns the list of matrices {\\em [(deltai,{} pi1(i)),{} ...,{} (deltai,{} pik(i))]} if the permutations {\\em pi1},{} ...,{} {\\em pik} are in list notation and are permuting {\\em {1,{} 2,{} ...,{} n}}.")
  (((|List| (|Matrix| (|Integer|))) (|List| (|Permutation| (|Integer|)))
    (|Integer|))
   "\\spad{permutationRepresentation([pi1,{} ...,{} pik],{} n)} returns the list of matrices {\\em [(deltai,{} pi1(i)),{} ...,{} (deltai,{} pik(i))]} (Kronecker delta) for the permutations {\\em pi1,{} ...,{} pik} of {\\em {1,{} 2,{} ...,{} n}}.")
  (((|Matrix| (|Integer|)) (|List| (|Integer|)))
   "\\spad{permutationRepresentation(\\spad{pi},{} n)} returns the matrix {\\em (deltai,{} \\spad{pi}(i))} (Kronecker delta) if the permutation {\\em \\spad{pi}} is in list notation and permutes {\\em {1,{} 2,{} ...,{} n}}.")
  (((|Matrix| (|Integer|)) (|Permutation| (|Integer|)) (|Integer|))
   "\\spad{permutationRepresentation(\\spad{pi},{} n)} returns the matrix {\\em (deltai,{} \\spad{pi}(i))} (Kronecker delta) for a permutation {\\em \\spad{pi}} of {\\em {1,{} 2,{} ...,{} n}}."))
 (|tensorProduct|
  (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)))
   "\\spad{tensorProduct([a1,{} ...ak])} calculates the list of Kronecker products of each matrix {\\em \\spad{ai}} with itself for {1 \\spad{<=} \\spad{i} \\spad{<=} \\spad{k}}. Note: If the list of matrices corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the representation with itself.")
  (((|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{tensorProduct(a)} calculates the Kronecker product of the matrix {\\em a} with itself.")
  (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)))
   "\\spad{tensorProduct([a1,{} ...,{} ak],{} [b1,{} ...,{} bk])} calculates the list of Kronecker products of the matrices {\\em \\spad{ai}} and {\\em \\spad{bi}} for {1 \\spad{<=} \\spad{i} \\spad{<=} \\spad{k}}. Note: If each list of matrices corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the two representations.")
  (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|))
   "\\spad{tensorProduct(a,{} b)} calculates the Kronecker product of the matrices {\\em a} and \\spad{b}. Note: if each matrix corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the two representations."))
 (|symmetricTensors|
  (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|PositiveInteger|))
   "\\spad{symmetricTensors(la,{} n)} applies to each \\spad{m}-by-\\spad{m} square matrix in the list {\\em la} the irreducible,{} polynomial representation of the general linear group {\\em GLm} which corresponds to the partition {\\em (n,{} 0,{} ...,{} 0)} of \\spad{n}. Error: if the matrices in {\\em la} are not square matrices. Note: this corresponds to the symmetrization of the representation with the trivial representation of the symmetric group {\\em Sn}. The carrier spaces of the representation are the symmetric tensors of the \\spad{n}-fold tensor product.")
  (((|Matrix| |#1|) (|Matrix| |#1|) (|PositiveInteger|))
   "\\spad{symmetricTensors(a,{} n)} applies to the \\spad{m}-by-\\spad{m} square matrix {\\em a} the irreducible,{} polynomial representation of the general linear group {\\em GLm} which corresponds to the partition {\\em (n,{} 0,{} ...,{} 0)} of \\spad{n}. Error: if {\\em a} is not a square matrix. Note: this corresponds to the symmetrization of the representation with the trivial representation of the symmetric group {\\em Sn}. The carrier spaces of the representation are the symmetric tensors of the \\spad{n}-fold tensor product."))
 (|createGenericMatrix|
  (((|Matrix| (|Polynomial| |#1|)) (|NonNegativeInteger|))
   "\\spad{createGenericMatrix(m)} creates a square matrix of dimension \\spad{k} whose entry at the \\spad{i}-th row and \\spad{j}-th column is the indeterminate {\\em x[i,{} j]} (double subscripted)."))
 (|antisymmetricTensors|
  (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|PositiveInteger|))
   "\\spad{antisymmetricTensors(la,{} n)} applies to each \\spad{m}-by-\\spad{m} square matrix in the list {\\em la} the irreducible,{} polynomial representation of the general linear group {\\em GLm} which corresponds to the partition {\\em (1,{} 1,{} ...,{} 1,{} 0,{} 0,{} ...,{} 0)} of \\spad{n}. Error: if \\spad{n} is greater than \\spad{m}. Note: this corresponds to the symmetrization of the representation with the sign representation of the symmetric group {\\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \\spad{n}-fold tensor product.")
  (((|Matrix| |#1|) (|Matrix| |#1|) (|PositiveInteger|))
   "\\spad{antisymmetricTensors(a,{} n)} applies to the square matrix {\\em a} the irreducible,{} polynomial representation of the general linear group {\\em GLm},{} where \\spad{m} is the number of rows of {\\em a},{} which corresponds to the partition {\\em (1,{} 1,{} ...,{} 1,{} 0,{} 0,{} ...,{} 0)} of \\spad{n}. Error: if \\spad{n} is greater than \\spad{m}. Note: this corresponds to the symmetrization of the representation with the sign representation of the symmetric group {\\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \\spad{n}-fold tensor product."))) 
((|HasCategory| |#1| '(|CommutativeRing|))) 
(|RepresentationPackage2| R) 
((|constructor|
  (NIL
   "\\spad{RepresentationPackage2} provides functions for working with modular representations of finite groups and algebra. The routines in this package are created,{} using ideas of \\spad{R}. Parker,{} (the meat-Axe) to get smaller representations from bigger ones,{} \\spadignore{i.e.} finding sub- and factormodules,{} or to show,{} that such the representations are irreducible. Note: most functions are randomized functions of Las Vegas type \\spadignore{i.e.} every answer is correct,{} but with small probability the algorithm fails to get an answer."))
 (|scanOneDimSubspaces|
  (((|Vector| |#1|) (|List| (|Vector| |#1|)) (|Integer|))
   "\\spad{scanOneDimSubspaces(basis,{} n)} gives a canonical representative of the {\\em n}\\spad{-}th one-dimensional subspace of the vector space generated by the elements of {\\em basis},{} all from {\\em R^n}. The coefficients of the representative are of shape {\\em (0,{} ...,{} 0,{} 1,{} *,{} ...,{} *)},{} {\\em *} in \\spad{R}. If the size of \\spad{R} is \\spad{q},{} then there are {\\em (q^n-1)/(q-1)} of them. We first reduce \\spad{n} modulo this number,{} then find the largest \\spad{i} such that {\\em +/[q^i for i in 0..i-1] <= n}. Subtracting this sum of powers from \\spad{n} results in an \\spad{i}-digit number to \\spad{basis} \\spad{q}. This fills the positions of the stars."))
 (|meatAxe|
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|))
    (|PositiveInteger|))
   "\\spad{meatAxe(aG,{} numberOfTries)} calls {\\em meatAxe(aG,{} true,{} numberOfTries,{} 7)}. Notes: 7 covers the case of three-dimensional kernels over the field with 2 elements.")
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Boolean|))
   "\\spad{meatAxe(aG,{} randomElements)} calls {\\em meatAxe(aG,{} false,{} 6,{} 7)},{} only using Parker\\spad{'s} fingerprints,{} if {\\em randomElemnts} is \\spad{false}. If it is \\spad{true},{} it calls {\\em meatAxe(aG,{} true,{} 25,{} 7)},{} only using random elements. Note: the choice of 25 was rather arbitrary. Also,{} 7 covers the case of three-dimensional kernels over the field with 2 elements.")
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)))
   "\\spad{meatAxe(aG)} calls {\\em meatAxe(aG,{} false,{} 25,{} 7)} returns a 2-list of representations as follows. All matrices of argument \\spad{aG} are assumed to be square and of equal size. Then \\spad{aG} generates a subalgebra,{} say \\spad{A},{} of the algebra of all square matrices of dimension \\spad{n}. {\\em V R} is an A-module in the usual way. meatAxe(\\spad{aG}) creates at most 25 random elements of the algebra,{} tests them for singularity. If singular,{} it tries at most 7 elements of its kernel to generate a proper submodule. If successful a list which contains first the list of the representations of the submodule,{} then a list of the representations of the factor module is returned. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\\spad{'s} irreducibility test can be used either to prove irreducibility or to find the splitting. Notes: the first 6 tries use Parker\\spad{'s} fingerprints. Also,{} 7 covers the case of three-dimensional kernels over the field with 2 elements.")
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Boolean|)
    (|Integer|) (|Integer|))
   "\\spad{meatAxe(aG,{} randomElements,{} numberOfTries,{} maxTests)} returns a 2-list of representations as follows. All matrices of argument \\spad{aG} are assumed to be square and of equal size. Then \\spad{aG} generates a subalgebra,{} say \\spad{A},{} of the algebra of all square matrices of dimension \\spad{n}. {\\em V R} is an A-module in the usual way. meatAxe(\\spad{aG},{} \\spad{numberOfTries},{} maxTests) creates at most {\\em numberOfTries} random elements of the algebra,{} tests them for singularity. If singular,{} it tries at most {\\em maxTests} elements of its kernel to generate a proper submodule. If successful,{} a 2-list is returned: first,{} a list containing first the list of the representations of the submodule,{} then a list of the representations of the factor module. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\\spad{'s} irreducibility test can be used either to prove irreducibility or to find the splitting. If {\\em randomElements} is {\\em false},{} the first 6 tries use Parker\\spad{'s} fingerprints."))
 (|split|
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|))
    (|Vector| (|Vector| |#1|)))
   "\\spad{split(aG,{} submodule)} uses a proper submodule of {\\em R^n} to create the representations of the submodule and of the factor module.")
  (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Vector| |#1|))
   "\\spad{split(aG,{} vector)} returns a subalgebra \\spad{A} of all square matrix of dimension \\spad{n} as a list of list of matrices,{} generated by the list of matrices \\spad{aG},{} where \\spad{n} denotes both the size of vector as well as the dimension of each of the square matrices. {\\em V R} is an A-module in the natural way. split(\\spad{aG},{} vector) then checks whether the cyclic submodule generated by {\\em vector} is a proper submodule of {\\em V R}. If successful,{} it returns a two-element list,{} which contains first the list of the representations of the submodule,{} then the list of the representations of the factor module. If the vector generates the whole module,{} a one-element list of the old representation is given. Note: a later version this should call the other split."))
 (|isAbsolutelyIrreducible?|
  (((|Boolean|) (|List| (|Matrix| |#1|)))
   "\\spad{isAbsolutelyIrreducible?(aG)} calls {\\em isAbsolutelyIrreducible?(aG,{} 25)}. Note: the choice of 25 was rather arbitrary.")
  (((|Boolean|) (|List| (|Matrix| |#1|)) (|Integer|))
   "\\spad{isAbsolutelyIrreducible?(aG,{} numberOfTries)} uses Norton\\spad{'s} irreducibility test to check for absolute irreduciblity,{} assuming if a one-dimensional kernel is found. As no field extension changes create \"new\" elements in a one-dimensional space,{} the criterium stays \\spad{true} for every extension. The method looks for one-dimensionals only by creating random elements (no fingerprints) since a run of {\\em meatAxe} would have proved absolute irreducibility anyway."))
 (|areEquivalent?|
  (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))
    (|Integer|))
   "\\spad{areEquivalent?(aG0,{} aG1,{} numberOfTries)} calls {\\em areEquivalent?(aG0,{} aG1,{} true,{} 25)}. Note: the choice of 25 was rather arbitrary.")
  (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)))
   "\\spad{areEquivalent?(aG0,{} aG1)} calls {\\em areEquivalent?(aG0,{} aG1,{} true,{} 25)}. Note: the choice of 25 was rather arbitrary.")
  (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))
    (|Boolean|) (|Integer|))
   "\\spad{areEquivalent?(aG0,{} aG1,{} randomelements,{} numberOfTries)} tests whether the two lists of matrices,{} all assumed of same square shape,{} can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators,{} the representations are equivalent. The algorithm tries {\\em numberOfTries} times to create elements in the generated algebras in the same fashion. If their ranks differ,{} they are not equivalent. If an isomorphism is assumed,{} then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (\\spadignore{e.g.} irreducibility !) we use {\\em standardBasisOfCyclicSubmodule} to create the only possible transition matrix. The method checks whether the matrix conjugates all corresponding matrices from {\\em aGi}. The way to choose the singular matrices is as in {\\em meatAxe}. If the two representations are equivalent,{} this routine returns the transformation matrix {\\em TM} with {\\em aG0.i * TM = TM * aG1.i} for all \\spad{i}. If the representations are not equivalent,{} a small 0-matrix is returned. Note: the case with different sets of group generators cannot be handled."))
 (|standardBasisOfCyclicSubmodule|
  (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|Vector| |#1|))
   "\\spad{standardBasisOfCyclicSubmodule(lm,{} v)} returns a matrix as follows. It is assumed that the size \\spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra,{} say \\spad{A},{} of the algebra of all square matrices of dimension \\spad{n}. {\\em V R} is an \\spad{A}-module in the natural way. standardBasisOfCyclicSubmodule(\\spad{lm},{} \\spad{v}) calculates a matrix whose non-zero column vectors are the \\spad{R}-Basis of {\\em Av} achieved in the way as described in section 6 of \\spad{R}. A. Parker\\spad{'s} \"The Meat-Axe\". Note: in contrast to {\\em cyclicSubmodule},{} the result is not in echelon form."))
 (|cyclicSubmodule|
  (((|Vector| (|Vector| |#1|)) (|List| (|Matrix| |#1|)) (|Vector| |#1|))
   "\\spad{cyclicSubmodule(lm,{} v)} generates a basis as follows. It is assumed that the size \\spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra,{} say \\spad{A},{} of the algebra of all square matrices of dimension \\spad{n}. {\\em V R} is an \\spad{A}-module in the natural way. cyclicSubmodule(\\spad{lm},{} \\spad{v}) generates the \\spad{R}-Basis of {\\em Av} as described in section 6 of \\spad{R}. A. Parker\\spad{'s} \"The Meat-Axe\". Note: in contrast to the description in \"The Meat-Axe\" and to {\\em standardBasisOfCyclicSubmodule} the result is in echelon form."))
 (|createRandomElement|
  (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|Matrix| |#1|))
   "\\spad{createRandomElement(aG,{} x)} creates a random element of the group algebra generated by {\\em aG}."))
 (|completeEchelonBasis|
  (((|Matrix| |#1|) (|Vector| (|Vector| |#1|)))
   "\\spad{completeEchelonBasis(lv)} completes the basis {\\em lv} assumed to be in echelon form of a subspace of {\\em R^n} (\\spad{n} the length of all the vectors in {\\em lv}) with unit vectors to a basis of {\\em R^n}. It is assumed that the argument is not an empty vector and that it is not the basis of the 0-subspace. Note: the rows of the result correspond to the vectors of the basis."))) 
((|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Finite|)))
 (|HasCategory| |#1| '(|EuclideanDomain|))) 
(|RepeatedDoubling| S) 
((|constructor| (NIL "Implements multiplication by repeated addition"))
 (|double|
  ((|#1| (|PositiveInteger|) |#1|)
   "\\spad{double(i,{} r)} multiplies \\spad{r} by \\spad{i} using repeated doubling."))
 (+ (($ $ $) "\\spad{x+y} returns the sum of \\spad{x} and \\spad{y}"))) 
NIL 
(|RepeatedSquaring| S) 
((|constructor| (NIL "Implements exponentiation by repeated squaring"))
 (|expt|
  ((|#1| |#1| (|PositiveInteger|))
   "\\spad{expt(r,{} i)} computes r^i by repeated squaring"))
 (* (($ $ $) "\\spad{x*y} returns the product of \\spad{x} and \\spad{y}"))) 
NIL 
(|ResolveLatticeCompletion| S) 
((|constructor|
  (NIL
   "This package provides coercions for the special types \\spadtype{Exit} and \\spadtype{Void}."))
 (|coerce|
  ((|#1| (|Exit|))
   "\\spad{coerce(e)} is never really evaluated. This coercion is used for formal type correctness when a function will not return directly to its caller.")
  (((|Void|) |#1|)
   "\\spad{coerce(s)} throws all information about \\spad{s} away. This coercion allows values of any type to appear in contexts where they will not be used. For example,{} it allows the resolution of different types in the \\spad{then} and \\spad{else} branches when an \\spad{if} is in a context where the resulting value is not used."))) 
NIL 
(|ResidueRing| F |Expon| |VarSet| |FPol| |LFPol|) 
((|constructor|
  (NIL
   "ResidueRing is the quotient of a polynomial ring by an ideal. The ideal is given as a list of generators. The elements of the domain are equivalence classes expressed in terms of reduced elements"))
 (|lift|
  ((|#4| $)
   "\\spad{lift(x)} return the canonical representative of the equivalence class \\spad{x}"))
 (|coerce|
  (($ |#4|)
   "\\spad{coerce(f)} produces the equivalence class of \\spad{f} in the residue ring"))
 (|reduce|
  (($ |#4|)
   "\\spad{reduce(f)} produces the equivalence class of \\spad{f} in the residue ring"))) 
NIL 
(|Result|) 
((|constructor|
  (NIL
   "A domain used to return the results from a call to the NAG Library. It prints as a list of names and types,{} though the user may choose to display values automatically if he or she wishes."))
 (|showArrayValues|
  (((|Boolean|) (|Boolean|))
   "\\spad{showArrayValues(true)} forces the values of array components to be \\indented{1}{displayed rather than just their types.}"))
 (|showScalarValues|
  (((|Boolean|) (|Boolean|))
   "\\spad{showScalarValues(true)} forces the values of scalar components to be \\indented{1}{displayed rather than just their types.}"))) 
((|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                '(|BasicType|))
 (|HasCategory| (|Symbol|) '(|OrderedSet|))
 (OR (|HasCategory| (|Any|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| (|Any|) '(|BasicType|))
 (|HasCategory| (|Any|) '(|SetCategory|))
 (AND (|HasCategory| (|Any|) (LIST '|Evalable| '(|Any|)))
      (|HasCategory| (|Any|) '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| '(|Symbol|))
                             (LIST '|:| '|entry| '(|Any|)))))
  (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                 '(|SetCategory|)))
 (OR (|HasCategory| (|Any|) '(|BasicType|))
     (|HasCategory| (|Any|) '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    '(|SetCategory|)))
 (OR (|HasCategory| (|Any|) '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    '(|SetCategory|)))
 (OR (|HasCategory| (|Any|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Any|) '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                    '(|SetCategory|)))
 (|HasCategory| (|Any|) '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                     '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Any|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Any|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                      '(|BasicType|)))
  (|HasCategory| (|Any|) '(|SetCategory|))
  (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|)))
                 '(|SetCategory|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Any|) '(|OrderedSet|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|RetractableFrom&| A S) 
((|constructor|
  (NIL
   "\\spad{B} is retractable from A means that some elements in A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A."))
 (|retract|
  (($ |#2|)
   "\\spad{retract(a)} transforms a into an element of \\% if possible. Error: if a cannot be made into an element of \\%."))
 (|retractIfCan|
  (((|Union| $ "failed") |#2|)
   "\\spad{retractIfCan(a)} transforms a into an element of \\% if possible. Returns \"failed\" if a cannot be made into an element of \\%."))) 
NIL 
(|RetractableFrom| S) 
((|constructor|
  (NIL
   "\\spad{B} is retractable from A means that some elements in A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A."))
 (|retract|
  (($ |#1|)
   "\\spad{retract(a)} transforms a into an element of \\% if possible. Error: if a cannot be made into an element of \\%."))
 (|retractIfCan|
  (((|Union| $ "failed") |#1|)
   "\\spad{retractIfCan(a)} transforms a into an element of \\% if possible. Returns \"failed\" if a cannot be made into an element of \\%."))) 
NIL 
(|RetractableTo&| A S) 
((|constructor|
  (NIL
   "A is retractable to \\spad{B} means that some elements of A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A."))
 (|retract|
  ((|#2| $)
   "\\spad{retract(a)} transforms a into an element of \\spad{S} if possible. Error: if a cannot be made into an element of \\spad{S}."))
 (|retractIfCan|
  (((|Union| |#2| "failed") $)
   "\\spad{retractIfCan(a)} transforms a into an element of \\spad{S} if possible. Returns \"failed\" if a cannot be made into an element of \\spad{S}."))) 
NIL 
(|RetractableTo| S) 
((|constructor|
  (NIL
   "A is retractable to \\spad{B} means that some elements of A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A."))
 (|retract|
  ((|#1| $)
   "\\spad{retract(a)} transforms a into an element of \\spad{S} if possible. Error: if a cannot be made into an element of \\spad{S}."))
 (|retractIfCan|
  (((|Union| |#1| "failed") $)
   "\\spad{retractIfCan(a)} transforms a into an element of \\spad{S} if possible. Returns \"failed\" if a cannot be made into an element of \\spad{S}."))) 
NIL 
(|RetractSolvePackage| Q R) 
((|constructor|
  (NIL
   "RetractSolvePackage is an interface to \\spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving."))
 (|solveRetract|
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#2|)))))
    (|List| (|Polynomial| |#2|)) (|List| (|Symbol|)))
   "\\spad{solveRetract(lp,{} lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv}. The function tries to retract all the coefficients of the equations to \\spad{Q} before solving if possible."))) 
NIL 
(|RationalFunction| R) 
((|constructor|
  (NIL
   "Utilities that provide the same top-level manipulations on fractions than on polynomials."))
 (|coerce|
  (((|Fraction| (|Polynomial| |#1|)) |#1|)
   "\\spad{coerce(r)} returns \\spad{r} viewed as a rational function over \\spad{R}."))
 (|eval|
  (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|))
    (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
   "\\spad{eval(f,{} [v1 = g1,{} ...,{} vn = gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel,{} \\spadignore{i.e.} \\spad{vi}\\spad{'s} appearing inside the \\spad{gi}\\spad{'s} are not replaced. Error: if any \\spad{vi} is not a symbol.")
  (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|))
    (|Equation| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{eval(f,{} v = g)} returns \\spad{f} with \\spad{v} replaced by \\spad{g}. Error: if \\spad{v} is not a symbol.")
  (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|))
    (|List| (|Symbol|)) (|List| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{eval(f,{} [v1,{} ...,{} vn],{} [g1,{} ...,{} gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel,{} \\spadignore{i.e.} \\spad{vi}\\spad{'s} appearing inside the \\spad{gi}\\spad{'s} are not replaced.")
  (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|))
    (|Symbol|) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{eval(f,{} v,{} g)} returns \\spad{f} with \\spad{v} replaced by \\spad{g}."))
 (|multivariate|
  (((|Fraction| (|Polynomial| |#1|))
    (|Fraction|
     (|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))))
    (|Symbol|))
   "\\spad{multivariate(f,{} v)} applies both the numerator and denominator of \\spad{f} to \\spad{v}."))
 (|univariate|
  (((|Fraction|
     (|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{univariate(f,{} v)} returns \\spad{f} viewed as a univariate rational function in \\spad{v}."))
 (|mainVariable|
  (((|Union| (|Symbol|) "failed") (|Fraction| (|Polynomial| |#1|)))
   "\\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \\spad{f},{} \"failed\" if \\spad{f} has no variables."))
 (|variables|
  (((|List| (|Symbol|)) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \\spad{f}."))) 
NIL 
(|RandomFloatDistributions|) 
((|constructor|
  (NIL "This package exports random floating-point distributions"))
 (|t|
  (((|Mapping| (|Float|)) (|NonNegativeInteger|))
   "\\spad{t(n)} \\undocumented"))
 (F
  (((|Mapping| (|Float|)) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{F(n,{} m)} \\undocumented"))
 (|Beta|
  (((|Mapping| (|Float|)) (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{Beta(n,{} m)} \\undocumented"))
 (|chiSquare|
  (((|Mapping| (|Float|)) (|NonNegativeInteger|))
   "\\spad{chiSquare(n)} \\undocumented"))
 (|exponential|
  (((|Mapping| (|Float|)) (|Float|)) "\\spad{exponential(f)} \\undocumented"))
 (|normal|
  (((|Mapping| (|Float|)) (|Float|) (|Float|))
   "\\spad{normal(f,{} g)} \\undocumented"))
 (|uniform|
  (((|Mapping| (|Float|)) (|Float|) (|Float|))
   "\\spad{uniform(f,{} g)} \\undocumented"))
 (|chiSquare1|
  (((|Float|) (|NonNegativeInteger|)) "\\spad{chiSquare1(n)} \\undocumented"))
 (|exponential1| (((|Float|)) "\\spad{exponential1()} \\undocumented"))
 (|normal01| (((|Float|)) "\\spad{normal01()} \\undocumented"))
 (|uniform01| (((|Float|)) "\\spad{uniform01()} \\undocumented"))) 
NIL 
(|RationalFunctionFactor| UP) 
((|constructor|
  (NIL
   "Factorization of univariate polynomials with coefficients which are rational functions with integer coefficients."))
 (|factor|
  (((|Factored| |#1|) |#1|)
   "\\spad{factor(p)} returns a prime factorisation of \\spad{p}."))) 
NIL 
(|RootFSSplit| R F) 
((|alg_split_roots|
  (((|List|
     (|Record| (|:| |funs| (|List| |#2|)) (|:| |nroot| |#2|)
               (|:| |npow1| (|Integer|)) (|:| |npow2| (|Integer|))))
    (|List| |#2|) (|Kernel| |#2|) (|Kernel| |#2|))
   "\\spad{alg_split_roots(lf,{} r1,{} r2)} splits each \\spad{f} in \\spad{lf} into linear combination of product of powers of \\spad{r1} and \\spad{r2} which must be independent roots."))) 
NIL 
(|RegularChain| R |ls|) 
((|constructor|
  (NIL
   "A domain for regular chains (\\spadignore{i.e.} regular triangular sets) over a \\spad{Gcd}-Domain and with a fix list of variables. This is just a front-end for the \\spadtype{RegularTriangularSet} domain constructor."))
 (|zeroSetSplit|
  (((|List| $)
    (|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
    (|Boolean|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?,{} info?)} returns a list \\spad{lts} of regular chains such that the union of the closures of their regular zero sets equals the affine variety associated with \\spad{lp}. Moreover,{} if \\spad{clos?} is \\spad{false} then the union of the regular zero set of the \\spad{ts} (for \\spad{ts} in \\spad{lts}) equals this variety. If \\spad{info?} is \\spad{true} then some information is displayed during the computations. See \\spadopFrom{zeroSetSplit}{RegularTriangularSet}."))) 
((AND
  (|HasCategory|
   (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
   (LIST '|Evalable|
         (LIST '|NewSparseMultivariatePolynomial| (|devaluate| |#1|)
               (LIST '|OrderedVariableList| (|devaluate| |#2|)))))
  (|HasCategory|
   (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
   '(|SetCategory|)))
 (|HasCategory|
  (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
  (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory|
  (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
  '(|BasicType|))
 (|HasCategory|
  (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
  '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| (|OrderedVariableList| |#2|) '(|Finite|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory|
       (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
       '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory|
       (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))
       '(|OrderedSet|)))) 
(|RandomIntegerDistributions|) 
((|constructor| (NIL "This package exports integer distributions"))
 (|ridHack1|
  (((|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{ridHack1(i,{} j,{} k,{} l)} \\undocumented"))
 (|geometric|
  (((|Mapping| (|Integer|)) (|Fraction| (|Integer|)))
   "\\spad{geometric(f)} \\undocumented"))
 (|poisson|
  (((|Mapping| (|Integer|)) (|Fraction| (|Integer|)))
   "\\spad{poisson(f)} \\undocumented"))
 (|binomial|
  (((|Mapping| (|Integer|)) (|Integer|) (|Fraction| (|Integer|)))
   "\\spad{binomial(n,{} f)} \\undocumented"))
 (|uniform|
  (((|Mapping| (|Integer|)) (|Segment| (|Integer|)))
   "\\spad{uniform(s)} \\undocumented"))) 
NIL 
(|Ring|) 
((|constructor|
  (NIL
   "The category of rings with unity,{} always associative,{} but not necessarily commutative."))) 
NIL 
(|RationalInterpolation| |xx| F) 
((|constructor| (NIL "This package exports rational interpolation algorithms"))) 
NIL 
(|RectangularMatrixCategory&| S |m| |n| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \\spad{R}-modules and will be non-mutable."))
 (|nullSpace|
  (((|List| |#6|) $)
   "\\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) $)
   "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|columnSpace|
  (((|List| |#6|) $)
   "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} forming a basis of its column space."))
 (|rowEchelon|
  (($ $)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))
 (/
  (($ $ |#4|)
   "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r}. Error: if \\spad{r = 0}."))
 (|exquo|
  (((|Union| $ "failed") $ |#4|)
   "\\spad{exquo(m,{} r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r},{} returning \\spad{\"failed\"} if this is not possible."))
 (|map|
  (($ (|Mapping| |#4| |#4| |#4|) $ $)
   "\\spad{map(f,{} a,{} b)} returns \\spad{c},{} where \\spad{c} is such that \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \\spad{i},{} \\spad{j}.")
  (($ (|Mapping| |#4| |#4|) $)
   "\\spad{map(f,{} a)} returns \\spad{b},{} where \\spad{b(i,{} j) = a(i,{} j)} for all \\spad{i},{} \\spad{j}."))
 (|column|
  ((|#6| $ (|Integer|))
   "\\spad{column(m,{} j)} returns the \\spad{j}th column of the matrix \\spad{m}. Error: if the index outside the proper range."))
 (|row|
  ((|#5| $ (|Integer|))
   "\\spad{row(m,{} i)} returns the \\spad{i}th row of the matrix \\spad{m}. Error: if the index is outside the proper range."))
 (|qelt|
  ((|#4| $ (|Integer|) (|Integer|))
   "\\spad{qelt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m}. Note: there is NO error check to determine if indices are in the proper ranges."))
 (|elt|
  ((|#4| $ (|Integer|) (|Integer|) |#4|)
   "\\spad{elt(m,{} i,{} j,{} r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m},{} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,{} and returns \\spad{r} otherwise.")
  ((|#4| $ (|Integer|) (|Integer|))
   "\\spad{elt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m}. Error: if indices are outside the proper ranges."))
 (|listOfLists|
  (((|List| (|List| |#4|)) $)
   "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list of lists."))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(m)} returns the number of columns in the matrix \\spad{m}."))
 (|nrows|
  (((|NonNegativeInteger|) $)
   "\\spad{nrows(m)} returns the number of rows in the matrix \\spad{m}."))
 (|maxColIndex|
  (((|Integer|) $)
   "\\spad{maxColIndex(m)} returns the index of the 'last' column of the matrix \\spad{m}."))
 (|minColIndex|
  (((|Integer|) $)
   "\\spad{minColIndex(m)} returns the index of the 'first' column of the matrix \\spad{m}."))
 (|maxRowIndex|
  (((|Integer|) $)
   "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the matrix \\spad{m}."))
 (|minRowIndex|
  (((|Integer|) $)
   "\\spad{minRowIndex(m)} returns the index of the 'first' row of the matrix \\spad{m}."))
 (|antisymmetric?|
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise.")
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|symmetric?|
  (((|Boolean|) $)
   "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|diagonal?|
  (((|Boolean|) $)
   "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."))
 (|square?|
  (((|Boolean|) $)
   "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."))
 (|matrix|
  (($ (|List| (|List| |#4|)))
   "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix."))) 
((|HasCategory| |#4| '(|EuclideanDomain|)) (|HasCategory| |#4| '(|Field|))
 (|HasCategory| |#4| '(|IntegralDomain|))
 (|HasCategory| |#4| '(|AbelianGroup|))
 (|HasCategory| |#4| '(|CommutativeRing|)) (|HasCategory| |#4| '(|Finite|))) 
(|RectangularMatrixCategory| |m| |n| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \\spad{R}-modules and will be non-mutable."))
 (|nullSpace|
  (((|List| |#5|) $)
   "\\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \\spad{m}."))
 (|nullity|
  (((|NonNegativeInteger|) $)
   "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m}. This is the dimension of the null space of the matrix \\spad{m}."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank(m)} returns the rank of the matrix \\spad{m}."))
 (|columnSpace|
  (((|List| |#5|) $)
   "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} forming a basis of its column space."))
 (|rowEchelon|
  (($ $)
   "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m}."))
 (/
  (($ $ |#3|)
   "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r}. Error: if \\spad{r = 0}."))
 (|exquo|
  (((|Union| $ "failed") $ |#3|)
   "\\spad{exquo(m,{} r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r},{} returning \\spad{\"failed\"} if this is not possible."))
 (|map|
  (($ (|Mapping| |#3| |#3| |#3|) $ $)
   "\\spad{map(f,{} a,{} b)} returns \\spad{c},{} where \\spad{c} is such that \\spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \\spad{i},{} \\spad{j}.")
  (($ (|Mapping| |#3| |#3|) $)
   "\\spad{map(f,{} a)} returns \\spad{b},{} where \\spad{b(i,{} j) = a(i,{} j)} for all \\spad{i},{} \\spad{j}."))
 (|column|
  ((|#5| $ (|Integer|))
   "\\spad{column(m,{} j)} returns the \\spad{j}th column of the matrix \\spad{m}. Error: if the index outside the proper range."))
 (|row|
  ((|#4| $ (|Integer|))
   "\\spad{row(m,{} i)} returns the \\spad{i}th row of the matrix \\spad{m}. Error: if the index is outside the proper range."))
 (|qelt|
  ((|#3| $ (|Integer|) (|Integer|))
   "\\spad{qelt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m}. Note: there is NO error check to determine if indices are in the proper ranges."))
 (|elt|
  ((|#3| $ (|Integer|) (|Integer|) |#3|)
   "\\spad{elt(m,{} i,{} j,{} r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m},{} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,{} and returns \\spad{r} otherwise.")
  ((|#3| $ (|Integer|) (|Integer|))
   "\\spad{elt(m,{} i,{} j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m}. Error: if indices are outside the proper ranges."))
 (|listOfLists|
  (((|List| (|List| |#3|)) $)
   "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list of lists."))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(m)} returns the number of columns in the matrix \\spad{m}."))
 (|nrows|
  (((|NonNegativeInteger|) $)
   "\\spad{nrows(m)} returns the number of rows in the matrix \\spad{m}."))
 (|maxColIndex|
  (((|Integer|) $)
   "\\spad{maxColIndex(m)} returns the index of the 'last' column of the matrix \\spad{m}."))
 (|minColIndex|
  (((|Integer|) $)
   "\\spad{minColIndex(m)} returns the index of the 'first' column of the matrix \\spad{m}."))
 (|maxRowIndex|
  (((|Integer|) $)
   "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the matrix \\spad{m}."))
 (|minRowIndex|
  (((|Integer|) $)
   "\\spad{minRowIndex(m)} returns the index of the 'first' row of the matrix \\spad{m}."))
 (|antisymmetric?|
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise.")
  (((|Boolean|) $)
   "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = -m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|symmetric?|
  (((|Boolean|) $)
   "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (\\spadignore{i.e.} \\spad{m[i,{} j] = m[j,{} i]} for all \\spad{i} and \\spad{j}) and \\spad{false} otherwise."))
 (|diagonal?|
  (((|Boolean|) $)
   "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (\\spadignore{i.e.} all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise."))
 (|square?|
  (((|Boolean|) $)
   "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (\\spadignore{i.e.} if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise."))
 (|matrix|
  (($ (|List| (|List| |#3|)))
   "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix."))) 
NIL 
(|RectangularMatrix| |m| |n| R) 
((|constructor|
  (NIL
   "\\spadtype{RectangularMatrix} is a matrix domain where the number of rows and the number of columns are parameters of the domain."))
 (|coerce|
  (((|Matrix| |#3|) $)
   "\\spad{coerce(m)} converts a matrix of type \\spadtype{RectangularMatrix} to a matrix of type \\spad{Matrix}."))
 (|rectangularMatrix|
  (($ (|Matrix| |#3|))
   "\\spad{rectangularMatrix(m)} converts a matrix of type \\spadtype{Matrix} to a matrix of type \\spad{RectangularMatrix}."))) 
((|HasCategory| |#3| '(|AbelianGroup|))
 (|HasCategory| |#3| '(|CommutativeRing|)) (|HasCategory| |#3| '(|Finite|))
 (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
      (|HasCategory| |#3| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Finite|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SetCategory|))))
 (|HasCategory| |#3| '(|BasicType|)) (|HasCategory| |#3| '(|OrderedSet|))
 (|HasCategory| |#3| '(|Field|)) (|HasCategory| |#3| '(|EuclideanDomain|))
 (|HasCategory| |#3| '(|IntegralDomain|))
 (|HasCategory| |#3| '(|AbelianMonoid|))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|)))
 (|HasCategory| |#3| (LIST '|ConvertibleTo| '(|InputForm|)))
 (OR (|HasCategory| |#3| (LIST '|ConvertibleTo| '(|InputForm|)))
     (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
          (|HasCategory| |#3| '(|Finite|)))
     (AND (|HasCategory| |#3| '(|AbelianGroup|))
          (|HasCategory| |#3| '(|Finite|)))
     (AND (|HasCategory| |#3| '(|AbelianMonoid|))
          (|HasCategory| |#3| '(|Finite|)))
     (AND (|HasCategory| |#3| '(|CommutativeRing|))
          (|HasCategory| |#3| '(|Finite|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#3| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#3| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|RectangularMatrixCategoryFunctions2| |m| |n| R1 |Row1| |Col1| M1 R2 |Row2|
                                       |Col2| M2) 
((|constructor|
  (NIL
   "\\spadtype{RectangularMatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \\spadfun{map} and \\spadfun{reduce}."))
 (|reduce|
  ((|#7| (|Mapping| |#7| |#3| |#7|) |#6| |#7|)
   "\\spad{reduce(f,{} m,{} r)} returns a matrix \\spad{n} where \\spad{n[i,{} j] = f(m[i,{} j],{} r)} for all indices spad{\\spad{i}} and \\spad{j}."))
 (|map|
  ((|#10| (|Mapping| |#7| |#3|) |#6|)
   "\\spad{map(f,{} m)} applies the function \\spad{f} to the elements of the matrix \\spad{m}."))) 
NIL 
(|RightModule| R) 
((|constructor|
  (NIL
   "The category of right modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports right multiplation by elements of the \\spad{rng}. \\blankline"))
 (*
  (($ $ |#1|)
   "\\spad{x*r} returns the right multiplication of the module element \\spad{x} by the ring element \\spad{r}."))) 
NIL 
(|Rng&| S) 
((|constructor|
  (NIL
   "The category of associative rings,{} not necessarily commutative,{} and not necessarily with a 1. This is a combination of an abelian group and a semigroup,{} with multiplication distributing over addition. \\blankline"))
 (|annihilate?|
  (((|Boolean|) $ $)
   "\\spad{annihilate?(x,{}y)} holds when the product of \\spad{x} and \\spad{y} is \\spad{0}."))) 
NIL 
(|Rng|) 
((|constructor|
  (NIL
   "The category of associative rings,{} not necessarily commutative,{} and not necessarily with a 1. This is a combination of an abelian group and a semigroup,{} with multiplication distributing over addition. \\blankline"))
 (|annihilate?|
  (((|Boolean|) $ $)
   "\\spad{annihilate?(x,{}y)} holds when the product of \\spad{x} and \\spad{y} is \\spad{0}."))) 
NIL 
(|RealNumberSystem&| S) 
((|constructor|
  (NIL
   "The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \\spadtype{DifferentialRing} or the elementary functions (see \\spadtype{TranscendentalFunctionCategory}) in the definition."))
 (|round| (($ $) "\\spad{round x} computes the integer closest to \\spad{x}."))
 (|truncate|
  (($ $)
   "\\spad{truncate x} returns the integer between \\spad{x} and 0 closest to \\spad{x}."))
 (|fractionPart|
  (($ $) "\\spad{fractionPart x} returns the fractional part of \\spad{x}."))
 (|wholePart|
  (((|Integer|) $)
   "\\spad{wholePart x} returns the integer part of \\spad{x}."))
 (|floor| (($ $) "\\spad{floor x} returns the largest integer \\spad{<= x}."))
 (|ceiling|
  (($ $) "\\spad{ceiling x} returns the small integer \\spad{>= x}."))
 (|norm| (($ $) "\\spad{norm x} returns the same as absolute value."))) 
NIL 
(|RealNumberSystem|) 
((|constructor|
  (NIL
   "The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \\spadtype{DifferentialRing} or the elementary functions (see \\spadtype{TranscendentalFunctionCategory}) in the definition."))
 (|round| (($ $) "\\spad{round x} computes the integer closest to \\spad{x}."))
 (|truncate|
  (($ $)
   "\\spad{truncate x} returns the integer between \\spad{x} and 0 closest to \\spad{x}."))
 (|fractionPart|
  (($ $) "\\spad{fractionPart x} returns the fractional part of \\spad{x}."))
 (|wholePart|
  (((|Integer|) $)
   "\\spad{wholePart x} returns the integer part of \\spad{x}."))
 (|floor| (($ $) "\\spad{floor x} returns the largest integer \\spad{<= x}."))
 (|ceiling|
  (($ $) "\\spad{ceiling x} returns the small integer \\spad{>= x}."))
 (|norm| (($ $) "\\spad{norm x} returns the same as absolute value."))) 
NIL 
(|RightOpenIntervalRootCharacterization| |TheField| |ThePolDom|) 
((|constructor|
  (NIL
   "\\spadtype{RightOpenIntervalRootCharacterization} provides work with interval root coding."))
 (|relativeApprox|
  ((|#1| |#2| $ |#1|)
   "\\spad{relativeApprox(exp,{} c,{} p) = a} is relatively close to exp as a polynomial in \\spad{c} up to precision \\spad{p}"))
 (|mightHaveRoots|
  (((|Boolean|) |#2| $)
   "\\spad{mightHaveRoots(p,{} r)} is \\spad{false} if \\spad{p.r} is not 0"))
 (|refine|
  (($ $)
   "\\spad{refine(rootChar)} shrinks isolating interval around \\spad{rootChar}"))
 (|middle|
  ((|#1| $)
   "\\spad{middle(rootChar)} is the middle of the isolating interval"))
 (|size| ((|#1| $) "The size of the isolating interval"))
 (|right|
  ((|#1| $)
   "\\spad{right(rootChar)} is the right bound of the isolating interval"))
 (|left|
  ((|#1| $)
   "\\spad{left(rootChar)} is the left bound of the isolating interval"))) 
NIL 
(|RomanNumeral|) 
((|constructor|
  (NIL
   "\\spadtype{RomanNumeral} provides functions for converting \\indented{1}{integers to roman numerals.}"))
 (|roman|
  (($ (|Integer|)) "\\spad{roman(n)} creates a roman numeral for \\spad{n}.")
  (($ (|Symbol|))
   "\\spad{roman(n)} creates a roman numeral for symbol \\spad{n}."))
 (|convert|
  (($ (|Symbol|))
   "\\spad{convert(n)} creates a roman numeral for symbol \\spad{n}."))) 
NIL 
(|RecursivePolynomialCategory&| S R E V) 
((|constructor|
  (NIL
   "A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \\spadfun{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \\spad{w}. \\spad{r}. \\spad{t}. to the total ordering on the elements in the ordered set,{} so that some operations usually defined for univariate polynomials make sense here."))
 (|mainSquareFreePart|
  (($ $)
   "\\spad{mainSquareFreePart(p)} returns the square free part of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|mainPrimitivePart|
  (($ $)
   "\\spad{mainPrimitivePart(p)} returns the primitive part of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|mainContent|
  (($ $)
   "\\spad{mainContent(p)} returns the content of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|primitivePart!|
  (($ $)
   "\\spad{primitivePart!(p)} replaces \\spad{p} by its primitive part."))
 (|gcd|
  ((|#2| |#2| $)
   "\\spad{gcd(r,{} p)} returns the \\spad{gcd} of \\spad{r} and the content of \\spad{p}."))
 (|iexactQuo|
  ((|#2| |#2| |#2|)
   "\\spad{iexactQuo(x,{} y)} should be local but conditional"))
 (|next_subResultant2|
  (($ $ $ $ $)
   "\\spad{next_subResultant2(p,{} q,{} z,{} s)} is the multivariate version of the operation \\spadopFrom{\\spad{next_sousResultant2}}{PseudoRemainderSequence} from the \\spadtype{PseudoRemainderSequence} constructor."))
 (|LazardQuotient2|
  (($ $ $ $ (|NonNegativeInteger|))
   "\\spad{LazardQuotient2(p,{} a,{} b,{} n)} returns \\spad{(a^(n-1) * p) exquo b^(n-1)} assuming that this quotient does not fail."))
 (|LazardQuotient|
  (($ $ $ (|NonNegativeInteger|))
   "\\spad{LazardQuotient(a,{} b,{} n)} returns \\spad{a^n exquo b^(n-1)} assuming that this quotient does not fail."))
 (|lastSubResultant|
  (($ $ $)
   "\\spad{lastSubResultant(a,{} b)} returns the last non-zero subresultant of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v}."))
 (|subResultantChain|
  (((|List| $) $ $)
   "\\spad{subResultantChain(a,{} b)},{} where \\spad{a} and \\spad{b} are not constant polynomials with the same main variable,{} returns the subresultant chain of \\spad{a} and \\spad{b}."))
 (|resultant|
  (($ $ $)
   "\\spad{resultant(a,{} b)} computes the resultant of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v}."))
 (|halfExtendedSubResultantGcd2|
  (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd2(a,{} b)} returns \\spad{[g,{} cb]} if \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} otherwise produces an error."))
 (|halfExtendedSubResultantGcd1|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd1(a,{} b)} returns \\spad{[g,{} ca]} if \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} otherwise produces an error."))
 (|extendedSubResultantGcd|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $)
   "\\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} such that \\spad{g} is \\spad{subResultantGcd(a,{} b)} and we have \\spad{ca * a + cb * cb = g}."))
 (|subResultantGcd|
  (($ $ $)
   "\\spad{subResultantGcd(a,{} b)} computes a \\spad{gcd} of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v} with coefficients in the fraction field of the polynomial ring generated by their other variables over \\spad{R}."))
 (|exactQuotient!|
  (($ $ $)
   "\\spad{exactQuotient!(a,{} b)} replaces \\spad{a} by \\spad{exactQuotient(a,{} b)}")
  (($ $ |#2|)
   "\\spad{exactQuotient!(p,{} r)} replaces \\spad{p} by \\spad{exactQuotient(p,{} r)}."))
 (|exactQuotient|
  (($ $ $)
   "\\spad{exactQuotient(a,{} b)} computes the exact quotient of \\spad{a} by \\spad{b},{} which is assumed to be a divisor of \\spad{a}. No error is returned if this exact quotient fails!")
  (($ $ |#2|)
   "\\spad{exactQuotient(p,{} r)} computes the exact quotient of \\spad{p} by \\spad{r},{} which is assumed to be a divisor of \\spad{p}. No error is returned if this exact quotient fails!"))
 (|primPartElseUnitCanonical!|
  (($ $)
   "\\spad{primPartElseUnitCanonical!(p)} replaces \\spad{p} by \\spad{primPartElseUnitCanonical(p)}."))
 (|primPartElseUnitCanonical|
  (($ $)
   "\\spad{primPartElseUnitCanonical(p)} returns \\spad{primitivePart(p)} if \\spad{R} is a \\spad{gcd}-domain,{} otherwise \\spad{unitCanonical(p)}."))
 (|convert|
  (($ (|Polynomial| |#2|))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}.")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}.")
  (($ (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}."))
 (|retract|
  (($ (|Polynomial| |#2|))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced.")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced.")
  (($ (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced."))
 (|retractIfCan|
  (((|Union| $ "failed") (|Polynomial| |#2|))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}.")
  (((|Union| $ "failed") (|Polynomial| (|Integer|)))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}.")
  (((|Union| $ "failed") (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}."))
 (|initiallyReduce|
  (($ $ $)
   "\\spad{initiallyReduce(a,{} b)} returns a polynomial \\spad{r} such that \\spad{initiallyReduced?(r,{} b)} holds and there exists an integer \\spad{e} such that \\spad{init(b)^e a - r} is zero modulo \\spad{b}."))
 (|headReduce|
  (($ $ $)
   "\\spad{headReduce(a,{} b)} returns a polynomial \\spad{r} such that \\spad{headReduced?(r,{} b)} holds and there exists an integer \\spad{e} such that \\spad{init(b)^e a - r} is zero modulo \\spad{b}."))
 (|lazyResidueClass|
  (((|Record| (|:| |polnum| $) (|:| |polden| $)
              (|:| |power| (|NonNegativeInteger|)))
    $ $)
   "\\spad{lazyResidueClass(a,{} b)} returns \\spad{[p,{} q,{} n]} where \\spad{p / q^n} represents the residue class of \\spad{a} modulo \\spad{b} and \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and \\spad{q} is \\spad{init(b)}."))
 (|monicModulo|
  (($ $ $)
   "\\spad{monicModulo(a,{} b)} computes \\spad{a mod b},{} if \\spad{b} is monic as univariate polynomial in its main variable."))
 (|pseudoDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{pseudoDivide(a,{} b)} computes \\spad{[pquo(a,{} b),{} prem(a,{} b)]},{} both polynomials viewed as univariate polynomials in the main variable of \\spad{b},{} if \\spad{b} is not a constant polynomial."))
 (|lazyPseudoDivide|
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |quotient| $) (|:| |remainder| $))
    $ $ |#4|)
   "\\spad{lazyPseudoDivide(a,{} b,{} v)} returns \\spad{[c,{} g,{} q,{} r]} such that \\spad{r = lazyPrem(a,{} b,{} v)},{} \\spad{(c^g)*r = prem(a,{} b,{} v)} and \\spad{q} is the pseudo-quotient computed in this lazy pseudo-division.")
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |quotient| $) (|:| |remainder| $))
    $ $)
   "\\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]} such that \\spad{[c,{} g,{} r] = lazyPremWithDefault(a,{} b)} and \\spad{q} is the pseudo-quotient computed in this lazy pseudo-division."))
 (|lazyPremWithDefault|
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |remainder| $))
    $ $ |#4|)
   "\\spad{lazyPremWithDefault(a,{} b,{} v)} returns \\spad{[c,{} g,{} r]} such that \\spad{r = lazyPrem(a,{} b,{} v)} and \\spad{(c^g)*r = prem(a,{} b,{} v)}.")
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |remainder| $))
    $ $)
   "\\spad{lazyPremWithDefault(a,{} b)} returns \\spad{[c,{} g,{} r]} such that \\spad{r = lazyPrem(a,{} b)} and \\spad{(c^g)*r = prem(a,{} b)}."))
 (|lazyPquo|
  (($ $ $ |#4|)
   "\\spad{lazyPquo(a,{} b,{} v)} returns the polynomial \\spad{q} such that \\spad{lazyPseudoDivide(a,{} b,{} v)} returns \\spad{[c,{} g,{} q,{} r]}.")
  (($ $ $)
   "\\spad{lazyPquo(a,{} b)} returns the polynomial \\spad{q} such that \\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]}."))
 (|lazyPrem|
  (($ $ $ |#4|)
   "\\spad{lazyPrem(a,{} b,{} v)} returns the polynomial \\spad{r} reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} viewed as univariate polynomials in the variable \\spad{v} such that \\spad{b} divides \\spad{init(b)^e a - r} where \\spad{e} is the number of steps of this pseudo-division.")
  (($ $ $)
   "\\spad{lazyPrem(a,{} b)} returns the polynomial \\spad{r} reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and such that \\spad{b} divides \\spad{init(b)^e a - r} where \\spad{e} is the number of steps of this pseudo-division."))
 (|pquo|
  (($ $ $ |#4|)
   "\\spad{pquo(a,{} b,{} v)} computes the pseudo-quotient of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in \\spad{v}.")
  (($ $ $)
   "\\spad{pquo(a,{} b)} computes the pseudo-quotient of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in the main variable of \\spad{b}."))
 (|prem|
  (($ $ $ |#4|)
   "\\spad{prem(a,{} b,{} v)} computes the pseudo-remainder of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in \\spad{v}.")
  (($ $ $)
   "\\spad{prem(a,{} b)} computes the pseudo-remainder of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in the main variable of \\spad{b}."))
 (|normalized?|
  (((|Boolean|) $ (|List| $))
   "\\spad{normalized?(q,{} lp)} returns \\spad{true} iff \\spad{normalized?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{normalized?(a,{} b)} returns \\spad{true} iff \\spad{a} and its iterated initials have degree zero \\spad{w}.\\spad{r}.\\spad{t}. the main variable of \\spad{b}"))
 (|initiallyReduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{initiallyReduced?(q,{} lp)} returns \\spad{true} iff \\spad{initiallyReduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{initiallyReduced?(a,{} b)} returns \\spad{false} iff there exists an iterated initial of \\spad{a} which is not reduced \\spad{w}.\\spad{r}.\\spad{t} \\spad{b}."))
 (|headReduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{headReduced?(q,{} lp)} returns \\spad{true} iff \\spad{headReduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{headReduced?(a,{} b)} returns \\spad{true} iff \\spad{degree(head(a),{} mvar(b)) < mdeg(b)}."))
 (|reduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{reduced?(q,{} lp)} returns \\spad{true} iff \\spad{reduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{reduced?(a,{} b)} returns \\spad{true} iff \\spad{degree(a,{} mvar(b)) < mdeg(b)}."))
 (|supRittWu?|
  (((|Boolean|) $ $)
   "\\spad{supRittWu?(a,{} b)} returns \\spad{true} if \\spad{a} is greater than \\spad{b} \\spad{w}.\\spad{r}.\\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard."))
 (|infRittWu?|
  (((|Boolean|) $ $)
   "\\spad{infRittWu?(a,{} b)} returns \\spad{true} if \\spad{a} is less than \\spad{b} \\spad{w}.\\spad{r}.\\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard."))
 (|RittWuCompare|
  (((|Union| (|Boolean|) "failed") $ $)
   "\\spad{RittWuCompare(a,{}b)} returns \\spad{\"failed\"} if \\spad{a} and \\spad{b} have same rank \\spad{w}.\\spad{r}.\\spad{t}. Ritt and Wu Wen Tsun ordering using the refinement of Lazard,{} otherwise returns \\spad{infRittWu?(a,{} b)}."))
 (|mainMonomials|
  (((|List| $) $)
   "\\spad{mainMonomials(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns [1],{} otherwise returns the list of the monomials of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mainCoefficients|
  (((|List| $) $)
   "\\spad{mainCoefficients(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns [\\spad{p}],{} otherwise returns the list of the coefficients of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|leastMonomial|
  (($ $)
   "\\spad{leastMonomial(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{1},{} otherwise,{} the monomial of \\spad{p} with lowest degree,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mainMonomial|
  (($ $)
   "\\spad{mainMonomial(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{1},{} otherwise,{} \\spad{mvar(p)} raised to the power \\spad{mdeg(p)}."))
 (|quasiMonic?|
  (((|Boolean|) $)
   "\\spad{quasiMonic?(p)} returns \\spad{false} if \\spad{p} belongs to \\spad{R},{} otherwise returns \\spad{true} iff the initial of \\spad{p} lies in the base ring \\spad{R}."))
 (|monic?|
  (((|Boolean|) $)
   "\\spad{monic?(p)} returns \\spad{false} if \\spad{p} belongs to \\spad{R},{} otherwise returns \\spad{true} iff \\spad{p} is monic as a univariate polynomial in its main variable."))
 (|reductum|
  (($ $ |#4|)
   "\\spad{reductum(p,{} v)} returns the reductum of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in \\spad{v}."))
 (|leadingCoefficient|
  (($ $ |#4|)
   "\\spad{leadingCoefficient(p,{} v)} returns the leading coefficient of \\spad{p},{} where \\spad{p} is viewed as A univariate polynomial in \\spad{v}."))
 (|deepestInitial|
  (($ $)
   "\\spad{deepestInitial(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns the last term of \\spad{iteratedInitials(p)}."))
 (|iteratedInitials|
  (((|List| $) $)
   "\\spad{iteratedInitials(p)} returns \\spad{[]} if \\spad{p} belongs to \\spad{R},{} otherwise returns the list of the iterated initials of \\spad{p}."))
 (|deepestTail|
  (($ $)
   "\\spad{deepestTail(p)} returns \\spad{0} if \\spad{p} belongs to \\spad{R},{} otherwise returns tail(\\spad{p}),{} if \\spad{tail(p)} belongs to \\spad{R} or \\spad{mvar(tail(p)) < mvar(p)},{} otherwise returns \\spad{deepestTail(tail(p))}."))
 (|tail|
  (($ $)
   "\\spad{tail(p)} returns its reductum,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|head|
  (($ $)
   "\\spad{head(p)} returns \\spad{p} if \\spad{p} belongs to \\spad{R},{} otherwise returns its leading term (monomial in the FriCAS sense),{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|init|
  (($ $)
   "\\spad{init(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns its leading coefficient,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mdeg|
  (((|NonNegativeInteger|) $)
   "\\spad{mdeg(p)} returns an error if \\spad{p} is \\spad{0},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{0},{} otherwise,{} returns the degree of \\spad{p} in its main variable."))
 (|mvar|
  ((|#4| $)
   "\\spad{mvar(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns its main variable \\spad{w}. \\spad{r}. \\spad{t}. to the total ordering on the elements in \\spad{V}."))) 
((|HasCategory| |#2| '(|GcdDomain|)) (|HasCategory| |#2| '(|IntegralDomain|))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|Algebra| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|Symbol|)))) 
(|RecursivePolynomialCategory| R E V) 
((|constructor|
  (NIL
   "A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \\spadfun{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \\spad{w}. \\spad{r}. \\spad{t}. to the total ordering on the elements in the ordered set,{} so that some operations usually defined for univariate polynomials make sense here."))
 (|mainSquareFreePart|
  (($ $)
   "\\spad{mainSquareFreePart(p)} returns the square free part of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|mainPrimitivePart|
  (($ $)
   "\\spad{mainPrimitivePart(p)} returns the primitive part of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|mainContent|
  (($ $)
   "\\spad{mainContent(p)} returns the content of \\spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\spad{R}."))
 (|primitivePart!|
  (($ $)
   "\\spad{primitivePart!(p)} replaces \\spad{p} by its primitive part."))
 (|gcd|
  ((|#1| |#1| $)
   "\\spad{gcd(r,{} p)} returns the \\spad{gcd} of \\spad{r} and the content of \\spad{p}."))
 (|iexactQuo|
  ((|#1| |#1| |#1|)
   "\\spad{iexactQuo(x,{} y)} should be local but conditional"))
 (|next_subResultant2|
  (($ $ $ $ $)
   "\\spad{next_subResultant2(p,{} q,{} z,{} s)} is the multivariate version of the operation \\spadopFrom{\\spad{next_sousResultant2}}{PseudoRemainderSequence} from the \\spadtype{PseudoRemainderSequence} constructor."))
 (|LazardQuotient2|
  (($ $ $ $ (|NonNegativeInteger|))
   "\\spad{LazardQuotient2(p,{} a,{} b,{} n)} returns \\spad{(a^(n-1) * p) exquo b^(n-1)} assuming that this quotient does not fail."))
 (|LazardQuotient|
  (($ $ $ (|NonNegativeInteger|))
   "\\spad{LazardQuotient(a,{} b,{} n)} returns \\spad{a^n exquo b^(n-1)} assuming that this quotient does not fail."))
 (|lastSubResultant|
  (($ $ $)
   "\\spad{lastSubResultant(a,{} b)} returns the last non-zero subresultant of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v}."))
 (|subResultantChain|
  (((|List| $) $ $)
   "\\spad{subResultantChain(a,{} b)},{} where \\spad{a} and \\spad{b} are not constant polynomials with the same main variable,{} returns the subresultant chain of \\spad{a} and \\spad{b}."))
 (|resultant|
  (($ $ $)
   "\\spad{resultant(a,{} b)} computes the resultant of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v}."))
 (|halfExtendedSubResultantGcd2|
  (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd2(a,{} b)} returns \\spad{[g,{} cb]} if \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} otherwise produces an error."))
 (|halfExtendedSubResultantGcd1|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $)
   "\\spad{halfExtendedSubResultantGcd1(a,{} b)} returns \\spad{[g,{} ca]} if \\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} otherwise produces an error."))
 (|extendedSubResultantGcd|
  (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $)
   "\\spad{extendedSubResultantGcd(a,{} b)} returns \\spad{[g,{} ca,{} cb]} such that \\spad{g} is \\spad{subResultantGcd(a,{} b)} and we have \\spad{ca * a + cb * cb = g}."))
 (|subResultantGcd|
  (($ $ $)
   "\\spad{subResultantGcd(a,{} b)} computes a \\spad{gcd} of \\spad{a} and \\spad{b} where \\spad{a} and \\spad{b} are assumed to have the same main variable \\spad{v} and are viewed as univariate polynomials in \\spad{v} with coefficients in the fraction field of the polynomial ring generated by their other variables over \\spad{R}."))
 (|exactQuotient!|
  (($ $ $)
   "\\spad{exactQuotient!(a,{} b)} replaces \\spad{a} by \\spad{exactQuotient(a,{} b)}")
  (($ $ |#1|)
   "\\spad{exactQuotient!(p,{} r)} replaces \\spad{p} by \\spad{exactQuotient(p,{} r)}."))
 (|exactQuotient|
  (($ $ $)
   "\\spad{exactQuotient(a,{} b)} computes the exact quotient of \\spad{a} by \\spad{b},{} which is assumed to be a divisor of \\spad{a}. No error is returned if this exact quotient fails!")
  (($ $ |#1|)
   "\\spad{exactQuotient(p,{} r)} computes the exact quotient of \\spad{p} by \\spad{r},{} which is assumed to be a divisor of \\spad{p}. No error is returned if this exact quotient fails!"))
 (|primPartElseUnitCanonical!|
  (($ $)
   "\\spad{primPartElseUnitCanonical!(p)} replaces \\spad{p} by \\spad{primPartElseUnitCanonical(p)}."))
 (|primPartElseUnitCanonical|
  (($ $)
   "\\spad{primPartElseUnitCanonical(p)} returns \\spad{primitivePart(p)} if \\spad{R} is a \\spad{gcd}-domain,{} otherwise \\spad{unitCanonical(p)}."))
 (|convert|
  (($ (|Polynomial| |#1|))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}.")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}.")
  (($ (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{convert(p)} returns the same as \\spad{retract(p)}."))
 (|retract|
  (($ (|Polynomial| |#1|))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced.")
  (($ (|Polynomial| (|Integer|)))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced.")
  (($ (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{retract(p)} returns \\spad{p} as an element of the current domain,{} if \\spad{retractIfCan(p)} does not return \"failed\",{} otherwise an error is produced."))
 (|retractIfCan|
  (((|Union| $ "failed") (|Polynomial| |#1|))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}.")
  (((|Union| $ "failed") (|Polynomial| (|Integer|)))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}.")
  (((|Union| $ "failed") (|Polynomial| (|Fraction| (|Integer|))))
   "\\spad{retractIfCan(p)} returns \\spad{p} as an element of the current domain,{} if all its variables belong to \\spad{V}."))
 (|initiallyReduce|
  (($ $ $)
   "\\spad{initiallyReduce(a,{} b)} returns a polynomial \\spad{r} such that \\spad{initiallyReduced?(r,{} b)} holds and there exists an integer \\spad{e} such that \\spad{init(b)^e a - r} is zero modulo \\spad{b}."))
 (|headReduce|
  (($ $ $)
   "\\spad{headReduce(a,{} b)} returns a polynomial \\spad{r} such that \\spad{headReduced?(r,{} b)} holds and there exists an integer \\spad{e} such that \\spad{init(b)^e a - r} is zero modulo \\spad{b}."))
 (|lazyResidueClass|
  (((|Record| (|:| |polnum| $) (|:| |polden| $)
              (|:| |power| (|NonNegativeInteger|)))
    $ $)
   "\\spad{lazyResidueClass(a,{} b)} returns \\spad{[p,{} q,{} n]} where \\spad{p / q^n} represents the residue class of \\spad{a} modulo \\spad{b} and \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and \\spad{q} is \\spad{init(b)}."))
 (|monicModulo|
  (($ $ $)
   "\\spad{monicModulo(a,{} b)} computes \\spad{a mod b},{} if \\spad{b} is monic as univariate polynomial in its main variable."))
 (|pseudoDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{pseudoDivide(a,{} b)} computes \\spad{[pquo(a,{} b),{} prem(a,{} b)]},{} both polynomials viewed as univariate polynomials in the main variable of \\spad{b},{} if \\spad{b} is not a constant polynomial."))
 (|lazyPseudoDivide|
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |quotient| $) (|:| |remainder| $))
    $ $ |#3|)
   "\\spad{lazyPseudoDivide(a,{} b,{} v)} returns \\spad{[c,{} g,{} q,{} r]} such that \\spad{r = lazyPrem(a,{} b,{} v)},{} \\spad{(c^g)*r = prem(a,{} b,{} v)} and \\spad{q} is the pseudo-quotient computed in this lazy pseudo-division.")
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |quotient| $) (|:| |remainder| $))
    $ $)
   "\\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]} such that \\spad{[c,{} g,{} r] = lazyPremWithDefault(a,{} b)} and \\spad{q} is the pseudo-quotient computed in this lazy pseudo-division."))
 (|lazyPremWithDefault|
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |remainder| $))
    $ $ |#3|)
   "\\spad{lazyPremWithDefault(a,{} b,{} v)} returns \\spad{[c,{} g,{} r]} such that \\spad{r = lazyPrem(a,{} b,{} v)} and \\spad{(c^g)*r = prem(a,{} b,{} v)}.")
  (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|))
              (|:| |remainder| $))
    $ $)
   "\\spad{lazyPremWithDefault(a,{} b)} returns \\spad{[c,{} g,{} r]} such that \\spad{r = lazyPrem(a,{} b)} and \\spad{(c^g)*r = prem(a,{} b)}."))
 (|lazyPquo|
  (($ $ $ |#3|)
   "\\spad{lazyPquo(a,{} b,{} v)} returns the polynomial \\spad{q} such that \\spad{lazyPseudoDivide(a,{} b,{} v)} returns \\spad{[c,{} g,{} q,{} r]}.")
  (($ $ $)
   "\\spad{lazyPquo(a,{} b)} returns the polynomial \\spad{q} such that \\spad{lazyPseudoDivide(a,{} b)} returns \\spad{[c,{} g,{} q,{} r]}."))
 (|lazyPrem|
  (($ $ $ |#3|)
   "\\spad{lazyPrem(a,{} b,{} v)} returns the polynomial \\spad{r} reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} viewed as univariate polynomials in the variable \\spad{v} such that \\spad{b} divides \\spad{init(b)^e a - r} where \\spad{e} is the number of steps of this pseudo-division.")
  (($ $ $)
   "\\spad{lazyPrem(a,{} b)} returns the polynomial \\spad{r} reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{b} and such that \\spad{b} divides \\spad{init(b)^e a - r} where \\spad{e} is the number of steps of this pseudo-division."))
 (|pquo|
  (($ $ $ |#3|)
   "\\spad{pquo(a,{} b,{} v)} computes the pseudo-quotient of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in \\spad{v}.")
  (($ $ $)
   "\\spad{pquo(a,{} b)} computes the pseudo-quotient of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in the main variable of \\spad{b}."))
 (|prem|
  (($ $ $ |#3|)
   "\\spad{prem(a,{} b,{} v)} computes the pseudo-remainder of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in \\spad{v}.")
  (($ $ $)
   "\\spad{prem(a,{} b)} computes the pseudo-remainder of \\spad{a} by \\spad{b},{} both viewed as univariate polynomials in the main variable of \\spad{b}."))
 (|normalized?|
  (((|Boolean|) $ (|List| $))
   "\\spad{normalized?(q,{} lp)} returns \\spad{true} iff \\spad{normalized?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{normalized?(a,{} b)} returns \\spad{true} iff \\spad{a} and its iterated initials have degree zero \\spad{w}.\\spad{r}.\\spad{t}. the main variable of \\spad{b}"))
 (|initiallyReduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{initiallyReduced?(q,{} lp)} returns \\spad{true} iff \\spad{initiallyReduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{initiallyReduced?(a,{} b)} returns \\spad{false} iff there exists an iterated initial of \\spad{a} which is not reduced \\spad{w}.\\spad{r}.\\spad{t} \\spad{b}."))
 (|headReduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{headReduced?(q,{} lp)} returns \\spad{true} iff \\spad{headReduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{headReduced?(a,{} b)} returns \\spad{true} iff \\spad{degree(head(a),{} mvar(b)) < mdeg(b)}."))
 (|reduced?|
  (((|Boolean|) $ (|List| $))
   "\\spad{reduced?(q,{} lp)} returns \\spad{true} iff \\spad{reduced?(q,{} p)} holds for every \\spad{p} in \\spad{lp}.")
  (((|Boolean|) $ $)
   "\\spad{reduced?(a,{} b)} returns \\spad{true} iff \\spad{degree(a,{} mvar(b)) < mdeg(b)}."))
 (|supRittWu?|
  (((|Boolean|) $ $)
   "\\spad{supRittWu?(a,{} b)} returns \\spad{true} if \\spad{a} is greater than \\spad{b} \\spad{w}.\\spad{r}.\\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard."))
 (|infRittWu?|
  (((|Boolean|) $ $)
   "\\spad{infRittWu?(a,{} b)} returns \\spad{true} if \\spad{a} is less than \\spad{b} \\spad{w}.\\spad{r}.\\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard."))
 (|RittWuCompare|
  (((|Union| (|Boolean|) "failed") $ $)
   "\\spad{RittWuCompare(a,{}b)} returns \\spad{\"failed\"} if \\spad{a} and \\spad{b} have same rank \\spad{w}.\\spad{r}.\\spad{t}. Ritt and Wu Wen Tsun ordering using the refinement of Lazard,{} otherwise returns \\spad{infRittWu?(a,{} b)}."))
 (|mainMonomials|
  (((|List| $) $)
   "\\spad{mainMonomials(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns [1],{} otherwise returns the list of the monomials of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mainCoefficients|
  (((|List| $) $)
   "\\spad{mainCoefficients(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns [\\spad{p}],{} otherwise returns the list of the coefficients of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|leastMonomial|
  (($ $)
   "\\spad{leastMonomial(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{1},{} otherwise,{} the monomial of \\spad{p} with lowest degree,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mainMonomial|
  (($ $)
   "\\spad{mainMonomial(p)} returns an error if \\spad{p} is \\spad{O},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{1},{} otherwise,{} \\spad{mvar(p)} raised to the power \\spad{mdeg(p)}."))
 (|quasiMonic?|
  (((|Boolean|) $)
   "\\spad{quasiMonic?(p)} returns \\spad{false} if \\spad{p} belongs to \\spad{R},{} otherwise returns \\spad{true} iff the initial of \\spad{p} lies in the base ring \\spad{R}."))
 (|monic?|
  (((|Boolean|) $)
   "\\spad{monic?(p)} returns \\spad{false} if \\spad{p} belongs to \\spad{R},{} otherwise returns \\spad{true} iff \\spad{p} is monic as a univariate polynomial in its main variable."))
 (|reductum|
  (($ $ |#3|)
   "\\spad{reductum(p,{} v)} returns the reductum of \\spad{p},{} where \\spad{p} is viewed as a univariate polynomial in \\spad{v}."))
 (|leadingCoefficient|
  (($ $ |#3|)
   "\\spad{leadingCoefficient(p,{} v)} returns the leading coefficient of \\spad{p},{} where \\spad{p} is viewed as A univariate polynomial in \\spad{v}."))
 (|deepestInitial|
  (($ $)
   "\\spad{deepestInitial(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns the last term of \\spad{iteratedInitials(p)}."))
 (|iteratedInitials|
  (((|List| $) $)
   "\\spad{iteratedInitials(p)} returns \\spad{[]} if \\spad{p} belongs to \\spad{R},{} otherwise returns the list of the iterated initials of \\spad{p}."))
 (|deepestTail|
  (($ $)
   "\\spad{deepestTail(p)} returns \\spad{0} if \\spad{p} belongs to \\spad{R},{} otherwise returns tail(\\spad{p}),{} if \\spad{tail(p)} belongs to \\spad{R} or \\spad{mvar(tail(p)) < mvar(p)},{} otherwise returns \\spad{deepestTail(tail(p))}."))
 (|tail|
  (($ $)
   "\\spad{tail(p)} returns its reductum,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|head|
  (($ $)
   "\\spad{head(p)} returns \\spad{p} if \\spad{p} belongs to \\spad{R},{} otherwise returns its leading term (monomial in the FriCAS sense),{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|init|
  (($ $)
   "\\spad{init(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns its leading coefficient,{} where \\spad{p} is viewed as a univariate polynomial in its main variable."))
 (|mdeg|
  (((|NonNegativeInteger|) $)
   "\\spad{mdeg(p)} returns an error if \\spad{p} is \\spad{0},{} otherwise,{} if \\spad{p} belongs to \\spad{R} returns \\spad{0},{} otherwise,{} returns the degree of \\spad{p} in its main variable."))
 (|mvar|
  ((|#3| $)
   "\\spad{mvar(p)} returns an error if \\spad{p} belongs to \\spad{R},{} otherwise returns its main variable \\spad{w}. \\spad{r}. \\spad{t}. to the total ordering on the elements in \\spad{V}."))) 
NIL 
(|RealRootCharacterizationCategory&| S |TheField| |ThePols|) 
((|constructor|
  (NIL
   "\\spadtype{RealRootCharacterizationCategory} provides common access functions for all real root codings."))
 (|relativeApprox|
  ((|#2| |#3| $ |#2|)
   "\\spad{approximate(term,{} root,{} prec)} gives an approximation of \\spad{term} over \\spad{root} with precision \\spad{prec}"))
 (|approximate|
  ((|#2| |#3| $ |#2|)
   "\\spad{approximate(term,{} root,{} prec)} gives an approximation of \\spad{term} over \\spad{root} with precision \\spad{prec}"))
 (|rootOf|
  (((|Union| $ "failed") |#3| (|PositiveInteger|))
   "\\spad{rootOf(pol,{} n)} gives the \\spad{n}th root for the order of the Real Closure"))
 (|allRootsOf|
  (((|List| $) |#3|)
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} in the Real Closure,{} assumed in order."))
 (|definingPolynomial|
  ((|#3| $)
   "\\spad{definingPolynomial(aRoot)} gives a polynomial such that \\spad{definingPolynomial(aRoot).aRoot = 0}"))
 (|recip|
  (((|Union| |#3| "failed") |#3| $)
   "\\spad{recip(pol,{} aRoot)} tries to inverse \\spad{pol} interpreted as \\spad{aRoot}"))
 (|positive?|
  (((|Boolean|) |#3| $)
   "\\spad{positive?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is positive"))
 (|negative?|
  (((|Boolean|) |#3| $)
   "\\spad{negative?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is negative"))
 (|zero?|
  (((|Boolean|) |#3| $)
   "\\spad{zero?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is \\spad{0}"))
 (|sign|
  (((|Integer|) |#3| $)
   "\\spad{sign(pol,{} aRoot)} gives the sign of \\spad{pol} interpreted as \\spad{aRoot}"))) 
NIL 
(|RealRootCharacterizationCategory| |TheField| |ThePols|) 
((|constructor|
  (NIL
   "\\spadtype{RealRootCharacterizationCategory} provides common access functions for all real root codings."))
 (|relativeApprox|
  ((|#1| |#2| $ |#1|)
   "\\spad{approximate(term,{} root,{} prec)} gives an approximation of \\spad{term} over \\spad{root} with precision \\spad{prec}"))
 (|approximate|
  ((|#1| |#2| $ |#1|)
   "\\spad{approximate(term,{} root,{} prec)} gives an approximation of \\spad{term} over \\spad{root} with precision \\spad{prec}"))
 (|rootOf|
  (((|Union| $ "failed") |#2| (|PositiveInteger|))
   "\\spad{rootOf(pol,{} n)} gives the \\spad{n}th root for the order of the Real Closure"))
 (|allRootsOf|
  (((|List| $) |#2|)
   "\\spad{allRootsOf(pol)} creates all the roots of \\spad{pol} in the Real Closure,{} assumed in order."))
 (|definingPolynomial|
  ((|#2| $)
   "\\spad{definingPolynomial(aRoot)} gives a polynomial such that \\spad{definingPolynomial(aRoot).aRoot = 0}"))
 (|recip|
  (((|Union| |#2| "failed") |#2| $)
   "\\spad{recip(pol,{} aRoot)} tries to inverse \\spad{pol} interpreted as \\spad{aRoot}"))
 (|positive?|
  (((|Boolean|) |#2| $)
   "\\spad{positive?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is positive"))
 (|negative?|
  (((|Boolean|) |#2| $)
   "\\spad{negative?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is negative"))
 (|zero?|
  (((|Boolean|) |#2| $)
   "\\spad{zero?(pol,{} aRoot)} answers if \\spad{pol} interpreted as \\spad{aRoot} is \\spad{0}"))
 (|sign|
  (((|Integer|) |#2| $)
   "\\spad{sign(pol,{} aRoot)} gives the sign of \\spad{pol} interpreted as \\spad{aRoot}"))) 
NIL 
(|RegularSetDecompositionPackage| R E V P TS) 
((|constructor|
  (NIL
   "A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are proposed: in the sense of Zariski closure (like in Kalkbrener\\spad{'s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard methods). This algorithm is valid for nay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \\spad{TS} and the packages \\spadtype{QCMPACK}(\\spad{R},{} \\spad{E},{} \\spad{V},{} \\spad{P},{} \\spad{TS}) and \\spadtype{RSETGCD}(\\spad{R},{} \\spad{E},{} \\spad{V},{} \\spad{P},{} \\spad{TS}). The same way it does not care about the way univariate polynomial \\spad{gcd} (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these \\spad{gcd} need to have invertible initials (normalized or not). WARNING. There is no need for a user to call diectly any operation of this package since they can be accessed by the domain \\spad{TS}. Thus,{} the operations of this package are not documented.\\newline"))) 
NIL 
(|RegularTriangularSetCategory&| S R E V P) 
((|constructor|
  (NIL
   "The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \\spad{k[x1,{} ...,{} xn]} where \\spad{k} is the fraction field of \\spad{R}. The triangular set \\spad{[t1,{} ...,{} tm]} is regular iff for every \\spad{i} the initial of \\spad{ti+1} is invertible in the tower of simple extensions associated with \\spad{[t1,{} ...,{} \\spad{ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \\spad{I} iff the radical of \\spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \\spad{[T1,{} ...,{} \\spad{Ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \\spad{T} iff it is a split of Kalkbrener of the saturated ideal of \\spad{T}. Let \\spad{K} be an algebraic closure of \\spad{k}. Assume that \\spad{V} is finite with cardinality \\spad{n} and let \\spad{A} be the affine space \\spad{K^n}. For a regular triangular set \\spad{T} let denote by \\spad{W(T)} the set of regular zeros of \\spad{T}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given subset \\spad{S} of \\spad{A} iff the union of the \\spad{W(\\spad{Ti})} contains \\spad{S} and is contained in the closure of \\spad{S} (\\spad{w}.\\spad{r}.\\spad{t}. Zariski topology). A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given triangular set \\spad{T} if it is a split of Lazard of \\spad{W(T)}. Note that if \\spad{[T1,{} ...,{} Ts]} is a split of Lazard of \\spad{T} then it is also a split of Kalkbrener of \\spad{T}. The converse is \\spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \\newline"))
 (|zeroSetSplit|
  (((|List| $) (|List| |#5|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?)} returns \\spad{lts} a split of Kalkbrener of the radical ideal associated with \\spad{lp}. If \\spad{clos?} is \\spad{false},{} it is also a decomposition of the variety associated with \\spad{lp} into the regular zero set of the \\spad{ts} in \\spad{lts} (or,{} in other words,{} a split of Lazard of this variety). See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets."))
 (|extend|
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{extend(lp,{} lts)} returns the same as \\spad{concat([extend(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{extend(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp} \\spad{extend(p,{} ts)} if \\spad{lp = [p]} else \\spad{extend(first lp,{} extend(rest lp,{} ts))}")
  (((|List| $) |#5| (|List| $))
   "\\spad{extend(p,{} lts)} returns the same as \\spad{concat([extend(p,{} ts) for ts in lts])|}")
  (((|List| $) |#5| $)
   "\\spad{extend(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is not a regular triangular set."))
 (|internalAugment|
  (($ (|List| |#5|) $)
   "\\spad{internalAugment(lp,{} ts)} returns \\spad{ts} if \\spad{lp} is empty otherwise returns \\spad{internalAugment(rest lp,{} internalAugment(first lp,{} ts))}")
  (($ |#5| $)
   "\\spad{internalAugment(p,{} ts)} assumes that \\spad{augment(p,{} ts)} returns a singleton and returns it."))
 (|augment|
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{augment(lp,{} lts)} returns the same as \\spad{concat([augment(lp,{} ts) for ts in lts])}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{augment(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp},{} \\spad{augment(p,{} ts)} if \\spad{lp = [p]},{} otherwise \\spad{augment(first lp,{} augment(rest lp,{} ts))}")
  (((|List| $) |#5| (|List| $))
   "\\spad{augment(p,{} lts)} returns the same as \\spad{concat([augment(p,{} ts) for ts in lts])}")
  (((|List| $) |#5| $)
   "\\spad{augment(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. This operation assumes also that if \\spad{p} is added to \\spad{ts} the resulting set,{} say \\spad{ts+p},{} is a regular triangular set. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is required to be square-free."))
 (|intersect|
  (((|List| $) |#5| (|List| $))
   "\\spad{intersect(p,{} lts)} returns the same as \\spad{intersect([p],{} lts)}")
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{intersect(lp,{} lts)} returns the same as \\spad{concat([intersect(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{intersect(lp,{} ts)} returns \\spad{lts} a split of Lazard of the intersection of the affine variety associated with \\spad{lp} and the regular zero set of \\spad{ts}.")
  (((|List| $) |#5| $)
   "\\spad{intersect(p,{} ts)} returns the same as \\spad{intersect([p],{} ts)}"))
 (|squareFreePart|
  (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| $)
   "\\spad{squareFreePart(p,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a square-free polynomial \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} this polynomial being associated with \\spad{p} modulo \\spad{lpwt.i.tower},{} for every \\spad{i}. Moreover,{} the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. WARNING: This assumes that \\spad{p} is a non-constant polynomial such that if \\spad{p} is added to \\spad{ts},{} then the resulting set is a regular triangular set."))
 (|lastSubResultant|
  (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| |#5| $)
   "\\spad{lastSubResultant(p1,{} p2,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} for every \\spad{i},{} and such that the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. Moreover,{} if \\spad{p1} and \\spad{p2} do not have a non-trivial \\spad{gcd} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower} then \\spad{lpwt.i.val} is the resultant of these polynomials \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|lastSubResultantElseSplit|
  (((|Union| |#5| (|List| $)) |#5| |#5| $)
   "\\spad{lastSubResultantElseSplit(p1,{} p2,{} ts)} returns either \\spad{g} a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. the \\spad{ts} or a split of Kalkbrener of \\spad{ts}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|invertibleSet|
  (((|List| $) |#5| $)
   "\\spad{invertibleSet(p,{} ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \\spad{I} by \\spad{p} where \\spad{I} is the radical of saturated of \\spad{ts}."))
 (|invertible?|
  (((|Boolean|) |#5| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{true} iff \\spad{p} is invertible in the tower associated with \\spad{ts}.")
  (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| $))) |#5| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{lbwt} where \\spad{lbwt.i} is the result of \\spad{invertibleElseSplit?(p,{} lbwt.i.tower)} and the list of the \\spad{(lqrwt.i).tower} is a split of Kalkbrener of \\spad{ts}."))
 (|invertibleElseSplit?|
  (((|Union| (|Boolean|) (|List| $)) |#5| $)
   "\\spad{invertibleElseSplit?(p,{} ts)} returns \\spad{true} (resp. \\spad{false}) if \\spad{p} is invertible in the tower associated with \\spad{ts} or returns a split of Kalkbrener of \\spad{ts}."))
 (|purelyAlgebraicLeadingMonomial?|
  (((|Boolean|) |#5| $)
   "\\spad{purelyAlgebraicLeadingMonomial?(p,{} ts)} returns \\spad{true} iff the main variable of any non-constant iterarted initial of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|algebraicCoefficients?|
  (((|Boolean|) |#5| $)
   "\\spad{algebraicCoefficients?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} which is not the main one of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|purelyTranscendental?|
  (((|Boolean|) |#5| $)
   "\\spad{purelyTranscendental?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is not algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}"))
 (|purelyAlgebraic?|
  (((|Boolean|) $)
   "\\spad{purelyAlgebraic?(ts)} returns \\spad{true} iff for every algebraic variable \\spad{v} of \\spad{ts} we have \\spad{algebraicCoefficients?(t_v,{} ts_v_-)} where \\spad{ts_v} is \\spadopFrom{select}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}) and \\spad{ts_v_-} is \\spadopFrom{collectUnder}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}).")
  (((|Boolean|) |#5| $)
   "\\spad{purelyAlgebraic?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))) 
NIL 
(|RegularTriangularSetCategory| R E V P) 
((|constructor|
  (NIL
   "The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \\spad{k[x1,{} ...,{} xn]} where \\spad{k} is the fraction field of \\spad{R}. The triangular set \\spad{[t1,{} ...,{} tm]} is regular iff for every \\spad{i} the initial of \\spad{ti+1} is invertible in the tower of simple extensions associated with \\spad{[t1,{} ...,{} \\spad{ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \\spad{I} iff the radical of \\spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \\spad{[T1,{} ...,{} \\spad{Ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \\spad{T} iff it is a split of Kalkbrener of the saturated ideal of \\spad{T}. Let \\spad{K} be an algebraic closure of \\spad{k}. Assume that \\spad{V} is finite with cardinality \\spad{n} and let \\spad{A} be the affine space \\spad{K^n}. For a regular triangular set \\spad{T} let denote by \\spad{W(T)} the set of regular zeros of \\spad{T}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given subset \\spad{S} of \\spad{A} iff the union of the \\spad{W(\\spad{Ti})} contains \\spad{S} and is contained in the closure of \\spad{S} (\\spad{w}.\\spad{r}.\\spad{t}. Zariski topology). A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given triangular set \\spad{T} if it is a split of Lazard of \\spad{W(T)}. Note that if \\spad{[T1,{} ...,{} Ts]} is a split of Lazard of \\spad{T} then it is also a split of Kalkbrener of \\spad{T}. The converse is \\spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \\newline"))
 (|zeroSetSplit|
  (((|List| $) (|List| |#4|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?)} returns \\spad{lts} a split of Kalkbrener of the radical ideal associated with \\spad{lp}. If \\spad{clos?} is \\spad{false},{} it is also a decomposition of the variety associated with \\spad{lp} into the regular zero set of the \\spad{ts} in \\spad{lts} (or,{} in other words,{} a split of Lazard of this variety). See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets."))
 (|extend|
  (((|List| $) (|List| |#4|) (|List| $))
   "\\spad{extend(lp,{} lts)} returns the same as \\spad{concat([extend(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#4|) $)
   "\\spad{extend(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp} \\spad{extend(p,{} ts)} if \\spad{lp = [p]} else \\spad{extend(first lp,{} extend(rest lp,{} ts))}")
  (((|List| $) |#4| (|List| $))
   "\\spad{extend(p,{} lts)} returns the same as \\spad{concat([extend(p,{} ts) for ts in lts])|}")
  (((|List| $) |#4| $)
   "\\spad{extend(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is not a regular triangular set."))
 (|internalAugment|
  (($ (|List| |#4|) $)
   "\\spad{internalAugment(lp,{} ts)} returns \\spad{ts} if \\spad{lp} is empty otherwise returns \\spad{internalAugment(rest lp,{} internalAugment(first lp,{} ts))}")
  (($ |#4| $)
   "\\spad{internalAugment(p,{} ts)} assumes that \\spad{augment(p,{} ts)} returns a singleton and returns it."))
 (|augment|
  (((|List| $) (|List| |#4|) (|List| $))
   "\\spad{augment(lp,{} lts)} returns the same as \\spad{concat([augment(lp,{} ts) for ts in lts])}")
  (((|List| $) (|List| |#4|) $)
   "\\spad{augment(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp},{} \\spad{augment(p,{} ts)} if \\spad{lp = [p]},{} otherwise \\spad{augment(first lp,{} augment(rest lp,{} ts))}")
  (((|List| $) |#4| (|List| $))
   "\\spad{augment(p,{} lts)} returns the same as \\spad{concat([augment(p,{} ts) for ts in lts])}")
  (((|List| $) |#4| $)
   "\\spad{augment(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. This operation assumes also that if \\spad{p} is added to \\spad{ts} the resulting set,{} say \\spad{ts+p},{} is a regular triangular set. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is required to be square-free."))
 (|intersect|
  (((|List| $) |#4| (|List| $))
   "\\spad{intersect(p,{} lts)} returns the same as \\spad{intersect([p],{} lts)}")
  (((|List| $) (|List| |#4|) (|List| $))
   "\\spad{intersect(lp,{} lts)} returns the same as \\spad{concat([intersect(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#4|) $)
   "\\spad{intersect(lp,{} ts)} returns \\spad{lts} a split of Lazard of the intersection of the affine variety associated with \\spad{lp} and the regular zero set of \\spad{ts}.")
  (((|List| $) |#4| $)
   "\\spad{intersect(p,{} ts)} returns the same as \\spad{intersect([p],{} ts)}"))
 (|squareFreePart|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| $))) |#4| $)
   "\\spad{squareFreePart(p,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a square-free polynomial \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} this polynomial being associated with \\spad{p} modulo \\spad{lpwt.i.tower},{} for every \\spad{i}. Moreover,{} the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. WARNING: This assumes that \\spad{p} is a non-constant polynomial such that if \\spad{p} is added to \\spad{ts},{} then the resulting set is a regular triangular set."))
 (|lastSubResultant|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| $))) |#4| |#4| $)
   "\\spad{lastSubResultant(p1,{} p2,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} for every \\spad{i},{} and such that the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. Moreover,{} if \\spad{p1} and \\spad{p2} do not have a non-trivial \\spad{gcd} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower} then \\spad{lpwt.i.val} is the resultant of these polynomials \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|lastSubResultantElseSplit|
  (((|Union| |#4| (|List| $)) |#4| |#4| $)
   "\\spad{lastSubResultantElseSplit(p1,{} p2,{} ts)} returns either \\spad{g} a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. the \\spad{ts} or a split of Kalkbrener of \\spad{ts}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|invertibleSet|
  (((|List| $) |#4| $)
   "\\spad{invertibleSet(p,{} ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \\spad{I} by \\spad{p} where \\spad{I} is the radical of saturated of \\spad{ts}."))
 (|invertible?|
  (((|Boolean|) |#4| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{true} iff \\spad{p} is invertible in the tower associated with \\spad{ts}.")
  (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| $))) |#4| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{lbwt} where \\spad{lbwt.i} is the result of \\spad{invertibleElseSplit?(p,{} lbwt.i.tower)} and the list of the \\spad{(lqrwt.i).tower} is a split of Kalkbrener of \\spad{ts}."))
 (|invertibleElseSplit?|
  (((|Union| (|Boolean|) (|List| $)) |#4| $)
   "\\spad{invertibleElseSplit?(p,{} ts)} returns \\spad{true} (resp. \\spad{false}) if \\spad{p} is invertible in the tower associated with \\spad{ts} or returns a split of Kalkbrener of \\spad{ts}."))
 (|purelyAlgebraicLeadingMonomial?|
  (((|Boolean|) |#4| $)
   "\\spad{purelyAlgebraicLeadingMonomial?(p,{} ts)} returns \\spad{true} iff the main variable of any non-constant iterarted initial of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|algebraicCoefficients?|
  (((|Boolean|) |#4| $)
   "\\spad{algebraicCoefficients?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} which is not the main one of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|purelyTranscendental?|
  (((|Boolean|) |#4| $)
   "\\spad{purelyTranscendental?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is not algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}"))
 (|purelyAlgebraic?|
  (((|Boolean|) $)
   "\\spad{purelyAlgebraic?(ts)} returns \\spad{true} iff for every algebraic variable \\spad{v} of \\spad{ts} we have \\spad{algebraicCoefficients?(t_v,{} ts_v_-)} where \\spad{ts_v} is \\spadopFrom{select}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}) and \\spad{ts_v_-} is \\spadopFrom{collectUnder}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}).")
  (((|Boolean|) |#4| $)
   "\\spad{purelyAlgebraic?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))) 
NIL 
(|RegularTriangularSetGcdPackage| R E V P TS) 
((|constructor|
  (NIL
   "An internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field.\\newline"))
 (|toseSquareFreePart|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#5|)
   "\\spad{toseSquareFreePart(p,{} ts)} has the same specifications as \\spadopFrom{squareFreePart}{RegularTriangularSetCategory}."))
 (|toseInvertibleSet|
  (((|List| |#5|) |#4| |#5|)
   "\\spad{toseInvertibleSet(p1,{} p2,{} ts)} has the same specifications as \\spadopFrom{invertibleSet}{RegularTriangularSetCategory}."))
 (|toseInvertible?|
  (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| |#5|))) |#4| |#5|)
   "\\spad{toseInvertible?(p1,{} p2,{} ts)} has the same specifications as \\spadopFrom{invertible?}{RegularTriangularSetCategory}.")
  (((|Boolean|) |#4| |#5|)
   "\\spad{toseInvertible?(p1,{} p2,{} ts)} has the same specifications as \\spadopFrom{invertible?}{RegularTriangularSetCategory}."))
 (|toseLastSubResultant|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5|)
   "\\spad{toseLastSubResultant(p1,{} p2,{} ts)} has the same specifications as \\spadopFrom{lastSubResultant}{RegularTriangularSetCategory}."))
 (|integralLastSubResultant|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5|)
   "\\spad{integralLastSubResultant(p1,{} p2,{} ts)} is an internal subroutine,{} exported only for developement."))
 (|internalLastSubResultant|
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|)))
    (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) |#3|
    (|Boolean|))
   "\\spad{internalLastSubResultant(lpwt,{} v,{} flag)} is an internal subroutine,{} exported only for developement.")
  (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5|
    (|Boolean|) (|Boolean|))
   "\\spad{internalLastSubResultant(p1,{} p2,{} ts,{} inv?,{} break?)} is an internal subroutine,{} exported only for developement."))
 (|prepareSubResAlgo|
  (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) |#4| |#4|
    |#5|)
   "\\spad{prepareSubResAlgo(p1,{} p2,{} ts)} is an internal subroutine,{} exported only for developement."))
 (|stopTableInvSet!|
  (((|Void|))
   "\\spad{stopTableInvSet!()} is an internal subroutine,{} exported only for developement."))
 (|startTableInvSet!|
  (((|Void|) (|String|) (|String|) (|String|))
   "\\spad{startTableInvSet!(s1,{} s2,{} s3)} is an internal subroutine,{} exported only for developement."))
 (|stopTableGcd!|
  (((|Void|))
   "\\spad{stopTableGcd!()} is an internal subroutine,{} exported only for developement."))
 (|startTableGcd!|
  (((|Void|) (|String|) (|String|) (|String|))
   "\\spad{startTableGcd!(s1,{} s2,{} s3)} is an internal subroutine,{} exported only for developement."))) 
NIL 
(|RewriteRule| |Base| R F) 
((|constructor|
  (NIL
   "\\indented{1}{Rules for the pattern matcher} Author: Manuel Bronstein Date Created: 24 Oct 1988 Keywords: pattern,{} matching,{} rule."))
 (|quotedOperators|
  (((|List| (|Symbol|)) $)
   "\\spad{quotedOperators(r)} returns the list of operators on the right hand side of \\spad{r} that are considered quoted,{} that is they are not evaluated during any rewrite,{} but just applied formally to their arguments."))
 (|elt|
  ((|#3| $ |#3| (|PositiveInteger|))
   "\\spad{elt(r,{} f,{} n)} or \\spad{r}(\\spad{f},{} \\spad{n}) applies the rule \\spad{r} to \\spad{f} at most \\spad{n} times."))
 (|rhs|
  ((|#3| $)
   "\\spad{rhs(r)} returns the right hand side of the rule \\spad{r}."))
 (|lhs|
  ((|#3| $)
   "\\spad{lhs(r)} returns the left hand side of the rule \\spad{r}."))
 (|pattern|
  (((|Pattern| |#1|) $)
   "\\spad{pattern(r)} returns the pattern corresponding to the left hand side of the rule \\spad{r}."))
 (|suchThat|
  (($ $ (|List| (|Symbol|)) (|Mapping| (|Boolean|) (|List| |#3|)))
   "\\spad{suchThat(r,{} [a1,{} ...,{} an],{} f)} returns the rewrite rule \\spad{r} with the predicate \\spad{f(a1,{} ...,{} an)} attached to it."))
 (|rule|
  (($ |#3| |#3| (|List| (|Symbol|)))
   "\\spad{rule(f,{} g,{} [f1,{} ...,{} fn])} creates the rewrite rule \\spad{f == eval(eval(g,{} g is f),{} [f1,{} ...,{} fn])},{} that is a rule with left-hand side \\spad{f} and right-hand side \\spad{g}; The symbols \\spad{f1},{} ...,{} \\spad{fn} are the operators that are considered quoted,{} that is they are not evaluated during any rewrite,{} but just applied formally to their arguments.")
  (($ |#3| |#3|)
   "\\spad{rule(f,{} g)} creates the rewrite rule: \\spad{f == eval(g,{} g is f)},{} with left-hand side \\spad{f} and right-hand side \\spad{g}."))) 
NIL 
(|RuleCalled| |f|) 
((|constructor| (NIL "This domain implements named rules"))
 (|name| (((|Symbol|) $) "\\spad{name(x)} returns the symbol"))) 
NIL 
(|Ruleset| |Base| R F) 
((|constructor|
  (NIL "A ruleset is a set of pattern matching rules grouped together."))
 (|elt|
  ((|#3| $ |#3| (|PositiveInteger|))
   "\\spad{elt(r,{} f,{} n)} or \\spad{r}(\\spad{f},{} \\spad{n}) applies all the rules of \\spad{r} to \\spad{f} at most \\spad{n} times."))
 (|rules|
  (((|List| (|RewriteRule| |#1| |#2| |#3|)) $)
   "\\spad{rules(r)} returns the rules contained in \\spad{r}."))
 (|ruleset|
  (($ (|List| (|RewriteRule| |#1| |#2| |#3|)))
   "\\spad{ruleset([r1,{} ...,{} rn])} creates the rule set \\spad{{r1,{} ...,{} rn}}."))) 
NIL 
(|RationalUnivariateRepresentationPackage| R |ls|) 
((|constructor|
  (NIL
   "\\indented{1}{A package for computing the rational univariate representation} \\indented{1}{of a zero-dimensional algebraic variety given by a regular} \\indented{1}{triangular set. This package is essentially an interface for the} \\spadtype{InternalRationalUnivariateRepresentationPackage} constructor. It is used in the \\spadtype{ZeroDimensionalSolvePackage} for solving polynomial systems with finitely many solutions."))
 (|rur|
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|))
   "\\spad{rur(lp,{} univ?,{} check?)} returns the same as \\spad{rur(lp,{} true)}. Moreover,{} if \\spad{check?} is \\spad{true} then the result is checked.")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{rur(lp)} returns the same as \\spad{rur(lp,{} true)}")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|Boolean|))
   "\\spad{rur(lp,{} univ?)} returns a rational univariate representation of \\spad{lp}. This assumes that \\spad{lp} defines a regular triangular \\spad{ts} whose associated variety is zero-dimensional over \\spad{R}. \\spad{rur(lp,{} univ?)} returns a list of items \\spad{[u,{} lc]} where \\spad{u} is an irreducible univariate polynomial and each \\spad{c} in \\spad{lc} involves two variables: one from \\spad{ls},{} called the coordinate of \\spad{c},{} and an extra variable which represents any root of \\spad{u}. Every root of \\spad{u} leads to a tuple of values for the coordinates of \\spad{lc}. Moreover,{} a point \\spad{x} belongs to the variety associated with \\spad{lp} iff there exists an item \\spad{[u,{} lc]} in \\spad{rur(lp,{} univ?)} and a root \\spad{r} of \\spad{u} such that \\spad{x} is given by the tuple of values for the coordinates of \\spad{lc} evaluated at \\spad{r}. If \\spad{univ?} is \\spad{true} then each polynomial \\spad{c} will have a constant leading coefficient \\spad{w}.\\spad{r}.\\spad{t}. its coordinate. See the example which illustrates the \\spadtype{ZeroDimensionalSolvePackage} package constructor."))) 
NIL 
(|SimpleAlgebraicExtension| R UP M) 
((|constructor|
  (NIL
   "Domain which represents simple algebraic extensions of arbitrary rings. The first argument to the domain,{} \\spad{R},{} is the underlying ring,{} the second argument is a domain of univariate polynomials over \\spad{R},{} while the last argument specifies the defining minimal polynomial. The elements of the domain are canonically represented as polynomials of degree less than that of the minimal polynomial with coefficients in \\spad{R}. The second argument is both the type of the third argument and the underlying representation used by \\spadtype{SAE} itself."))) 
((|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|FiniteFieldCategory|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|FiniteFieldCategory|)))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|Finite|))
 (OR
  (AND (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| |#1| '(|Field|)))
  (|HasCategory| |#1| '(|FiniteFieldCategory|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#1| '(|Field|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| '(|Field|)))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| '(|FiniteFieldCategory|))))
 (OR
  (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#1| '(|Field|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
  (|HasCategory| |#1| '(|FiniteFieldCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| $ '(|CharacteristicNonZero|)))
  (AND (|HasCategory| |#1| '(|FiniteFieldCategory|))
       (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))) 
(|SingletonAsOrderedSet|) 
((|constructor|
  (NIL
   "\\indented{1}{This trivial domain let us build Univariate Polynomials} in an anonymous variable."))) 
NIL 
(|SArgand|) 
((|constructor|
  (NIL
   "\\indented{1}{Domain for representing points,{} vectors,{} subspaces and properties} of components in a subspace as complex numbers"))) 
NIL 
(|SBoundary| PT) 
((|constructor|
  (NIL
   "\\indented{1}{SBoundary implements boundaries for use in scene graph} This defines the outer extent of the scene,{} or of an element in the scene,{} or of some branch in the scene. The difference between this boundary and an \\spad{n}-dimensional surface,{} such as IFS,{} is that boundary must always have a well defined inside and an outside. SBoundary does not necessarily follow the exact outer contours of the shape but just constructs a simple boundary shape where all points of the shape are guaranteed to be inside the boundary. Currently there are the following boundary forms: \\indented{1}{Simple types:} \\indented{2}{\"box\"::Symbol which is a \\spad{n}-dimensional axis-aligned rectangle.} \\indented{2}{\"ellipoid\"::Symbol which is a \\spad{n}-dimensional axis-aligned ellipse.} \\indented{1}{Compound types:} \\indented{2}{This is a combination of simple and other compound types such} \\indented{2}{as union or intersection.} \\indented{3}{\"union\"::Symbol represents union of supplied list} \\indented{3}{\"intersection\"::Symbol represents intersection of supplied list} \\indented{1}{Null types:} \\indented{2}{\"none\" is used for a node which does not have a boundary in} \\indented{6}{space,{} for example,{} when the boundary of a material node} \\indented{6}{is requested.} The uses of SBoundary are: 1) So we know how much to scale a given scene to fit in a \\indented{3}{given size.} 2) So that we know where to terminate arrows going in out out of \\indented{3}{of the shape.} 3) To detect if objects intersect (collision detect),{} or if one \\indented{3}{object is contained completely inside another.}"))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(bd)} outputs description of \\spad{bd} as formatted text"))
 (|link|
  (((|List| |#1|) $ $)
   "\\spad{link(m,{} n)} returns a line which is the shortest distance between the two boundaries. The line is represented by its two endpoints. \\spad{m:} \\% is the first boundary to be linked \\spad{n:} \\% is the second boundary to be linked"))
 (|getCentre|
  ((|#1| $)
   "\\spad{getCentre(n)} returns centre coordinate of the boundary. \\spad{n:} \\% is the boundary"))
 (|getMax|
  ((|#1| $)
   "\\spad{getMax(n)} returns maximum coordinate of the boundary. \\spad{n} is the boundary"))
 (|getMin|
  ((|#1| $)
   "\\spad{getMin(n)} returns minimum coordinate of the boundary. \\spad{n} is the boundary"))
 (|isBox?|
  (((|Boolean|) $)
   "\\spad{isBox?(n)} returns \\spad{true} if this is a rectangular boundary."))
 (|isEllipse?|
  (((|Boolean|) $)
   "\\spad{isEllipse?(n)} returns \\spad{true} if this is a ellipsoid boundary."))
 (|isNull?|
  (((|Boolean|) $)
   "\\spad{isNull?(n)} returns \\spad{true} if this is a null boundary,{} that is no boundary"))
 (|lineIntersect|
  ((|#1| $ |#1|)
   "\\spad{lineIntersect(n,{} p)} returns the point where a line,{} from the centre of the boundary to the point \\spad{p},{} intersects with the boundary. \\spad{n:} \\% is the boundary \\spad{p:} \\spad{PT} is the point at the end of the line (outside boundary)"))
 (|containsPoint?|
  (((|Boolean|) $ |#1|)
   "\\spad{containsPoint?(n,{} p)} returns \\spad{true} if the point is inside \\indented{2}{the boundary.} \\spad{n} is the boundary \\spad{p} is the point"))
 (|extendToPoint|
  (($ $ |#1|)
   "\\spad{extendToPoint(n,{} p)} creates a boundary that is the union \\indented{2}{of a boundary and a point.} \\spad{n} is the boundary \\spad{p} is the point"))
 (|sunion|
  (($ $ $)
   "\\spad{sunion(x,{} y)} gives the union of two boundaries as a box,{} \\indented{2}{that is it gives a box that is external to both.} \\spad{x:} \\% is first boundary to be combined \\spad{y:} \\% is second boundary to be combined"))
 (|intersection|
  (($ (|List| $))
   "\\spad{intersection(x)} constructs a compound boundary from the intersection of \\spad{x} \\spad{x:} List \\% is supplied list of boundaries to form intersection."))
 (|union|
  (($ (|List| $))
   "\\spad{union(x)} constructs a compound boundary from the union of \\spad{x} \\spad{x:} List \\% is supplied list of boundaries to form union"))
 (|ellipseBoundary|
  (($ |#1| |#1|)
   "\\spad{ellipseBoundary(c1,{} c2)} constructs an ellipse boundary \\spad{n}-dimensional axis-aligned ellipoid with given parameters \\spad{c1:} \\spad{PT} holds centre point \\spad{c2:} \\spad{PT} holds extent (radius for each coordinate)"))
 (|boxBoundary|
  (($ |#1| |#1|)
   "\\spad{boxBoundary(c1,{} c2)} constructs a box boundary (\\spad{n}-dimensional axis-aligned rectangle) with given parameters \\spad{c1:} \\spad{PT} holds minimum coordinates \\spad{c2:} \\spad{PT} holds maximum coordinates"))
 (|nullBoundary|
  (($)
   "\\spad{nullBoundary()} constructs a null boundary,{} for example,{} when the boundary of a material node is requested."))) 
NIL 
(|SortedCache| S) 
((|constructor|
  (NIL
   "A sorted cache of a cachable set \\spad{S} is a dynamic structure that keeps the elements of \\spad{S} sorted and assigns an integer to each element of \\spad{S} once it is in the cache. This way,{} equality and ordering on \\spad{S} are tested directly on the integers associated with the elements of \\spad{S},{} once they have been entered in the cache."))
 (|binarySearch|
  (((|Union| |#1| "failed") |#1| (|Mapping| (|Integer|) |#1| |#1|))
   "\\spad{binarySearch(x,{} f)} searches \\spad{x} in the cache,{} calling \\spad{f(x,{} y)} to determine order. It returns \\spad{y} from cache if \\spad{f}(\\spad{x},{} \\spad{y}) is 0 or \"failed\" if no such \\spad{y} exists."))
 (|linearSearch|
  (((|Union| |#1| "failed") |#1| (|Mapping| (|Boolean|) |#1|))
   "\\spad{linearSearch(x,{} f)} searches \\spad{x} in the cache,{} calling \\spad{f(y)} to determine whether \\spad{x} is equal to \\spad{y}. It returns \\spad{y} from cache if \\spad{f}(\\spad{y}) is \\spad{true} or \"failed\" if no such \\spad{y} exists."))
 (|enterInCache|
  ((|#1| |#1| (|Mapping| (|Integer|) |#1| |#1|))
   "\\spad{enterInCache(x,{} f)} enters \\spad{x} in the cache,{} calling \\spad{f(x,{} y)} to determine whether \\spad{x < y (f(x,{} y) < 0),{} x = y (f(x,{} y) = 0)},{} or \\spad{x > y (f(x,{} y) > 0)}. It returns \\spad{x} with an integer associated with it.")
  ((|#1| |#1| (|Mapping| (|Boolean|) |#1|))
   "\\spad{enterInCache(x,{} f)} enters \\spad{x} in the cache,{} calling \\spad{f(y)} to determine whether \\spad{x} is equal to \\spad{y}. It returns \\spad{x} with an integer associated with it."))
 (|clearCache| (((|Void|)) "\\spad{clearCache()} empties the cache."))) 
NIL 
(|ScanningUtilities|) 
((|parse_integer|
  (((|Integer|) (|String|))
   "\\spad{parse_integer(s)} converts string of digits \\spad{s} into integer"))) 
NIL 
(|SimpleCell| |TheField| |ThePols|) 
((|variableOf|
  (((|Symbol|) $) "\\spad{variableOf(c)} returns variable of \\spad{c}"))
 (|samplePoint|
  ((|#1| $) "\\spad{samplePoint(c)} returns the sample point of \\spad{c}"))
 (|hasDimension?|
  (((|Boolean|) $)
   "\\spad{hasDimension?(c)} returns \\spad{true} if \\spad{c} is of positive dimension (that is one-dimensional),{} otherwise hasDimension?(\\spad{c}) returns \\spad{false}"))
 (|allSimpleCells|
  (((|List| $) (|List| |#2|) (|Symbol|))
   "\\spad{allSimpleCells(lp,{} sym)} returns decomposition into cells such that each \\spad{p} in \\spad{lp} has constant sign on each member of decomposition")
  (((|List| $) |#2| (|Symbol|))
   "\\spad{allSimpleCells(p,{} sym)} is allSimpleCells([\\spad{p}],{} \\spad{sym})"))) 
NIL 
(|Scene| PT) 
((|constructor|
  (NIL
   "\\indented{1}{these are the parameters that can be set for nodes of} various types"))
 (|coerce|
  (((|OutputForm|) $)
   "output a full scenegraph could contain a lot of data and so we have to be careful to restrict the output to what is reasonable on the command line. Therefore we do not display all subnodes or the full information from nodes such as IFS."))
 (|writeObj|
  (((|Void|) $ (|String|))
   "\\spad{writeObj(n,{} filename)} writes an 'OBJ' (Wavefront) representation of node \\spad{'n'} to the filename supplied."))
 (|writeVRML|
  (((|Void|) $ (|String|))
   "\\spad{writeVRML(n,{} filename)} writes an 'VRML' representation of node \\spad{'n'} to the filename supplied."))
 (|writeX3d|
  (((|Void|) $ (|String|))
   "writeX3d: (\\spad{n},{} filename) writes an 'X3D' representation of node \\spad{'n'} to the filename supplied."))
 (|writeSvgQuantised|
  (((|Void|) $ (|String|))
   "\\spad{writeSvgQuantised(n,{} filename)} writes an 'SVG' representation of node \\spad{'n'} to the filename supplied."))
 (|writeSvg|
  (((|Void|) $ (|String|))
   "\\spad{writeSvg(n,{} filename)} writes an 'SVG' representation of node \\spad{'n'} to the filename supplied."))
 (|toObj|
  (((|Void|) $ (|Reference| (|List| |#1|))
    (|Reference| (|List| (|List| (|NonNegativeInteger|))))
    (|Reference| (|NonNegativeInteger|)) (|STransform| |#1|)
    (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (((|Void|) $ (|Reference| (|List| |#1|))
    (|Reference| (|List| (|List| (|NonNegativeInteger|))))
    (|Reference| (|NonNegativeInteger|)) (|STransform| |#1|)
    (|SBoundary| |#1|))
   "\\spad{toObj(n,{} ptLst,{} indexLst,{} indexNxt,{} tran,{} bb)} creates an .OBJ (Wavefront) file from scenegraph tree structure called recursively for each node,{} so when called on root node in scenegraph all other nodes in the scenegraph will get called. \\spad{n} is the scene to be output to \\spad{ptLst} and \\spad{indexLst} \\spad{ptLst} is the points. This will be set to ref([]) at the start \\indented{6}{and will be built up as this function is called recursively} \\spad{indexLst} is list of faces,{} where faces are list of points indexed \\indented{9}{by \\spad{ptLst} This will be set to ref([]) at the start} \\indented{6}{and will be built up as this function is called recursively} \\spad{tran} is the default transform which may be overridden by subnodes \\spad{bb} is the default boundary which may be overridden by subnodes"))
 (|toX3D|
  (((|XmlElement|) $
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|)))
    (|STransform| |#1|) (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (((|XmlElement|) $
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|)))
    (|STransform| |#1|) (|SBoundary| |#1|))
   "\\spad{toX3D(n,{} mat,{} tran,{} bb)} creates an XmlElement containing a 'X3D' representation of node \\spad{'n'} and the nodes below it. \\spad{n} is the scene to be output to \\spad{XML} elements \\spad{mat} is the default material which may be overridden by subnodes \\spad{tran} is the default transform which may be overridden by subnodes \\spad{bb} is the default boundary which may be overridden by subnodes"))
 (|toSVG|
  (((|XmlElement|) $
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|)))
    (|STransform| |#1|) (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|))
    (|DoubleFloat|) (|Boolean|) (|Boolean|) (|SceneNamedPoints| |#1|))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (((|XmlElement|) $
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|)))
    (|STransform| |#1|) (|SBoundary| |#1|) (|DoubleFloat|) (|Boolean|)
    (|Boolean|) (|SceneNamedPoints| |#1|))
   "\\spad{toSVG(n,{} mat,{} tran,{} bb,{} scale,{} clipEn,{} useInteger,{} npt)} creates an XmlElement containing a 'SVG' representation of node \\spad{'n'} and the nodes below it. \\spad{n} is the scene to be output to \\spad{XML} elements \\spad{mat} is the default material which may be overridden by subnodes \\spad{tran} is the default transform which may be overridden by subnodes \\spad{bb} is the default boundary which may be overridden by subnodes \\spad{scale} is the \\spad{scale} used to \\spad{scale} into canvas,{} it would be better \\indented{6}{to merge this into trans.} \\spad{clipEn} if \\spad{true} this clips the output to the boundary \\spad{useInteger} if \\spad{true} truncate to integer values. \\spad{npt} names points can be provided. If not required then set \\indented{4}{to namedBranch([],{} [])}"))
 (|setTransform!|
  (((|Void|) $ (|STransform| |#1|))
   "\\spad{setTransform!(n,{} tran)} changes the transform without altering the scene hierarchy"))
 (|removeChild!|
  (((|Void|) $ $)
   "\\spad{removeChild!(n,{} c)} removes the specified child node \\spad{'c'} below node \\spad{'n'}"))
 (|addChild!|
  (((|Void|) $ $)
   "\\spad{addChild!(n,{} c)} adds the specified child node \\spad{'c'} below node \\spad{'n'}"))
 (|boundary|
  (((|SBoundary| |#1|) $ (|DoubleFloat|))
   "\\spad{boundary(n,{} fontScale)} returns the boundary of a given node,{} so if this is called on the root node,{} it will return the boundary of the whole scene. There is a difficulty involving text nodes,{} that is they have a fixed font size. But we want to calculate the boundary in local coordinates,{} to do this conversion we need to know the total boundary size but that is what we are trying to calculate! To get round this contradiction the parameter fontScale is required since fonts are rendered at a fixed size we need a scaling factor so that we can give the boundary in our coordinate system. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if this node,{} or its subnodes,{} do not contain a text node then its value is not significant."))
 (|addArrows2Din2D|
  (($ $ (|Mapping| |#1| |#1|) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{addArrows2Din2D(n,{} ptFun,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createArrows2Din2D with addChild!"))
 (|createArrows2Din2D|
  (($ (|Mapping| |#1| |#1|) (|Segment| (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{createArrows2Din2D(ptFun,{} uSeg,{} vSeg,{} numPts)} creates arrows to represent output for each input point in other words this represents a two dimensional force field with the arrows showing the direction of the field"))
 (|addPlot2Din3Dparametric|
  (($ $
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!")
  (($ $ (|Mapping| |#1| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!"))
 (|createPlot2Din3Dparametric|
  (($
    (|ParametricSurface|
     (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot2Din3Dparametric(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \\spad{x} = \\spad{f}(\\spad{u},{} \\spad{v}),{} \\spad{y} = \\spad{g}(\\spad{u},{} \\spad{v}),{} \\spad{z} = \\spad{h}(\\spad{u},{} \\spad{v}) as \\spad{u} ranges from min(a,{} \\spad{b}) to max(a,{} \\spad{b}) and \\spad{v} ranges from min(\\spad{c},{} \\spad{d}) to max(\\spad{c},{} \\spad{d}). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node")
  (($ (|Mapping| |#1| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot2Din3Dparametric(f,{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \\spad{f}(\\spad{u},{} \\spad{v}) as \\spad{u} ranges from min(a,{} \\spad{b}) to max(a,{} \\spad{b}) and \\spad{v} ranges from min(\\spad{c},{} \\spad{d}) to max(\\spad{c},{} \\spad{d}). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node"))
 (|addPlot2Din3D|
  (($ $ (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot2Din3D(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3D with addChild!"))
 (|createPlot2Din3D|
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot2Din3D(f,{} a..b,{} c..d)} returns a scene node which contains the graph of \\spad{z} = \\spad{f}(\\spad{x},{} \\spad{y}) as \\spad{x} ranges from min(a,{} \\spad{b}) to max(a,{} \\spad{b}) and \\spad{y} ranges from min(\\spad{c},{} \\spad{d}) to max(\\spad{c},{} \\spad{d}). create a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node")
  (($ (|Mapping| |#1| (|DoubleFloat|) (|DoubleFloat|))
    (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot2Din3D(ptFun,{} uSeg,{} vSeg,{} numPts)} create a surface (2D subspace) in 3D space. The surface is approximated by polygons which are represented by in indexed face set (IFS) node"))
 (|addPlot1Din3Dparametric|
  (($ $ (|Mapping| |#1| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot1Din3Dparametric(n,{} pcfun,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!")
  (($ $ (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{addPlot1Din3Dparametric(n,{} psc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!"))
 (|createPlot1Din3Dparametric|
  (($ (|Mapping| |#1| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot1Din3Dparametric(pcfun,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph PCFUN is a function from float to point: \\spad{DF} \\spad{->} \\spad{PT}")
  (($ (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{createPlot1Din3Dparametric(psc,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \\spad{PSC} ParametricSpaceCurve(\\spad{DF} \\spad{->} \\spad{DF}) is created with curve(\\spad{f1},{} \\spad{f2},{} \\spad{f3}) where \\spad{f1},{} \\spad{f2} and \\spad{f3} are functions of type ComponentFunction,{} in this case \\spad{DF} \\spad{->} \\spad{DF}"))
 (|addPlot1Din2Dparametric|
  (($ $ (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{addPlot1Din2Dparametric(n,{} ppc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2Dparametric with addChild!"))
 (|createPlot1Din2Dparametric|
  (($ (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|)))
    (|Segment| (|DoubleFloat|)) (|NonNegativeInteger|))
   "\\spad{createPlot1Din2Dparametric(ppc,{} tRange,{} numPts)} creates a node from plot using Parametric Plane Curve. This represents 1 dimension (line - possibly curved) in 2 dimensions (plane) In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \\spad{PPC} is ParametricPlaneCurve(\\spad{DF} \\spad{->} \\spad{DF}) which is created with curve(\\spad{f1},{} \\spad{f2}) where \\spad{f1} and \\spad{f2} are functions of type ComponentFunction,{} in this case \\spad{DF} \\spad{->} \\spad{DF}"))
 (|addPlot1Din2D|
  (($ $ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!")
  (($ $ (|Mapping| |#1| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!"))
 (|createPlot1Din2D|
  (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates two dimensional function plot. Draws the graph of \\spad{y} = \\spad{f}(\\spad{x}) as \\spad{x} ranges from min(a,{} \\spad{b}) to max(a,{} \\spad{b}). \\spad{tRange} is a..\\spad{b}")
  (($ (|Mapping| |#1| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))
    (|NonNegativeInteger|))
   "\\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates a two dimensional function plot draws the graph from a mapping of float to point as \\spad{x} ranges from min(a,{} \\spad{b}) to max(a,{} \\spad{b}). \\spad{tRange} is a..\\spad{b}"))
 (|addSceneTransform|
  (($ $ (|STransform| |#1|))
   "\\spad{addSceneTransform(n,{} tran)} is a convenience function which combines createSceneTransform with addChild!"))
 (|createSceneTransform|
  (($ (|STransform| |#1|))
   "\\spad{createSceneTransform(tran)} constructs a transform node This transforms the points and vectors below this node If a given node has more than one transform node above it in the hierarchy then the transforms are compound"))
 (|addSceneMaterial|
  (($ $ (|DoubleFloat|) (|String|) (|String|))
   "\\spad{addSceneMaterial(n,{} lineW,{} lineC,{} fillC)} is a convenience function which combines createSceneMaterial with addChild!")
  (($ $
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|))))
   "\\spad{addSceneMaterial(n,{} mat)} is a convenience function which combines createSceneMaterial with addChild!"))
 (|createSceneMaterial|
  (($ (|DoubleFloat|) (|String|) (|String|))
   "\\spad{createSceneMaterial(lineW,{} lineC,{} fillC)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy")
  (($
    (|Record| (|:| |lineWidth| (|DoubleFloat|)) (|:| |lineCol| (|String|))
              (|:| |fillCol| (|String|)) (|:| |matOpacity| (|DoubleFloat|))))
   "\\spad{createSceneMaterial(mat)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy line width is expressed relative to the width of current boundary"))
 (|addSceneGraph|
  (($ $ (|DirectedGraph| (|String|)) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|Boolean|))
   "\\spad{addSceneGraph(n,{} g,{} x,{} y,{} dispArrowName)} is a convenience function which combines createSceneGraph with addChild!"))
 (|createSceneGraph|
  (($ (|DirectedGraph| (|String|)) (|NonNegativeInteger|)
    (|NonNegativeInteger|) (|Boolean|))
   "\\spad{createSceneGraph(g,{} x,{} y,{} dispArrowName)} creates a graph theory diagram"))
 (|addSceneRuler|
  (($ $ (|Symbol|) |#1| (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ $ (|Symbol|) |#1| (|SBoundary| |#1|))
   "\\spad{addSceneRuler(n,{} ptype,{} offset,{} bb)} is a convenience function which combines createSceneRuler with addChild!"))
 (|createSceneRuler|
  (($ (|Symbol|) |#1| (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|Symbol|) |#1| (|SBoundary| |#1|))
   "\\spad{createSceneRuler(ptype,{} offset,{} bb)} creates a scale that can be used to provide numeric values for an axis: ptype= \"HORIZONTAL\"::Symbol : horizontal axis. ptype= \"VERTICAL\"::Symbol: vertical axis. ptype= \"DEBTH\"::Symbol: depth axis."))
 (|addScenePattern|
  (($ $ (|Symbol|) (|NonNegativeInteger|)
    (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ $ (|Symbol|) (|NonNegativeInteger|) (|SBoundary| |#1|))
   "\\spad{addScenePattern(n,{} ptype,{} step,{} bb)} is a convenience function which combines createScenePattern with addChild!"))
 (|createScenePattern|
  (($ (|Symbol|) (|NonNegativeInteger|)
    (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|Symbol|) (|NonNegativeInteger|) (|SBoundary| |#1|))
   "\\spad{createScenePattern(ptype,{} step,{} bb)} creates a test pattern suitable for showing the effect of transforms. The pattern depends on \\spad{ptype} parameter as follows: ptype=\"GRID\"::Symbol : construct a set of horizontal and vertical lines in the current clip boundary and current material with a spacing between lines given by the \\spad{step} parameter. ptype=\"SIERPINSKI\"::Symbol: constructs a Sierpinski fractal. \\spad{step} parameter gives the level of subdivision. ptype=\"HOUSE\"::Symbol: constructs a house shape."))
 (|addSceneGrid|
  (($ $ (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ $ (|SBoundary| |#1|))
   "\\spad{addSceneGrid(n,{} bb)} is a convenience function which combines createSceneGrid with addChild!")
  (($ $ (|DoubleFloat|) (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ $ (|DoubleFloat|) (|SBoundary| |#1|))
   "\\spad{addSceneGrid(n,{} stepSize,{} bb)} is a convenience function which combines createSceneGrid with addChild!"))
 (|createSceneGrid|
  (($ (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|SBoundary| |#1|))
   "\\spad{createSceneGrid(bb)} constructs a grid with narrow blue lines every 20 units wide blue lines every 100 units wide red lines every 200 units")
  (($ (|DoubleFloat|) (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|DoubleFloat|) (|SBoundary| |#1|))
   "\\spad{createSceneGrid(stepSize,{} bb)} constructs a grid,{} consists of a group,{} under which are vertical and horizontal lines. The spacing between lines is given by step."))
 (|addSceneClip|
  (($ $ (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ $ (|SBoundary| |#1|))
   "\\spad{addSceneClip(n,{} bb)} is a convenience function which combines createSceneClip with addChild!"))
 (|createSceneClip|
  (($ (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|SBoundary| |#1|))
   "\\spad{createSceneClip(bb)} constructs a clip node,{} clips its sub nodes in the coordinate system in force at the clip node."))
 (|addSceneText|
  (($ $ (|List| (|String|)) (|NonNegativeInteger|) |#1|)
   "\\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!")
  (($ $ (|String|) (|NonNegativeInteger|) |#1|)
   "\\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!")
  (($ $
    (|Record| (|:| |txt| (|String|)) (|:| |siz| (|NonNegativeInteger|))
              (|:| |pos| |#1|) (|:| |np| (|List| (|String|)))))
   "\\spad{addSceneText(n,{} text)} is a convenience function which combines createSceneText with addChild!"))
 (|createSceneText|
  (($ (|List| (|String|)) (|NonNegativeInteger|) |#1|)
   "\\spad{createSceneText(str,{} sz,{} pz)} constructs a text node using information from named points node.")
  (($ (|String|) (|NonNegativeInteger|) |#1|)
   "\\spad{createSceneText(str,{} sz,{} pz)} constructs a text node,{} text can be used for labelling anything such as graphs,{} axes and so on.")
  (($
    (|Record| (|:| |txt| (|String|)) (|:| |siz| (|NonNegativeInteger|))
              (|:| |pos| |#1|) (|:| |np| (|List| (|String|)))))
   "\\spad{createSceneText(text)} constructs a \\spad{text} node,{} \\spad{text} can be used for labelling anything such as graphs,{} axes and so on."))
 (|addSceneBox|
  (($ $ (|DoubleFloat|))
   "\\spad{addSceneBox(n,{} size)} is a convenience function which combines createSceneBox with addChild!"))
 (|createSceneBox|
  (($ (|DoubleFloat|))
   "\\spad{createSceneBox(size)} constructs an indexed face set node which is a 3D box of a given \\spad{size}"))
 (|addSceneIFS|
  (($ $ (|SceneIFS| |#1|))
   "\\spad{addSceneIFS(n,{} in1)} is a convenience function which combines createSceneIFS with addChild!")
  (($ $ (|List| (|List| (|NonNegativeInteger|))) (|List| |#1|))
   "\\spad{addSceneIFS(n,{} inx,{} pts)} is a convenience function which combines createSceneIFS with addChild!"))
 (|createSceneIFS|
  (($ (|SceneIFS| |#1|))
   "\\spad{createSceneIFS(in1)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \\spad{n}-dimensional space.")
  (($ (|List| (|List| (|NonNegativeInteger|))) (|List| |#1|))
   "\\spad{createSceneIFS(inx,{} pts)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \\spad{n}-dimensional space."))
 (|addSceneNamedPoints|
  (($ $ (|SceneNamedPoints| |#1|))
   "\\spad{addSceneNamedPoints(n,{} np)} is a convenience function which combines createSceneNamedPoints with addChild!"))
 (|createSceneNamedPoints|
  (($ (|SceneNamedPoints| |#1|))
   "\\spad{createSceneNamedPoints(np)} constructs a named points node,{} this allows us to define a set of points which can be used multiple times in the scenegraph."))
 (|addSceneArrow|
  (($ $ $ $ |#1| (|Symbol|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size,{} fontScale)} is a convenience function which combines createSceneArrow with addChild!")
  (($ $ (|String|) (|String|) |#1| (|Symbol|) (|DoubleFloat|))
   "\\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size)} is a convenience function which combines createSceneArrow with addChild!"))
 (|createSceneArrow|
  (($ $ $ |#1| (|Symbol|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size,{} fontScale)} constructs an arrow node,{} in \\spad{n}-dimensional space,{} going from \\spad{st} to \\spad{en}. 'st' and 'en' are nodes in the scene and the arrows will be drawn upto their boundary. \\spad{st} is the node at the start of the arrow \\spad{en} is the node at the end of the arrow 'mode' and 'size' parameters determine the \\spad{size} of the arrowhead. \\spad{mode} can have the following values: \\indented{2}{\"fixed\"::Symbol \\spad{--} fixed \\spad{size} line width given by 'size' parameter} \\indented{2}{\"proportional\"::Symbol \\spad{--} \\spad{size} as a proportion of the overall bounds} \\indented{2}{\"variable\"::Symbol \\spad{--} \\spad{size} as a proportion of the arrow length} So \"proportional\" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. \"variable\" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \\spad{st} or \\spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.")
  (($ (|String|) (|String|) |#1| (|Symbol|) (|DoubleFloat|))
   "\\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size)} constructs an arrow node,{} in \\spad{n}-dimensional space,{} going from \\spad{st} to \\spad{en}. 'st' and 'en' are determined from a list of points from named points node. \\spad{st} is the start of the arrow \\spad{en} is the end of the arrow 'mode' and 'size' parameters determine the size of the arrowhead. \\spad{mode} can have the following values: \\indented{2}{\"fixed\"::Symbol \\spad{--} fixed size line width given by 'size' parameter} \\indented{2}{\"proportional\"::Symbol \\spad{--} size as a proportion of the overall bounds} \\indented{2}{\"variable\"::Symbol \\spad{--} size as a proportion of the arrow length} So \"proportional\" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. \"variable\" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force."))
 (|addSceneArrows|
  (($ $ (|List| (|List| |#1|)) (|Symbol|) (|DoubleFloat|))
   "\\spad{addSceneArrows(n,{} line,{} mode,{} size)} is a convenience function which combines createSceneArrows with addChild!"))
 (|createSceneArrows|
  (($ (|List| (|List| |#1|)) (|Symbol|) (|DoubleFloat|))
   "\\spad{createSceneArrows(line,{} mode,{} size)} constructs an arrow node,{} this contains arrows (represented by a list of points) in \\spad{n}-dimensional space. The space is implicit in the \\spad{PT} and \\spad{TR} parameters supplied when this Scene was created. 'mode' and 'size' parameters determine the size of the arrowhead. \\spad{mode} can have the following values: \\indented{2}{\"fixed\"::Symbol \\spad{--} fixed size \\spad{line} width given by 'size' parameter} \\indented{2}{\"proportional\"::Symbol \\spad{--} size as a proportion of the overall bounds} \\indented{2}{\"variable\"::Symbol \\spad{--} size as a proportion of the arrow length} So \"proportional\" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. \"variable\" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force."))
 (|addSceneUse|
  (($ $ (|String|))
   "\\spad{addSceneUse(n,{} nam)} is a convenience function which combines createSceneUse with addChild!"))
 (|createSceneUse|
  (($ (|String|))
   "\\spad{createSceneUse(nam)} uses another point in the scenegraph."))
 (|addSceneDef|
  (($ $ (|String|) $)
   "\\spad{addSceneDef(n,{} nam,{} nde)} is a convenience function which combines createSceneDef with addChild!"))
 (|createSceneDef|
  (($ (|String|) $)
   "\\spad{createSceneDef(nam,{} nde)} defines a point in the scenegraph so that it can be used elsewhere."))
 (|addSceneShape|
  (($ $ (|SBoundary| |#1|))
   "\\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!")
  (($ $
    (|Record| (|:| |shptype| (|Symbol|)) (|:| |centre| |#1|) (|:| |size| |#1|)
              (|:| |fill| (|Boolean|))))
   "\\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!"))
 (|createSceneShape|
  (($ (|SBoundary| |#1|))
   "\\spad{createSceneShape(shape)} constructs a \\spad{shape} node from a boundary,{} this contains a \\spad{shape} such as a rectangle or an ellipse.")
  (($
    (|Record| (|:| |shptype| (|Symbol|)) (|:| |centre| |#1|) (|:| |size| |#1|)
              (|:| |fill| (|Boolean|))))
   "\\spad{createSceneShape(shape)} constructs a \\spad{shape} node,{} this contains a \\spad{shape} such as a rectangle or an ellipse."))
 (|addSceneLines|
  (($ $ (|List| (|List| |#1|)))
   "\\spad{addSceneLines(n,{} line)} is a convenience function which combines createSceneLines with addChild!"))
 (|createSceneLines|
  (($ (|List| (|List| |#1|)))
   "\\spad{createSceneLines(line)} constructs a \\spad{line} node,{} this contains lines (represented by a list of points) in \\spad{n}-dimensional space. The space is implicit in the \\spad{PT} and \\spad{TR} parameters supplied when this Scene was created."))
 (|addSceneLine|
  (($ $ $ $ (|DoubleFloat|) (|Boolean|))
   "\\spad{addSceneLine(n,{} st,{} en,{} fontScale)} is a convenience function which combines createSceneLine with addChild!")
  (($ $ $ $ (|DoubleFloat|))
   "\\spad{addSceneLine(n,{} st,{} en,{} fontScale)} is a convenience function which combines createSceneLine with addChild!")
  (($ $ (|List| |#1|))
   "\\spad{addSceneLine(n,{} line)} is a convenience function which combines createSceneLine with addChild!"))
 (|createSceneLine|
  (($ $ $ (|DoubleFloat|) (|Boolean|))
   "\\spad{createSceneLine(st,{} en,{} fontScale,{} shortenLine)} constructs a line node,{} that contains a line,{} in \\spad{n}-dimensions,{} from \\spad{st} to \\spad{en}. 'st' and 'en' are nodes in the scene and the line will be drawn upto their boundary. \\spad{st} is the node at the start of the line \\spad{en} is the node at the end of the line \\spad{fontScale} should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \\spad{st} or \\spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant. shortenLine if \\spad{true} line drawn upto boundary rather than \\indented{12}{centre of destination.}")
  (($ $ $ (|DoubleFloat|))
   "\\spad{createSceneLine(st,{} en,{} fontScale)} constructs a line node,{} that contains a line,{} in \\spad{n}-dimensions,{} from \\spad{st} to \\spad{en}. 'st' and 'en' are nodes in the scene and the line will be drawn upto their boundary. \\spad{st} is the node at the start of the line \\spad{en} is the node at the end of the line fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \\spad{st} or \\spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.")
  (($ (|List| |#1|))
   "\\spad{createSceneLine(line)} constructs a \\spad{line} node,{} this contains a \\spad{line} (represented by a list of points) in \\spad{n}-dimensional space. The space is implicit in the \\spad{PT} and \\spad{TR} parameters supplied when this Scene was created."))
 (|addSceneGroup|
  (($ $)
   "\\spad{addSceneGroup(n)} is a convenience function which combines createSceneGroup with addChild!"))
 (|createSceneGroup|
  (($)
   "\\spad{createSceneGroup()} constructs a group node,{} this node does not do anything itself but contains other nodes"))
 (|createSceneRoot|
  (($ (|Integer|) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{createSceneRoot(minx,{} miny,{} maxx,{} maxy)} constructs the root node,{} all other nodes are contained in a tree structure under this node")
  (($ (|Record| (|:| |mins| |#1|) (|:| |maxs| |#1|)))
   "deprecated: this has been superseded by version with SBoundary(\\spad{PT}) do not use,{} may be removed in the future.")
  (($ (|SBoundary| |#1|))
   "\\spad{createSceneRoot(bb)} constructs the root node,{} all other nodes are contained in a tree structure under this node")
  (($)
   "\\spad{createSceneRoot()} constructs the root node,{} all other nodes are contained in a tree structure under this node"))) 
NIL 
(|SceneIFS| PT) 
((|constructor|
  (NIL
   "Generates various surfaces (2 dimensional subsets of 3D space). When 1 dimensional subspace (a line) needs to be represented in a 3D editor then we convert the line into a tube. Many of the functions here are from NumericTubePlot and related packages. However \\spad{I} needed them to be defined over SPointCategory so \\spad{I} adapted them here."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(me)} list this instance to the command line"))
 (|pointList|
  (((|List| |#1|) $)
   "\\spad{pointList(me)} returns points at vertices of this mesh."))
 (|indexes|
  (((|List| (|List| (|NonNegativeInteger|))) $)
   "\\spad{indexes(me)} returns indexes into pointList(\\spad{me})"))
 (|curveLoops|
  (((|List| (|List| |#1|)) (|List| |#1|) (|DoubleFloat|) (|Integer|))
   "\\spad{curveLoops(pts1,{} r,{} nn)} generates ifs from line given by \\spad{pts1}"))
 (|stube|
  (($
    (|List|
     (|Record| (|:| |source| (|Mapping| |#1| (|DoubleFloat|)))
               (|:| |ranges| (|List| (|Segment| (|DoubleFloat|))))
               (|:| |knots| (|List| (|DoubleFloat|)))
               (|:| |points| (|List| |#1|))))
    (|DoubleFloat|) (|Integer|))
   "\\spad{stube(functions: List Clipd,{} r,{} n)} creates a tube of radius \\spad{r} around the curve functions."))
 (|sierpinskiDivide|
  (($ $ (|NonNegativeInteger|))
   "\\spad{sierpinskiDivide(me,{} level)} for each edge of each face calculate a new point in the centre of the edge,{} then build a new set of faces which include the new points."))
 (|subdivide|
  (($ $)
   "\\spad{subdivide(me)} for each face calculate a new point in the centre of the face,{} then build a new set of faces which include the new point."))
 (|singleFace|
  (($ (|List| |#1|))
   "\\spad{singleFace(ptin)} constructs a ifs representation of a face from an array of points"))
 (|smesh|
  (($ (|List| (|List| |#1|)) (|Boolean|))
   "\\spad{smesh(ptin,{} clos)} constructs a ifs representation of a mesh from a 2 dimensional array of points"))) 
NIL 
(|SceneNamedPoints| PT) 
((|constructor|
  (NIL
   "Associates points or nodes in Scene structure with names (or a hierarchy of names). The aim is,{} where a point or node is used in several different constructions,{} it only needs to be specified once."))
 (|toString|
  (((|String|) $)
   "\\spad{toString(n)} returns string representation for debug purposes."))
 (|findNode|
  (((|Scene| |#1|) $ (|String|))
   "\\spad{findNode(n,{} ptName)} finds a scene node"))
 (|addNode!|
  (($ $ (|String|) (|Scene| |#1|))
   "\\spad{addNode!(n,{} ptName,{} sc)} adds a scene node."))
 (|addPoints!|
  (($ $ (|String|) $)
   "\\spad{addPoints!(n,{} ptName,{} pts)} adds a points node."))
 (|findPoint|
  ((|#1| $ (|String|))
   "\\spad{findPoint(n,{} ptName)} find the point associated with a given string."))
 (|getNames|
  (((|List| (|String|)) $)
   "\\spad{getNames(n)} returns a list of names for this node"))
 (|isNodeBranch?|
  (((|Boolean|) $)
   "\\spad{isNodeBranch?(n)} returns \\spad{true} if this is a branch."))
 (|isNodeLeaf?|
  (((|Boolean|) $)
   "\\spad{isNodeLeaf?(n)} returns \\spad{true} if this is a leaf which holds Scene nodes."))
 (|isPointLeaf?|
  (((|Boolean|) $)
   "\\spad{isPointLeaf?(n)} returns \\spad{true} if this is a \\spad{pt} node,{} that is,{} if this node contains points"))
 (|namedBranch|
  (($ (|List| $) (|List| (|String|)))
   "\\spad{namedBranch(chin,{} nmin)} constructs a branch in the tree structure"))
 (|namedPoints|
  (($ (|List| (|Scene| |#1|)) (|List| (|String|)))
   "\\spad{namedPoints(scin,{} nmin)} constructs a list of named nodes.")
  (($ (|List| |#1|) (|List| (|String|)))
   "\\spad{namedPoints(ptin,{} nmin)} constructs a list of named points."))) 
NIL 
(|SConformal| |n|) 
((|constructor|
  (NIL
   "\\indented{1}{number of base dimensions (excluding point at infinity and point} at origin)"))
 (|normalisePoint|
  (($ $)
   "normalised point has scalar value of one,{} if this is not the case then scale values"))) 
NIL 
(|StructuralConstantsPackage| R) 
((|constructor|
  (NIL
   "StructuralConstantsPackage provides functions creating structural constants from a multiplication tables or a basis of a matrix algebra and other useful functions in this context."))
 (|coordinates|
  (((|Vector| |#1|) (|Matrix| |#1|) (|List| (|Matrix| |#1|)))
   "\\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)))
   "\\spad{structuralConstants(basis)} takes the \\spad{basis} of a matrix algebra,{} \\spadignore{e.g.} the result of \\spadfun{basisOfCentroid} and calculates the structural constants. Note,{} that the it is not checked,{} whether \\spad{basis} really is a \\spad{basis} of a matrix algebra.")
  (((|Vector| (|Matrix| (|Polynomial| |#1|))) (|List| (|Symbol|))
    (|Matrix| (|Polynomial| |#1|)))
   "\\spad{structuralConstants(ls,{} mt)} determines the structural constants of an algebra with generators \\spad{ls} and multiplication table \\spad{mt},{} the entries of which must be given as linear polynomials in the indeterminates given by \\spad{ls}. The result is in particular useful \\indented{1}{as fourth argument for \\spadtype{AlgebraGivenByStructuralConstants}} \\indented{1}{and \\spadtype{GenericNonAssociativeAlgebra}.}")
  (((|Vector| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|))
    (|Matrix| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{structuralConstants(ls,{} mt)} determines the structural constants of an algebra with generators \\spad{ls} and multiplication table \\spad{mt},{} the entries of which must be given as linear polynomials in the indeterminates given by \\spad{ls}. The result is in particular useful \\indented{1}{as fourth argument for \\spadtype{AlgebraGivenByStructuralConstants}} \\indented{1}{and \\spadtype{GenericNonAssociativeAlgebra}.}"))) 
NIL 
(|SCartesian| |n|) 
((|constructor|
  (NIL
   "an implementation of PointCategory to represent points and vectors in three dimensional coordinate space"))) 
NIL 
(|SequentialDifferentialPolynomial| R) 
((|constructor|
  (NIL
   "\\spadtype{SequentialDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates,{} with coefficients in a ring. The ranking on the differential indeterminate is sequential. \\blankline"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|DifferentialRing|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory|
  (|IndexedExponents| (|SequentialDifferentialVariable| (|Symbol|)))
  '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|DifferentialRing|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|DifferentialRing|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|))
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|SequentialDifferentialVariable| S) 
((|constructor|
  (NIL
   "\\spadtype{OrderlyDifferentialVariable} adds a commonly used sequential ranking to the set of derivatives of an ordered list of differential indeterminates. A sequential ranking is a ranking \\spadfun{<} of the derivatives with the property that for any derivative \\spad{v},{} there are only a finite number of derivatives \\spad{u} with \\spad{u} \\spadfun{<} \\spad{v}. This domain belongs to \\spadtype{DifferentialVariableCategory}. It defines \\spadfun{weight} to be just \\spadfun{order},{} and it defines a sequential ranking \\spadfun{<} on derivatives \\spad{u} by the lexicographic order on the pair (\\spadfun{variable}(\\spad{u}),{} \\spadfun{order}(\\spad{u}))."))) 
NIL 
(|Segment| S) 
((|constructor|
  (NIL "This type is used to specify a range of values from type \\spad{S}."))) 
((|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedRing|)) (|HasCategory| |#1| '(|SetCategory|))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (|HasCategory| |#1| '(|AbelianGroup|))) 
(|SegmentFunctions2| R S) 
((|constructor|
  (NIL
   "This package provides operations for mapping functions onto segments."))
 (|map|
  (((|List| |#2|) (|Mapping| |#2| |#1|) (|Segment| |#1|))
   "\\spad{map(f,{} s)} expands the segment \\spad{s},{} applying \\spad{f} to each value. For example,{} if \\spad{s = l..h by k},{} then the list \\spad{[f(l),{} f(l+k),{} ...,{} f(lN)]} is computed,{} where \\spad{lN <= h < lN+k}.")
  (((|Segment| |#2|) (|Mapping| |#2| |#1|) (|Segment| |#1|))
   "\\spad{map(f,{} l..h)} returns a new segment \\spad{f(l)..f(h)}."))) 
((|HasCategory| |#1| '(|OrderedRing|))) 
(|SegmentBinding| S) 
((|constructor|
  (NIL
   "This domain is used to provide the function argument syntax \\spad{v=a..b}. This is used,{} for example,{} by the top-level \\spadfun{draw} functions."))
 (|segment|
  (((|Segment| |#1|) $)
   "\\spad{segment(segb)} returns the segment from the right hand side of the \\spadtype{SegmentBinding}. For example,{} if \\spad{segb} is \\spad{v=a..b},{} then \\spad{segment(segb)} returns \\spad{a..b}."))
 (|variable|
  (((|Symbol|) $)
   "\\spad{variable(segb)} returns the variable from the left hand side of the \\spadtype{SegmentBinding}. For example,{} if \\spad{segb} is \\spad{v=a..b},{} then \\spad{variable(segb)} returns \\spad{v}."))
 (|equation|
  (($ (|Symbol|) (|Segment| |#1|))
   "\\spad{equation(v,{} a..b)} creates a segment binding value with variable \\spad{v} and segment \\spad{a..b}. Note that the interpreter parses \\spad{v=a..b} to this form."))) 
((|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|SetCategory|))) 
(|SegmentBindingFunctions2| R S) 
((|constructor|
  (NIL
   "This package provides operations for mapping functions onto \\spadtype{SegmentBinding}\\spad{s}."))
 (|map|
  (((|SegmentBinding| |#2|) (|Mapping| |#2| |#1|) (|SegmentBinding| |#1|))
   "\\spad{map(f,{} v=a..b)} returns the value given by \\spad{v=f(a)..f(b)}."))) 
NIL 
(|SegmentCategory| S) 
((|constructor|
  (NIL
   "This category provides operations on ranges,{} or {\\em segments} as they are called."))
 (|reverse|
  (($ $) "\\spad{reverse(s)} returns segment \\spad{s} in reverse order."))
 (-
  (($ $ |#1|) "\\spad{(l..h)\\spad{-i}} returns segment \\spad{l-i .. h-i}."))
 (+ (($ $ |#1|) "\\spad{(l..h)\\spad{+i}} returns segment \\spad{l+i .. h+i}.")
    (($ |#1| $) "\\spad{i+(l..h)} returns segment \\spad{i+l .. i+h}."))
 (|convert| (($ |#1|) "\\spad{convert(i)} creates the segment \\spad{i..i}."))
 (|segment|
  (($ |#1| |#1|)
   "\\spad{segment(i,{} j)} is an alternate way to create the segment \\spad{i..j}."))
 (|incr|
  (((|Integer|) $)
   "\\spad{incr(s)} returns \\spad{n},{} where \\spad{s} is a segment in which every \\spad{n}\\spad{-}th element is used. Note: \\spad{incr(l..h by n) = n}."))
 (|high|
  ((|#1| $)
   "\\spad{high(s)} returns the second endpoint of \\spad{s}. Note: \\spad{high(l..h) = h}."))
 (|low|
  ((|#1| $)
   "\\spad{low(s)} returns the first endpoint of \\spad{s}. Note: \\spad{low(l..h) = l}."))
 (BY
  (($ $ (|Integer|))
   "\\spad{s by n} creates a new segment in which only every \\spad{n}\\spad{-}th element is used."))
 (SEGMENT
  (($ |#1| |#1|)
   "\\spad{l..h} creates a segment with \\spad{l} and \\spad{h} as the endpoints."))) 
NIL 
(|SegmentExpansionCategory| S L) 
((|constructor|
  (NIL
   "This category provides an interface for expanding segments to a stream of elements."))
 (|map|
  ((|#2| (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} l..h by k)} produces a value of type \\spad{L} by applying \\spad{f} to each of the successive elements of the segment,{} that is,{} \\spad{[f(l),{} f(l+k),{} ...,{} f(lN)]},{} where \\spad{lN <= h < lN+k}."))
 (|expand|
  ((|#2| $)
   "\\spad{expand(l..h by k)} creates value of type \\spad{L} with elements \\spad{l,{} l+k,{} ... lN} where \\spad{lN <= h < lN+k}. For example,{} \\spad{expand(1..5 by 2) = [1,{} 3,{} 5]}.")
  ((|#2| (|List| $))
   "\\spad{expand(l)} creates a new value of type \\spad{L} in which each segment \\spad{l..h by k} is replaced with \\spad{l,{} l+k,{} ... lN},{} where \\spad{lN <= h < lN+k}. For example,{} \\spad{expand [1..4,{} 7..9] = [1,{} 2,{} 3,{} 4,{} 7,{} 8,{} 9]}."))) 
NIL 
(|SparseEchelonMatrix| C D) 
((|constructor|
  (NIL
   "\\spad{SparseEchelonMatrix(C,{} D)} implements sparse matrices whose columns are enumerated by the \\spadtype{OrderedSet} \\spad{C} and whose entries belong to the \\spadtype{GcdDomain} \\spad{D}. The basic operation of this domain is the computation of an row echelon form. The algorithm used tries to maintain the sparsity and is especially adapted to matrices which are already close to a row echelon form."))
 (|horizSplit|
  (((|Record| (|:| |Left| $) (|:| |Right| $)) $ |#1|)
   "\\spad{horizSplit(A,{} c)} splits the matrix \\spad{A} into two at the column given by \\spad{c}. The first column of the right matrix is enumerated by the first index less or equal to \\spad{c}."))
 (|horizJoin|
  (($ $ $)
   "\\spad{horizJoin(A,{} B)} horizontally concats the matrices \\spad{A} and \\spad{B}. It is assumed that all indices of \\spad{B} are smaller than those of \\spad{A}."))
 (|join|
  (($ $ $)
   "\\spad{join(A,{} B)} vertically concats the matrices \\spad{A} and \\spad{B}."))
 (*
  (($ (|Matrix| (|Fraction| |#2|)) $)
   "\\spad{L*A} implements left multiplication with a usual matrix over the quotient field of \\spad{D}.")
  (($ (|Matrix| |#2|) $)
   "\\spad{L*A} implements left multiplication with a usual matrix."))
 (|pivots|
  (((|Record| (|:| |Indices| (|List| |#1|)) (|:| |Entries| (|List| |#2|))) $)
   "\\spad{pivots(A)} returns all leading entries of the matrix \\spad{A} together with their indices."))
 (|pivot|
  (((|Record| (|:| |Index| |#1|) (|:| |Entry| |#2|)) $ (|Integer|))
   "\\spad{pivot(A,{} i)} returns the leading entry of the \\spad{i}\\spad{-}th row of the matrix \\spad{A} together with its index."))
 (|primitiveRowEchelon|
  (((|Record| (|:| |Ech| $) (|:| |Lt| (|Matrix| (|Fraction| |#2|)))
              (|:| |Pivots| (|List| |#2|)) (|:| |Rank| (|NonNegativeInteger|)))
    $)
   "\\spad{primitiveRowEchelon(A)} computes a row echelon form for the matrix \\spad{A}. The algorithm used is fraction-free elimination. Every row is made primitive by division by the \\spad{gcd}. The algorithm is especially adapted to matrices already close to row echelon form. The transformation matrix,{} the used pivots and the rank of the matrix are also returned."))
 (|setGcdMode|
  (((|Symbol|) (|Symbol|))
   "\\spad{setGcdMode(s)} sets a new value for the flag deciding on the method used to compute gcd`s for lists. Possible values for \\spad{s} are \\spad{iterated} and \\spad{random}."))
 (|rowEchelon|
  (((|Record| (|:| |Ech| $) (|:| |Lt| (|Matrix| |#2|))
              (|:| |Pivots| (|List| |#2|)) (|:| |Rank| (|NonNegativeInteger|)))
    $)
   "\\spad{primitiveRowEchelon(A)} computes a row echelon form for the matrix \\spad{A}. The algorithm used is fraction-free elimination. It is especially adapted to matrices already close to row echelon form. The transformation matrix,{} the used pivots and the rank of the matrix are also returned."))
 (|extract|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{extract(A,{} i1,{} i2)} extracts the rows \\spad{i1} to \\spad{i2} and returns them as a new matrix."))
 (|appendRow!|
  (((|Void|) $
    (|Record| (|:| |Indices| (|List| |#1|)) (|:| |Entries| (|List| |#2|))))
   "\\spad{appendRow!(A,{} r)} appends the row \\spad{r} at the end of the matrix \\spad{A}."))
 (|consRow!|
  (((|Void|) $
    (|Record| (|:| |Indices| (|List| |#1|)) (|:| |Entries| (|List| |#2|))))
   "\\spad{consRow!(A,{} r)} inserts the row \\spad{r} at the top of the matrix \\spad{A}."))
 (|deleteRow!|
  (((|Void|) $ (|Integer|))
   "\\spad{deleteRow(A,{} i)} deletes the \\spad{i}\\spad{-}th row of the matrix \\spad{A}."))
 (|setRow!|
  (((|Void|) $ (|Integer|) (|List| |#1|) (|List| |#2|))
   "\\spad{setRow!(A,{} i,{} ind,{} ent)} sets the \\spad{i}\\spad{-}th row of the matrix \\spad{A}. Its indices are \\spad{ind}; the entries \\spad{ent}.")
  (((|Void|) $ (|Integer|)
    (|Record| (|:| |Indices| (|List| |#1|)) (|:| |Entries| (|List| |#2|))))
   "\\spad{setRow!(A,{} i,{} ind,{} ent)} sets the \\spad{i}\\spad{-}th row of the matrix \\spad{A} to the value \\spad{r}."))
 (|row|
  (((|Record| (|:| |Indices| (|List| |#1|)) (|:| |Entries| (|List| |#2|))) $
    (|Integer|))
   "\\spad{row(A,{} i)} returns the \\spad{i}\\spad{-}th row of the matrix \\spad{A}."))
 (|setelt!|
  (((|Void|) $ (|Integer|) |#1| |#2|)
   "\\spad{setelt!(A,{} i,{} c,{} d)} sets the entry of the matrix \\spad{A} in row \\spad{i} and in the column with index \\spad{c} to the value \\spad{d}."))
 (|elt|
  ((|#2| $ (|Integer|) |#1|)
   "\\spad{elt(A,{} i,{} c)} returns the entry of the matrix \\spad{A} in row \\spad{i} and in the column with index \\spad{c}."))
 (|new|
  (($ (|List| |#1|) (|Integer|))
   "\\spad{new(inds,{} nrows)} generates a new matrix with \\spad{nrows} rows and columns enumerated by the indices \\spad{inds}. The matrix is empty,{} \\spadignore{i.e.} the zero matrix."))
 (|sortedPurge!|
  (((|Void|) $ (|Mapping| (|Boolean|) |#1|))
   "\\spad{sortedPurge!(A,{} crit)} is like \\spad{purge},{} however,{} with the additional assumption that \\spad{crit} respects the ordering of the indices."))
 (|purge!|
  (((|Void|) $ (|Mapping| (|Boolean|) |#1|))
   "\\spad{purge!(A,{} crit)} eliminates all columns belonging to an index \\spad{c} such that \\spad{crit(c)} yields \\spad{true}."))
 (|elimZeroCols!|
  (((|Void|) $)
   "\\spad{elimZeroCols!(A)} removes columns which contain only zeros. This affects basically only the value of \\spad{allIndices(A)}."))
 (|allIndices|
  (((|List| |#1|) $)
   "\\spad{allIndices(A)} returns all indices used for enumerating the columns of the matrix \\spad{A}."))
 (|nrows|
  (((|NonNegativeInteger|) $)
   "\\spad{nrows(A)} returns the number of rows of the matrix \\spad{A}."))
 (|ncols|
  (((|NonNegativeInteger|) $)
   "\\spad{ncols(A)} returns the number of columns of the matrix \\spad{A}."))
 (|copy| (($ $) "\\spad{copy(A)} returns a copy of the matrix \\spad{A}."))
 (|coerce|
  (((|Matrix| |#2|) $)
   "\\spad{coerce(A)} yields the matrix \\spad{A} in the usual matrix type."))
 (|finiteAggregate| ((|attribute|) "Matrices are finite."))
 (|shallowlyMutable| ((|attribute|) "Matrices may be altered destructively."))) 
((|HasCategory| |#2| '(|GcdDomain|)) (|HasCategory| |#2| '(|IntegralDomain|))) 
(|Sequence| R) 
((|constructor|
  (NIL
   "A domain for infinite sequences over a commutative ring. It is implemented as stream with arithmetics."))) 
((AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|BasicType|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|)))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))) 
(|SequenceFunctions2| R1 R2) 
((|constructor| (NIL "A domain for mappings between sequences."))
 (|map|
  (((|Sequence| |#2|) (|Mapping| |#2| |#1|) (|Sequence| |#1|))
   "\\spad{map(f,{} x)} maps the function \\spad{f} on the entries of \\spad{x}"))) 
NIL 
(|SequenceCategory| R) 
((|constructor|
  (NIL
   "A category for infinite sequences over a commutative ring. It is a stream with arithmetics."))
 (|dilate|
  (($ |#1| $)
   "\\spad{dilate(a,{} x)} returns the sequence \\$a^n \\spad{x_n}\\$ (starting at \\$\\spad{n=1}\\$)"))
 (|firstn|
  (((|List| |#1|) $ (|NonNegativeInteger|))
   "\\spad{firstn(x,{} n)} returns a list of the first \\spad{n} entries"))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(x,{} n)} returns the sequence of the first \\spad{n} entries"))
 (|stream| (((|Stream| |#1|) $) "\\spad{stream(x)} returns stream of entries"))
 (|sequence|
  (($ (|Mapping| |#1| |#1|) |#1|)
   "\\spad{sequence(f,{} s0)} generates a stream recursively by applying the function \\spad{f:} \\spad{S} \\spad{->} \\spad{S} to the last computed value.")
  (($ (|Stream| |#1|))
   "\\spad{sequence(x)} turns the stream \\spad{x} into a sequence"))
 (|coerce| (($ (|Stream| |#1|)) "\\spad{coerce(x)} creation of elements"))
 (|cons|
  (($ |#1| $)
   "\\spad{cons(r,{} s)} prepends \\spad{r} to the stream \\spad{s}"))
 (|apply|
  ((|#1| $ (|Partition|))
   "\\spad{elt(mm,{} \\spad{pi})} returns the product of the entries indexed by the integer partition \\spad{pi} (as in partitionend moments)"))
 (|elt|
  ((|#1| $ (|Integer|))
   "\\spad{elt(mm,{} n)} returns the \\spad{n}th element of a sequence."))) 
NIL 
(|Set| S) 
((|constructor|
  (NIL
   "A set over a domain \\spad{S} models the usual mathematical notion of a finite set of elements from \\spad{S}. Sets are unordered collections of distinct elements (that is,{} order and duplication does not matter). The notation \\spad{set [a,{} b,{} c]} can be used to create a set and the usual operations such as union and intersection are available to form new sets. If \\spad{S} has OrderdSet,{} \\Language{} maintains the entries in sorted order. Specifically,{} the parts function returns the entries as a list in ascending order and the \\spadfun{extract!} operation returns the maximum entry. Given two sets \\spad{s} and \\spad{t} where \\spad{\\#s = m} and \\spad{\\#t = n},{} the complexity of \\indented{2}{\\spad{s = t} is \\spad{O(min(n,{} m))}} \\indented{2}{\\spad{s < t} is \\spad{O(max(n,{} m))}} \\indented{2}{\\spad{union(s,{} t)},{} \\spad{intersect(s,{} t)},{} \\spad{minus(s,{} t)},{} \\spad{symmetricDifference(s,{} t)} is \\spad{O(max(n,{} m))}} \\indented{2}{\\spad{member?(x,{} t)} is \\spad{O(n log n)}} \\indented{2}{\\spad{insert!(x,{} t)} and \\spad{remove!(x,{} t)} is \\spad{O(n)}}"))) 
((|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|Finite|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Comparable|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|Finite|)))
  (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
       (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| $ '(|shallowlyMutable|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|SetAggregate&| A S) 
((|constructor|
  (NIL
   "A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both,{} the relationship between the two cannot be described by inclusion or inheritance."))
 (|union|
  (($ |#2| $)
   "\\spad{union(x,{} u)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x},{} \\spad{union(x,{} u)} returns a copy of \\spad{u}.")
  (($ $ |#2|)
   "\\spad{union(u,{} x)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x},{} \\spad{union(u,{} x)} returns a copy of \\spad{u}.")
  (($ $ $)
   "\\spad{union(u,{} v)} returns the set aggregate of elements which are members of either set aggregate \\spad{u} or \\spad{v}."))
 (|subset?|
  (((|Boolean|) $ $)
   "\\spad{subset?(u,{} v)} tests if \\spad{u} is a subset of \\spad{v}. Note: equivalent to \\spad{reduce(and,{} [member?(x,{} v) for x in members(u)],{} true,{} false)}."))
 (|symmetricDifference|
  (($ $ $)
   "\\spad{symmetricDifference(u,{} v)} returns the set aggregate of elements \\spad{x} which are members of set aggregate \\spad{u} or set aggregate \\spad{v} but not both. If \\spad{u} and \\spad{v} have no elements in common,{} \\spad{symmetricDifference(u,{} v)} returns a copy of \\spad{u}. Note: \\spad{symmetricDifference(u,{} v) = union(difference(u,{} v),{} difference(v,{} u))}"))
 (|difference|
  (($ $ |#2|)
   "\\spad{difference(u,{} x)} returns the set aggregate \\spad{u} with element \\spad{x} removed. If \\spad{u} does not contain \\spad{x},{} a copy of \\spad{u} is returned. Note: \\spad{difference(s,{} x) = difference(s,{} set [x])}.")
  (($ $ $)
   "\\spad{difference(u,{} v)} returns the set aggregate \\spad{w} consisting of elements in set aggregate \\spad{u} but not in set aggregate \\spad{v}. If \\spad{u} and \\spad{v} have no elements in common,{} \\spad{difference(u,{} v)} returns a copy of \\spad{u}. Note: equivalent to the notation (not currently supported) \\spad{[x for x in u | not member?(x,{} v)]}."))
 (|intersect|
  (($ $ $)
   "\\spad{intersect(u,{} v)} returns the set aggregate \\spad{w} consisting of elements common to both set aggregates \\spad{u} and \\spad{v}. Note: equivalent to the notation (not currently supported) [\\spad{x} for \\spad{x} in \\spad{u} | member?(\\spad{x},{} \\spad{v})]."))
 (|set|
  (($ (|List| |#2|))
   "\\spad{set([x,{} y,{} ...,{} z])} creates a set aggregate containing items \\spad{x},{} \\spad{y},{} ...,{} \\spad{z}.")
  (($)
   "\\spad{set()}\\$\\spad{D} creates an empty set aggregate of type \\spad{D}."))) 
NIL 
(|SetAggregate| S) 
((|constructor|
  (NIL
   "A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both,{} the relationship between the two cannot be described by inclusion or inheritance."))
 (|union|
  (($ |#1| $)
   "\\spad{union(x,{} u)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x},{} \\spad{union(x,{} u)} returns a copy of \\spad{u}.")
  (($ $ |#1|)
   "\\spad{union(u,{} x)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x},{} \\spad{union(u,{} x)} returns a copy of \\spad{u}.")
  (($ $ $)
   "\\spad{union(u,{} v)} returns the set aggregate of elements which are members of either set aggregate \\spad{u} or \\spad{v}."))
 (|subset?|
  (((|Boolean|) $ $)
   "\\spad{subset?(u,{} v)} tests if \\spad{u} is a subset of \\spad{v}. Note: equivalent to \\spad{reduce(and,{} [member?(x,{} v) for x in members(u)],{} true,{} false)}."))
 (|symmetricDifference|
  (($ $ $)
   "\\spad{symmetricDifference(u,{} v)} returns the set aggregate of elements \\spad{x} which are members of set aggregate \\spad{u} or set aggregate \\spad{v} but not both. If \\spad{u} and \\spad{v} have no elements in common,{} \\spad{symmetricDifference(u,{} v)} returns a copy of \\spad{u}. Note: \\spad{symmetricDifference(u,{} v) = union(difference(u,{} v),{} difference(v,{} u))}"))
 (|difference|
  (($ $ |#1|)
   "\\spad{difference(u,{} x)} returns the set aggregate \\spad{u} with element \\spad{x} removed. If \\spad{u} does not contain \\spad{x},{} a copy of \\spad{u} is returned. Note: \\spad{difference(s,{} x) = difference(s,{} set [x])}.")
  (($ $ $)
   "\\spad{difference(u,{} v)} returns the set aggregate \\spad{w} consisting of elements in set aggregate \\spad{u} but not in set aggregate \\spad{v}. If \\spad{u} and \\spad{v} have no elements in common,{} \\spad{difference(u,{} v)} returns a copy of \\spad{u}. Note: equivalent to the notation (not currently supported) \\spad{[x for x in u | not member?(x,{} v)]}."))
 (|intersect|
  (($ $ $)
   "\\spad{intersect(u,{} v)} returns the set aggregate \\spad{w} consisting of elements common to both set aggregates \\spad{u} and \\spad{v}. Note: equivalent to the notation (not currently supported) [\\spad{x} for \\spad{x} in \\spad{u} | member?(\\spad{x},{} \\spad{v})]."))
 (|set|
  (($ (|List| |#1|))
   "\\spad{set([x,{} y,{} ...,{} z])} creates a set aggregate containing items \\spad{x},{} \\spad{y},{} ...,{} \\spad{z}.")
  (($)
   "\\spad{set()}\\$\\spad{D} creates an empty set aggregate of type \\spad{D}."))) 
NIL 
(|SetCategory&| S) 
((|constructor|
  (NIL
   "\\spadtype{SetCategory} is the basic category for describing a collection of elements with \\spadop{=} (equality) and \\spadfun{coerce} to output form. \\blankline Conditional Attributes: \\indented{3}{canonical\\tab{15}data structure equality is the same as \\spadop{=}}"))
 (|latex|
  (((|String|) $)
   "\\spad{latex(s)} returns a LaTeX-printable output representation of \\spad{s}."))
 (|hashUpdate!|
  (((|HashState|) (|HashState|) $)
   "\\spad{hashUpdate!(hs,{} s)} computes new HashState from old and \\spad{s} used for incremental computation of hash values. hashUpdate! might destructively work on its first argument."))
 (|hash|
  (((|SingleInteger|) $)
   "\\spad{hash(s)} calculates a hash code for \\spad{s}."))) 
NIL 
(|SetCategory|) 
((|constructor|
  (NIL
   "\\spadtype{SetCategory} is the basic category for describing a collection of elements with \\spadop{=} (equality) and \\spadfun{coerce} to output form. \\blankline Conditional Attributes: \\indented{3}{canonical\\tab{15}data structure equality is the same as \\spadop{=}}"))
 (|latex|
  (((|String|) $)
   "\\spad{latex(s)} returns a LaTeX-printable output representation of \\spad{s}."))
 (|hashUpdate!|
  (((|HashState|) (|HashState|) $)
   "\\spad{hashUpdate!(hs,{} s)} computes new HashState from old and \\spad{s} used for incremental computation of hash values. hashUpdate! might destructively work on its first argument."))
 (|hash|
  (((|SingleInteger|) $)
   "\\spad{hash(s)} calculates a hash code for \\spad{s}."))) 
NIL 
(|SubsetLattice| S |top|) 
((|constructor|
  (NIL
   "Implementation of subset logic. \\indented{3}{implements pseudo complement} \\indented{3}{subset of powerset} \\indented{3}{related to 'containment order'} \\indented{3}{REP holds a single node and complete set (representing 'top')} Date Created: Oct 2015"))
 (|complement| (($ $ (|List| |#1|)) "pseudo complement")
  (($ $) "pseudo complement"))
 (|subsetLattice| (($ (|List| |#1|)) "construct subset lattice element"))) 
NIL 
(|SetOfMIntegersInOneToN| |m| |n|) 
((|constructor|
  (NIL
   "\\spadtype{SetOfMIntegersInOneToN} implements the subsets of \\spad{M} integers in the interval \\spad{[1..n]}"))
 (|delta|
  (((|NonNegativeInteger|) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{delta(S,{} k,{} p)} returns the number of elements of \\spad{S} which are strictly between \\spad{p} and the \\spad{k^}{th} element of \\spad{S}."))
 (|member?|
  (((|Boolean|) (|PositiveInteger|) $)
   "\\spad{member?(p,{} s)} returns \\spad{true} is \\spad{p} is in \\spad{s},{} \\spad{false} otherwise."))
 (|enumerate|
  (((|Vector| $))
   "\\spad{enumerate()} returns a vector of all the sets of \\spad{M} integers in \\spad{1..n}."))
 (|setOfMinN|
  (($ (|List| (|PositiveInteger|)))
   "\\spad{setOfMinN([a_1,{} ...,{} a_m])} returns the set {\\spad{a_1},{} ...,{} a_m}. Error if {\\spad{a_1},{} ...,{} a_m} is not a set of \\spad{M} integers in \\spad{1..n}."))
 (|elements|
  (((|List| (|PositiveInteger|)) $)
   "\\spad{elements(S)} returns the list of the elements of \\spad{S} in increasing order."))
 (|replaceKthElement|
  (((|Union| $ #1="failed") $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{replaceKthElement(S,{} k,{} p)} replaces the \\spad{k^}{th} element of \\spad{S} by \\spad{p},{} and returns \"failed\" if the result is not a set of \\spad{M} integers in \\spad{1..n} any more."))
 (|incrementKthElement|
  (((|Union| $ #1#) $ (|PositiveInteger|))
   "\\spad{incrementKthElement(S,{} k)} increments the \\spad{k^}{th} element of \\spad{S},{} and returns \"failed\" if the result is not a set of \\spad{M} integers in \\spad{1..n} any more."))) 
NIL 
(|SExpression|) 
((|constructor|
  (NIL "This domain allows the manipulation of the usual Lisp values."))) 
NIL 
(|SExpressionCategory| |Str| |Sym| |Int| |Flt|) 
((|constructor|
  (NIL
   "This category allows the manipulation of Lisp values while keeping the grunge fairly localized."))
 (|elt|
  (($ $ (|List| (|Integer|)))
   "\\spad{elt((a1,{} ...,{} an),{} [i1,{} ...,{} im])} returns \\spad{(a_i1,{} ...,{} a_im)}.")
  (($ $ (|Integer|))
   "\\spad{elt((a1,{} ...,{} an),{} i)} returns \\spad{\\spad{ai}}."))
 (|#| (((|Integer|) $) "\\spad{\\#((a1,{} ...,{} an))} returns \\spad{n}."))
 (|cdr|
  (($ $) "\\spad{cdr((a1,{} ...,{} an))} returns \\spad{(a2,{} ...,{} an)}."))
 (|car| (($ $) "\\spad{car((a1,{} ...,{} an))} returns \\spad{a1}."))
 (|convert| (($ |#4|) "\\spad{convert(x)} returns the Lisp atom \\spad{x}.")
            (($ |#3|) "\\spad{convert(x)} returns the Lisp atom \\spad{x}.")
            (($ |#2|) "\\spad{convert(x)} returns the Lisp atom \\spad{x}.")
            (($ |#1|) "\\spad{convert(x)} returns the Lisp atom \\spad{x}.")
            (($ (|List| $))
             "\\spad{convert([a1,{} ...,{} an])} returns the \\spad{S}-expression \\spad{(a1,{} ...,{} an)}."))
 (|float|
  ((|#4| $)
   "\\spad{float(s)} returns \\spad{s} as an element of \\spad{Flt}; Error: if \\spad{s} is not an atom that also belongs to \\spad{Flt}."))
 (|integer|
  ((|#3| $)
   "\\spad{integer(s)} returns \\spad{s} as an element of Int. Error: if \\spad{s} is not an atom that also belongs to Int."))
 (|symbol|
  ((|#2| $)
   "\\spad{symbol(s)} returns \\spad{s} as an element of \\spad{Sym}. Error: if \\spad{s} is not an atom that also belongs to \\spad{Sym}."))
 (|string|
  ((|#1| $)
   "\\spad{string(s)} returns \\spad{s} as an element of \\spad{Str}. Error: if \\spad{s} is not an atom that also belongs to \\spad{Str}."))
 (|destruct|
  (((|List| $) $)
   "\\spad{destruct((a1,{} ...,{} an))} returns the list [\\spad{a1},{} ...,{} an]."))
 (|float?|
  (((|Boolean|) $)
   "\\spad{float?(s)} is \\spad{true} if \\spad{s} is an atom and belong to \\spad{Flt}."))
 (|integer?|
  (((|Boolean|) $)
   "\\spad{integer?(s)} is \\spad{true} if \\spad{s} is an atom and belong to Int."))
 (|symbol?|
  (((|Boolean|) $)
   "\\spad{symbol?(s)} is \\spad{true} if \\spad{s} is an atom and belong to \\spad{Sym}."))
 (|string?|
  (((|Boolean|) $)
   "\\spad{string?(s)} is \\spad{true} if \\spad{s} is an atom and belong to \\spad{Str}."))
 (|list?|
  (((|Boolean|) $)
   "\\spad{list?(s)} is \\spad{true} if \\spad{s} is a Lisp list,{} possibly ()."))
 (|pair?|
  (((|Boolean|) $)
   "\\spad{pair?(s)} is \\spad{true} if \\spad{s} has is a non-null Lisp list."))
 (|atom?|
  (((|Boolean|) $)
   "\\spad{atom?(s)} is \\spad{true} if \\spad{s} is a Lisp atom."))
 (|null?|
  (((|Boolean|) $)
   "\\spad{null?(s)} is \\spad{true} if \\spad{s} is the \\spad{S}-expression ()."))
 (|eq|
  (((|Boolean|) $ $)
   "\\spad{eq(s,{} t)} is \\spad{true} if EQ(\\spad{s},{} \\spad{t}) is \\spad{true} in Lisp."))) 
NIL 
(|SExpressionOf| |Str| |Sym| |Int| |Flt|) 
((|constructor|
  (NIL
   "This domain allows the manipulation of Lisp values over arbitrary atomic types."))) 
NIL 
(|SimpleFortranProgram| R FS) 
((|constructor|
  (NIL
   "\\spadtype{SimpleFortranProgram} provides a simple model of some FORTRAN subprograms,{} making it possible to coerce objects of various domains into a FORTRAN subprogram called \\spad{f}. These can then be translated into legal FORTRAN code."))
 (|fortran|
  (($ (|Symbol|) (|FortranScalarType|) |#2|)
   "\\spad{fortran(fname,{} ftype,{} body)} builds an object of type \\spadtype{FortranProgramCategory}. The three arguments specify the name,{} the type and the body of the program."))) 
NIL 
(|SquareFreeQuasiComponentPackage| R E V P TS) 
((|constructor|
  (NIL
   "A internal package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets. \\newline"))
 (|branchIfCan|
  (((|Union|
     (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|)
               (|:| |ineq| (|List| |#4|)))
     "failed")
    (|List| |#4|) |#5| (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|)
    (|Boolean|) (|Boolean|))
   "\\spad{branchIfCan(leq,{} ts,{} lineq,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for developement."))
 (|prepareDecompose|
  (((|List|
     (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|)
               (|:| |ineq| (|List| |#4|))))
    (|List| |#4|) (|List| |#5|) (|Boolean|) (|Boolean|))
   "\\spad{prepareDecompose(lp,{} lts,{} b1,{} b2)} is an internal subroutine,{} exported only for developement."))
 (|removeSuperfluousCases|
  (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))
    (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))))
   "\\spad{removeSuperfluousCases(llpwt)} is an internal subroutine,{} exported only for developement."))
 (|subCase?|
  (((|Boolean|) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))
    (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))
   "\\spad{subCase?(lpwt1,{} lpwt2)} is an internal subroutine,{} exported only for developement."))
 (|removeSuperfluousQuasiComponents|
  (((|List| |#5|) (|List| |#5|))
   "\\spad{removeSuperfluousQuasiComponents(lts)} removes from \\spad{lts} any \\spad{ts} such that \\spad{subQuasiComponent?(ts,{} us)} holds for another \\spad{us} in \\spad{lts}."))
 (|subQuasiComponent?|
  (((|Boolean|) |#5| (|List| |#5|))
   "\\spad{subQuasiComponent?(ts,{} lus)} returns \\spad{true} iff \\spad{subQuasiComponent?(ts,{} us)} holds for one \\spad{us} in \\spad{lus}.")
  (((|Boolean|) |#5| |#5|)
   "\\spad{subQuasiComponent?(ts,{} us)} returns \\spad{true} iff \\spadopFrom{internalSubQuasiComponent?(\\spad{ts},{} us)}{QuasiComponentPackage} returs \\spad{true}."))
 (|internalSubQuasiComponent?|
  (((|Union| (|Boolean|) "failed") |#5| |#5|)
   "\\spad{internalSubQuasiComponent?(ts,{} us)} returns a boolean \\spad{b} value if the fact the regular zero set of \\spad{us} contains that of \\spad{ts} can be decided (and in that case \\spad{b} gives this inclusion) otherwise returns \\spad{\"failed\"}."))
 (|infRittWu?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{infRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for developement."))
 (|internalInfRittWu?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{internalInfRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for developement."))
 (|internalSubPolSet?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{internalSubPolSet?(lp1,{} lp2)} returns \\spad{true} iff \\spad{lp1} is a sub-set of \\spad{lp2} assuming that these lists are sorted increasingly \\spad{w}.\\spad{r}.\\spad{t}. \\spadopFrom{infRittWu?}{RecursivePolynomialCategory}."))
 (|subPolSet?|
  (((|Boolean|) (|List| |#4|) (|List| |#4|))
   "\\spad{subPolSet?(lp1,{} lp2)} returns \\spad{true} iff \\spad{lp1} is a sub-set of \\spad{lp2}."))
 (|subTriSet?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{subTriSet?(ts,{} us)} returns \\spad{true} iff \\spad{ts} is a sub-set of \\spad{us}."))
 (|moreAlgebraic?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{moreAlgebraic?(ts,{} us)} returns \\spad{false} iff \\spad{ts} and \\spad{us} are both empty,{} or \\spad{ts} has less elements than \\spad{us},{} or some variable is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{us} and is not \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|algebraicSort|
  (((|List| |#5|) (|List| |#5|))
   "\\spad{algebraicSort(lts)} sorts \\spad{lts} \\spad{w}.\\spad{r}.\\spad{t} \\spadopFrom{supDimElseRittWu}{QuasiComponentPackage}."))
 (|supDimElseRittWu?|
  (((|Boolean|) |#5| |#5|)
   "\\spad{supDimElseRittWu(ts,{} us)} returns \\spad{true} iff \\spad{ts} has less elements than \\spad{us} otherwise if \\spad{ts} has higher rank than \\spad{us} \\spad{w}.\\spad{r}.\\spad{t}. Ritt and Wu ordering."))
 (|stopTable!|
  (((|Void|))
   "\\spad{stopTableGcd!()} is an internal subroutine,{} exported only for developement."))
 (|startTable!|
  (((|Void|) (|String|) (|String|) (|String|))
   "\\spad{startTableGcd!(s1,{} s2,{} s3)} is an internal subroutine,{} exported only for developement."))) 
NIL 
(|SquareFreeRegularTriangularSetGcdPackage| R E V P TS) 
((|constructor|
  (NIL
   "A internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field. There is no need to use directly this package since its main operations are available from \\spad{TS}. \\newline"))) 
NIL 
(|SquareFreeRegularTriangularSetCategory| R E V P) 
((|constructor|
  (NIL
   "The category of square-free regular triangular sets. A regular triangular set \\spad{ts} is square-free if the \\spad{gcd} of any polynomial \\spad{p} in \\spad{ts} and \\spad{differentiate(p,{} mvar(p))} \\spad{w}.\\spad{r}.\\spad{t}. \\spadopFrom{collectUnder}{TriangularSetCategory}(\\spad{ts},{} \\spadopFrom{mvar}{RecursivePolynomialCategory}(\\spad{p})) has degree zero \\spad{w}.\\spad{r}.\\spad{t}. \\spad{mvar(p)}. Thus any square-free regular set defines a tower of square-free simple extensions.\\newline"))) 
NIL 
(|SymmetricGroupCombinatoricFunctions|) 
((|constructor|
  (NIL
   "SymmetricGroupCombinatoricFunctions contains combinatoric functions concerning symmetric groups and representation theory: list young tableaus,{} improper partitions,{} subsets bijection of Coleman."))
 (|unrankImproperPartitions1|
  (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{unrankImproperPartitions1(n,{} m,{} k)} computes the {\\em k}\\spad{-}th improper partition of nonnegative \\spad{n} in at most \\spad{m} nonnegative parts ordered as follows: first,{} in reverse lexicographically according to their non-zero parts,{} then according to their positions (\\spadignore{i.e.} lexicographical order using {\\em subSet}: {\\em [3,{} 0,{} 0] < [0,{} 3,{} 0] < [0,{} 0,{} 3] < [2,{} 1,{} 0] < [2,{} 0,{} 1] < [0,{} 2,{} 1] < [1,{} 2,{} 0] < [1,{} 0,{} 2] < [0,{} 1,{} 2] < [1,{} 1,{} 1]}). Note: counting of subtrees is done by {\\em numberOfImproperPartitionsInternal}."))
 (|unrankImproperPartitions0|
  (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{unrankImproperPartitions0(n,{} m,{} k)} computes the {\\em k}\\spad{-}th improper partition of nonnegative \\spad{n} in \\spad{m} nonnegative parts in reverse lexicographical order. Example: {\\em [0,{} 0,{} 3] < [0,{} 1,{} 2] < [0,{} 2,{} 1] < [0,{} 3,{} 0] < [1,{} 0,{} 2] < [1,{} 1,{} 1] < [1,{} 2,{} 0] < [2,{} 0,{} 1] < [2,{} 1,{} 0] < [3,{} 0,{} 0]}. Error: if \\spad{k} is negative or too big. Note: counting of subtrees is done by \\spadfunFrom{numberOfImproperPartitions}{SymmetricGroupCombinatoricFunctions}."))
 (|subSet|
  (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|))
   "\\spad{subSet(n,{} m,{} k)} calculates the {\\em k}\\spad{-}th {\\em m}-subset of the set {\\em 0,{} 1,{} ...,{} (n-1)} in the lexicographic order considered as a decreasing map from {\\em 0,{} ...,{} (m-1)} into {\\em 0,{} ...,{} (n-1)}. See \\spad{S}.\\spad{G}. Williamson: Theorem 1.60. Error: if not {\\em (0 <= m <= n and 0 < = k < (n choose m))}."))
 (|numberOfImproperPartitions|
  (((|Integer|) (|Integer|) (|Integer|))
   "\\spad{numberOfImproperPartitions(n,{} m)} computes the number of partitions of the nonnegative integer \\spad{n} in \\spad{m} nonnegative parts with regarding the order (improper partitions). Example: {\\em numberOfImproperPartitions (3,{} 3)} is 10,{} since {\\em [0,{} 0,{} 3],{} [0,{} 1,{} 2],{} [0,{} 2,{} 1],{} [0,{} 3,{} 0],{} [1,{} 0,{} 2],{} [1,{} 1,{} 1],{} [1,{} 2,{} 0],{} [2,{} 0,{} 1],{} [2,{} 1,{} 0],{} [3,{} 0,{} 0]} are the possibilities. Note: this operation has a recursive implementation."))
 (|nextPartition|
  (((|Vector| (|Integer|)) (|List| (|Integer|)) (|Vector| (|Integer|))
    (|Integer|))
   "\\spad{nextPartition(gamma,{} part,{} number)} generates the partition of {\\em number} which follows {\\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\\em gamma}. the first partition is achieved by {\\em part=[]}. Also,{} {\\em []} indicates that {\\em part} is the last partition.")
  (((|Vector| (|Integer|)) (|Vector| (|Integer|)) (|Vector| (|Integer|))
    (|Integer|))
   "\\spad{nextPartition(gamma,{} part,{} number)} generates the partition of {\\em number} which follows {\\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\\em gamma}. The first partition is achieved by {\\em part=[]}. Also,{} {\\em []} indicates that {\\em part} is the last partition."))
 (|nextLatticePermutation|
  (((|List| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)) (|Boolean|))
   "\\spad{nextLatticePermutation(lambda,{} lattP,{} constructNotFirst)} generates the lattice permutation according to the proper partition {\\em lambda} succeeding the lattice permutation {\\em lattP} in lexicographical order as long as {\\em constructNotFirst} is \\spad{true}. If {\\em constructNotFirst} is \\spad{false},{} the first lattice permutation is returned. The result {\\em []} indicates that {\\em lattP} has no successor."))
 (|nextColeman|
  (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|))
    (|Matrix| (|Integer|)))
   "\\spad{nextColeman(alpha,{} beta,{} C)} generates the next Coleman matrix of column sums {\\em alpha} and row sums {\\em beta} according to the lexicographical order from bottom-to-top. The first Coleman matrix is achieved by {\\em C=new(1,{} 1,{} 0)}. Also,{} {\\em new(1,{} 1,{} 0)} indicates that \\spad{C} is the last Coleman matrix."))
 (|makeYoungTableau|
  (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)))
   "\\spad{makeYoungTableau(lambda,{} gitter)} computes for a given lattice permutation {\\em gitter} and for an improper partition {\\em lambda} the corresponding standard tableau of shape {\\em lambda}. Notes: see {\\em listYoungTableaus}. The entries are from {\\em 0,{} ...,{} n-1}."))
 (|listYoungTableaus|
  (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|)))
   "\\spad{listYoungTableaus(lambda)} where {\\em lambda} is a proper partition generates the list of all standard tableaus of shape {\\em lambda} by means of lattice permutations. The numbers of the lattice permutation are interpreted as column labels. Hence the contents of these lattice permutations are the conjugate of {\\em lambda}. Notes: the functions {\\em nextLatticePermutation} and {\\em makeYoungTableau} are used. The entries are from {\\em 0,{} ...,{} n-1}."))
 (|inverseColeman|
  (((|List| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|))
    (|Matrix| (|Integer|)))
   "\\spad{inverseColeman(alpha,{} beta,{} C)}: there is a bijection from the set of matrices having nonnegative entries and row sums {\\em alpha},{} column sums {\\em beta} to the set of {\\em Salpha - Sbeta} double cosets of the symmetric group {\\em Sn}. ({\\em Salpha} is the Young subgroup corresponding to the improper partition {\\em alpha}). For such a matrix \\spad{C},{} inverseColeman(\\spad{alpha},{} \\spad{beta},{} \\spad{C}) calculates the lexicographical smallest {\\em \\spad{pi}} in the corresponding double coset. Note: the resulting permutation {\\em \\spad{pi}} of {\\em {1,{} 2,{} ...,{} n}} is given in list form. Notes: the inverse of this map is {\\em coleman}. For details,{} see James/Kerber."))
 (|coleman|
  (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|))
    (|List| (|Integer|)))
   "\\spad{coleman(alpha,{} beta,{} \\spad{pi})}: there is a bijection from the set of matrices having nonnegative entries and row sums {\\em alpha},{} column sums {\\em beta} to the set of {\\em Salpha - Sbeta} double cosets of the symmetric group {\\em Sn}. ({\\em Salpha} is the Young subgroup corresponding to the improper partition {\\em alpha}). For a representing element {\\em \\spad{pi}} of such a double coset,{} coleman(\\spad{alpha},{} \\spad{beta},{} \\spad{pi}) generates the Coleman-matrix corresponding to {\\em alpha,{} beta,{} \\spad{pi}}. Note: The permutation {\\em \\spad{pi}} of {\\em {1,{} 2,{} ...,{} n}} has to be given in list form. Note: the inverse of this map is {\\em inverseColeman} (if {\\em \\spad{pi}} is the lexicographical smallest permutation in the coset). For details see James/Kerber."))) 
NIL 
(|SemiGroup|) 
((|constructor|
  (NIL
   "the class of all multiplicative semigroups,{} \\spadignore{i.e.} a set with an associative operation \\spadop{*}. \\blankline"))) 
NIL 
(|SplitHomogeneousDirectProduct| |dimtot| |dim1| S) 
((|constructor|
  (NIL
   "\\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered as if they were split into two blocks. The \\spad{dim1} parameter specifies the length of the first block. The ordering is lexicographic between the blocks but acts like \\spadtype{HomogeneousDirectProduct} within each block. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
 (OR (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
 (|HasCategory| |#3| '(|OrderedSet|))
 (OR (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)))
 (|HasCategory| |#3| '(|unitsKnown|)) (|HasCategory| |#3| '(|CommutativeRing|))
 (|HasCategory| |#3| '(|AbelianGroup|)) (|HasCategory| |#3| '(|SemiRng|))
 (|HasCategory| |#3| '(|Ring|)) (|HasCategory| |#3| '(|Monoid|))
 (OR (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#3| '(|Finite|))
 (OR (|HasCategory| |#3| '(|Finite|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)))
 (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#3| '(|DifferentialRing|))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|)) (|HasCategory| |#3| '(|Ring|))
     (|HasCategory| |#3| '(|SemiRng|)))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|)) (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|SetCategory|))
 (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
      (|HasCategory| |#3| '(|SetCategory|)))
 (|HasCategory| |#3| '(|BasicType|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (OR (|HasCategory| |#3| '(|Finite|)) (|HasCategory| |#3| '(|OrderedSet|)))
 (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#3| '(|Ring|)))
 (AND (|HasCategory| |#3| '(|DifferentialRing|))
      (|HasCategory| |#3| '(|Ring|)))
 (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#3| '(|Ring|)))
 (|HasCategory| |#3| '(|AbelianMonoid|))
 (AND (|HasCategory| |#3| '(|AbelianMonoid|)) (|HasCategory| |#3| '(|Monoid|)))
 (AND (|HasCategory| |#3| '(|AbelianMonoid|))
      (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|)) (|HasCategory| |#3| '(|Ring|))
     (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#3| '(|SemiGroup|))
 (OR
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Finite|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Monoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|OrderedSet|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|Ring|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SemiGroup|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SemiRng|)))
  (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
       (|HasCategory| |#3| '(|SetCategory|))))
 (OR (|HasCategory| |#3| '(|Monoid|)) (|HasCategory| |#3| '(|SemiGroup|)))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|BasicType|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|))
     (|HasCategory| |#3| '(|Finite|)) (|HasCategory| |#3| '(|Monoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)) (|HasCategory| |#3| '(|Ring|))
     (|HasCategory| |#3| '(|SemiGroup|)) (|HasCategory| |#3| '(|SemiRng|))
     (|HasCategory| |#3| '(|SetCategory|)))
 (OR (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#3| '(|AbelianGroup|))
     (|HasCategory| |#3| '(|AbelianMonoid|))
     (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#3| '(|CommutativeRing|))
     (|HasCategory| |#3| '(|DifferentialRing|))
     (|HasCategory| |#3| '(|Finite|)) (|HasCategory| |#3| '(|Monoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoid|))
     (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|))
     (|HasCategory| |#3| '(|OrderedSet|)) (|HasCategory| |#3| '(|Ring|))
     (|HasCategory| |#3| '(|SemiGroup|)) (|HasCategory| |#3| '(|SemiRng|))
     (|HasCategory| |#3| '(|SetCategory|)))
 (OR (|HasCategory| |#3| '(|AbelianMonoid|)) (|HasCategory| |#3| '(|SemiRng|)))
 (|HasCategory| |#3| (LIST '|CoercibleTo| '(|OutputForm|)))
 (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
      (|HasCategory| |#3| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|))))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Finite|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Monoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|OrderedSet|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|Ring|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SemiGroup|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SemiRng|)))
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SetCategory|))))
 (OR
  (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
       (|HasCategory| |#3| '(|SetCategory|)))
  (|HasCategory| |#3| '(|Ring|)))
 (AND
  (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| |#3| '(|SetCategory|)))
 (OR (|HasCategory| |#3| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#3| (LIST '|Evalable| (|devaluate| |#3|)))
          (|HasCategory| |#3| '(|SetCategory|)))
     (AND
      (|HasCategory| |#3|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#3| '(|SetCategory|)))
     (AND (|HasCategory| |#3| (LIST '|RetractableTo| '(|Integer|)))
          (|HasCategory| |#3| '(|SetCategory|)))
     (AND (|HasCategory| |#3| '(|AbelianGroup|))
          (|HasCategory| |#3| '(|SemiRng|)))
     (AND (|HasCategory| |#3| '(|AbelianMonoid|))
          (|HasCategory| |#3| '(|SemiRng|))))
 (OR
  (AND (|HasCategory| |#3| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#3|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND (|HasCategory| |#3| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#3|
                      (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|CancellationAbelianMonoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|CommutativeRing|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|DifferentialRing|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Finite|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Monoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedAbelianMonoid|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedAbelianMonoidSup|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|OrderedSet|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|Ring|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SemiGroup|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SemiRng|)))
  (AND
   (|HasCategory| |#3| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
   (|HasCategory| |#3| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#3| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#3| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (OR (|HasCategory| |#3| '(|AbelianMonoid|))
     (AND (|HasCategory| |#3| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianMonoid|))))
 (OR
  (AND (|HasCategory| |#3| '(|AbelianGroup|))
       (|HasCategory| |#3| '(|SemiRng|)))
  (|HasCategory| |#3| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#3| '(|SemiRng|)) (|HasCategory| $ '(|AbelianGroup|))))
 (OR (|HasCategory| |#3| '(|AbelianGroup|))
     (AND (|HasCategory| |#3| '(|SemiRng|))
          (|HasCategory| $ '(|AbelianGroup|))))
 (OR
  (AND (|HasCategory| |#3| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#3| '(|SetCategory|)))) 
(|SturmHabichtPackage| R UP) 
((|constructor|
  (NIL
   "This package provides functions for counting real roots of univariate polynomials over an OrderedIntegralDomain."))
 (|countRealRootsMultiple|
  (((|Integer|) |#2|)
   "\\spad{countRealRootsMultiple(p)} says how many real roots \\spad{p} has,{} counted with multiplicity"))
 (|SturmHabichtMultiple|
  (((|Integer|) |#2| |#2|)
   "\\spad{SturmHabichtMultiple(p1,{} p2)} computes \\spad{c_}{+}\\spad{-c_}{-} where \\spad{c_}{+} is the number of real roots of \\spad{p1} with \\spad{p2>0} and \\spad{c_}{-} is the number of real roots of \\spad{p1} with \\spad{p2<0}. If \\spad{p2=1} what you get is the number of real roots of \\spad{p1}."))
 (|countRealRoots|
  (((|Integer|) |#2|)
   "\\spad{countRealRoots(p)} says how many real roots \\spad{p} has"))
 (|SturmHabicht|
  (((|Integer|) |#2| |#2|)
   "\\spad{SturmHabicht(p1,{} p2)} computes \\spad{c_}{+}\\spad{-c_}{-} where \\spad{c_}{+} is the number of real roots of \\spad{p1} with \\spad{p2>0} and \\spad{c_}{-} is the number of real roots of \\spad{p1} with \\spad{p2<0}. If \\spad{p2=1} what you get is the number of real roots of \\spad{p1}."))
 (|SturmHabichtCoefficients|
  (((|List| |#1|) |#2| |#2|)
   "\\spad{SturmHabichtCoefficients(p1,{} p2)} computes the principal Sturm-Habicht coefficients of \\spad{p1} and \\spad{p2}"))
 (|SturmHabichtSequence|
  (((|List| |#2|) |#2| |#2|)
   "\\spad{SturmHabichtSequence(p1,{} p2)} computes the Sturm-Habicht sequence of \\spad{p1} and \\spad{p2}"))) 
((|HasCategory| |#1| '(|GcdDomain|))) 
(|ElementaryFunctionSign| R F) 
((|constructor|
  (NIL
   "This package provides functions to determine the sign of an elementary function around a point or infinity."))
 (|sign|
  (((|Union| (|Integer|) #1="failed") |#2| (|Symbol|) |#2| (|String|))
   "\\spad{sign(f,{} x,{} a,{} s)} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a} from below if \\spad{s} is \"left\",{} or above if \\spad{s} is \"right\".")
  (((|Union| (|Integer|) #1#) |#2| (|Symbol|) (|OrderedCompletion| |#2|))
   "\\spad{sign(f,{} x,{} a)} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a},{} from both sides if \\spad{a} is finite.")
  (((|Union| (|Integer|) #1#) |#2|)
   "\\spad{sign(f)} returns 1 if \\spad{f} is always non-negative; returns \\spad{-1} is \\spad{f} is always non-positive; returns 0 if \\spad{f} is always 0; returns \"failed\" if the sign of \\spad{f} varies or can\\spad{'t} be determined."))) 
NIL 
(|RationalFunctionSign| R) 
((|constructor|
  (NIL "Find the sign of a rational function around a point or infinity."))
 (|sign|
  (((|Union| (|Integer|) #1="failed") (|Fraction| (|Polynomial| |#1|))
    (|Symbol|) (|Fraction| (|Polynomial| |#1|)) (|String|))
   "\\spad{sign(f,{} x,{} a,{} s)} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a} from the left (below) if \\spad{s} is the string \\spad{\"left\"},{} or from the right (above) if \\spad{s} is the string \\spad{\"right\"}.")
  (((|Union| (|Integer|) #1#) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)
    (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{sign(f,{} x,{} a)} returns the sign of \\spad{f} as \\spad{x} approaches \\spad{a},{} from both sides if \\spad{a} is finite.")
  (((|Union| (|Integer|) #1#) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{sign f} returns the sign of \\spad{f} if it is constant everywhere."))) 
NIL 
(|SimplifyAlgebraicNumberConvertPackage|) 
((|constructor|
  (NIL
   "\\indented{1}{Package to allow simplify to be called on AlgebraicNumbers} by converting to EXPR(INT)"))
 (|simplify|
  (((|Expression| (|Integer|)) (|AlgebraicNumber|))
   "\\spad{simplify(an)} applies simplifications to \\spad{an}"))) 
NIL 
(|FiniteSimplicialComplex| VS) 
((|constructor|
  (NIL
   "\\indented{2}{A Finite Simplicial Complex} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/} Date Created: Dec 2015 Basic Operations: star,{} link,{} cone,{} product Related packages: Related categories: Related Domains: DeltaComplex is an alternative representation \\indented{3}{which is less compact but allows edges,{} triangles,{} etc to be indexed.} Also See: AMS Classifications:"))
 (|coerce|
  (((|DeltaComplex| |#1|) $)
   "\\spad{coerce SimplicialComplex} to DeltaComplex"))
 (|coHomology|
  (((|List| (|Homology|)) $)
   "calculate cohomology using SmithNormalForm \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/cohomol/index.\\spad{htm}}"))
 (|homology|
  (((|List| (|Homology|)) $)
   "calculate homology using SmithNormalForm For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/index.\\spad{htm}}"))
 (|coChain|
  (((|CoChainComplex| |#1|) $)
   "returns a matrix sequence representing the face maps in linear algebra form For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/cochain/index.\\spad{htm}}"))
 (|chain|
  (((|ChainComplex|) $)
   "returns a matrix sequence representing the face maps in linear algebra form For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/index.\\spad{htm}}"))
 (|fundamentalGroup|
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|))
   "Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This version has options to: simplify - if \\spad{true} attempts to simplify the group presentation trace - if \\spad{true} outputs trace of simplification rules used. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\\spad{htm}}")
  (((|GroupPresentation|) $)
   "Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\\spad{'t} want this use alternative function of same name. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\\spad{htm}}"))
 (|oneSkeleton|
  (((|DirectedGraph| (|NonNegativeInteger|)) $)
   "generates graph AKA 1-skeleton"))
 (|product|
  (($ $ $)
   "Forms product of two simplicial complexes. For more detailed explanation of simplex product code see: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Also see Hatcher [9]. page 277 - The simplicial cross product. page 278 - The cohomology cross product. Returns list,{} each entry is a 'lattice path' from (0,{} 0) to (\\spad{x},{} \\spad{y}) where \\spad{x} is number of entries in sa and \\spad{y} is number of entries in \\spad{sb}."))
 (|merge| (($ $ $) "Forms union of two simplicial complexes."))
 (|simplicialJoin|
  (($ $ $ (|Boolean|))
   "Forms join of two simplicial complexes. The join \\spad{S*T} of two simplicial sets \\spad{S} and \\spad{T} is a new simplicial set that may geometrically be thought of as a cone over \\spad{T} with tip of shape \\spad{S}. simplicialJoin is commutative and associative. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/join/index.\\spad{htm}}"))
 (|makeDisjoint|
  (($ $ $)
   "If index numbers of \\spad{'b'} overlap with index numbers of 'a' then refactor \\spad{'b'} so that it does not overlap."))
 (|refactorIndexes|
  (($ $ (|NonNegativeInteger|))
   "add \\spad{'n'} to all indexes without changing the structure of this simplicial complex."))
 (|cone|
  (($ $ (|NonNegativeInteger|))
   "The 'cone' of a simplicial complex is formed by adding the vertex to every facet. 'vertex' should not already be included in existing faces,{} this is not checked and so will lead to simplexes with duplicate vertices."))
 (|link|
  (($ $ (|OrientedFacet|))
   "The 'link' of a simplicial complex and a vertex contains the boundary of the simplexes of \\spad{s} which include simplex."))
 (|star|
  (($ $ (|OrientedFacet|))
   "The 'star' of a simplicial complex and a facet contains only the faces of \\spad{s} which include simplex."))
 (|boundary|
  (($ $)
   "Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can."))
 (|addImpliedFaces|
  (((|List| (|List| (|OrientedFacet|))) $)
   "a function to take a set of faces and add those that are implied by the simplecicalComplex conventions (if they don\\spad{'t} already exist). For example,{} if the input is a triangle ((1,{} 2,{} 3)) then we would add: its points ((1),{} (2),{} (3)). and its edges ((1,{} 2),{} (1,{} 3),{} (2,{} 3))."))
 (|sort| (($ $) "sort"))
 (|grade|
  (((|List| (|List| (|OrientedFacet|))) $)
   "a function to grade simplexes according to their lengths. This nests the lists according to their length. Vertices,{} edges,{} triangles and so on. The list is returned in reverse order,{} that is,{} it starts at highest grade and works down."))
 (|minIndex| (((|NonNegativeInteger|) $) "find the minimum index."))
 (|maxIndex| (((|NonNegativeInteger|) $) "find the maximum index."))
 (|addSimplex|
  (($ $ (|OrientedFacet|))
   "Add a facet to this simplex If the facet is also in the list then,{} do not append,{} instead change the multiplier. Used by boundary function"))
 (|simplicialComplexIfCan|
  (((|Union| $ "failed") (|DeltaComplex| |#1|))
   "construct FiniteSimplicialComplex from DeltaComplex. If there are 'implied' loops,{} such as facets with multiple entries with the same index,{} then this function may fail.")
  (((|Union| $ "failed") (|DeltaComplex| |#1|) (|Boolean|))
   "construct FiniteSimplicialComplex from DeltaComplex with trace. If there are 'implied' loops,{} such as facets with multiple entries with the same index,{} then this function may fail."))
 (|simplicialComplex| (($ (|List| |#1|)) "construct empty simplex")
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "constructor where the simplices are supplied")
  (($ (|List| |#1|) (|NonNegativeInteger|)
    (|List| (|List| (|NonNegativeInteger|))))
   "constructor where the simplices are supplied"))) 
NIL 
(|SimplicialComplexFactory| VS) 
((|constructor|
  (NIL "Provides functions to construct various simplicial complexes."))
 (|dunceHat|
  (((|FiniteSimplicialComplex| |#1|))
   "Generate a minimal triangulation of dunce hat."))
 (|kleinBottle|
  (((|FiniteSimplicialComplex| |#1|))
   "generate a minimal triangulation of the surface of a Klein bottle."))
 (|projectiveSpace|
  (((|FiniteSimplicialComplex| |#1|) (|Integer|))
   "Generate a minimal triangulation of the surface of a projective plane. A one sided surface which cannot be embedded in 3D space without intersecting itself. There are no external boundaries,{} every edge connects two faces. (A punctured projective plane is equivalent to a Moebius band)"))
 (|moebiusBand|
  (((|FiniteSimplicialComplex| |#1|))
   "Generate a minimal triangulation of the surface of a Moebius band. A one sided surface with a single external boundary line."))
 (|band|
  (((|FiniteSimplicialComplex| |#1|))
   "Generate a minimal triangulation of the surface of a cylinder without ends"))
 (|torusSurface|
  (((|FiniteSimplicialComplex| |#1|))
   "generate a minimal triangulation of the surface of a 3-dimensional torus."))
 (|line|
  (((|FiniteSimplicialComplex| |#1|))
   "create a simplicial complex containing a line."))
 (|sphereSurface|
  (((|FiniteSimplicialComplex| |#1|) (|NonNegativeInteger|))
   "Generate a simplicial complex equivalent to the surface of a hyper-sphere. That is,{} the surface of a volume with no holes in it,{} so we use a minimal triangulation of the faces of a single simplex."))
 (|sphereSolid|
  (((|FiniteSimplicialComplex| |#1|) (|NonNegativeInteger|))
   "Generate a simplicial complex equivalent to a solid hyper-sphere. That is,{} a solid volume with no holes in it,{} so we use a single \\spad{n}-dimensional simplex."))) 
NIL 
(|SingleInteger|) 
((|constructor|
  (NIL "SingleInteger is intended to support machine integer arithmetic."))
 (|Or|
  (($ $ $)
   "\\spad{Or(n,{} m)} returns the bit-by-bit logical {\\em or} of the single integers \\spad{n} and \\spad{m}."))
 (|And|
  (($ $ $)
   "\\spad{And(n,{} m)} returns the bit-by-bit logical {\\em and} of the single integers \\spad{n} and \\spad{m}."))
 (|Not|
  (($ $)
   "\\spad{Not(n)} returns the bit-by-bit logical {\\em not} of the single integer \\spad{n}."))
 (|xor|
  (($ $ $)
   "\\spad{xor(n,{} m)} returns the bit-by-bit logical {\\em xor} of the single integers \\spad{n} and \\spad{m}."))
 (|\\/|
  (($ $ $)
   "\\spad{n} \\spad{\\/} \\spad{m} returns the bit-by-bit logical {\\em or} of the single integers \\spad{n} and \\spad{m}."))
 (|/\\|
  (($ $ $)
   "\\spad{n} \\spad{/\\} \\spad{m} returns the bit-by-bit logical {\\em and} of the single integers \\spad{n} and \\spad{m}."))
 (~
  (($ $)
   "\\spad{~ n} returns the bit-by-bit logical {\\em not} of the single integer \\spad{n}."))
 (|not|
  (($ $)
   "\\spad{not(n)} returns the bit-by-bit logical {\\em not} of the single integer \\spad{n}."))
 (|min| (($) "\\spad{min()} returns the smallest single integer."))
 (|max| (($) "\\spad{max()} returns the largest single integer."))
 (|qconvert|
  (($ (|Integer|))
   "\\spad{qconvert(x)} converts \\spad{x} to \\% trusting that \\spad{x} is in correct range."))) 
NIL 
(|StackAggregate| S) 
((|constructor|
  (NIL
   "A stack is a bag where the last item inserted is the first item extracted."))
 (|top|
  ((|#1| $)
   "\\spad{top(s)} returns the top element \\spad{x} from \\spad{s}; \\spad{s} remains unchanged. Note: Use \\spad{pop!(s)} to obtain \\spad{x} and remove it from \\spad{s}."))
 (|pop!|
  ((|#1| $)
   "\\spad{pop!(s)} returns the top element \\spad{x},{} destructively removing \\spad{x} from \\spad{s}. Note: Use \\spad{top(s)} to obtain \\spad{x} without removing it from \\spad{s}. Error: if \\spad{s} is empty."))
 (|push!|
  ((|#1| |#1| $)
   "\\spad{push!(x,{} s)} pushes \\spad{x} onto stack \\spad{s},{} \\spadignore{i.e.} destructively changing \\spad{s} so as to have a new first (top) element \\spad{x}. Afterwards,{} pop!(\\spad{s}) produces \\spad{x} and pop!(\\spad{s}) produces the original \\spad{s}."))) 
NIL 
(|SKICombinators| UT) 
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toString| (((|String|) $) "output"))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal (deep search) that is: all terms at all levels in tree must be equal to return \\spad{true} all terms must be exactly equal,{} not just equivalent,{} that is SKK=I will return \\spad{false} even though 'SKK' and 'I' have the same effect"))
 (|redux|
  (($ $)
   "weak reduction - apply this combinator to rearrange its subnodes then apply recursively to its subnodes."))
 (|freeVariable?|
  (((|Boolean|) $ |#1|)
   "the variable indicated by \\spad{'s'} is free if it does not appear in node \\spad{'n'} or any of its subnodes."))
 (|getVariable|
  ((|#1| $)
   "returns the variable,{} if this is not a variable then return \\spad{I}"))
 (|isS?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is a \\spad{S} combinator node"))
 (|isK?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is a \\spad{K} combinator node"))
 (|isI?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an \\spad{I} combinator node"))
 (|variable?| (((|Boolean|) $) "returns \\spad{true} if this is an variable"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseSki. It would rarely be called externally but it is here to allow it to call parseSki that is to allow circular calls"))
 (|parseSki| (($ (|String|)) "Constructs combinators from a string"))
 (S (($) "Constructs a \\spad{S} combinator"))
 (K (($) "Constructs a \\spad{K} combinator"))
 (I (($) "Constructs a \\spad{I} combinator"))
 (|ski| (($ |#1|) "Constructs variable combinator")
  (($ $ $) "Constructs a node combinator over combinators"))) 
NIL 
(|SparseMultivariateSkewPolynomial| R |Var| |sigma| |delta|) 
((|constructor|
  (NIL
   "SparseMultivariateSkewPolynomial(\\spad{R},{} Var,{} sigma,{} delta) defines a mutivariate Ore ring over \\spad{R} in variables from \\spad{V}. \\spad{sigma(v)} gives automorphism of \\spad{R} corresponding to variable \\spad{v} and \\spad{delta(v)} gives corresponding derivative. \\blankline"))
 (|Delta|
  (($ (|Symbol|))
   "\\spad{Delta(s)} returns operator corresponding to derivative with respect to \\spad{s} in \\spad{R}."))
 (D
  (($ |#2|)
   "\\spad{D(v)} returns operator corresponding to derivative with respect to \\spad{v} in \\spad{R}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasSignature| |#2| (LIST '|variable| (LIST (|devaluate| |#2|) '(|Symbol|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|SquareMatrixCategory&| S |ndim| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col."))
 (^
  (($ $ (|Integer|))
   "\\spad{m^n} computes an integral power of the matrix \\spad{m}. Error: if the matrix is not invertible."))
 (|inverse|
  (((|Union| $ "failed") $)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m},{} if that matrix is invertible and returns \"failed\" otherwise."))
 (|Pfaffian|
  ((|#3| $)
   "\\spad{Pfaffian(m)} returns the Pfaffian of the matrix \\spad{m}. Error: if the matrix is not antisymmetric."))
 (|minordet|
  ((|#3| $)
   "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors."))
 (|determinant|
  ((|#3| $)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}."))
 (*
  ((|#4| |#4| $)
   "\\spad{r * x} is the product of the row vector \\spad{r} and the matrix \\spad{x}. Error: if the dimensions are incompatible.")
  ((|#5| $ |#5|)
   "\\spad{x * c} is the product of the matrix \\spad{x} and the column vector \\spad{c}. Error: if the dimensions are incompatible."))
 (|diagonalProduct|
  ((|#3| $)
   "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m}."))
 (|trace|
  ((|#3| $)
   "\\spad{trace(m)} returns the trace of the matrix \\spad{m}. this is the sum of the elements on the diagonal of the matrix \\spad{m}."))
 (|diagonal|
  ((|#4| $)
   "\\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \\spad{m}."))
 (|diagonalMatrix|
  (($ (|List| |#3|))
   "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal."))
 (|scalarMatrix|
  (($ |#3|)
   "\\spad{scalarMatrix(r)} returns an \\spad{n}-by-\\spad{n} matrix with \\spad{r}\\spad{'s} on the diagonal and zeroes elsewhere."))) 
((|HasCategory| |#3| '(|Field|)) (|HasCategory| |#3| '(|CommutativeRing|))
 (|HasCategory| |#3| '(|Ring|)) (|HasCategory| |#3| '(|SemiRing|))) 
(|SquareMatrixCategory| |ndim| R |Row| |Col|) 
((|constructor|
  (NIL
   "\\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col."))
 (^
  (($ $ (|Integer|))
   "\\spad{m^n} computes an integral power of the matrix \\spad{m}. Error: if the matrix is not invertible."))
 (|inverse|
  (((|Union| $ "failed") $)
   "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m},{} if that matrix is invertible and returns \"failed\" otherwise."))
 (|Pfaffian|
  ((|#2| $)
   "\\spad{Pfaffian(m)} returns the Pfaffian of the matrix \\spad{m}. Error: if the matrix is not antisymmetric."))
 (|minordet|
  ((|#2| $)
   "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors."))
 (|determinant|
  ((|#2| $)
   "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m}."))
 (*
  ((|#3| |#3| $)
   "\\spad{r * x} is the product of the row vector \\spad{r} and the matrix \\spad{x}. Error: if the dimensions are incompatible.")
  ((|#4| $ |#4|)
   "\\spad{x * c} is the product of the matrix \\spad{x} and the column vector \\spad{c}. Error: if the dimensions are incompatible."))
 (|diagonalProduct|
  ((|#2| $)
   "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m}."))
 (|trace|
  ((|#2| $)
   "\\spad{trace(m)} returns the trace of the matrix \\spad{m}. this is the sum of the elements on the diagonal of the matrix \\spad{m}."))
 (|diagonal|
  ((|#3| $)
   "\\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \\spad{m}."))
 (|diagonalMatrix|
  (($ (|List| |#2|))
   "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal."))
 (|scalarMatrix|
  (($ |#2|)
   "\\spad{scalarMatrix(r)} returns an \\spad{n}-by-\\spad{n} matrix with \\spad{r}\\spad{'s} on the diagonal and zeroes elsewhere."))) 
NIL 
(|SmithNormalForm| R |Row| |Col| M) 
((|constructor|
  (NIL
   "\\spadtype{SmithNormalForm} is a package which provides some standard canonical forms for matrices."))
 (|diophantineSystem|
  (((|Record| (|:| |particular| (|Union| |#3| "failed"))
              (|:| |basis| (|List| |#3|)))
    |#4| |#3|)
   "\\spad{diophantineSystem(A,{} B)} returns a particular integer solution and an integer basis of the equation \\spad{A X = B}."))
 (|completeSmith|
  (((|Record| (|:| |Smith| |#4|) (|:| |leftEqMat| |#4|)
              (|:| |rightEqMat| |#4|))
    |#4|)
   "\\spad{completeSmith} returns a record that contains the Smith normal form \\spad{H} of the matrix and the left and right equivalence matrices \\spad{U} and \\spad{V} such that U*m*v = \\spad{H}"))
 (|smith|
  ((|#4| |#4|)
   "\\spad{smith(m)} returns the Smith Normal form of the matrix \\spad{m}."))
 (|completeHermite|
  (((|Record| (|:| |Hermite| |#4|) (|:| |eqMat| |#4|)) |#4|)
   "\\spad{completeHermite} returns a record that contains the Hermite normal form \\spad{H} of the matrix and the equivalence matrix \\spad{U} such that U*m = \\spad{H}"))
 (|hermite|
  ((|#4| |#4|)
   "\\spad{hermite(m)} returns the Hermite normal form of the matrix \\spad{m}."))) 
NIL 
(|SparseMultivariatePolynomial| R |VarSet|) 
((|constructor|
  (NIL
   "\\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials. It is parameterized by the coefficient ring and the variable set which may be infinite. The variable ordering is determined by the variable set parameter. The coefficient ring may be non-commutative,{} but the variables are assumed to commute."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| |#2|
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|SparsePolynomialCoercionHelpers| R |VarSet1| |VarSet2|) 
((|remap_variables|
  (((|SparseMultivariatePolynomial| |#1| |#3|)
    (|SparseMultivariatePolynomial| |#1| |#2|) (|List| |#2|) (|List| |#3|))
   "\\spad{remap_variables(p,{} lv1,{} lv2)} replaces corresponding variables from \\spad{l1} by variables from \\spad{lv2}. Assumes that \\spad{lv1} and \\spad{lv2} have the same length and that \\spad{p} has variables in \\spad{lv1}."))) 
NIL 
(|SparseMultivariatePolynomialExpressions| R) 
NIL 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|NonNegativeInteger|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|TranscendentalFunctionCategory|))
 (|HasCategory| (|IndexedExponents| (|NonNegativeInteger|)) '(|Comparable|))
 (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|NonNegativeInteger|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|NonNegativeInteger|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|NonNegativeInteger|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|NonNegativeInteger|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|NonNegativeInteger|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|NonNegativeInteger|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|SparseMultivariateTaylorSeries| |Coef| |Var| SMP) 
((|constructor|
  (NIL
   "This domain provides multivariate Taylor series with variables from an arbitrary ordered set. A Taylor series is represented by a stream of polynomials from the polynomial domain \\spad{SMP}. The \\spad{n}th element of the stream is a form of degree \\spad{n}. SMTS is an internal domain."))
 (|fintegrate|
  (($ (|Mapping| $) |#2| |#1|)
   "\\spad{fintegrate(f,{} v,{} c)} is the integral of \\spad{f()} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.} \\indented{1}{The evaluation of \\spad{f()} is delayed.}"))
 (|integrate|
  (($ $ |#2| |#1|)
   "\\spad{integrate(s,{} v,{} c)} is the integral of \\spad{s} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.}"))
 (|csubst|
  (((|Mapping| (|Stream| |#3|) |#3|) (|List| |#2|) (|List| (|Stream| |#3|)))
   "\\spad{csubst(a,{} b)} is for internal use only"))
 (*
  (($ |#3| $)
   "\\spad{smp*ts} multiplies a TaylorSeries by a monomial \\spad{SMP}."))
 (|coerce|
  (($ |#3|)
   "\\spad{coerce(poly)} regroups the terms by total degree and forms a series.")
  (($ |#2|) "\\spad{coerce(var)} converts a variable to a Taylor series"))
 (|series|
  (($ (|Stream| |#3|))
   "\\spad{series(st)} creates a series from a stream of coefficients."))
 (|coefficients|
  (((|Stream| |#3|) $)
   "\\spad{coefficients(s)} gives stream of coefficients of \\spad{s},{} \\spadignore{i.e.} [coefficient(\\spad{s},{}0),{} coefficient(\\spad{s},{}1),{} ...]"))
 (|coefficient|
  ((|#3| $ (|NonNegativeInteger|))
   "\\spad{coefficient(s,{} n)} gives the terms of total degree \\spad{n}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|IndexedExponents| |#2|) '(|Comparable|))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|SquareFreeNormalizedTriangularSetCategory| R E V P) 
((|constructor|
  (NIL
   "The category of square-free and normalized triangular sets. Thus,{} up to the primitivity axiom of [1],{} these sets are Lazard triangular sets.\\newline"))) 
NIL 
(|PolynomialSolveByFormulas| UP F RR) 
((|constructor|
  (NIL
   "This package factors the formulas out of the general solve code,{} allowing their recursive use over different domains. Care is taken to introduce few radicals so that radical extension domains can more easily simplify the results."))
 (|aQuartic|
  ((|#2| |#2| |#2| |#2| |#2| |#2|)
   "\\spad{aQuartic(f,{} g,{} h,{} i,{} k)} \\undocumented"))
 (|aCubic|
  ((|#2| |#2| |#2| |#2| |#2|)
   "\\spad{aCubic(f,{} g,{} h,{} j)} \\undocumented"))
 (|aQuadratic|
  ((|#2| |#2| |#2| |#2|) "\\spad{aQuadratic(f,{} g,{} h)} \\undocumented"))
 (|aLinear| ((|#2| |#2| |#2|) "\\spad{aLinear(f,{} g)} \\undocumented"))
 (|quartic|
  (((|List| |#2|) |#2| |#2| |#2| |#2| |#2|)
   "\\spad{quartic(f,{} g,{} h,{} i,{} j)} \\undocumented")
  (((|List| |#2|) |#1|) "\\spad{quartic(u)} \\undocumented"))
 (|cubic|
  (((|List| |#2|) |#2| |#2| |#2| |#2|)
   "\\spad{cubic(f,{} g,{} h,{} i)} \\undocumented")
  (((|List| |#2|) |#1|) "\\spad{cubic(u)} \\undocumented"))
 (|quadratic|
  (((|List| |#2|) |#2| |#2| |#2|)
   "\\spad{quadratic(f,{} g,{} h)} \\undocumented")
  (((|List| |#2|) |#1|) "\\spad{quadratic(u)} \\undocumented"))
 (|linear| (((|List| |#2|) |#2| |#2|) "\\spad{linear(f,{} g)} \\undocumented")
  (((|List| |#2|) |#1|) "\\spad{linear(u)} \\undocumented"))
 (|particularSolution|
  ((|#2| |#1|) "\\spad{particularSolution(u)} \\undocumented"))
 (|solve| (((|List| |#2|) |#1|) "\\spad{solve(u)} \\undocumented"))) 
NIL 
(|RadicalSolvePackage| R) 
((|constructor|
  (NIL
   "This package tries to find solutions expressed in terms of radicals for systems of equations of rational functions with coefficients in an integral domain \\spad{R}."))
 (|cyclotomic_case?|
  (((|Union| (|Integer|) "failed")
    (|SparseUnivariatePolynomial| (|Polynomial| |#1|)))
   "\\spad{cyclotomic_case?(u)} should be local but conditional"))
 (|contractSolve|
  (((|SuchThat| (|List| (|Expression| |#1|))
                (|List| (|Equation| (|Expression| |#1|))))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{contractSolve(rf,{} x)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x},{} where \\spad{rf} is a rational function. The result contains new symbols for common subexpressions in order to reduce the size of the output.")
  (((|SuchThat| (|List| (|Expression| |#1|))
                (|List| (|Equation| (|Expression| |#1|))))
    (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|))
   "\\spad{contractSolve(eq,{} x)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the symbol \\spad{x}. The result contains new symbols for common subexpressions in order to reduce the size of the output."))
 (|radicalRoots|
  (((|List| (|List| (|Expression| |#1|)))
    (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|)))
   "\\spad{radicalRoots(lrf,{} lvar)} finds the roots expressed in terms of radicals of the list of rational functions \\spad{lrf} with respect to the list of symbols lvar.")
  (((|List| (|Expression| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{radicalRoots(rf,{} x)} finds the roots expressed in terms of radicals of the rational function \\spad{rf} with respect to the symbol \\spad{x}."))
 (|radicalSolve|
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
   "\\spad{radicalSolve(leq)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \\spad{leq} with respect to all symbols appearing in \\spad{leq}.")
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|)))
   "\\spad{radicalSolve(leq,{} lvar)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \\spad{leq} with respect to the list of symbols lvar.")
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{radicalSolve(lrf)} finds the solutions expressed in terms of radicals of the system of equations \\spad{lrf} = 0,{} where \\spad{lrf} is a list of rational functions.")
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|)))
   "\\spad{radicalSolve(lrf,{} lvar)} finds the solutions expressed in terms of radicals of the system of equations \\spad{lrf} = 0 with respect to the list of symbols lvar,{} where \\spad{lrf} is a list of rational functions.")
  (((|List| (|Equation| (|Expression| |#1|)))
    (|Equation| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{radicalSolve(eq)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the unique symbol \\spad{x} appearing in \\spad{eq}.")
  (((|List| (|Equation| (|Expression| |#1|)))
    (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|))
   "\\spad{radicalSolve(eq,{} x)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the symbol \\spad{x}.")
  (((|List| (|Equation| (|Expression| |#1|))) (|Fraction| (|Polynomial| |#1|)))
   "\\spad{radicalSolve(rf)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0,{} where \\spad{rf} is a univariate rational function.")
  (((|List| (|Equation| (|Expression| |#1|))) (|Fraction| (|Polynomial| |#1|))
    (|Symbol|))
   "\\spad{radicalSolve(rf,{} x)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x},{} where \\spad{rf} is a rational function."))) 
NIL 
(|TransSolvePackageService| R) 
((|constructor|
  (NIL
   "This package finds the function \\spad{func3} where \\spad{func1} and \\spad{func2} \\indented{1}{are given and\\space{2}\\spad{func1} = \\spad{func3}(\\spad{func2}) .\\space{2}If there is no solution then} \\indented{1}{function \\spad{func1} will be returned.} \\indented{1}{An example would be\\space{2}\\spad{func1 := 8*X^3+32*X^2-14*X ::EXPR INT} and} \\indented{1}{\\spad{func2 := 2*X ::EXPR INT} convert them via univariate} \\indented{1}{to FRAC SUP EXPR INT and then the solution is \\spad{func3 := X^3+X^2-X}} \\indented{1}{of type FRAC SUP EXPR INT}"))
 (|unvectorise|
  (((|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))
    (|Vector| (|Expression| |#1|))
    (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))
    (|Integer|))
   "\\spad{unvectorise(vect,{} var,{} n)} returns \\spad{vect(1) + vect(2)*var + ... + vect(n+1)*var^(n)} where \\spad{vect} is the vector of the coefficients of the polynomial,{} \\spad{var} the new variable and \\spad{n} the degree."))
 (|decomposeFunc|
  (((|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))
    (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))
    (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))
    (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))))
   "\\spad{decomposeFunc(func1,{} func2,{} newvar)} returns a function \\spad{func3} where \\spad{func1} = \\spad{func3}(\\spad{func2}) and expresses it in the new variable newvar. If there is no solution then \\spad{func1} will be returned."))) 
NIL 
(|TransSolvePackage| R) 
((|constructor|
  (NIL
   "This package tries to find solutions of equations of type Expression(\\spad{R}). This means expressions involving transcendental,{} exponential,{} logarithmic and nthRoot functions. After trying to transform different kernels to one kernel by applying several rules,{} it calls zerosOf for the SparseUnivariatePolynomial in the remaining kernel. For example the expression \\spad{sin(x)*cos(x)-2} will be transformed to \\indented{3}{\\spad{-2 tan(x/2)^4 -2 tan(x/2)^3 -4 tan(x/2)^2 +2 tan(x/2) -2}} by using the function normalize and then to \\indented{3}{\\spad{-2 tan(x)^2 + tan(x) -2}} with help of subsTan. This function tries to express the given function in terms of \\spad{tan(x/2)} to express in terms of \\spad{tan(x)} . Other examples are the expressions \\spad{sqrt(x+1)+sqrt(x+7)+1} or \\indented{1}{\\spad{sqrt(sin(x))+1} .}"))
 (|solve|
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Equation| (|Expression| |#1|))) (|List| (|Expression| |#1|)))
   "\\spad{solve(leqs,{} lexpr)} returns a list of solutions to the list of equations \\spad{leqs} with respect to the list of expressions lexpr. Each expression in lexpr is treated as a variable and must be a single kernel.")
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Equation| (|Expression| |#1|)))
    (|List| (|Kernel| (|Expression| |#1|))))
   "\\spad{solve(leqs,{} lker)} returns a list of solutions to the list of equations \\spad{leqs} with respect to the list of kernels lker.")
  (((|List| (|List| (|Equation| (|Expression| |#1|))))
    (|List| (|Equation| (|Expression| |#1|))) (|List| (|Symbol|)))
   "\\spad{solve(leqs,{} lvar)} returns a list of solutions to the list of equations \\spad{leqs} with respect to the list of symbols lvar.")
  (((|List| (|Equation| (|Expression| |#1|))) (|Expression| |#1|) (|Symbol|))
   "\\spad{solve(expr,{} x)} finds the solutions of the equation \\spad{expr} = 0 with respect to the symbol \\spad{x} where \\spad{expr} is a function of type Expression(\\spad{R}).")
  (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Expression| |#1|))
    (|Symbol|))
   "\\spad{solve(eq,{} x)} finds the solutions of the equation \\spad{eq} where \\spad{eq} is an equation of functions of type Expression(\\spad{R}) with respect to the symbol \\spad{x}.")
  (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Expression| |#1|)))
   "\\spad{solve(eq)} finds the solutions of the equation \\spad{eq} where \\spad{eq} is an equation of functions of type Expression(\\spad{R}) with respect to the unique symbol \\spad{x} appearing in \\spad{eq}.")
  (((|List| (|Equation| (|Expression| |#1|))) (|Expression| |#1|))
   "\\spad{solve(expr)} finds the solutions of the equation \\spad{expr} = 0 where \\spad{expr} is a function of type Expression(\\spad{R}) with respect to the unique symbol \\spad{x} appearing in eq."))) 
NIL 
(|SmallOrdinal|) 
((|constructor|
  (NIL
   "SmallOrdinal implements ordinal numbers up to \\spad{epsilon_0}. \\spad{+} and \\spad{*} are \"natural\" addition and multiplication of ordinals. Available separately are \"ordered\" operataions."))
 (^
  (($ $ $)
   "\\spad{o1^o2} returns \\spad{o1} to power \\spad{o2},{} where power is inductively defined using successive natural multiplication from the left"))
 (|limitPart|
  (($ $)
   "\\spad{limitPart(o)} = \\spad{l} when \\spad{o} = \\spad{l} + \\spad{n} and \\spad{l} is a limit ordinal and \\spad{n} is a nonnegative integer"))
 (|integerPart|
  (((|NonNegativeInteger|) $)
   "\\spad{integerPart(o)} = \\spad{n} when \\spad{o} = \\spad{l} + \\spad{n} and \\spad{l} is a limit ordinal"))
 (|ordinalPower|
  (($ $ $)
   "\\spad{ordinalPower(o1,{} o2)} returns \\spad{o1} to power \\spad{o2},{} where power is inductively defined using successive ordinal multiplication from the left"))
 (|ordinalMul|
  (($ $ $)
   "\\spad{ordinalMul(o1,{} o2)} returns product of \\spad{o1} and \\spad{o2} as ordered sets"))
 (|ordinalAdd|
  (($ $ $)
   "\\spad{ordinalAdd(o1,{} o2)} returns sum of \\spad{o1} and \\spad{o2} as ordered sets"))
 (|omegapower| (($ $) "\\spad{omegapower(p)} returns omega^p"))
 (|omega| (($) "\\spad{omega()} is the first infinite ordinal"))) 
((|HasCategory| $ '(|AbelianGroup|))) 
(|SortedExponentVector|) 
((|constructor|
  (NIL
   "\\indented{1}{Domain for storing information about structure of polynomials} as vectors of exponents"))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|SortPackage| S A) 
((|constructor| (NIL "This package exports sorting algorithnms"))
 (|insertionSort!| ((|#2| |#2|) "\\spad{insertionSort! }\\undocumented")
  ((|#2| |#2| (|Mapping| (|Boolean|) |#1| |#1|))
   "\\spad{insertionSort!(a,{} f)} \\undocumented"))
 (|bubbleSort!| ((|#2| |#2|) "\\spad{bubbleSort!(a)} \\undocumented")
  ((|#2| |#2| (|Mapping| (|Boolean|) |#1| |#1|))
   "\\spad{bubbleSort!(a,{} f)} \\undocumented"))) 
((|HasCategory| |#1| '(|OrderedSet|))) 
(|ThreeSpace| R) 
((|constructor|
  (NIL
   "The domain ThreeSpace is used for creating three dimensional objects using functions for defining points,{} curves,{} polygons,{} constructs and the subspaces containing them."))) 
NIL 
(|ThreeSpaceCategory| R) 
((|constructor|
  (NIL
   "The category ThreeSpaceCategory is used for creating three dimensional objects using functions for defining points,{} curves,{} polygons,{} constructs and the subspaces containing them."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(s)} returns the \\spadtype{ThreeSpace} \\spad{s} to Output format."))
 (|subspace|
  (((|SubSpace| 3 |#1|) $)
   "\\spad{subspace(s)} returns the \\spadtype{SubSpace} which holds all the point information in the \\spadtype{ThreeSpace},{} \\spad{s}."))
 (|check|
  (($ $)
   "\\spad{check(s)} returns lllpt,{} list of lists of lists of point information about the \\spadtype{ThreeSpace} \\spad{s}."))
 (|objects|
  (((|Record| (|:| |points| (|NonNegativeInteger|))
              (|:| |curves| (|NonNegativeInteger|))
              (|:| |polygons| (|NonNegativeInteger|))
              (|:| |constructs| (|NonNegativeInteger|)))
    $)
   "\\spad{objects(s)} returns the \\spadtype{ThreeSpace},{} \\spad{s},{} in the form of a 3D object record containing information on the number of points,{} curves,{} polygons and constructs comprising the \\spadtype{ThreeSpace}.."))
 (|lprop|
  (((|List| (|SubSpaceComponentProperty|)) $)
   "\\spad{lprop(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of subspace component properties,{} and if so,{} returns the list; An error is signaled otherwise."))
 (|llprop|
  (((|List| (|List| (|SubSpaceComponentProperty|))) $)
   "\\spad{llprop(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of curves which are lists of the subspace component properties of the curves,{} and if so,{} returns the list of lists; An error is signaled otherwise."))
 (|lllp|
  (((|List| (|List| (|List| (|Point| |#1|)))) $)
   "\\spad{lllp(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise."))
 (|lllip|
  (((|List| (|List| (|List| (|NonNegativeInteger|)))) $)
   "\\spad{lllip(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of indices to points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise."))
 (|lp|
  (((|List| (|Point| |#1|)) $)
   "\\spad{lp(s)} returns the list of points component which the \\spadtype{ThreeSpace},{} \\spad{s},{} contains; these points are used by reference,{} \\spadignore{i.e.} the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points."))
 (|mesh?|
  (((|Boolean|) $)
   "\\spad{mesh?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} is composed of one component,{} a mesh comprising a list of curves which are lists of points,{} or returns \\spad{false} if otherwise"))
 (|mesh|
  (((|List| (|List| (|Point| |#1|))) $)
   "\\spad{mesh(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single surface component defined by a list curves which contain lists of points,{} and if so,{} returns the list of lists of points; An error is signaled otherwise.")
  (($ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh([[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} creates a surface defined over a list of curves,{} \\spad{p0} through \\spad{pn},{} which are lists of points; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: \\spad{close1} set to \\spad{true} means that each individual list (a curve) is to be closed (that is,{} the last point of the list is to be connected to the first point); \\spad{close2} set to \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the \\spadtype{ThreeSpace} containing this surface is returned.")
  (($ (|List| (|List| (|Point| |#1|))))
   "\\spad{mesh([[p0],{} [p1],{} ...,{} [pn]])} creates a surface defined by a list of curves which are lists,{} \\spad{p0} through \\spad{pn},{} of points,{} and returns a \\spadtype{ThreeSpace} whose component is the surface.")
  (($ $ (|List| (|List| (|List| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} close1,{} close2)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s},{} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: if \\spad{close1} is \\spad{true} this means that each individual list (a curve) is to be closed (\\spadignore{i.e.} the last point of the list is to be connected to the first point); if \\spad{close2} is \\spad{true},{} this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).")
  (($ $ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} adds a surface component to the \\spadtype{ThreeSpace},{} which is defined over a list of curves,{} in which each of these curves is a list of points. The boolean arguments \\spad{close1} and \\spad{close2} indicate how the surface is to be closed. Argument \\spad{close1} equal \\spad{true} means that each individual list (a curve) is to be closed,{} \\spadignore{i.e.} the last point of the list is to be connected to the first point. Argument \\spad{close2} equal \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end,{} \\spadignore{i.e.} the boundaries are defined as the first list of points (curve) and the last list of points (curve).")
  (($ $ (|List| (|List| (|List| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   "\\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} [props],{} prop)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s},{} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list,{} and prop is the subspace component property by which the points are defined.")
  (($ $ (|List| (|List| (|Point| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   "\\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} [props],{} prop)} adds a surface component,{} defined over a list curves which contains lists of points,{} to the \\spadtype{ThreeSpace} \\spad{s}; props is a list which contains the subspace component properties for each surface parameter,{} and prop is the subspace component property by which the points are defined."))
 (|polygon?|
  (((|Boolean|) $)
   "\\spad{polygon?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single polygon component,{} or \\spad{false} otherwise."))
 (|polygon|
  (((|List| (|Point| |#1|)) $)
   "\\spad{polygon(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single polygon component defined by a list of points,{} and if so,{} returns the list of points; An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{polygon([p0,{} p1,{} ...,{} pn])} creates a polygon defined by a list of points,{} \\spad{p0} through \\spad{pn},{} and returns a \\spadtype{ThreeSpace} whose component is the polygon.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{polygon(s,{} [[r0],{} [r1],{} ...,{} [rn]])} adds a polygon component defined by a list of points \\spad{r0} through \\spad{rn},{} which are lists of elements from the domain \\spad{PointDomain(m,{} R)} to the \\spadtype{ThreeSpace} \\spad{s},{} where \\spad{m} is the dimension of the points and \\spad{R} is the \\spadtype{Ring} over which the points are defined.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{polygon(s,{} [p0,{} p1,{} ...,{} pn])} adds a polygon component defined by a list of points,{} \\spad{p0} throught \\spad{pn},{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|closedCurve?|
  (((|Boolean|) $)
   "\\spad{closedCurve?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single closed curve component,{} \\spadignore{i.e.} the first element of the curve is also the last element,{} or \\spad{false} otherwise."))
 (|closedCurve|
  (((|List| (|Point| |#1|)) $)
   "\\spad{closedCurve(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single closed curve component defined by a list of points in which the first point is also the last point,{} all of which are from the domain \\spad{PointDomain(m,{} R)} and if so,{} returns the list of points. An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{closedCurve(lp)} sets a list of points defined by the first element of \\spad{lp} through the last element of \\spad{lp} and back to the first elelment again and returns a \\spadtype{ThreeSpace} whose component is the closed curve defined by \\spad{lp}.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{closedCurve(s,{} [[lr0],{} [lr1],{} ...,{} [lrn],{} [lr0]])} adds a closed curve component defined by a list of points \\spad{lr0} through \\spad{lrn},{} which are lists of elements from the domain \\spad{PointDomain(m,{} R)},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points,{} in which the last element of the list of points contains a copy of the first element list,{} \\spad{lr0}. The closed curve is added to the \\spadtype{ThreeSpace},{} \\spad{s}.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{closedCurve(s,{} [p0,{} p1,{} ...,{} pn,{} p0])} adds a closed curve component which is a list of points defined by the first element \\spad{p0} through the last element \\spad{pn} and back to the first element \\spad{p0} again,{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|curve?|
  (((|Boolean|) $)
   "\\spad{curve?(s)} queries whether the \\spadtype{ThreeSpace},{} \\spad{s},{} is a curve,{} \\spadignore{i.e.} has one component,{} a list of list of points,{} and returns \\spad{true} if it is,{} or \\spad{false} otherwise."))
 (|curve|
  (((|List| (|Point| |#1|)) $)
   "\\spad{curve(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single curve defined by a list of points and if so,{} returns the curve,{} \\spadignore{i.e.} list of points. An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{curve([p0,{} p1,{} p2,{} ...,{} pn])} creates a space curve defined by the list of points \\spad{p0} through \\spad{pn},{} and returns the \\spadtype{ThreeSpace} whose component is the curve.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{curve(s,{} [[p0],{} [p1],{} ...,{} [pn]])} adds a space curve which is a list of points \\spad{p0} through \\spad{pn} defined by lists of elements from the domain \\spad{PointDomain(m,{} R)},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points,{} to the \\spadtype{ThreeSpace} \\spad{s}.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{curve(s,{} [p0,{} p1,{} ...,{} pn])} adds a space curve component defined by a list of points \\spad{p0} through \\spad{pn},{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|point?|
  (((|Boolean|) $)
   "\\spad{point?(s)} queries whether the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single component which is a point and returns the boolean result."))
 (|point|
  (((|Point| |#1|) $)
   "\\spad{point(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of only a single point and if so,{} returns the point. An error is signaled otherwise.")
  (($ (|Point| |#1|))
   "\\spad{point(p)} returns a \\spadtype{ThreeSpace} object which is composed of one component,{} the point \\spad{p}.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{point(s,{} i)} adds a point component which is placed into a component list of the \\spadtype{ThreeSpace},{} \\spad{s},{} at the index given by \\spad{i}.")
  (($ $ (|List| |#1|))
   "\\spad{point(s,{} [x,{} y,{} z])} adds a point component defined by a list of elements which are from the \\spad{PointDomain(R)} to the \\spadtype{ThreeSpace},{} \\spad{s},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined.")
  (($ $ (|Point| |#1|))
   "\\spad{point(s,{} p)} adds a point component defined by the point,{} \\spad{p},{} specified as a list from \\spad{List(R)},{} to the \\spadtype{ThreeSpace},{} \\spad{s},{} where \\spad{R} is the \\spadtype{Ring} over which the point is defined."))
 (|modifyPointData|
  (($ $ (|NonNegativeInteger|) (|Point| |#1|))
   "\\spad{modifyPointData(s,{} i,{} p)} changes the point at the indexed location \\spad{i} in the \\spadtype{ThreeSpace},{} \\spad{s},{} to that of point \\spad{p}. This is useful for making changes to a point which has been transformed."))
 (|enterPointData|
  (((|NonNegativeInteger|) $ (|List| (|Point| |#1|)))
   "\\spad{enterPointData(s,{} [p0,{} p1,{} ...,{} pn])} adds a list of points from \\spad{p0} through \\spad{pn} to the \\spadtype{ThreeSpace},{} \\spad{s},{} and returns the index,{} to the starting point of the list."))
 (|copy|
  (($ $)
   "\\spad{copy(s)} returns a new \\spadtype{ThreeSpace} that is an exact copy of \\spad{s}."))
 (|composites|
  (((|List| $) $)
   "\\spad{composites(s)} takes the \\spadtype{ThreeSpace} \\spad{s},{} and creates a list containing a unique \\spadtype{ThreeSpace} for each single composite of \\spad{s}. If \\spad{s} has no composites defined (composites need to be explicitly created),{} the list returned is empty. Note that not all the components need to be part of a composite."))
 (|components|
  (((|List| $) $)
   "\\spad{components(s)} takes the \\spadtype{ThreeSpace} \\spad{s},{} and creates a list containing a unique \\spadtype{ThreeSpace} for each single component of \\spad{s}. If \\spad{s} has no components defined,{} the list returned is empty."))
 (|composite|
  (($ (|List| $))
   "\\spad{composite([s1,{} s2,{} ...,{} sn])} will create a new \\spadtype{ThreeSpace} that is a union of all the components from each \\spadtype{ThreeSpace} in the parameter list,{} grouped as a composite."))
 (|merge|
  (($ $ $)
   "\\spad{merge(s1,{} s2)} will create a new \\spadtype{ThreeSpace} that has the components of \\spad{s1} and \\spad{s2}; Groupings of components into composites are maintained.")
  (($ (|List| $))
   "\\spad{merge([s1,{} s2,{} ...,{} sn])} will create a new \\spadtype{ThreeSpace} that has the components of all the ones in the list; Groupings of components into composites are maintained."))
 (|numberOfComposites|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComposites(s)} returns the number of supercomponents,{} or composites,{} in the \\spadtype{ThreeSpace},{} \\spad{s}; Composites are arbitrary groupings of otherwise distinct and unrelated components; A \\spadtype{ThreeSpace} need not have any composites defined at all and,{} outside of the requirement that no component can belong to more than one composite at a time,{} the definition and interpretation of composites are unrestricted."))
 (|numberOfComponents|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComponents(s)} returns the number of distinct object components in the indicated \\spadtype{ThreeSpace},{} \\spad{s},{} such as points,{} curves,{} polygons,{} and constructs."))
 (|create3Space|
  (($ (|SubSpace| 3 |#1|))
   "\\spad{create3Space(s)} creates a \\spadtype{ThreeSpace} object containing objects pre-defined within some \\spadtype{SubSpace} \\spad{s}.")
  (($)
   "\\spad{create3Space()} creates a \\spadtype{ThreeSpace} object capable of holding point,{} curve,{} mesh components and any combination."))) 
NIL 
(|SpecialOutputPackage|) 
((|constructor|
  (NIL
   "SpecialOutputPackage allows FORTRAN,{} Tex and \\indented{2}{Script Formula Formatter output from programs.}"))
 (|outputAsTex|
  (((|Void|) (|List| (|OutputForm|)))
   "\\spad{outputAsTex(l)} sends (for each expression in the list \\spad{l}) output in Tex format to the destination as defined by \\spadsys{)set output tex}.")
  (((|Void|) (|OutputForm|))
   "\\spad{outputAsTex(o)} sends output \\spad{o} in Tex format to the destination defined by \\spadsys{)set output tex}."))
 (|outputAsScript|
  (((|Void|) (|List| (|OutputForm|)))
   "\\spad{outputAsScript(l)} sends (for each expression in the list \\spad{l}) output in Script Formula Formatter format to the destination defined. by \\spadsys{)set output forumula}.")
  (((|Void|) (|OutputForm|))
   "\\spad{outputAsScript(o)} sends output \\spad{o} in Script Formula Formatter format to the destination defined by \\spadsys{)set output formula}."))
 (|outputAsFortran|
  (((|Void|) (|List| (|OutputForm|)))
   "\\spad{outputAsFortran(l)} sends (for each expression in the list \\spad{l}) output in FORTRAN format to the destination defined by \\spadsys{)set output fortran}.")
  (((|Void|) (|OutputForm|))
   "\\spad{outputAsFortran(o)} sends output \\spad{o} in FORTRAN format.")
  (((|Void|) (|String|) (|OutputForm|))
   "\\spad{outputAsFortran(v,{} o)} sends output \\spad{v} = \\spad{o} in FORTRAN format to the destination defined by \\spadsys{)set output fortran}."))) 
NIL 
(|SpecialFunctionCategory|) 
((|constructor| (NIL "Category for the other special functions."))
 (|meijerG|
  (($ (|List| $) (|List| $) (|List| $) (|List| $) $)
   "\\spad{meijerG(la,{} lb,{} lc,{} ld,{} z)} is the meijerG function."))
 (|hypergeometricF|
  (($ (|List| $) (|List| $) $)
   "\\spad{hypergeometricF(la,{} lb,{} z)} is the generalized hypergeometric function."))
 (|meixnerM|
  (($ $ $ $ $) "\\spad{meixnerM(n,{} b,{} c,{} z)} is the Meixner polynomial"))
 (|laguerreL|
  (($ $ $ $) "\\spad{laguerreL(n,{} a,{} z)} is the Laguerre polynomial"))
 (|jacobiP|
  (($ $ $ $ $) "\\spad{jacobiP(n,{} a,{} b,{} z)} is the Jacobi polynomial"))
 (|hermiteH| (($ $ $) "\\spad{hermiteH(n,{} z)} is the Hermite polynomial"))
 (|charlierC|
  (($ $ $ $) "\\spad{charlierC(n,{} a,{} z)} is the Charlier polynomial"))
 (|riemannZeta| (($ $) "\\spad{riemannZeta(z)} is the Riemann Zeta function."))
 (|lerchPhi|
  (($ $ $ $) "\\spad{lerchPhi(z,{} s,{} a)} is the Lerch Phi function."))
 (|jacobiTheta|
  (($ $ $)
   "\\spad{jacobiTheta(z,{} m)} is the Jacobi Theta function in Jacobi notation."))
 (|jacobiZeta|
  (($ $ $)
   "\\spad{jacobiZeta(z,{} m)} is the Jacobi elliptic zeta function,{} defined by \\spad{D(jacobiZeta(z,{} m),{} z) = jacobiDn(z,{} m)^2 - ellipticE(m)/ellipticK(m)} and \\spad{jacobiZeta(0,{} m) = 0}."))
 (|jacobiDn|
  (($ $ $)
   "\\spad{jacobiDn(z,{} m)} is the Jacobi elliptic \\spad{dn} function,{} defined by \\spad{jacobiDn(z,{} m)^2 + m*jacobiSn(z,{} m)^2 = 1} and \\spad{jacobiDn(0,{} m) = 1}."))
 (|jacobiCn|
  (($ $ $)
   "\\spad{jacobiCn(z,{} m)} is the Jacobi elliptic \\spad{cn} function,{} defined by \\spad{jacobiCn(z,{} m)^2 + jacobiSn(z,{} m)^2 = 1} and \\spad{jacobiCn(0,{} m) = 1}."))
 (|jacobiSn|
  (($ $ $)
   "\\spad{jacobiSn(z,{} m)} is the Jacobi elliptic \\spad{sn} function,{} defined by the formula \\spad{jacobiSn(ellipticF(z,{} m),{} m) = z}."))
 (|ellipticPi|
  (($ $ $ $)
   "\\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind: \\spad{ellipticPi(z,{} n,{} m) = integrate(1/((1-n*t^2)*sqrt((1-t^2)*(1-m*t^2))),{} t = 0..z)}."))
 (|ellipticF|
  (($ $ $)
   "\\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind : \\spad{ellipticF(z,{} m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..z)}."))
 (|ellipticE|
  (($ $ $)
   "\\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind: \\spad{ellipticE(z,{} m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..z)}.")
  (($ $)
   "\\spad{ellipticE(m)} is the complete elliptic integral of the second kind: \\spad{ellipticE(m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..1)}."))
 (|ellipticK|
  (($ $)
   "\\spad{ellipticK(m)} is the complete elliptic integral of the first kind: \\spad{ellipticK(m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..1)}."))
 (|kelvinKer|
  (($ $ $)
   "\\spad{kelvinKer(v,{} z)} is the Kelvin kei function defined by equality \\spad{kelvinKer(v,{} z) = real(exp(-v*\\%pi*\\%i/2)*besselK(v,{} exp(\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real."))
 (|kelvinKei|
  (($ $ $)
   "\\spad{kelvinKei(v,{} z)} is the Kelvin kei function defined by equality \\spad{kelvinKei(v,{} z) = imag(exp(-v*\\%pi*\\%i/2)*besselK(v,{} exp(\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real."))
 (|kelvinBer|
  (($ $ $)
   "\\spad{kelvinBer(v,{} z)} is the Kelvin ber function defined by equality \\spad{kelvinBer(v,{} z) = real(besselJ(v,{} exp(3*\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real."))
 (|kelvinBei|
  (($ $ $)
   "\\spad{kelvinBei(v,{} z)} is the Kelvin bei function defined by equality \\spad{kelvinBei(v,{} z) = imag(besselJ(v,{} exp(3*\\%pi*\\%i/4)*z))} for \\spad{z} and \\spad{v} real."))
 (|legendreQ|
  (($ $ $ $)
   "\\spad{legendreQ(nu,{} mu,{} z)} is the Legendre \\spad{Q} function."))
 (|legendreP|
  (($ $ $ $)
   "\\spad{legendreP(nu,{} mu,{} z)} is the Legendre \\spad{P} function."))
 (|kummerU|
  (($ $ $ $)
   "\\spad{kummerU(mu,{} nu,{} z)} is the Kummer \\spad{U} function."))
 (|kummerM|
  (($ $ $ $)
   "\\spad{kummerM(mu,{} nu,{} z)} is the Kummer \\spad{M} function."))
 (|lommelS2|
  (($ $ $ $)
   "\\spad{lommelS2(mu,{} nu,{} z)} is the Lommel \\spad{S} function."))
 (|lommelS1|
  (($ $ $ $)
   "\\spad{lommelS1(mu,{} nu,{} z)} is the Lommel \\spad{s} function."))
 (|hankelH2|
  (($ $ $)
   "\\spad{hankelH2(v,{} z)} is the second Hankel function (Bessel function of the third kind)."))
 (|hankelH1|
  (($ $ $)
   "\\spad{hankelH1(v,{} z)} is first Hankel function (Bessel function of the third kind)."))
 (|struveL|
  (($ $ $)
   "\\spad{struveL(v,{} z)} is the Struve \\spad{L} function defined by the formula \\spad{struveL(v,{} z) = -\\%i^exp(-v*\\%pi*\\%i/2)*struveH(v,{} \\%i*z)}."))
 (|struveH|
  (($ $ $) "\\spad{struveH(v,{} z)} is the Struve \\spad{H} function."))
 (|weberE| (($ $ $) "\\spad{weberE(v,{} z)} is the Weber \\spad{E} function."))
 (|angerJ| (($ $ $) "\\spad{angerJ(v,{} z)} is the Anger \\spad{J} function."))
 (|whittakerW|
  (($ $ $ $)
   "\\spad{whittakerW(k,{} m,{} z)} is the Whittaker \\spad{W} function."))
 (|whittakerM|
  (($ $ $ $)
   "\\spad{whittakerM(k,{} m,{} z)} is the Whittaker \\spad{M} function."))
 (|weierstrassPInverse|
  (($ $ $ $)
   "\\spad{weierstrassPInverse(g2,{} g3,{} z)} is the inverse of Weierstrass \\spad{P} function,{} defined by the formula \\spad{weierstrassP(g2,{} g3,{} weierstrassPInverse(g2,{} g3,{} z)) = z}."))
 (|weierstrassZeta|
  (($ $ $ $)
   "\\spad{weierstrassZeta(g2,{} g3,{} z)} is the Weierstrass Zeta function."))
 (|weierstrassSigma|
  (($ $ $ $)
   "\\spad{weierstrassSigma(g2,{} g3,{} z)} is the Weierstrass Sigma function."))
 (|weierstrassPPrime|
  (($ $ $ $)
   "\\spad{weierstrassPPrime(g2,{} g3,{} z)} is the derivative of Weierstrass \\spad{P} function."))
 (|weierstrassP|
  (($ $ $ $)
   "\\spad{weierstrassP(g2,{} g3,{} z)} is the Weierstrass \\spad{P} function."))
 (|polylog|
  (($ $ $)
   "\\spad{polylog(s,{} x)} is the polylogarithm of order \\spad{s} at \\spad{x}."))
 (|lambertW|
  (($ $)
   "\\spad{lambertW(z)} = \\spad{w} is the principial branch of the solution to the equation \\spad{we^w = z}."))
 (|airyBiPrime|
  (($ $)
   "airyBiPrime is the derivative of the Airy function \\spad{\\spad{Bi}(x)}."))
 (|airyBi|
  (($ $) "\\spad{airyBi(x)} is the Airy function \\spad{\\spad{Bi}(x)}."))
 (|airyAiPrime|
  (($ $)
   "\\spad{airyAiPrime(x)} is the derivative of the Airy function \\spad{\\spad{Ai}(x)}."))
 (|airyAi|
  (($ $) "\\spad{airyAi(x)} is the Airy function \\spad{\\spad{Ai}(x)}."))
 (|besselK|
  (($ $ $)
   "\\spad{besselK(v,{} z)} is the modified Bessel function of the second kind."))
 (|besselI|
  (($ $ $)
   "\\spad{besselI(v,{} z)} is the modified Bessel function of the first kind."))
 (|besselY|
  (($ $ $)
   "\\spad{besselY(v,{} z)} is the Bessel function of the second kind."))
 (|besselJ|
  (($ $ $)
   "\\spad{besselJ(v,{} z)} is the Bessel function of the first kind."))
 (|polygamma|
  (($ $ $)
   "\\spad{polygamma(k,{} x)} is the \\spad{k-th} derivative of \\spad{digamma(x)},{} (often written \\spad{psi(k,{} x)} in the literature)."))
 (|digamma|
  (($ $)
   "\\spad{digamma(x)} is the logarithmic derivative of \\spad{Gamma(x)} (often written \\spad{psi(x)} in the literature)."))
 (|Beta|
  (($ $ $) "\\spad{Beta(x,{} y)} is \\spad{Gamma(x) * Gamma(y)/Gamma(x+y)}."))
 (|Gamma| (($ $ $) "\\spad{Gamma(a,{} x)} is the incomplete Gamma function.")
  (($ $) "\\spad{Gamma(x)} is the Euler Gamma function."))
 (|conjugate|
  (($ $) "\\spad{conjugate(x)} returns the conjugate of \\spad{x}."))
 (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x}."))) 
NIL 
(|SpecialFunctionUnivariateTaylorSeries| |Coef| UTS) 
((|weierstrassSigma0|
  ((|#2| |#1| |#1| |#2|)
   "\\spad{weierstrassSigma0(g2,{} g3,{} x)} computes weierstrassSigma(\\spad{g2},{} \\spad{g3},{} \\spad{x}). \\spad{x} must have no term of order 0."))
 (|weierstrassZeta0|
  ((|#2| |#1| |#1| |#2|)
   "\\spad{weierstrassZeta0(g2,{} g3,{} x)} computes finite part of weierstrassZeta(\\spad{g2},{} \\spad{g3},{} \\spad{x}). \\spad{x} must have no term of order 0."))
 (|weierstrassPPrime0|
  ((|#2| |#1| |#1| |#2|)
   "\\spad{weierstrassPPrime0(g2,{} g3,{} x)} computes finite part of weierstrassPPrime(\\spad{g2},{} \\spad{g3},{} \\spad{x}). \\spad{x} must have no term of order 0."))
 (|weierstrassP0|
  ((|#2| |#1| |#1| |#2|)
   "\\spad{weierstrassP0(g2,{} g3,{} x)} computes finite part of weierstrassP(\\spad{g2},{} \\spad{g3},{} \\spad{x}). \\spad{x} must have no term of order 0."))
 (|lambertW0|
  ((|#2| |#2|)
   "\\spad{lambertW0(x)} applies lambertW to \\spad{x}. \\spad{x} must have no term of order 0."))) 
NIL 
(|SplittingNode| V C) 
((|constructor|
  (NIL
   "This domain exports a modest implementation for the vertices of splitting trees. These vertices are called here splitting nodes. Every of these nodes store 3 informations. The first one is its value,{} that is the current expression to evaluate. The second one is its condition,{} that is the hypothesis under which the value has to be evaluated. The last one is its status,{} that is a boolean flag which is \\spad{true} iff the value is the result of its evaluation under its condition. Two splitting vertices are equal iff they have the sane values and the same conditions (so their status do not matter)."))
 (|subNode?|
  (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{subNode?(n1,{} n2,{} o2)} returns \\spad{true} iff \\spad{value(n1) = value(n2)} and \\spad{o2(condition(n1),{} condition(n2))}"))
 (|infLex?|
  (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|)
    (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{infLex?(n1,{} n2,{} o1,{} o2)} returns \\spad{true} iff \\spad{o1(value(n1),{} value(n2))} or \\spad{value(n1) = value(n2)} and \\spad{o2(condition(n1),{} condition(n2))}."))
 (|setEmpty!|
  (($ $) "\\spad{setEmpty!(n)} replaces \\spad{n} by \\spad{empty()\\$\\%}."))
 (|setStatus!|
  (($ $ (|Boolean|))
   "\\spad{setStatus!(n,{} b)} returns \\spad{n} whose status has been replaced by \\spad{b} if it is not empty,{} else an error is produced."))
 (|setCondition!|
  (($ $ |#2|)
   "\\spad{setCondition!(n,{} t)} returns \\spad{n} whose condition has been replaced by \\spad{t} if it is not empty,{} else an error is produced."))
 (|setValue!|
  (($ $ |#1|)
   "\\spad{setValue!(n,{} v)} returns \\spad{n} whose value has been replaced by \\spad{v} if it is not empty,{} else an error is produced."))
 (|copy| (($ $) "\\spad{copy(n)} returns a copy of \\spad{n}."))
 (|construct|
  (((|List| $) |#1| (|List| |#2|))
   "\\spad{construct(v,{} lt)} returns the same as \\spad{[construct(v,{} t) for t in lt]}")
  (((|List| $) (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))))
   "\\spad{construct(lvt)} returns the same as \\spad{[construct(vt.val,{} vt.tower) for vt in lvt]}")
  (($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|)))
   "\\spad{construct(vt)} returns the same as \\spad{construct(vt.val,{} vt.tower)}")
  (($ |#1| |#2|)
   "\\spad{construct(v,{} t)} returns the same as \\spad{construct(v,{} t,{} false)}")
  (($ |#1| |#2| (|Boolean|))
   "\\spad{construct(v,{} t,{} b)} returns the non-empty node with value \\spad{v},{} condition \\spad{t} and flag \\spad{b}"))
 (|status|
  (((|Boolean|) $)
   "\\spad{status(n)} returns the status of the node \\spad{n}."))
 (|condition|
  ((|#2| $)
   "\\spad{condition(n)} returns the condition of the node \\spad{n}."))
 (|value|
  ((|#1| $) "\\spad{value(n)} returns the value of the node \\spad{n}."))
 (|empty?|
  (((|Boolean|) $)
   "\\spad{empty?(n)} returns \\spad{true} iff the node \\spad{n} is \\spad{empty()\\$\\%}."))
 (|empty|
  (($)
   "\\spad{empty()} returns the same as \\spad{[empty()\\$V,{} empty()\\$C,{} false]\\$\\%}"))) 
NIL 
(|SplittingTree| V C) 
((|constructor|
  (NIL
   "This domain exports a modest implementation of splitting trees. Splitting trees are needed when the evaluation of some quantity under some hypothesis requires to split the hypothesis into sub-cases. For instance by adding some new hypothesis on one hand and its negation on another hand. The computations are terminated for a splitting tree \\spad{a} when \\spad{status(value(a))} is \\spad{true}. Thus,{} if for the splitting tree \\spad{a} the flag \\spad{status(value(a))} is \\spad{true},{} then \\spad{status(value(d))} is \\spad{true} for any subtree \\spad{d} of \\spad{a}. This property of splitting trees is called the termination condition. If no vertex in a splitting tree \\spad{a} is equal to another,{} \\spad{a} is said to satisfy the no-duplicates condition. The splitting tree \\spad{a} will satisfy this condition if nodes are added to \\spad{a} by means of \\spad{splitNodeOf!} and if \\spad{construct} is only used to create the root of \\spad{a} with no children."))
 (|splitNodeOf!|
  (($ $ $ (|List| (|SplittingNode| |#1| |#2|))
    (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{splitNodeOf!(l,{} a,{} ls,{} sub?)} returns \\spad{a} where the children list of \\spad{l} has been set to \\spad{[[s]\\$\\% for s in ls | not subNodeOf?(s,{} a,{} sub?)]}. Thus,{} if \\spad{l} is not a node of \\spad{a},{} this latter splitting tree is unchanged.")
  (($ $ $ (|List| (|SplittingNode| |#1| |#2|)))
   "\\spad{splitNodeOf!(l,{} a,{} ls)} returns \\spad{a} where the children list of \\spad{l} has been set to \\spad{[[s]\\$\\% for s in ls | not nodeOf?(s,{} a)]}. Thus,{} if \\spad{l} is not a node of \\spad{a},{} this latter splitting tree is unchanged."))
 (|remove!|
  (($ (|SplittingNode| |#1| |#2|) $)
   "\\spad{remove!(s,{} a)} replaces a by remove(\\spad{s},{} a)"))
 (|remove|
  (($ (|SplittingNode| |#1| |#2|) $)
   "\\spad{remove(s,{} a)} returns the splitting tree obtained from a by removing every sub-tree \\spad{b} such that \\spad{value(b)} and \\spad{s} have the same value,{} condition and status."))
 (|subNodeOf?|
  (((|Boolean|) (|SplittingNode| |#1| |#2|) $
    (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{subNodeOf?(s,{} a,{} sub?)} returns \\spad{true} iff for some node \\spad{n} in \\spad{a} we have \\spad{s = n} or \\spad{status(n)} and \\spad{subNode?(s,{} n,{} sub?)}."))
 (|nodeOf?|
  (((|Boolean|) (|SplittingNode| |#1| |#2|) $)
   "\\spad{nodeOf?(s,{} a)} returns \\spad{true} iff some node of \\spad{a} is equal to \\spad{s}"))
 (|result|
  (((|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))) $)
   "\\spad{result(a)} where \\spad{ls} is the leaves list of \\spad{a} returns \\spad{[[value(s),{} condition(s)]\\$VT for s in ls]} if the computations are terminated in \\spad{a} else an error is produced."))
 (|conditions|
  (((|List| |#2|) $)
   "\\spad{conditions(a)} returns the list of the conditions of the leaves of a"))
 (|construct|
  (($ |#1| |#2| |#1| (|List| |#2|))
   "\\spad{construct(v1,{} t,{} v2,{} lt)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\spad{[v,{} t]\\$S} and with children list given by \\spad{[[[v,{} t]\\$S]\\$\\% for s in ls]}.")
  (($ |#1| |#2| (|List| (|SplittingNode| |#1| |#2|)))
   "\\spad{construct(v,{} t,{} ls)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\spad{[v,{} t]\\$S} and with children list given by \\spad{[[s]\\$\\% for s in ls]}.")
  (($ |#1| |#2| (|List| $))
   "\\spad{construct(v,{} t,{} la)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\spad{[v,{} t]\\$S} and with \\spad{la} as children list.")
  (($ (|SplittingNode| |#1| |#2|))
   "\\spad{construct(s)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\spad{s} and no children. Thus,{} if the status of \\spad{s} is \\spad{false},{} \\spad{[s]} represents the starting point of the evaluation \\spad{value(s)} under the hypothesis \\spad{condition(s)}."))
 (|updateStatus!|
  (($ $)
   "\\spad{updateStatus!(a)} returns a where the status of the vertices are updated to satisfy the \"termination condition\"."))
 (|extractSplittingLeaf|
  (((|Union| $ "failed") $)
   "\\spad{extractSplittingLeaf(a)} returns the left most leaf (as a tree) whose status is \\spad{false} if any,{} else \"failed\" is returned."))) 
((|HasCategory| (|SplittingNode| |#1| |#2|) '(|SetCategory|))
 (AND
  (|HasCategory| (|SplittingNode| |#1| |#2|)
                 (LIST '|Evalable|
                       (LIST '|SplittingNode| (|devaluate| |#1|)
                             (|devaluate| |#2|))))
  (|HasCategory| (|SplittingNode| |#1| |#2|) '(|SetCategory|)))
 (|HasCategory| (|SplittingNode| |#1| |#2|) '(|OrderedSet|))
 (|HasCategory| (|SplittingNode| |#1| |#2|) '(|BasicType|))
 (OR (|HasCategory| (|SplittingNode| |#1| |#2|) '(|BasicType|))
     (|HasCategory| (|SplittingNode| |#1| |#2|) '(|SetCategory|)))
 (|HasCategory| (|SplittingNode| |#1| |#2|)
                (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR
  (|HasCategory| (|SplittingNode| |#1| |#2|)
                 (LIST '|CoercibleTo| '(|OutputForm|)))
  (AND
   (|HasCategory| (|SplittingNode| |#1| |#2|)
                  (LIST '|Evalable|
                        (LIST '|SplittingNode| (|devaluate| |#1|)
                              (|devaluate| |#2|))))
   (|HasCategory| (|SplittingNode| |#1| |#2|) '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|SplittingNode| |#1| |#2|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|SplittingNode| |#1| |#2|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|SplittingNode| |#1| |#2|) '(|BasicType|)))
  (|HasCategory| (|SplittingNode| |#1| |#2|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|SPointCategory&| S) 
((|constructor|
  (NIL
   "PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another."))
 (|coerce| (((|OutputForm|) $) "output"))
 (|extendedCoords|
  (((|List| (|DoubleFloat|)) $)
   "\\spad{extendedCoords(pt)} returns extended coordinates as a list."))
 (|screenCoords|
  (((|List| (|DoubleFloat|)) $)
   "\\spad{screenCoords(pt)} returns screen coordinates as a list."))
 (|screenCoordZ|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordZ(pt)} returns the \\spad{'z'}(out from screen) screen coordinate."))
 (|screenCoordY|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordY(pt)} returns the \\spad{'y'}(bottom to top) screen coordinate."))
 (|screenCoordX|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordX(pt)} returns the \\spad{'x'}(left to right) screen coordinate."))
 (|inBounds?|
  (((|Boolean|) $ $ $)
   "\\spad{inBounds?(pt,{} mns,{} mxs)} returns \\spad{true} if \\spad{pt} is inside bounding box where bounding box is specified by min and max."))
 (|isVector?|
  (((|Boolean|) $)
   "\\spad{isVector? returns} \\spad{true} if this represents a vector as opposed to a point."))
 (|isPoint?|
  (((|Boolean|) $)
   "\\spad{isPoint?(p)} returns \\spad{true} if this represents a point as opposed to a vector."))
 (|toVector|
  (($ $)
   "\\spad{toVector returns} a Vector with the same coordinates as \\spad{p} If \\spad{p} was originally a point then the vector will be the distance from the origin."))
 (|toPoint|
  (($ $)
   "\\spad{toPoint(p)} returns a Point with the same coordinates as \\spad{p} If \\spad{p} was originally a vector then that will be treated as the distance from the origin."))
 (*
  (($ (|DoubleFloat|) $)
   "*(\\spad{s},{} \\spad{x}) gives scalar multiplication Although,{} scalar multiplication is strictly only a valid operation for vectors and not points,{} we allow it here because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5."))
 (-
  (($ $ $)
   "\\spad{-(x,{} y)} gives subtraction subtract the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector - vector = vector point - vector = point vector - point = invalid (but interpret as point) point - point = invalid (but interpret as vector) Although,{} subtracting two points is not strictly a valid operation,{} we allow it here by interpreting the result as the vector distance between the two points."))
 (+
  (($ $ $)
   "+(\\spad{x},{} \\spad{y}) gives addition add the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector + vector = vector point + vector = point point + point = invalid (but interpret as vector) Although,{} adding two points is not strictly a valid operation,{} we allow it here by interpreting the point as a vector relative to the origin. We do that because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5."))
 (|perpendicular|
  (($ $ $)
   "\\spad{perpendicular(x,{} y)} returns a vector perpendicular to the two vectors in the case of 3D Euclidean space this is the cross the product of two vectors. We use this function to compute orthogonal"))
 (|colinearity|
  (((|DoubleFloat|) $ $)
   "\\spad{colinearity(x,{} y)} returns a measure of how parallel two vectors are independent of the length of the vectors: 1.0 is completely parallel 0.0 is completely perpendicular returned value will be between these"))
 (|parallel|
  (((|DoubleFloat|) $ $)
   "\\spad{parallel(x,{} y)} returns the length of the parallel component of two vectors. In the case of Euclidean space this is the dot product of two vectors. We use this function to test the colinearity"))
 (|distance|
  (((|DoubleFloat|) $ $)
   "\\spad{distance(p1,{} p2)} returns the distance between the points \\spad{p1} is the first point. \\spad{p2} is the second point. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space."))
 (|distanceSquared|
  (((|DoubleFloat|) $ $)
   "\\spad{distanceSquared(p1,{} p2)} returns the distance between the points \\spad{p1} and \\spad{p2}. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space."))
 (|unitVector|
  (($ $)
   "\\spad{unitVector(p)} returns a vector with the same direction as \\spad{p} but with unit length. We scale until length is 1"))
 (|Pnan?|
  (((|Boolean|) $)
   "\\spad{Pnan?(p)} returns \\spad{true} if any of its elements are not valid DoubleFloat values. Examples of invalid floating point numbers are when we have divided a given element by zero or taken sqrt of negative number at some stage? Note: we can still represent a point at infinity and we can represent points using complex numbers,{} but we do this using projective or conformal space or by using the appropriate instance of SPointCategory,{} not by using invalid floating point numbers."))
 (|dimension|
  (((|PositiveInteger|) $)
   "\\spad{dimension(p)} returns the number of dimensions that make up the point category \\spad{p}."))
 (|max|
  (($ $ $)
   "\\spad{max(a,{} b)} returns a point whose value in each dimension is the maximum. So if a has the largest \\spad{x} value and \\spad{b} has the largest \\spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points."))
 (|min|
  (($ $ $)
   "\\spad{min(a,{} b)} returns a point whose value in each dimension is the minimum. So if a has the smallest \\spad{x} value and \\spad{b} has the smallest \\spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points."))
 (|sivec|
  (($ (|Integer|) (|Integer|) (|Integer|))
   "\\spad{sivec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \\spad{b} and \\spad{c} of type Integer")
  (($ (|Integer|) (|Integer|))
   "\\spad{sivec(a,{} b)} constructs a 2D vector defined by a and \\spad{b} of type Integer"))
 (|svec|
  (($ (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{svec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \\spad{b} and \\spad{c} of type \\spad{R}")
  (($ (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{svec(a,{} b)} constructs a 2D vector defined by a and \\spad{b} of type \\spad{R}"))
 (|sipnt|
  (($ (|Integer|) (|Integer|) (|Integer|))
   "\\spad{sipnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \\spad{b} and \\spad{c} of type Integer")
  (($ (|Integer|) (|Integer|))
   "\\spad{sipnt(a,{} b)} constructs a 2D point defined by a and \\spad{b} of type Integer"))
 (|spnt|
  (($ (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{spnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \\spad{b} and \\spad{c} of type \\spad{R}")
  (($ (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{spnt(a,{} b)} constructs a 2D point defined by a and \\spad{b} of type \\spad{R}"))) 
NIL 
(|SPointCategory|) 
((|constructor|
  (NIL
   "PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another."))
 (|coerce| (((|OutputForm|) $) "output"))
 (|extendedCoords|
  (((|List| (|DoubleFloat|)) $)
   "\\spad{extendedCoords(pt)} returns extended coordinates as a list."))
 (|screenCoords|
  (((|List| (|DoubleFloat|)) $)
   "\\spad{screenCoords(pt)} returns screen coordinates as a list."))
 (|screenCoordZ|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordZ(pt)} returns the \\spad{'z'}(out from screen) screen coordinate."))
 (|screenCoordY|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordY(pt)} returns the \\spad{'y'}(bottom to top) screen coordinate."))
 (|screenCoordX|
  (((|DoubleFloat|) $)
   "\\spad{screenCoordX(pt)} returns the \\spad{'x'}(left to right) screen coordinate."))
 (|inBounds?|
  (((|Boolean|) $ $ $)
   "\\spad{inBounds?(pt,{} mns,{} mxs)} returns \\spad{true} if \\spad{pt} is inside bounding box where bounding box is specified by min and max."))
 (|isVector?|
  (((|Boolean|) $)
   "\\spad{isVector? returns} \\spad{true} if this represents a vector as opposed to a point."))
 (|isPoint?|
  (((|Boolean|) $)
   "\\spad{isPoint?(p)} returns \\spad{true} if this represents a point as opposed to a vector."))
 (|toVector|
  (($ $)
   "\\spad{toVector returns} a Vector with the same coordinates as \\spad{p} If \\spad{p} was originally a point then the vector will be the distance from the origin."))
 (|toPoint|
  (($ $)
   "\\spad{toPoint(p)} returns a Point with the same coordinates as \\spad{p} If \\spad{p} was originally a vector then that will be treated as the distance from the origin."))
 (*
  (($ (|DoubleFloat|) $)
   "*(\\spad{s},{} \\spad{x}) gives scalar multiplication Although,{} scalar multiplication is strictly only a valid operation for vectors and not points,{} we allow it here because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5."))
 (-
  (($ $ $)
   "\\spad{-(x,{} y)} gives subtraction subtract the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector - vector = vector point - vector = point vector - point = invalid (but interpret as point) point - point = invalid (but interpret as vector) Although,{} subtracting two points is not strictly a valid operation,{} we allow it here by interpreting the result as the vector distance between the two points."))
 (+
  (($ $ $)
   "+(\\spad{x},{} \\spad{y}) gives addition add the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector + vector = vector point + vector = point point + point = invalid (but interpret as vector) Although,{} adding two points is not strictly a valid operation,{} we allow it here by interpreting the point as a vector relative to the origin. We do that because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5."))
 (|perpendicular|
  (($ $ $)
   "\\spad{perpendicular(x,{} y)} returns a vector perpendicular to the two vectors in the case of 3D Euclidean space this is the cross the product of two vectors. We use this function to compute orthogonal"))
 (|colinearity|
  (((|DoubleFloat|) $ $)
   "\\spad{colinearity(x,{} y)} returns a measure of how parallel two vectors are independent of the length of the vectors: 1.0 is completely parallel 0.0 is completely perpendicular returned value will be between these"))
 (|parallel|
  (((|DoubleFloat|) $ $)
   "\\spad{parallel(x,{} y)} returns the length of the parallel component of two vectors. In the case of Euclidean space this is the dot product of two vectors. We use this function to test the colinearity"))
 (|distance|
  (((|DoubleFloat|) $ $)
   "\\spad{distance(p1,{} p2)} returns the distance between the points \\spad{p1} is the first point. \\spad{p2} is the second point. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space."))
 (|distanceSquared|
  (((|DoubleFloat|) $ $)
   "\\spad{distanceSquared(p1,{} p2)} returns the distance between the points \\spad{p1} and \\spad{p2}. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space."))
 (|unitVector|
  (($ $)
   "\\spad{unitVector(p)} returns a vector with the same direction as \\spad{p} but with unit length. We scale until length is 1"))
 (|Pnan?|
  (((|Boolean|) $)
   "\\spad{Pnan?(p)} returns \\spad{true} if any of its elements are not valid DoubleFloat values. Examples of invalid floating point numbers are when we have divided a given element by zero or taken sqrt of negative number at some stage? Note: we can still represent a point at infinity and we can represent points using complex numbers,{} but we do this using projective or conformal space or by using the appropriate instance of SPointCategory,{} not by using invalid floating point numbers."))
 (|dimension|
  (((|PositiveInteger|) $)
   "\\spad{dimension(p)} returns the number of dimensions that make up the point category \\spad{p}."))
 (|max|
  (($ $ $)
   "\\spad{max(a,{} b)} returns a point whose value in each dimension is the maximum. So if a has the largest \\spad{x} value and \\spad{b} has the largest \\spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points."))
 (|min|
  (($ $ $)
   "\\spad{min(a,{} b)} returns a point whose value in each dimension is the minimum. So if a has the smallest \\spad{x} value and \\spad{b} has the smallest \\spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points."))
 (|sivec|
  (($ (|Integer|) (|Integer|) (|Integer|))
   "\\spad{sivec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \\spad{b} and \\spad{c} of type Integer")
  (($ (|Integer|) (|Integer|))
   "\\spad{sivec(a,{} b)} constructs a 2D vector defined by a and \\spad{b} of type Integer"))
 (|svec|
  (($ (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{svec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \\spad{b} and \\spad{c} of type \\spad{R}")
  (($ (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{svec(a,{} b)} constructs a 2D vector defined by a and \\spad{b} of type \\spad{R}"))
 (|sipnt|
  (($ (|Integer|) (|Integer|) (|Integer|))
   "\\spad{sipnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \\spad{b} and \\spad{c} of type Integer")
  (($ (|Integer|) (|Integer|))
   "\\spad{sipnt(a,{} b)} constructs a 2D point defined by a and \\spad{b} of type Integer"))
 (|spnt|
  (($ (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{spnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \\spad{b} and \\spad{c} of type \\spad{R}")
  (($ (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{spnt(a,{} b)} constructs a 2D point defined by a and \\spad{b} of type \\spad{R}"))) 
NIL 
(|SquareMatrix| |ndim| R) 
((|constructor|
  (NIL
   "\\spadtype{SquareMatrix} is a matrix domain of square matrices,{} where the number of rows (= number of columns) is a parameter of the type."))
 (|coerce|
  (((|Matrix| |#2|) $)
   "\\spad{coerce(m)} converts a matrix of type \\spadtype{SquareMatrix} to a matrix of type \\spadtype{Matrix}."))
 (|squareMatrix|
  (($ (|Matrix| |#2|))
   "\\spad{squareMatrix(m)} converts a matrix of type \\spadtype{Matrix} to a matrix of type \\spadtype{SquareMatrix}."))
 (|transpose|
  (($ $)
   "\\spad{transpose(m)} returns the transpose of the matrix \\spad{m}."))
 (|unitsKnown|
  ((|attribute|)
   "the invertible matrices are simply the matrices whose determinants are units in the Ring \\spad{R}."))) 
((|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|SemiRing|))
 (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasCategory| |#2| '(|DifferentialRing|))
 (OR (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|DifferentialRing|)) (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|Finite|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeStar|))
       (|HasCategory| |#2| '(|unitsKnown|)))
  (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|EuclideanDomain|))
 (|HasCategory| |#2| '(|IntegralDomain|)) (|HasCategory| |#2| '(|OrderedSet|))
 (|HasCategory| |#2| '(|BasicType|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|))))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Finite|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|Ring|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SemiRing|)))
  (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
       (|HasCategory| |#2| '(|SetCategory|))))
 (|HasCategory| |#2| '(|Field|))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| '(|DifferentialRing|))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
 (OR (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
     (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
          (|HasCategory| |#2| '(|Finite|)))
     (AND
      (|HasCategory| |#2|
                     (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
      (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| '(|AbelianGroup|))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| '(|CommutativeStar|))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| '(|DifferentialRing|))
          (|HasCategory| |#2| '(|Finite|)))
     (AND (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|Ring|)))
     (AND (|HasCategory| |#2| '(|Finite|)) (|HasCategory| |#2| '(|SemiRing|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|StringAggregate&| S) 
((|constructor|
  (NIL
   "A string aggregate is a category for strings,{} that is,{} one dimensional arrays of characters."))
 (|elt|
  (($ $ $)
   "\\spad{elt(s,{} t)} returns the concatenation of \\spad{s} and \\spad{t}. It is provided to allow juxtaposition of strings to work as concatenation. For example,{} \\spad{\"smoo\" \"shed\"} returns \\spad{\"smooshed\"}."))
 (|rightTrim|
  (($ $ (|CharacterClass|))
   "\\spad{rightTrim(s,{} cc)} returns \\spad{s} with all trailing occurrences of characters in \\spad{cc} deleted. For example,{} \\spad{rightTrim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"(abc\"}."))
 (|leftTrim|
  (($ $ (|CharacterClass|))
   "\\spad{leftTrim(s,{} cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example,{} \\spad{leftTrim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"abc)\"}."))
 (|trim|
  (($ $ (|CharacterClass|))
   "\\spad{trim(s,{} cc)} returns \\spad{s} with all characters in \\spad{cc} deleted from right and left ends. For example,{} \\spad{trim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"abc\"}."))
 (|split|
  (((|List| $) $ (|CharacterClass|))
   "\\spad{split(s,{} cc)} returns a list of substrings delimited by characters in \\spad{cc}.")
  (((|List| $) $ (|Character|))
   "\\spad{split(s,{} c)} returns a list of substrings delimited by character \\spad{c}."))
 (|coerce|
  (($ (|Character|))
   "\\spad{coerce(c)} returns \\spad{c} as a string \\spad{s} with the character \\spad{c}."))
 (|position|
  (((|Integer|) (|CharacterClass|) $ (|Integer|))
   "\\spad{position(cc,{} t,{} i)} returns the position \\spad{j} in string \\spad{t} of the first character belonging to \\spad{cc},{} beginning at index \\spad{i}. Returns \\spad{minIndex(t) - 1} if there is no such \\spad{j}.")
  (((|Integer|) $ $ (|Integer|))
   "\\spad{position(s,{} t,{} i)} returns the position \\spad{j} of the substring \\spad{s} in string \\spad{t},{} beginning at index \\spad{i}. Returns \\spad{minIndex(s) - 1} if there is no such \\spad{j}."))
 (|replace|
  (($ $ (|UniversalSegment| (|Integer|)) $)
   "\\spad{replace(s,{} i..j,{} t)} replaces the substring \\spad{s(i..j)} of \\spad{s} by string \\spad{t}."))
 (|match?|
  (((|Boolean|) $ $ (|Character|))
   "\\spad{match?(s,{} t,{} c)} tests if \\spad{s} matches \\spad{t} except perhaps for multiple and consecutive occurrences of character \\spad{c}. Typically \\spad{c} is the blank character."))
 (|substring?|
  (((|Boolean|) $ $ (|Integer|))
   "\\spad{substring?(s,{} t,{} i)} tests if \\spad{s} is a substring of \\spad{t} beginning at index \\spad{i}. Note: \\spad{substring?(s,{} t,{} 0) = prefix?(s,{} t)}."))
 (|suffix?|
  (((|Boolean|) $ $)
   "\\spad{suffix?(s,{} t)} tests if the string \\spad{s} is the final substring of \\spad{t}. Note: \\spad{suffix?(s,{} t) = reduce(and,{} [s.i = t.(n - m + i) for i indices s])} where \\spad{m} and \\spad{n} denote the maxIndex of \\spad{s} and \\spad{t} respectively."))
 (|prefix?|
  (((|Boolean|) $ $)
   "\\spad{prefix?(s,{} t)} tests if the string \\spad{s} is the initial substring of \\spad{t}. Note: \\spad{prefix?(s,{} t) = reduce(and,{} [s.i = t.i for i in indices s])}."))
 (|upperCase!|
  (($ $)
   "\\spad{upperCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by corresponding upper case characters."))
 (|upperCase|
  (($ $)
   "\\spad{upperCase(s)} returns the string with all characters in upper case."))
 (|lowerCase!|
  (($ $)
   "\\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by lower case."))
 (|lowerCase|
  (($ $)
   "\\spad{lowerCase(s)} returns the string with all characters in lower case."))) 
NIL 
(|StringAggregate|) 
((|constructor|
  (NIL
   "A string aggregate is a category for strings,{} that is,{} one dimensional arrays of characters."))
 (|elt|
  (($ $ $)
   "\\spad{elt(s,{} t)} returns the concatenation of \\spad{s} and \\spad{t}. It is provided to allow juxtaposition of strings to work as concatenation. For example,{} \\spad{\"smoo\" \"shed\"} returns \\spad{\"smooshed\"}."))
 (|rightTrim|
  (($ $ (|CharacterClass|))
   "\\spad{rightTrim(s,{} cc)} returns \\spad{s} with all trailing occurrences of characters in \\spad{cc} deleted. For example,{} \\spad{rightTrim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"(abc\"}."))
 (|leftTrim|
  (($ $ (|CharacterClass|))
   "\\spad{leftTrim(s,{} cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example,{} \\spad{leftTrim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"abc)\"}."))
 (|trim|
  (($ $ (|CharacterClass|))
   "\\spad{trim(s,{} cc)} returns \\spad{s} with all characters in \\spad{cc} deleted from right and left ends. For example,{} \\spad{trim(\"(abc)\",{} charClass \"()\")} returns \\spad{\"abc\"}."))
 (|split|
  (((|List| $) $ (|CharacterClass|))
   "\\spad{split(s,{} cc)} returns a list of substrings delimited by characters in \\spad{cc}.")
  (((|List| $) $ (|Character|))
   "\\spad{split(s,{} c)} returns a list of substrings delimited by character \\spad{c}."))
 (|coerce|
  (($ (|Character|))
   "\\spad{coerce(c)} returns \\spad{c} as a string \\spad{s} with the character \\spad{c}."))
 (|position|
  (((|Integer|) (|CharacterClass|) $ (|Integer|))
   "\\spad{position(cc,{} t,{} i)} returns the position \\spad{j} in string \\spad{t} of the first character belonging to \\spad{cc},{} beginning at index \\spad{i}. Returns \\spad{minIndex(t) - 1} if there is no such \\spad{j}.")
  (((|Integer|) $ $ (|Integer|))
   "\\spad{position(s,{} t,{} i)} returns the position \\spad{j} of the substring \\spad{s} in string \\spad{t},{} beginning at index \\spad{i}. Returns \\spad{minIndex(s) - 1} if there is no such \\spad{j}."))
 (|replace|
  (($ $ (|UniversalSegment| (|Integer|)) $)
   "\\spad{replace(s,{} i..j,{} t)} replaces the substring \\spad{s(i..j)} of \\spad{s} by string \\spad{t}."))
 (|match?|
  (((|Boolean|) $ $ (|Character|))
   "\\spad{match?(s,{} t,{} c)} tests if \\spad{s} matches \\spad{t} except perhaps for multiple and consecutive occurrences of character \\spad{c}. Typically \\spad{c} is the blank character."))
 (|substring?|
  (((|Boolean|) $ $ (|Integer|))
   "\\spad{substring?(s,{} t,{} i)} tests if \\spad{s} is a substring of \\spad{t} beginning at index \\spad{i}. Note: \\spad{substring?(s,{} t,{} 0) = prefix?(s,{} t)}."))
 (|suffix?|
  (((|Boolean|) $ $)
   "\\spad{suffix?(s,{} t)} tests if the string \\spad{s} is the final substring of \\spad{t}. Note: \\spad{suffix?(s,{} t) = reduce(and,{} [s.i = t.(n - m + i) for i indices s])} where \\spad{m} and \\spad{n} denote the maxIndex of \\spad{s} and \\spad{t} respectively."))
 (|prefix?|
  (((|Boolean|) $ $)
   "\\spad{prefix?(s,{} t)} tests if the string \\spad{s} is the initial substring of \\spad{t}. Note: \\spad{prefix?(s,{} t) = reduce(and,{} [s.i = t.i for i in indices s])}."))
 (|upperCase!|
  (($ $)
   "\\spad{upperCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by corresponding upper case characters."))
 (|upperCase|
  (($ $)
   "\\spad{upperCase(s)} returns the string with all characters in upper case."))
 (|lowerCase!|
  (($ $)
   "\\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by lower case."))
 (|lowerCase|
  (($ $)
   "\\spad{lowerCase(s)} returns the string with all characters in lower case."))) 
NIL 
(|SquareFreeRegularSetDecompositionPackage| R E V P TS) 
((|constructor|
  (NIL
   "A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are provided: in the sense of Zariski closure (like in Kalkbrener\\spad{'s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard- Moreno methods). This algorithm is valid for nay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \\spad{TS} and the packages \\spad{QCMPPK(R,{} E,{} V,{} P,{} TS)} and \\spad{RSETGCD(R,{} E,{} V,{} P,{} TS)}. The same way it does not care about the way univariate polynomial gcds (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these gcds need to have invertible initials (normalized or not). WARNING. There is no need for a user to call diectly any operation of this package since they can be accessed by the domain \\spadtype{TS}. Thus,{} the operations of this package are not documented.\\newline"))) 
NIL 
(|SquareFreeRegularTriangularSet| R E V P) 
((|constructor|
  (NIL
   "This domain provides an implementation of square-free regular chains. Moreover,{} the operation \\spadopFrom{zeroSetSplit}{SquareFreeRegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\\newline"))
 (|pre_process|
  (((|Record| (|:| |val| (|List| |#4|)) (|:| |towers| (|List| $)))
    (|List| |#4|) (|Boolean|) (|Boolean|))
   "\\spad{pre_process(lp,{} b1,{} b2)} is an internal subroutine,{} exported only for developement."))
 (|internalZeroSetSplit|
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{internalZeroSetSplit(lp,{} b1,{} b2,{} b3)} is an internal subroutine,{} exported only for developement."))
 (|zeroSetSplit|
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} b1,{} b2.b3,{} b4)} is an internal subroutine,{} exported only for developement.")
  (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?,{} info?)} has the same specifications as \\spadopFrom{zeroSetSplit}{RegularTriangularSetCategory} from \\spadtype{RegularTriangularSetCategory} Moreover,{} if \\spad{clos?} then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \\spad{info?} then do print messages during the computations."))
 (|internalAugment|
  (((|List| $) |#4| $ (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)
    (|Boolean|))
   "\\spad{internalAugment(p,{} ts,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for developement."))) 
((AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#4| '(|BasicType|)) (|HasCategory| |#4| '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#3| '(|Finite|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|SemiRing|) 
((|constructor|
  (NIL
   "The category of associative semirings,{} not necessarily commutative,{} with 0 and 1."))) 
NIL 
(|SemiRng|) 
((|constructor|
  (NIL
   "The category of associative semirings,{} not necessarily commutative,{} and not necessarily with a 1."))) 
NIL 
(|SolvableSkewPolynomialCategory| R |Expon|) 
((|constructor|
  (NIL
   "This is the category of polynomials in noncommutative variables over noncommutative rings. We do not assume that variables and elements of the base ring commute. We assume that the polynomial ring is of solvable type,{} so noncommutative version of Buchberger algorithm works."))
 (|monomial|
  (($ |#1| |#2|)
   "\\spad{monomial(r,{} e)} makes a term from a coefficient \\spad{r} and an exponent \\spad{e}."))
 (|reductum|
  (($ $)
   "\\spad{reductum(u)} returns \\spad{u} minus its leading monomial returns zero if handed the zero element."))
 (|degree|
  ((|#2| $)
   "\\spad{degree(p)} returns the maximum of the exponents of the terms of \\spad{p}."))
 (|leadingMonomial|
  (($ $)
   "\\spad{leadingMonomial(p)} returns the monomial of \\spad{p} with the highest degree."))
 (|leadingCoefficient|
  ((|#1| $)
   "\\spad{leadingCoefficient(p)} returns the coefficient of the highest degree term of \\spad{p}."))) 
NIL 
(|Stack| S) 
((|constructor| (NIL "Linked List implementation of a Stack"))
 (|stack|
  (($ (|List| |#1|))
   "\\spad{stack([x,{} y,{} ...,{} z])} creates a stack with first (top) element \\spad{x},{} second element \\spad{y},{} ...,{} and last element \\spad{z}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|StreamAggregate&| A S) 
((|constructor|
  (NIL
   "A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \\spadtype{Stream}. From streams,{} a number of infinite structures such as power series can be built."))
 (|possiblyInfinite?|
  (((|Boolean|) $)
   "\\spad{possiblyInfinite?(s)} tests if the stream \\spad{s} could possibly have an infinite number of elements. Note: for many datatypes,{} \\spad{possiblyInfinite?(s) = not explictlyFinite?(s)}."))
 (|explicitlyFinite?|
  (((|Boolean|) $)
   "\\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements,{} and \\spad{false} otherwise. Note: for many datatypes,{} \\spad{explicitlyFinite?(s) = not possiblyInfinite?(s)}."))) 
NIL 
(|StreamAggregate| S) 
((|constructor|
  (NIL
   "A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \\spadtype{Stream}. From streams,{} a number of infinite structures such as power series can be built."))
 (|possiblyInfinite?|
  (((|Boolean|) $)
   "\\spad{possiblyInfinite?(s)} tests if the stream \\spad{s} could possibly have an infinite number of elements. Note: for many datatypes,{} \\spad{possiblyInfinite?(s) = not explictlyFinite?(s)}."))
 (|explicitlyFinite?|
  (((|Boolean|) $)
   "\\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements,{} and \\spad{false} otherwise. Note: for many datatypes,{} \\spad{explicitlyFinite?(s) = not possiblyInfinite?(s)}."))) 
NIL 
(|SparseTable| |Key| |Ent| |dent|) 
((|constructor|
  (NIL
   "A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|StepThrough|) 
((|constructor|
  (NIL
   "A class of objects which can be 'stepped through'. Repeated applications of \\spadfun{nextItem} is guaranteed never to return duplicate items and only return \"failed\" after exhausting all elements of the domain. This assumes that the sequence starts with \\spad{init()}. For infinite domains,{} repeated application of \\spadfun{nextItem} is not required to reach all possible domain elements starting from any initial element. \\blankline Conditional attributes: \\indented{2}{infinite\\tab{15}repeated \\spad{nextItem}\\spad{'s} are never \"failed\".}"))
 (|nextItem|
  (((|Union| $ "failed") $)
   "\\spad{nextItem(x)} returns the next item,{} or \"failed\" if domain is exhausted."))
 (|init| (($) "\\spad{init()} chooses an initial object for stepping."))) 
NIL 
(|StreamExponentialSeriesOperations| |Coef|) 
((|constructor|
  (NIL
   "StreamExponentialSeriesOperations implements arithmetic of exponential power series,{} where a power series is represented by a stream of its coefficients."))
 (|log1|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{log1(f)} returns the logarithm of the power series represented by cons(1,{} \\spad{f}),{} \\spadignore{i.e.} assuming that the constant term is 1 and therefore transcendentality is not involved."))
 (|exp0|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{exp0(f)} returns the exponential of the power series represented by cons(0,{} \\spad{f}),{} \\spadignore{i.e.} assuming zero constant term and therefore transcendentality is not involved."))
 (|lazyIntegrate|
  (((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|)))
   "\\spad{lazyIntegrate(c,{} f)} integrates with constant term \\spad{c},{} this is simply the right shift"))
 (|integrate|
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{integrate(c,{} f)} integrates with constant term \\spad{c},{} this is simply the right shift"))
 (|deriv|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{deriv(f)} is the derivative,{} which simply coincides with left shift"))
 (*
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a * b} returns the power series (Cauchy) product of \\spad{a} and \\spad{b:} \\spad{[a0,{} a1,{} ...] * [b0,{} b1,{} ...] = [c0,{} c1,{} ...]} where \\spad{ck = sum(i + j = k,{} binomial(k,{} i) * \\spad{ai} * bj)}."))) 
NIL 
(|StreamExponentialSeriesTranscendentalFunctions| |Coef|) 
((|constructor|
  (NIL
   "\\indented{1}{StreamExponentialSeriesTranscendentalFunctions implements} \\indented{1}{exp and log of exponential power series,{}} where a power series is represented by a stream of its coefficients."))) 
NIL 
(|StreamTensor| R) 
((|tensorMap|
  (((|Stream| |#1|) (|Stream| |#1|) (|Mapping| (|List| |#1|) |#1|))
   "\\spad{tensorMap([s1,{} s2,{} ...],{} f)} returns the stream consisting of all elements of \\spad{f}(\\spad{s1}) followed by all elements of \\spad{f}(\\spad{s2}) and so on."))) 
NIL 
(|STransform| PT) 
((|constructor|
  (NIL
   "\\indented{1}{Domains for transform from SPoint to SPoint} STransform transform domain can by used to represent linear transforms for instance when working with SCartesian where its Representation is a matrix of DoubleFloat Other transform domains may not necessarily be linear and will have different representations"))
 (|coerce| (((|OutputForm|) $) "\\spad{coerce(tr)} output"))
 (|compound| (($ $ $) "\\spad{compound(tr,{} inpt)} combine two transforms"))
 (|xform|
  ((|#1| $ |#1|)
   "\\spad{xform(tr,{} inpt)} apply transform to a point producing another point"))
 (|identity|
  (($)
   "\\spad{identity()} returns the identity element which is do nothing transform"))
 (|stranslate|
  (($ (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
    (|DoubleFloat|) (|DoubleFloat|))
   "\\spad{stranslate(offsetx,{} offsety,{} offsetz,{} scalex,{} scaley,{} scalez)} constructs a transform which represents pure translation we can also combine with scale which,{} for instance,{} is useful when writing to \\spad{SVG} file because the \\spad{y} dimension is inverted"))
 (|stransform|
  (($ (|List| (|DoubleFloat|)))
   "\\spad{stransform(m)} construct transform using a multivector")
  (($ (|Mapping| (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))))
   "\\spad{stransform(cpx)} construct transform as function of complex variable can only be used when \\spad{PT} is SArgand so this can be converted to \\spad{PT} \\spad{->} \\spad{PT}")
  (($ (|Mapping| |#1| |#1|))
   "\\spad{stransform(gen)} construct transform in general form as a mapping from \\spad{PT} to \\spad{PT}")
  (($ (|List| (|List| (|DoubleFloat|))))
   "\\spad{stransform(m)} constructs transform with given matrix elements"))) 
NIL 
(|STransformPackage| R UTSR ULSR UPSR) 
((|constructor|
  (NIL
   "A package to compute Taylor and Puiseux series of \\spad{S}-transforms."))
 (|distributionBySTransform|
  (((|Distribution| |#1|) |#4|)
   "\\spad{distributionBySTransform(x)} returns the distribution with \\spad{S}-transform \\spad{x}."))
 (|STransform|
  ((|#4| (|Distribution| |#1|))
   "\\spad{STransform(x)} returns the Puiseux expansion of the \\spad{S}-transform \\spad{S(z)}."))
 (|STransform2|
  ((|#4| (|Distribution| |#1|))
   "\\spad{STransform(x)} returns the Puiseux expansion of the \\spad{S}-transform \\spad{S(z)} if the mean is zero."))
 (|STransform1|
  ((|#2| (|Distribution| |#1|))
   "\\spad{STransform(x)} returns the Taylor expansion of the \\spad{S}-transform \\spad{S(z)} of the distribution \\spad{x} if the mean is nonzero."))) 
NIL 
(|Stream| S) 
((|constructor|
  (NIL
   "A stream is an implementation of a possibly infinite sequence using a list of terms that have been computed and a function closure to compute additional terms when needed."))
 (|filterUntil|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{filterUntil(p,{} s)} returns \\spad{[x0,{} x1,{} ...,{} x(n)]} where \\spad{s = [x0,{} x1,{} x2,{} ..]} and \\spad{n} is the smallest index such that \\spad{p(xn) = true}."))
 (|filterWhile|
  (($ (|Mapping| (|Boolean|) |#1|) $)
   "\\spad{filterWhile(p,{} s)} returns \\spad{[x0,{} x1,{} ...,{} x(n-1)]} where \\spad{s = [x0,{} x1,{} x2,{} ..]} and \\spad{n} is the smallest index such that \\spad{p(xn) = false}."))
 (|stream|
  (($ (|Mapping| |#1| |#1|) |#1|)
   "\\spad{stream(f,{} x)} creates an infinite stream whose first element is \\spad{x} and whose \\spad{n}th element (\\spad{n > 1}) is \\spad{f} applied to the previous element. Note: \\spad{stream(f,{} x) = [x,{} f(x),{} f(f(x)),{} ...]}.")
  (($ (|Mapping| |#1|))
   "\\spad{stream(f)} creates an infinite stream all of whose elements are equal to \\spad{f()}. Note: \\spad{stream(f) = [f(),{} f(),{} f(),{} ...]}."))
 (|setrest!|
  (($ $ (|Integer|) $)
   "\\spad{setrest!(x,{} n,{} y)} sets rest(\\spad{x},{} \\spad{n}) to \\spad{y}. The function will expand cycles if necessary."))
 (|showAll?|
  (((|Boolean|))
   "\\spad{showAll?()} returns \\spad{true} if all computed entries of streams will be displayed."))
 (|showAllElements|
  (((|OutputForm|) $)
   "\\spad{showAllElements(s)} creates an output form which displays all computed elements."))
 (|showElements|
  (((|OutputForm|) (|NonNegativeInteger|) $)
   "\\spad{showElements(n,{} st)} computes and creates and output form of the first \\spad{n} entries of st."))
 (|cons|
  (($ |#1| $)
   "\\spad{cons(a,{} s)} returns a stream whose \\spad{first} is \\spad{a} and whose \\spad{rest} is \\spad{s}. Note: \\spad{cons(a,{} s) = concat(a,{} s)}."))
 (|delay|
  (($ (|Mapping| $))
   "\\spad{delay(f)} creates a stream with a lazy evaluation defined by function \\spad{f}. Caution: This function can only be called in compiled code."))
 (|findCycle|
  (((|Record| (|:| |cycle?| (|Boolean|)) (|:| |prefix| (|NonNegativeInteger|))
              (|:| |period| (|NonNegativeInteger|)))
    (|NonNegativeInteger|) $)
   "\\spad{findCycle(n,{} st)} determines if st is periodic within \\spad{n}."))
 (|repeating?|
  (((|Boolean|) (|List| |#1|) $)
   "\\spad{repeating?(l,{} s)} returns \\spad{true} if a stream \\spad{s} is periodic with period \\spad{l},{} and \\spad{false} otherwise."))
 (|repeating|
  (($ (|List| |#1|))
   "\\spad{repeating(l)} is a repeating stream whose period is the list \\spad{l}."))
 (|coerce|
  (($ (|List| |#1|))
   "\\spad{coerce(l)} converts a list \\spad{l} to a stream."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))) 
(|StreamFunctions1| S) 
((|constructor| (NIL "Functions defined on streams with entries in one set."))
 (|concat|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{concat(u)} returns the left-to-right concatentation of the streams in \\spad{u}. Note: \\spad{concat(u) = reduce(concat,{} u)}."))) 
NIL 
(|StreamFunctions2| A B) 
((|constructor| (NIL "Functions defined on streams with entries in two sets."))
 (|reduce|
  ((|#2| |#2| (|Mapping| |#2| |#1| |#2|) (|Stream| |#1|))
   "\\spad{reduce(b,{} f,{} u)},{} where \\spad{u} is a finite stream \\spad{[x0,{} x1,{} ...,{} xn]},{} returns the value \\spad{r(n)} computed as follows: \\spad{r0 = f(x0,{} b),{} r1 = f(x1,{} r0),{} ...,{} r(n) = f(xn,{} r(n-1))}."))
 (|scan|
  (((|Stream| |#2|) |#2| (|Mapping| |#2| |#1| |#2|) (|Stream| |#1|))
   "\\spad{scan(b,{} h,{} [x0,{} x1,{} x2,{} ...])} returns \\spad{[y0,{} y1,{} y2,{} ...]},{} where \\spad{y0 = h(x0,{} b)},{} \\spad{y1 = h(x1,{} y0)},{} \\spad{...} \\spad{yn = h(xn,{} y(n-1))}."))
 (|map|
  (((|Stream| |#2|) (|Mapping| |#2| |#1|) (|Stream| |#1|))
   "\\spad{map(f,{} s)} returns a stream whose elements are the function \\spad{f} applied to the corresponding elements of \\spad{s}. Note: \\spad{map(f,{} [x0,{} x1,{} x2,{} ...]) = [f(x0),{} f(x1),{} f(x2),{} ..]}."))) 
NIL 
(|StreamFunctions3| A B C) 
((|constructor|
  (NIL "Functions defined on streams with entries in three sets."))
 (|map|
  (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|Stream| |#1|) (|Stream| |#2|))
   "\\spad{map(f,{} st1,{} st2)} returns the stream whose elements are the function \\spad{f} applied to the corresponding elements of \\spad{st1} and \\spad{st2}. Note: \\spad{map(f,{} [x0,{} x1,{} x2,{} ..],{} [y0,{} y1,{} y2,{} ..]) = [f(x0,{} y0),{} f(x1,{} y1),{} ..]}."))) 
NIL 
(|StringCategory|) 
((|constructor| (NIL "A category for string-like objects"))
 (|string|
  (($ (|Integer|))
   "\\spad{string(i)} returns the decimal representation of \\spad{i} as a string."))) 
NIL 
(|String|) 
((|constructor| (NIL "This is the domain of character strings."))
 (|uentries|
  (((|List| (|SingleInteger|)) $)
   "\\spad{uentries(s)} converts \\spad{s} to a list of Unicode code points encoding characters in \\spad{s}. It work even if lower layer does not support Unicode,{} in such case string is treated as sequence of octets using UTF-8 encoding. Consegently length of returened list may be smaller than length of the string in octets."))
 (|ucodeToString|
  (($ (|Integer|))
   "\\spad{ucodeToString(n)} converts Unicode code point to one-character string. If UTF-8 is in use the string may contain multiple octets."))) 
((AND (|HasCategory| (|Character|) (LIST '|Evalable| '(|Character|)))
      (|HasCategory| (|Character|) '(|SetCategory|)))
 (|HasCategory| (|Character|) '(|OrderedSet|))
 (|HasCategory| (|Character|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Character|) '(|BasicType|))
 (|HasCategory| (|Character|) '(|Comparable|))
 (OR (|HasCategory| (|Character|) '(|Comparable|))
     (|HasCategory| (|Character|) '(|OrderedSet|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Character|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Character|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Character|) '(|OrderedSet|))))) 
(|StringTable| |Entry|) 
((|constructor|
  (NIL
   "This domain provides tables where the keys are strings. A specialized hash function for strings is used."))) 
((|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                '(|BasicType|))
 (|HasCategory| (|String|) '(|OrderedSet|))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| '(|String|))
                             (LIST '|:| '|entry| (|devaluate| |#1|)))))
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                    '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|StreamTaylorSeriesOperations| A) 
((|constructor|
  (NIL
   "StreamTaylorSeriesOperations implements Taylor series arithmetic,{} where a Taylor series is represented by a stream of its coefficients."))
 (|power|
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{power(a,{} f)} returns the power series \\spad{f} raised to the power \\spad{a}."))
 (|lazyGintegrate|
  (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1|
    (|Mapping| (|Stream| |#1|)))
   "\\spad{lazyGintegrate(f,{} r,{} g)} is used for fixed point computations."))
 (|mapdiv|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{mapdiv([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \\spad{[a0/b0,{} a1/b1,{} ..]}."))
 (|powern|
  (((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|))
   "\\spad{powern(r,{} f)} raises power series \\spad{f} to the power \\spad{r}."))
 (|nlde|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{nlde(u)} solves a first order non-linear differential equation described by \\spad{u} of the form \\spad{[[b<0,{} 0>,{} b<0,{} 1>,{} ...],{} [b<1,{} 0>,{} b<1,{} 1>,{} .],{} ...]}. the differential equation has the form \\spad{y' = sum(i=0 to infinity,{} j=0 to infinity,{} b<i,{} j>*(x^i)*(y^j))}."))
 (|lazyIntegrate|
  (((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|)))
   "\\spad{lazyIntegrate(r,{} f)} is a version of integrate used for fixed point computations."))
 (|integrate|
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{integrate(r,{} a)} returns the integral of the power series \\spad{a} with respect to the power series variable where \\spad{r} denotes the constant of integration. Thus \\spad{integrate(a,{} [a0,{} a1,{} a2,{} ...]) = [a,{} a0,{} a1/2,{} a2/3,{} ...]}."))
 (|invmultisect|
  (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|))
   "\\spad{invmultisect(a,{} b,{} st)} substitutes \\spad{x^((a+b)*n)} for \\spad{x^n} and multiplies by \\spad{x^b}."))
 (|multisect|
  (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|))
   "\\spad{multisect(a,{} b,{} st)} selects the coefficients of \\spad{x^((a+b)*n+a)},{} and changes them to \\spad{x^n}."))
 (|general_Lambert_product|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|))
   "\\spad{general_Lambert_product(f(x),{} a,{} d)} returns \\spad{f(x^a)*f(x^(a + d))*f(x^(a + 2 d))* ...}. \\spad{f(x)} should have constant coefficient equal to one and \\spad{a} and \\spad{d} should be positive."))
 (|generalLambert|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|))
   "\\spad{generalLambert(f(x),{} a,{} d)} returns \\spad{f(x^a) + f(x^(a + d)) + f(x^(a + 2 d)) + ...}. \\spad{f(x)} should have zero constant coefficient and \\spad{a} and \\spad{d} should be positive."))
 (|evenlambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{evenlambert(st)} computes \\spad{f(x^2) + f(x^4) + f(x^6) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1,{} then \\spad{prod(f(x^(2*n)),{} n=1..infinity) = exp(evenlambert(log(f(x))))}."))
 (|oddlambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{oddlambert(st)} computes \\spad{f(x) + f(x^3) + f(x^5) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f}(\\spad{x}) is a power series with constant coefficient 1 then \\spad{prod(f(x^(2*n-1)),{} n=1..infinity) = exp(oddlambert(log(f(x))))}."))
 (|lambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{lambert(st)} computes \\spad{f(x) + f(x^2) + f(x^3) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1 then \\spad{prod(f(x^n),{} n = 1..infinity) = exp(lambert(log(f(x))))}."))
 (|prodiag|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{prodiag(x)} performs \"diagonal\" infinite product of a stream of streams. When \\spad{x(i)} is interpreted as stream of coefficients of series \\spad{f_i(z),{} i=1,{}...},{} then \\spad{prodiag(x) = (1 + z*f_1(z))*(1 + z^2*f_2(x))*...}"))
 (|addiag|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{addiag(x)} performs diagonal addition of a stream of streams. if \\spad{x} = \\spad{[[a<0,{} 0>,{} a<0,{} 1>,{} ..],{} [a<1,{} 0>,{} a<1,{} 1>,{} ..],{} [a<2,{} 0>,{} a<2,{} 1>,{} ..],{} ..]} and \\spad{addiag(x) = [b<0,{} b<1>,{} ...],{} then b<k> = sum(i+j=k,{} a<i,{} j>)}."))
 (|revert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{revert(a)} computes the inverse of a power series \\spad{a} with respect to composition. the series should have constant coefficient 0 and invertible first order coefficient."))
 (|lagrange|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{lagrange(g)} produces the power series for \\spad{f} where \\spad{f} is implicitly defined as \\spad{f(z) = z*g(f(z))}."))
 (|compose|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{compose(a,{} b)} composes the power series \\spad{a} with the power series \\spad{b}."))
 (|eval|
  (((|Stream| |#1|) (|Stream| |#1|) |#1|)
   "\\spad{eval(a,{} r)} returns a stream of partial sums of the power series \\spad{a} evaluated at the power series variable equal to \\spad{r}."))
 (|coerce|
  (((|Stream| |#1|) |#1|)
   "\\spad{coerce(r)} converts a ring element \\spad{r} to a stream with one element."))
 (|gderiv|
  (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|))
   "\\spad{gderiv(f,{} [a0,{} a1,{} a2,{} ..])} returns \\spad{[f(0)*a0,{} f(1)*a1,{} f(2)*a2,{} ..]}."))
 (|deriv|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{deriv(a)} returns the derivative of the power series with respect to the power series variable. Thus \\spad{deriv([a0,{} a1,{} a2,{} ...])} returns \\spad{[a1,{} 2 a2,{} 3 a3,{} ...]}."))
 (|mapmult|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{mapmult([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \\spad{[a0*b0,{} a1*b1,{} ..]}."))
 (|int|
  (((|Stream| |#1|) |#1|)
   "\\spad{int(r)} returns [\\spad{r},{} \\spad{r+1},{} \\spad{r+2},{} ...],{} where \\spad{r} is a ring element."))
 (|oddintegers|
  (((|Stream| (|Integer|)) (|Integer|))
   "\\spad{oddintegers(n)} returns \\spad{[n,{} n+2,{} n+4,{} ...]}."))
 (|integers|
  (((|Stream| (|Integer|)) (|Integer|))
   "\\spad{integers(n)} returns \\spad{[n,{} n+1,{} n+2,{} ...]}."))
 (|monom|
  (((|Stream| |#1|) |#1| (|Integer|))
   "\\spad{monom(deg,{} coef)} is a monomial of degree \\spad{deg} with coefficient coef."))
 (|recip|
  (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|))
   "\\spad{recip(a)} returns the power series reciprocal of \\spad{a},{} or \"failed\" if not possible."))
 (/
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a / b} returns the power series quotient of \\spad{a} by \\spad{b}. An error message is returned if \\spad{b} is not invertible. This function is used in fixed point computations."))
 (|exquo|
  (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{exquo(a,{} b)} returns the power series quotient of \\spad{a} by \\spad{b},{} if the quotient exists,{} and \"failed\" otherwise"))
 (*
  (((|Stream| |#1|) (|Stream| |#1|) |#1|)
   "\\spad{a * r} returns the power series scalar multiplication of \\spad{a} by \\spad{r:} \\spad{[a0,{} a1,{} ...] * r = [a0 * r,{} a1 * r,{} ...]}")
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{r * a} returns the power series scalar multiplication of \\spad{r} by \\spad{a}: \\spad{r * [a0,{} a1,{} ...] = [r * a0,{} r * a1,{} ...]}")
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a * b} returns the power series (Cauchy) product of \\spad{a} and \\spad{b:} \\spad{[a0,{} a1,{} ...] * [b0,{} b1,{} ...] = [c0,{} c1,{} ...]} where \\spad{ck = sum(i + j = k,{} \\spad{ai} * bk)}."))
 (-
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{- a} returns the power series negative of \\spad{a}: \\spad{- [a0,{} a1,{} ...] = [- a0,{} - a1,{} ...]}")
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a - b} returns the power series difference of \\spad{a} and \\spad{b}: \\spad{[a0,{} a1,{} ..] - [b0,{} b1,{} ..] = [a0 - b0,{} a1 - b1,{} ..]}"))
 (+
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a + b} returns the power series sum of \\spad{a} and \\spad{b}: \\spad{[a0,{} a1,{} ..] + [b0,{} b1,{} ..] = [a0 + b0,{} a1 + b1,{} ..]}"))) 
((|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))) 
(|StreamTranscendentalFunctions| |Coef|) 
((|constructor|
  (NIL
   "StreamTranscendentalFunctions implements transcendental functions on Taylor series,{} where a Taylor series is represented by a stream of its coefficients."))
 (|acsch|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \\spad{st}."))
 (|asech|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asech(st)} computes the inverse hyperbolic secant of a power series \\spad{st}."))
 (|acoth|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \\spad{st}."))
 (|atanh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \\spad{st}."))
 (|acosh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \\spad{st}."))
 (|asinh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \\spad{st}."))
 (|csch|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{csch(st)} computes the hyperbolic cosecant of a power series \\spad{st}."))
 (|sech|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sech(st)} computes the hyperbolic secant of a power series \\spad{st}."))
 (|coth|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{coth(st)} computes the hyperbolic cotangent of a power series \\spad{st}."))
 (|tanh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{tanh(st)} computes the hyperbolic tangent of a power series \\spad{st}."))
 (|cosh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cosh(st)} computes the hyperbolic cosine of a power series \\spad{st}."))
 (|sinh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sinh(st)} computes the hyperbolic sine of a power series \\spad{st}."))
 (|sinhcosh|
  (((|Record| (|:| |sinh| (|Stream| |#1|)) (|:| |cosh| (|Stream| |#1|)))
    (|Stream| |#1|))
   "\\spad{sinhcosh(st)} returns a record containing the hyperbolic sine and cosine of a power series \\spad{st}."))
 (|acsc|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acsc(st)} computes arccosecant of a power series \\spad{st}."))
 (|asec|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asec(st)} computes arcsecant of a power series \\spad{st}."))
 (|acot|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acot(st)} computes arccotangent of a power series \\spad{st}."))
 (|atan|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{atan(st)} computes arctangent of a power series \\spad{st}."))
 (|acos|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acos(st)} computes arccosine of a power series \\spad{st}."))
 (|asin|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asin(st)} computes arcsine of a power series \\spad{st}."))
 (|csc|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{csc(st)} computes cosecant of a power series \\spad{st}."))
 (|sec|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sec(st)} computes secant of a power series \\spad{st}."))
 (|cot|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cot(st)} computes cotangent of a power series \\spad{st}."))
 (|tan|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{tan(st)} computes tangent of a power series \\spad{st}."))
 (|cos|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cos(st)} computes cosine of a power series \\spad{st}."))
 (|sin|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sin(st)} computes sine of a power series \\spad{st}."))
 (|sincos|
  (((|Record| (|:| |sin| (|Stream| |#1|)) (|:| |cos| (|Stream| |#1|)))
    (|Stream| |#1|))
   "\\spad{sincos(st)} returns a record containing the sine and cosine of a power series \\spad{st}."))
 (^
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{st1 ^ st2} computes the power of a power series \\spad{st1} by another power series \\spad{st2}."))
 (|log|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{log(st)} computes the log of a power series."))
 (|exp|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{exp(st)} computes the exponential of a power series \\spad{st}."))) 
NIL 
(|StreamTranscendentalFunctionsNonCommutative| |Coef|) 
((|constructor|
  (NIL
   "StreamTranscendentalFunctionsNonCommutative implements transcendental functions on Taylor series over a non-commutative ring,{} where a Taylor series is represented by a stream of its coefficients."))
 (|acsch|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \\spad{st}."))
 (|asech|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asech(st)} computes the inverse hyperbolic secant of a power series \\spad{st}."))
 (|acoth|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \\spad{st}."))
 (|atanh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \\spad{st}."))
 (|acosh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \\spad{st}."))
 (|asinh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \\spad{st}."))
 (|csch|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{csch(st)} computes the hyperbolic cosecant of a power series \\spad{st}."))
 (|sech|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sech(st)} computes the hyperbolic secant of a power series \\spad{st}."))
 (|coth|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{coth(st)} computes the hyperbolic cotangent of a power series \\spad{st}."))
 (|tanh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{tanh(st)} computes the hyperbolic tangent of a power series \\spad{st}."))
 (|cosh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cosh(st)} computes the hyperbolic cosine of a power series \\spad{st}."))
 (|sinh|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sinh(st)} computes the hyperbolic sine of a power series \\spad{st}."))
 (|acsc|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acsc(st)} computes arccosecant of a power series \\spad{st}."))
 (|asec|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asec(st)} computes arcsecant of a power series \\spad{st}."))
 (|acot|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acot(st)} computes arccotangent of a power series \\spad{st}."))
 (|atan|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{atan(st)} computes arctangent of a power series \\spad{st}."))
 (|acos|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{acos(st)} computes arccosine of a power series \\spad{st}."))
 (|asin|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{asin(st)} computes arcsine of a power series \\spad{st}."))
 (|csc|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{csc(st)} computes cosecant of a power series \\spad{st}."))
 (|sec|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sec(st)} computes secant of a power series \\spad{st}."))
 (|cot|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cot(st)} computes cotangent of a power series \\spad{st}."))
 (|tan|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{tan(st)} computes tangent of a power series \\spad{st}."))
 (|cos|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{cos(st)} computes cosine of a power series \\spad{st}."))
 (|sin|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{sin(st)} computes sine of a power series \\spad{st}."))
 (^
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{st1 ^ st2} computes the power of a power series \\spad{st1} by another power series \\spad{st2}."))
 (|log|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{log(st)} computes the log of a power series."))
 (|exp|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{exp(st)} computes the exponential of a power series \\spad{st}."))) 
NIL 
(|SubResultantPackage| R UP) 
((|constructor|
  (NIL
   "This package computes the subresultants of two polynomials which is needed for the `Lazard Rioboo' enhancement to Tragers integrations formula. For efficiency reasons this has been rewritten to call Lionel Ducos package which is currently the best one. \\blankline"))
 (|primitivePart|
  ((|#2| |#2| |#1|)
   "\\spad{primitivePart(p,{} q)} reduces the coefficient of \\spad{p} modulo \\spad{q},{} takes the primitive part of the result,{} and ensures that the leading coefficient of that result is monic."))
 (|subresultantVector|
  (((|PrimitiveArray| |#2|) |#2| |#2|)
   "\\spad{subresultantVector(p,{} q)} returns \\spad{[p0,{} ...,{} pn]} where \\spad{pi} is the \\spad{i}-th subresultant of \\spad{p} and \\spad{q}. In particular,{} \\spad{p0 = resultant(p,{} q)}."))) 
((|HasCategory| |#1| '(|EuclideanDomain|))) 
(|SubSpace| |n| R) 
((|constructor| (NIL "This domain \\undocumented"))
 (|pointData|
  (((|List| (|Point| |#2|)) $)
   "\\spad{pointData(s)} returns the list of points from the point data field of the 3 dimensional subspace \\spad{s}."))
 (|parent|
  (($ $)
   "\\spad{parent(s)} returns the subspace which is the parent of the indicated 3 dimensional subspace \\spad{s}. If \\spad{s} is the top level subspace an error message is returned."))
 (|level|
  (((|NonNegativeInteger|) $)
   "\\spad{level(s)} returns a non negative integer which is the current level field of the indicated 3 dimensional subspace \\spad{s}."))
 (|extractProperty|
  (((|SubSpaceComponentProperty|) $)
   "\\spad{extractProperty(s)} returns the property of domain \\spadtype{SubSpaceComponentProperty} of the indicated 3 dimensional subspace \\spad{s}."))
 (|extractClosed|
  (((|Boolean|) $)
   "\\spad{extractClosed(s)} returns the \\spadtype{Boolean} value of the closed property for the indicated 3 dimensional subspace \\spad{s}. If the property is closed,{} \\spad{True} is returned,{} otherwise \\spad{False} is returned."))
 (|extractIndex|
  (((|NonNegativeInteger|) $)
   "\\spad{extractIndex(s)} returns a non negative integer which is the current index of the 3 dimensional subspace \\spad{s}."))
 (|extractPoint|
  (((|Point| |#2|) $)
   "\\spad{extractPoint(s)} returns the point which is given by the current index location into the point data field of the 3 dimensional subspace \\spad{s}."))
 (|traverse|
  (($ $ (|List| (|NonNegativeInteger|)))
   "\\spad{traverse(s,{} \\spad{li})} follows the branch list of the 3 dimensional subspace,{} \\spad{s},{} along the path dictated by the list of non negative integers,{} \\spad{li},{} which points to the component which has been traversed to. The subspace,{} \\spad{s},{} is returned,{} where \\spad{s} is now the subspace pointed to by \\spad{li}."))
 (|defineProperty|
  (($ $ (|List| (|NonNegativeInteger|)) (|SubSpaceComponentProperty|))
   "\\spad{defineProperty(s,{} \\spad{li},{} p)} defines the component property in the 3 dimensional subspace,{} \\spad{s},{} to be that of \\spad{p},{} where \\spad{p} is of the domain \\spadtype{SubSpaceComponentProperty}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose property is being defined. The subspace,{} \\spad{s},{} is returned with the component property definition."))
 (|closeComponent|
  (($ $ (|List| (|NonNegativeInteger|)) (|Boolean|))
   "\\spad{closeComponent(s,{} \\spad{li},{} b)} sets the property of the component in the 3 dimensional subspace,{} \\spad{s},{} to be closed if \\spad{b} is \\spad{true},{} or open if \\spad{b} is \\spad{false}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose closed property is to be set. The subspace,{} \\spad{s},{} is returned with the component property modification."))
 (|modifyPoint|
  (($ $ (|NonNegativeInteger|) (|Point| |#2|))
   "\\spad{modifyPoint(s,{} ind,{} p)} modifies the point referenced by the index location,{} \\spad{ind},{} by replacing it with the point,{} \\spad{p} in the 3 dimensional subspace,{} \\spad{s}. An error message occurs if \\spad{s} is empty,{} otherwise the subspace \\spad{s} is returned with the point modification.")
  (($ $ (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{modifyPoint(s,{} \\spad{li},{} i)} replaces an existing point in the 3 dimensional subspace,{} \\spad{s},{} with the 4 dimensional point indicated by the index location,{} \\spad{i}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \\spad{s} is empty,{} otherwise the subspace \\spad{s} is returned with the point modification.")
  (($ $ (|List| (|NonNegativeInteger|)) (|Point| |#2|))
   "\\spad{modifyPoint(s,{} \\spad{li},{} p)} replaces an existing point in the 3 dimensional subspace,{} \\spad{s},{} with the 4 dimensional point,{} \\spad{p}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \\spad{s} is empty,{} otherwise the subspace \\spad{s} is returned with the point modification."))
 (|addPointLast|
  (($ $ $ (|Point| |#2|) (|NonNegativeInteger|))
   "\\spad{addPointLast(s,{} s2,{} \\spad{li},{} p)} adds the 4 dimensional point,{} \\spad{p},{} to the 3 dimensional subspace,{} \\spad{s}. \\spad{s2} point to the end of the subspace \\spad{s}. \\spad{n} is the path in the \\spad{s2} component. The subspace \\spad{s} is returned with the additional point."))
 (|addPoint2|
  (($ $ (|Point| |#2|))
   "\\spad{addPoint2(s,{} p)} adds the 4 dimensional point,{} \\spad{p},{} to the 3 dimensional subspace,{} \\spad{s}. The subspace \\spad{s} is returned with the additional point."))
 (|addPoint|
  (((|NonNegativeInteger|) $ (|Point| |#2|))
   "\\spad{addPoint(s,{} p)} adds the point,{} \\spad{p},{} to the 3 dimensional subspace,{} \\spad{s},{} and returns the new total number of points in \\spad{s}.")
  (($ $ (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{addPoint(s,{} \\spad{li},{} i)} adds the 4 dimensional point indicated by the index location,{} \\spad{i},{} to the 3 dimensional subspace,{} \\spad{s}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\\spad{'s} length should range from 0 to \\spad{n - 1} where \\spad{n} is the dimension of the subspace. If the length is \\spad{n - 1},{} then a specific lowest level component is being referenced. If it is less than \\spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \\spad{s} is returned with the additional point.")
  (($ $ (|List| (|NonNegativeInteger|)) (|Point| |#2|))
   "\\spad{addPoint(s,{} \\spad{li},{} p)} adds the 4 dimensional point,{} \\spad{p},{} to the 3 dimensional subspace,{} \\spad{s}. The list of non negative integers,{} \\spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\\spad{'s} length should range from 0 to \\spad{n - 1} where \\spad{n} is the dimension of the subspace. If the length is \\spad{n - 1},{} then a specific lowest level component is being referenced. If it is less than \\spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \\spad{s} is returned with the additional point."))
 (|separate|
  (((|List| $) $)
   "\\spad{separate(s)} makes each of the components of the \\spadtype{SubSpace},{} \\spad{s},{} into a list of separate and distinct subspaces and returns the list."))
 (|merge|
  (($ (|List| $))
   "\\spad{merge(ls)} a list of subspaces,{} \\spad{ls},{} into one subspace.")
  (($ $ $)
   "\\spad{merge(s1,{} s2)} the subspaces \\spad{s1} and \\spad{s2} into a single subspace."))
 (|deepCopy| (($ $) "\\spad{deepCopy(x)} \\undocumented"))
 (|shallowCopy| (($ $) "\\spad{shallowCopy(x)} \\undocumented"))
 (|numberOfChildren|
  (((|NonNegativeInteger|) $) "\\spad{numberOfChildren(x)} \\undocumented"))
 (|children| (((|List| $) $) "\\spad{children(x)} \\undocumented"))
 (|child|
  (($ $ (|NonNegativeInteger|)) "\\spad{child(x,{} n)} \\undocumented"))
 (|birth| (($ $) "\\spad{birth(x)} \\undocumented"))
 (|subspace| (($) "\\spad{subspace()} \\undocumented"))
 (|new| (($) "\\spad{new()} \\undocumented"))
 (|internal?| (((|Boolean|) $) "\\spad{internal?(x)} \\undocumented"))
 (|root?| (((|Boolean|) $) "\\spad{root?(x)} \\undocumented"))
 (|leaf?| (((|Boolean|) $) "\\spad{leaf?(x)} \\undocumented"))) 
NIL 
(|SuchThat| S1 S2) 
((|constructor| (NIL "This domain implements \"such that\" forms"))
 (|rhs| ((|#2| $) "\\spad{rhs(f)} returns the right side of \\spad{f}"))
 (|lhs| ((|#1| $) "\\spad{lhs(f)} returns the left side of \\spad{f}"))
 (|construct|
  (($ |#1| |#2|)
   "\\spad{construct(s,{} t)} makes a form \\spad{s:} \\spad{t}"))) 
NIL 
(|SparseUnivariateLaurentSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Sparse Laurent series in one variable \\indented{2}{\\spadtype{SparseUnivariateLaurentSeries} is a domain representing Laurent} \\indented{2}{series in one variable with coefficients in an arbitrary ring.\\space{2}The} \\indented{2}{parameters of the type specify the coefficient ring,{} the power series} \\indented{2}{variable,{} and the center of the power series expansion.\\space{2}For example,{}} \\indented{2}{\\spad{SparseUnivariateLaurentSeries(Integer,{} x,{} 3)} represents Laurent} \\indented{2}{series in \\spad{(x - 3)} with integer coefficients.}"))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a Laurent series."))) 
((|HasCategory| (|Integer|) '(|SemiGroup|)) (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|RetractableTo| '(|Symbol|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|RealConstant|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|OrderedIntegralDomain|)))
 (OR (|HasCategory| |#1| '(|CharacteristicZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicZero|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedIntegralDomain|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|RetractableTo| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|StepThrough|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|InnerEvalable| '(|Symbol|)
                           (LIST '|SparseUnivariateTaylorSeries|
                                 (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|Evalable|
                           (LIST '|SparseUnivariateTaylorSeries|
                                 (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|Eltable|
                           (LIST '|SparseUnivariateTaylorSeries|
                                 (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#3|))
                           (LIST '|SparseUnivariateTaylorSeries|
                                 (|devaluate| |#1|) (|devaluate| |#2|)
                                 (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|LinearlyExplicitOver| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|Integer|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|Integer|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|Comparable|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedIntegralDomain|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedIntegralDomain|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedSet|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|PolynomialFactorizationExplicit|)))
 (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                '(|CharacteristicNonZero|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicNonZero|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|IntegerNumberSystem|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|EuclideanDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|Integer|)
                             (|devaluate| |#1|))))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasSignature| |#1|
                       (LIST '*
                             (LIST (|devaluate| |#1|) '(|Integer|)
                                   (|devaluate| |#1|)))))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      (LIST '|PartialDifferentialRing| '(|Symbol|)))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|DifferentialRing|)))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo|
                               (LIST '|Pattern| '(|Integer|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo| '(|InputForm|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|Eltable|
                               (LIST '|SparseUnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|))
                               (LIST '|SparseUnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|Evalable|
                               (LIST '|SparseUnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|InnerEvalable| '(|Symbol|)
                               (LIST '|SparseUnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|LinearlyExplicitOver| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|PatternMatchable| '(|Float|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|PatternMatchable| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|RetractableTo| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|RetractableTo| '(|Symbol|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedIntegralDomain|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|PolynomialFactorizationExplicit|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|RealConstant|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|StepThrough|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| $ '(|CharacteristicNonZero|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|PolynomialFactorizationExplicit|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))) 
(|FunctionSpaceSum| R F) 
((|constructor| (NIL "computes sums of top-level expressions."))
 (|sum|
  ((|#2| |#2| (|SegmentBinding| |#2|))
   "\\spad{sum(f(n),{} n = a..b)} returns \\spad{f}(a) + \\spad{f}(\\spad{a+1}) + ... + \\spad{f}(\\spad{b}).")
  ((|#2| |#2| (|Symbol|))
   "\\spad{sum(a(n),{} n)} returns A(\\spad{n}) such that A(\\spad{n+1}) - A(\\spad{n}) = a(\\spad{n})."))) 
NIL 
(|RationalFunctionSum| R) 
((|constructor| (NIL "Computes sums of rational functions."))
 (|sum|
  (((|Union| (|Fraction| (|Polynomial| |#1|)) (|Expression| |#1|))
    (|Fraction| (|Polynomial| |#1|))
    (|SegmentBinding| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{sum(f(n),{} n = a..b)} returns \\spad{f(a) + f(a+1) + ... f(b)}.")
  (((|Fraction| (|Polynomial| |#1|)) (|Polynomial| |#1|)
    (|SegmentBinding| (|Polynomial| |#1|)))
   "\\spad{sum(f(n),{} n = a..b)} returns \\spad{f(a) + f(a+1) + ... f(b)}.")
  (((|Union| (|Fraction| (|Polynomial| |#1|)) (|Expression| |#1|))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{sum(a(n),{} n)} returns \\spad{A} which is the indefinite sum of \\spad{a} with respect to upward difference on \\spad{n},{} \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}.")
  (((|Fraction| (|Polynomial| |#1|)) (|Polynomial| |#1|) (|Symbol|))
   "\\spad{sum(a(n),{} n)} returns \\spad{A} which is the indefinite sum of \\spad{a} with respect to upward difference on \\spad{n},{} \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}."))) 
NIL 
(|SparseUnivariatePolynomial| R) 
((|constructor|
  (NIL
   "This domain represents univariate polynomials over arbitrary (not necessarily commutative) coefficient rings. The variable is unspecified so that the variable displays as \\spad{?} in output. If it is necessary to specify the variable name,{} use type \\spadtype{UnivariatePolynomial}. The representation is sparse in the sense that only non-zero terms are represented."))
 (|outputForm|
  (((|OutputForm|) $ (|OutputForm|))
   "\\spad{outputForm(p,{} var)} converts the SparseUnivariatePolynomial \\spad{p} to an output form (see \\spadtype{OutputForm}) printed as a polynomial in the output form \\spad{var}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|)) (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#1| '(|SemiRing|)) (|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| '(|AbelianGroup|)) (|HasCategory| |#1| '(|EntireRing|))
 (|HasCategory| |#1| '(|GcdDomain|))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|GcdDomain|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|StepThrough|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|GcdDomain|))
     (|HasCategory| |#1| '(|IntegralDomain|))
     (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|)))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#1| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#1| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#1| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#1| '(|Ring|))
  (|HasCategory| (|SingletonAsOrderedSet|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#1|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#1| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#1| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|GcdDomain|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|SparseUnivariatePolynomialFunctions2| R S) 
((|constructor|
  (NIL
   "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from sparse univariate polynomial over \\spad{R} to a sparse univariate polynomial over \\spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial."))
 (|map|
  (((|SparseUnivariatePolynomial| |#2|) (|Mapping| |#2| |#1|)
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{map(func,{} poly)} creates a new polynomial by applying \\spad{func} to every non-zero coefficient of the polynomial poly."))) 
NIL 
(|SparseUnivariatePuiseuxSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Sparse Puiseux series in one variable \\indented{2}{\\spadtype{SparseUnivariatePuiseuxSeries} is a domain representing Puiseux} \\indented{2}{series in one variable with coefficients in an arbitrary ring.\\space{2}The} \\indented{2}{parameters of the type specify the coefficient ring,{} the power series} \\indented{2}{variable,{} and the center of the power series expansion.\\space{2}For example,{}} \\indented{2}{\\spad{SparseUnivariatePuiseuxSeries(Integer,{} x,{} 3)} represents Puiseux} \\indented{2}{series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients.}"))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (LIST '|Fraction| '(|Integer|))
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|)
                                  (LIST '|Fraction| '(|Integer|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Fraction| (|Integer|)) '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (LIST '|Fraction| '(|Integer|)))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|)))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))) 
(|SparseUnivariateTaylorSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Sparse Taylor series in one variable \\indented{2}{\\spadtype{SparseUnivariateTaylorSeries} is a domain representing Taylor} \\indented{2}{series in one variable with coefficients in an arbitrary ring.\\space{2}The} \\indented{2}{parameters of the type specify the coefficient ring,{} the power series} \\indented{2}{variable,{} and the center of the power series expansion.\\space{2}For example,{}} \\indented{2}{\\spadtype{SparseUnivariateTaylorSeries}(Integer,{} \\spad{x},{} 3) represents Taylor} \\indented{2}{series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients.}"))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x),{} x)} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} computes the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|univariatePolynomial|
  (((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))
   "\\spad{univariatePolynomial(f,{} k)} returns a univariate polynomial \\indented{1}{consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}.}"))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a \\indented{1}{Taylor series.}")
  (($ (|UnivariatePolynomial| |#2| |#1|))
   "\\spad{coerce(p)} converts a univariate polynomial \\spad{p} in the variable \\spad{var} to a univariate Taylor series in \\spad{var}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|NonNegativeInteger|) '(|SemiGroup|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|NonNegativeInteger|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|NonNegativeInteger|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))) 
(|Switch|) 
((|constructor|
  (NIL
   "This domain builds representations of boolean expressions for use with the \\spadtype{FortranCode} domain."))
 (NOT
  (($ $)
   "\\spad{NOT(x)} returns the \\spadtype{Switch} expression representing \\spad{\\~~x}.")
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{NOT(x)} returns the \\spadtype{Switch} expression representing \\spad{\\~~x}."))
 (AND
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{AND(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x and y}."))
 (EQ
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{EQ(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x = y}."))
 (OR
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{OR(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x or y}."))
 (GE
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{GE(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x>=y}."))
 (LE
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{LE(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x<=y}."))
 (GT
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{GT(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x>y}."))
 (LT
  (($
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))
    (|Union| (|:| I (|Expression| (|Integer|)))
             (|:| F (|Expression| (|Float|)))
             (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)))
   "\\spad{LT(x,{} y)} returns the \\spadtype{Switch} expression representing \\spad{x<y}."))
 (|coerce| (($ (|Symbol|)) "\\spad{coerce(s)} \\undocumented{}"))) 
NIL 
(|SymmetryAnalysis| JB1 |xi| |eta|) 
((|constructor|
  (NIL
   "\\spad{SymmetryAnalysis(JB,{} \\spad{xi},{} eta)} provides procedures for the symmetry analysis of differential equations over a given jet bundle. Currently there exist only some procedures to set up the determining system for the symmetry generators of Lie point symmetries."))
 (|detSysNS|
  (((|List| (|JetBundleExpression| |#1|)) (|List| (|JetBundleExpression| |#1|))
    (|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{detSysNS(sys,{} vf)} computes the determining system for symmetry generators without assuming solvability of the equations for some derivatives.")
  (((|List| (|JetBundleExpression| (|JetBundleSymAna| |#1| |#2| |#3|)))
    (|List| (|JetBundleExpression| |#1|)))
   "\\spad{detSysNS(sys,{} vf)} computes the determining system for symmetry generators without assuming solvability of the equations for some derivatives."))
 (|ncDetSys|
  (((|List| (|JetBundleExpression| |#1|)) (|List| (|JetBundleExpression| |#1|))
    (|List| |#1|) (|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{ncDetSys(sys,{} sjb,{} vf)} computes the determining system for generators of conditional symmetries of \\spad{sys}. The meaning of the further arguments is the same as in \\spad{detSys}.")
  (((|List| (|JetBundleExpression| |#1|)) (|List| (|JetBundleExpression| |#1|))
    (|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{ncDetSys(sys,{} vf)} computes the determining system for generators of conditional symmetries of \\spad{sys} with a given ansatz for the vector fields.")
  (((|List| (|JetBundleExpression| (|JetBundleSymAna| |#1| |#2| |#3|)))
    (|List| (|JetBundleExpression| |#1|)))
   "\\spad{ncDetSys(sys)} computes the determining system for generators of conditional symmetries of \\spad{sys}. It makes the same assumptions as \\spad{detSys}."))
 (|detSys|
  (((|List| (|JetBundleExpression| |#1|)) (|List| (|JetBundleExpression| |#1|))
    (|List| |#1|) (|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{detSys(sys,{} sjb,{} vf)} computes the determining system for symmetry generators of the system \\spad{sys} with a given ansatz for the generators. \\spad{sjb} contains jet variables for which the individual equations can be solved.")
  (((|List| (|JetBundleExpression| |#1|)) (|List| (|JetBundleExpression| |#1|))
    (|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{detSys(sys,{} vf)} computes the determining system for symmetry generators of the system \\spad{sys} with a given ansatz for the generators. It is assumed that each equation can be solved for its leading derivative.")
  (((|List| (|JetBundleExpression| (|JetBundleSymAna| |#1| |#2| |#3|)))
    (|List| (|JetBundleExpression| |#1|)))
   "\\spad{detSys(sys)} computes the determining system for symmetry generators of the system \\spad{sys}. It is assumed that each equation can be solved for its leading derivative."))
 (|linearize|
  (((|List|
     (|JetBundleLinearFunction| (|JetBundleSymAna| |#1| |#2| |#3|)
                                (|JetBundleXExpression|
                                 (|JetBundleSymAna| |#1| |#2| |#3|))))
    (|List| (|JetBundleExpression| (|JetBundleSymAna| |#1| |#2| |#3|))))
   "\\spad{linearize(sys)} tries to retract all equations in \\spad{sys} to a linear one. If that is not possible,{} an error occurs."))
 (|transform|
  (((|JetBundleExpression| (|JetBundleSymAna| |#1| |#2| |#3|))
    (|JetBundleExpression| |#1|))
   "\\spad{transform(f)} transforms expressions between the different function types involved."))
 (|ansatz|
  (((|JetVectorField| |#1| (|JetBundleExpression| |#1|)))
   "\\spad{ansatz()} returns a general ansatz for a symmetry generator."))) 
NIL 
(|Symbol|) 
((|constructor| (NIL "Basic and scripted symbols."))
 (|sample| (($) "\\spad{sample()} returns a sample of \\%"))
 (|string|
  (((|String|) $)
   "\\spad{string(s)} converts the symbol \\spad{s} to a string. Error: if the symbol is subscripted."))
 (|elt|
  (($ $ (|List| (|OutputForm|)))
   "\\spad{elt(s,{} [a1,{} ...,{} an])} or \\spad{s}([\\spad{a1},{} ...,{} an]) returns \\spad{s} subscripted by \\spad{[a1,{} ...,{} an]}."))
 (|argscript|
  (($ $ (|List| (|OutputForm|)))
   "\\spad{argscript(s,{} [a1,{} ...,{} an])} returns \\spad{s} arg-scripted by \\spad{[a1,{} ...,{} an]}."))
 (|superscript|
  (($ $ (|List| (|OutputForm|)))
   "\\spad{superscript(s,{} [a1,{} ...,{} an])} returns \\spad{s} superscripted by \\spad{[a1,{} ...,{} an]}."))
 (|subscript|
  (($ $ (|List| (|OutputForm|)))
   "\\spad{subscript(s,{} [a1,{} ...,{} an])} returns \\spad{s} subscripted by \\spad{[a1,{} ...,{} an]}."))
 (|script|
  (($ $
    (|Record| (|:| |sub| (|List| (|OutputForm|)))
              (|:| |sup| (|List| (|OutputForm|)))
              (|:| |presup| (|List| (|OutputForm|)))
              (|:| |presub| (|List| (|OutputForm|)))
              (|:| |args| (|List| (|OutputForm|)))))
   "\\spad{script(s,{} [a,{} b,{} c,{} d,{} e])} returns \\spad{s} with subscripts a,{} superscripts \\spad{b},{} pre-superscripts \\spad{c},{} pre-subscripts \\spad{d},{} and argument-scripts \\spad{e}.")
  (($ $ (|List| (|List| (|OutputForm|))))
   "\\spad{script(s,{} [a,{} b,{} c,{} d,{} e])} returns \\spad{s} with subscripts a,{} superscripts \\spad{b},{} pre-superscripts \\spad{c},{} pre-subscripts \\spad{d},{} and argument-scripts \\spad{e}. Omitted components are taken to be empty. For example,{} \\spad{script(s,{} [a,{} b,{} c])} is equivalent to \\spad{script(s,{} [a,{} b,{} c,{} [],{} []])}."))
 (|scripts|
  (((|Record| (|:| |sub| (|List| (|OutputForm|)))
              (|:| |sup| (|List| (|OutputForm|)))
              (|:| |presup| (|List| (|OutputForm|)))
              (|:| |presub| (|List| (|OutputForm|)))
              (|:| |args| (|List| (|OutputForm|))))
    $)
   "\\spad{scripts(s)} returns all the scripts of \\spad{s}."))
 (|scripted?|
  (((|Boolean|) $)
   "\\spad{scripted?(s)} is \\spad{true} if \\spad{s} has been given any scripts."))
 (|name| (($ $) "\\spad{name(s)} returns \\spad{s} without its scripts."))
 (|coerce|
  (($ (|String|))
   "\\spad{coerce(s)} converts the string \\spad{s} to a symbol."))
 (|resetNew|
  (((|Void|))
   "\\spad{resetNew()} resets the internals counters that new() and new(\\spad{s}) use to return distinct symbols every time."))
 (|new|
  (($ $)
   "\\spad{new(s)} returns a new symbol whose name starts with \\%\\spad{s}.")
  (($) "\\spad{new()} returns a new symbol whose name starts with \\%."))) 
NIL 
(|SymmetricFunctions| R) 
((|constructor|
  (NIL "Computes all the symmetric functions in \\spad{n} variables."))
 (|symFunc|
  (((|Vector| |#1|) |#1| (|PositiveInteger|))
   "\\spad{symFunc(r,{} n)} returns the vector of the elementary symmetric functions in \\spad{[r,{} r,{} ...,{} r]} \\spad{n} times.")
  (((|Vector| |#1|) (|List| |#1|))
   "\\spad{symFunc([r1,{} ...,{} rn])} returns the vector of the elementary symmetric functions in the \\spad{\\spad{ri}'s}: \\spad{[r1 + ... + rn,{} r1 r2 + ... + r(n-1) rn,{} ...,{} r1 r2 ... rn]}."))) 
NIL 
(|SymmetricPolynomial| R) 
((|constructor| (NIL "This domain implements symmetric polynomial"))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|EntireRing|)) (|HasCategory| |#1| '(|SemiRing|))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|EntireRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#1| '(|Comparable|))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| (|Partition|) '(|Comparable|)) (|HasCategory| |#1| '(|Field|))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| |#1| '(|GcdDomain|)) (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (|HasCategory| $ '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|EntireRing|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#1| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#1| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#1| '(|AbelianGroup|))
       (|HasCategory| |#1| '(|CommutativeRing|)))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|TheSymbolTable|) 
((|constructor|
  (NIL
   "Creates and manipulates one global symbol table for FORTRAN code generation,{} containing details of types,{} dimensions,{} and argument lists."))
 (|symbolTableOf|
  (((|SymbolTable|) (|Symbol|) $)
   "\\spad{symbolTableOf(f,{} tab)} returns the symbol table of \\spad{f}"))
 (|argumentListOf|
  (((|List| (|Symbol|)) (|Symbol|) $)
   "\\spad{argumentListOf(f,{} tab)} returns the argument list of \\spad{f}"))
 (|returnTypeOf|
  (((|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1="void"))
    (|Symbol|) $)
   "\\spad{returnTypeOf(f,{} tab)} returns the type of the object returned by \\spad{f}"))
 (|empty| (($) "\\spad{empty()} creates a new,{} empty symbol table."))
 (|printTypes|
  (((|Void|) (|Symbol|))
   "\\spad{printTypes(tab)} produces FORTRAN type declarations from \\spad{tab},{} on the current FORTRAN output stream"))
 (|printHeader|
  (((|Void|))
   "\\spad{printHeader()} produces the FORTRAN header for the current subprogram in the global symbol table on the current FORTRAN output stream.")
  (((|Void|) (|Symbol|))
   "\\spad{printHeader(f)} produces the FORTRAN header for subprogram \\spad{f} in the global symbol table on the current FORTRAN output stream.")
  (((|Void|) (|Symbol|) $)
   "\\spad{printHeader(f,{} tab)} produces the FORTRAN header for subprogram \\spad{f} in symbol table tab on the current FORTRAN output stream."))
 (|returnType!|
  (((|Void|) (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1#)))
   "\\spad{returnType!(t)} declares that the return type of he current subprogram in the global symbol table is \\spad{t}.")
  (((|Void|) (|Symbol|)
    (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1#)))
   "\\spad{returnType!(f,{} t)} declares that the return type of subprogram \\spad{f} in the global symbol table is \\spad{t}.")
  (((|Void|) (|Symbol|)
    (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| #1#)) $)
   "\\spad{returnType!(f,{} t,{} tab)} declares that the return type of subprogram \\spad{f} in symbol table tab is \\spad{t}."))
 (|argumentList!|
  (((|Void|) (|List| (|Symbol|)))
   "\\spad{argumentList!(l)} declares that the argument list for the current subprogram in the global symbol table is \\spad{l}.")
  (((|Void|) (|Symbol|) (|List| (|Symbol|)))
   "\\spad{argumentList!(f,{} l)} declares that the argument list for subprogram \\spad{f} in the global symbol table is \\spad{l}.")
  (((|Void|) (|Symbol|) (|List| (|Symbol|)) $)
   "\\spad{argumentList!(f,{} l,{} tab)} declares that the argument list for subprogram \\spad{f} in symbol table tab is \\spad{l}."))
 (|endSubProgram|
  (((|Symbol|))
   "\\spad{endSubProgram()} asserts that we are no longer processing the current subprogram."))
 (|currentSubProgram|
  (((|Symbol|))
   "\\spad{currentSubProgram()} returns the name of the current subprogram being processed"))
 (|newSubProgram|
  (((|Void|) (|Symbol|))
   "\\spad{newSubProgram(f)} asserts that from now on type declarations are part of subprogram \\spad{f}."))
 (|declare!|
  (((|FortranType|) (|Symbol|) (|FortranType|) (|Symbol|))
   "\\spad{declare!(u,{} t,{} asp)} declares the parameter \\spad{u} to have type \\spad{t} in asp.")
  (((|FortranType|) (|Symbol|) (|FortranType|))
   "\\spad{declare!(u,{} t)} declares the parameter \\spad{u} to have type \\spad{t} in the current level of the symbol table.")
  (((|FortranType|) (|List| (|Symbol|)) (|FortranType|) (|Symbol|) $)
   "\\spad{declare!(u,{} t,{} asp,{} tab)} declares the parameters \\spad{u} of subprogram \\spad{asp} to have type \\spad{t} in symbol table tab.")
  (((|FortranType|) (|Symbol|) (|FortranType|) (|Symbol|) $)
   "\\spad{declare!(u,{} t,{} asp,{} tab)} declares the parameter \\spad{u} of subprogram \\spad{asp} to have type \\spad{t} in symbol table tab."))
 (|clearTheSymbolTable|
  (((|Void|) (|Symbol|))
   "\\spad{clearTheSymbolTable(x)} removes the symbol \\spad{x} from the table")
  (((|Void|))
   "\\spad{clearTheSymbolTable()} clears the current symbol table."))
 (|showTheSymbolTable|
  (($) "\\spad{showTheSymbolTable()} returns the current symbol table."))) 
NIL 
(|SymbolTable|) 
((|constructor|
  (NIL "Create and manipulate a symbol table for generated FORTRAN code"))
 (|symbolTable|
  (($ (|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|FortranType|)))))
   "\\spad{symbolTable(l)} creates a symbol table from the elements of \\spad{l}."))
 (|printTypes|
  (((|Void|) $)
   "\\spad{printTypes(tab)} produces FORTRAN type declarations from \\spad{tab},{} on the current FORTRAN output stream"))
 (|newTypeLists|
  (((|SExpression|) $) "\\spad{newTypeLists(x)} \\undocumented"))
 (|typeLists|
  (((|List|
     (|List|
      (|Union| (|:| |name| (|Symbol|))
               (|:| |bounds|
                    (|List|
                     (|Union| (|:| S (|Symbol|))
                              (|:| P (|Polynomial| (|Integer|)))))))))
    $)
   "\\spad{typeLists(tab)} returns a list of lists of types of objects in \\spad{tab}"))
 (|externalList|
  (((|List| (|Symbol|)) $)
   "\\spad{externalList(tab)} returns a list of all the external symbols in \\spad{tab}"))
 (|typeList|
  (((|List|
     (|Union| (|:| |name| (|Symbol|))
              (|:| |bounds|
                   (|List|
                    (|Union| (|:| S (|Symbol|))
                             (|:| P (|Polynomial| (|Integer|))))))))
    (|FortranScalarType|) $)
   "\\spad{typeList(t,{} tab)} returns a list of all the objects of type \\spad{t} in tab"))
 (|parametersOf|
  (((|List| (|Symbol|)) $)
   "\\spad{parametersOf(tab)} returns a list of all the symbols declared in \\spad{tab}"))
 (|fortranTypeOf|
  (((|FortranType|) (|Symbol|) $)
   "\\spad{fortranTypeOf(u,{} tab)} returns the type of \\spad{u} in tab"))
 (|declare!|
  (((|FortranType|) (|Symbol|) (|FortranType|) $)
   "\\spad{declare!(u,{} t,{} tab)} creates a new entry in tab,{} declaring \\spad{u} to be of type \\spad{t}")
  (((|FortranType|) (|List| (|Symbol|)) (|FortranType|) $)
   "\\spad{declare!(l,{} t,{} tab)} creates new entrys in tab,{} declaring each of \\spad{l} to be of type \\spad{t}"))
 (|empty| (($) "\\spad{empty()} returns a new,{} empty symbol table"))
 (|coerce|
  (((|Table| (|Symbol|) (|FortranType|)) $)
   "\\spad{coerce(x)} returns a table view of \\spad{x}"))) 
NIL 
(|SystemSolvePackage| R) 
((|constructor|
  (NIL
   "Symbolic solver for systems of rational functions with coefficients in an integral domain \\spad{R}. The systems are solved in the field of rational functions over \\spad{R}. Solutions are exact of the form variable = value when the value is a member of the coefficient domain \\spad{R}. Otherwise the solutions are implicitly expressed as roots of univariate polynomial equations over \\spad{R}. Care is taken to guarantee that the denominators of the input equations do not vanish on the solution sets. The arguments to solve can either be given as equations or as rational functions interpreted as equal to zero. The user can specify an explicit list of symbols to be solved for,{} treating all other symbols appearing as parameters or omit the list of symbols in which case the system tries to solve with respect to all symbols appearing in the input."))
 (|triangularSystems|
  (((|List| (|List| (|Polynomial| |#1|)))
    (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|)))
   "\\spad{triangularSystems(lf,{} lv)} solves the system of equations defined by \\spad{lf} with respect to the list of symbols \\spad{lv}; the system of equations is obtaining by equating to zero the list of rational functions \\spad{lf}. The output is a list of solutions where each solution is expressed as a \"reduced\" triangular system of polynomials."))
 (|solve|
  (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))
    (|Equation| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{solve(eq)} finds the solutions of the equation \\spad{eq} with respect to the unique variable appearing in \\spad{eq}.")
  (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))
    (|Fraction| (|Polynomial| |#1|)))
   "\\spad{solve(p)} finds the solution of a rational function \\spad{p} = 0 with respect to the unique variable appearing in \\spad{p}.")
  (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))
    (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|))
   "\\spad{solve(eq,{} v)} finds the solutions of the equation \\spad{eq} with respect to the variable \\spad{v}.")
  (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))
    (|Fraction| (|Polynomial| |#1|)) (|Symbol|))
   "\\spad{solve(p,{} v)} solves the equation \\spad{p=0},{} where \\spad{p} is a rational function with respect to the variable \\spad{v}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
   "\\spad{solve(le)} finds the solutions of the list \\spad{le} of equations of rational functions with respect to all symbols appearing in \\spad{le}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Fraction| (|Polynomial| |#1|))))
   "\\spad{solve(lp)} finds the solutions of the list \\spad{lp} of rational functions with respect to all symbols appearing in \\spad{lp}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|)))
   "\\spad{solve(le,{} lv)} finds the solutions of the list \\spad{le} of equations of rational functions with respect to the list of symbols \\spad{lv}.")
  (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))))
    (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|)))
   "\\spad{solve(lp,{} lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv}."))) 
NIL 
(|TableauxBumpers| S) 
((|constructor|
  (NIL
   "TableauBumpers implements the Schenstead-Knuth correspondence between sequences and pairs of Young tableaux. The 2 Young tableaux are represented as a single tableau with pairs as components."))
 (|mr|
  (((|Record| (|:| |f1| (|List| |#1|))
              (|:| |f2| (|List| (|List| (|List| |#1|))))
              (|:| |f3| (|List| (|List| |#1|)))
              (|:| |f4| (|List| (|List| (|List| |#1|)))))
    (|List| (|List| (|List| |#1|))))
   "\\spad{mr(t)} is an auxiliary function which finds the position of the maximum element of a tableau \\spad{t} which is in the lowest row,{} producing a record of results"))
 (|maxrow|
  (((|Record| (|:| |f1| (|List| |#1|))
              (|:| |f2| (|List| (|List| (|List| |#1|))))
              (|:| |f3| (|List| (|List| |#1|)))
              (|:| |f4| (|List| (|List| (|List| |#1|)))))
    (|List| |#1|) (|List| (|List| (|List| |#1|))) (|List| (|List| |#1|))
    (|List| (|List| (|List| |#1|))) (|List| (|List| (|List| |#1|)))
    (|List| (|List| (|List| |#1|))))
   "\\spad{maxrow(a,{} b,{} c,{} d,{} e)} is an auxiliary function for \\spad{mr}"))
 (|inverse|
  (((|List| |#1|) (|List| |#1|))
   "\\spad{inverse(ls)} forms the inverse of a sequence \\spad{ls}"))
 (|slex|
  (((|List| (|List| |#1|)) (|List| |#1|))
   "\\spad{slex(ls)} sorts the argument sequence \\spad{ls},{} then zips (see \\spadfunFrom{map}{\\spad{ListFunctions3}}) the original argument sequence with the sorted result to a list of pairs"))
 (|lex|
  (((|List| (|List| |#1|)) (|List| (|List| |#1|)))
   "\\spad{lex(ls)} sorts a list of pairs to lexicographic order"))
 (|tab|
  (((|Tableau| (|List| |#1|)) (|List| |#1|))
   "\\spad{tab(ls)} creates a tableau from \\spad{ls} by first creating a list of pairs using \\spadfunFrom{slex}{TableauBumpers},{} then creating a tableau using \\spadfunFrom{\\spad{tab1}}{TableauBumpers}."))
 (|tab1|
  (((|List| (|List| (|List| |#1|))) (|List| (|List| |#1|)))
   "\\spad{tab1(lp)} creates a tableau from a list of pairs \\spad{lp}"))
 (|bat|
  (((|List| (|List| |#1|)) (|Tableau| (|List| |#1|)))
   "\\spad{bat(ls)} unbumps a tableau \\spad{ls}"))
 (|bat1|
  (((|List| (|List| |#1|)) (|List| (|List| (|List| |#1|))))
   "\\spad{bat1(llp)} unbumps a tableau \\spad{llp}. Operation \\spad{bat1} is the inverse of \\spad{tab1}."))
 (|untab|
  (((|List| (|List| |#1|)) (|List| (|List| |#1|))
    (|List| (|List| (|List| |#1|))))
   "\\spad{untab(lp,{} llp)} is an auxiliary function which unbumps a tableau \\spad{llp},{} using \\spad{lp} to accumulate pairs"))
 (|bumptab1|
  (((|List| (|List| (|List| |#1|))) (|List| |#1|)
    (|List| (|List| (|List| |#1|))))
   "\\spad{bumptab1(pr,{} t)} bumps a tableau \\spad{t} with a pair \\spad{pr} using comparison function \\spadfun{<},{} returning a new tableau"))
 (|bumptab|
  (((|List| (|List| (|List| |#1|))) (|Mapping| (|Boolean|) |#1| |#1|)
    (|List| |#1|) (|List| (|List| (|List| |#1|))))
   "\\spad{bumptab(cf,{} pr,{} t)} bumps a tableau \\spad{t} with a pair \\spad{pr} using comparison function \\spad{cf},{} returning a new tableau"))
 (|bumprow|
  (((|Record| (|:| |fs| (|Boolean|)) (|:| |sd| (|List| |#1|))
              (|:| |td| (|List| (|List| |#1|))))
    (|Mapping| (|Boolean|) |#1| |#1|) (|List| |#1|) (|List| (|List| |#1|)))
   "\\spad{bumprow(cf,{} pr,{} r)} is an auxiliary function which bumps a row \\spad{r} with a pair \\spad{pr} using comparison function \\spad{cf},{} and returns a record"))) 
NIL 
(|Table| |Key| |Entry|) 
((|constructor|
  (NIL
   "This is the general purpose table type. The keys are hashed to look up the entries. This creates a \\spadtype{HashTable} if equal for the Key domain is consistent with Lisp EQUAL otherwise an \\spadtype{AssociationList}"))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|Tableau| S) 
((|constructor|
  (NIL
   "The tableau domain is for printing Young tableaux,{} and coercions to and from List List \\spad{S} where \\spad{S} is a set."))
 (|listOfLists|
  (((|List| (|List| |#1|)) $)
   "\\spad{listOfLists t} converts a tableau \\spad{t} to a list of lists."))
 (|tableau|
  (($ (|List| (|List| |#1|)))
   "\\spad{tableau(ll)} converts a list of lists \\spad{ll} to a tableau."))) 
NIL 
(|TangentExpansions| R) 
((|constructor| (NIL "Expands tangents of sums and scalar products."))
 (|tanNa|
  ((|#1| |#1| (|Integer|))
   "\\spad{tanNa(a,{} n)} returns \\spad{f(a)} such that if \\spad{a = tan(u)} then \\spad{f(a) = tan(n * u)}."))
 (|tanAn|
  (((|SparseUnivariatePolynomial| |#1|) |#1| (|PositiveInteger|))
   "\\spad{tanAn(a,{} n)} returns \\spad{P(x)} such that if \\spad{a = tan(u)} then \\spad{P(tan(u/n)) = 0}."))
 (|tanSum|
  ((|#1| (|List| |#1|))
   "\\spad{tanSum([a1,{} ...,{} an])} returns \\spad{f(a1,{} ...,{} an)} such that if \\spad{\\spad{ai} = tan(\\spad{ui})} then \\spad{f(a1,{} ...,{} an) = tan(u1 + ... + un)}."))) 
NIL 
(|TableAggregate&| S |Key| |Entry|) 
((|constructor|
  (NIL
   "A table aggregate is a model of a table,{} \\spadignore{i.e.} a discrete many-to-one mapping from keys to entries."))
 (|map|
  (($ (|Mapping| |#3| |#3| |#3|) $ $)
   "\\spad{map(fn,{} t1,{} t2)} creates a new table \\spad{t} from given tables \\spad{t1} and \\spad{t2} with elements \\spad{fn}(\\spad{x},{} \\spad{y}) where \\spad{x} and \\spad{y} are corresponding elements from \\spad{t1} and \\spad{t2} respectively."))
 (|table|
  (($ (|List| (|Record| (|:| |key| |#2|) (|:| |entry| |#3|))))
   "\\spad{table([x,{} y,{} ...,{} z])} creates a table consisting of entries \\spad{x,{} y,{} ...,{} z}.")
  (($)
   "\\spad{table()}\\$\\spad{T} creates an empty table of type \\spad{T}."))
 (|setelt!|
  ((|#3| $ |#2| |#3|)
   "\\spad{setelt!(t,{} k,{} e)} (also written \\spad{t.k := e}) is equivalent to \\spad{(insert!([k,{} e],{} t); e)}."))) 
NIL 
(|TableAggregate| |Key| |Entry|) 
((|constructor|
  (NIL
   "A table aggregate is a model of a table,{} \\spadignore{i.e.} a discrete many-to-one mapping from keys to entries."))
 (|map|
  (($ (|Mapping| |#2| |#2| |#2|) $ $)
   "\\spad{map(fn,{} t1,{} t2)} creates a new table \\spad{t} from given tables \\spad{t1} and \\spad{t2} with elements \\spad{fn}(\\spad{x},{} \\spad{y}) where \\spad{x} and \\spad{y} are corresponding elements from \\spad{t1} and \\spad{t2} respectively."))
 (|table|
  (($ (|List| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))))
   "\\spad{table([x,{} y,{} ...,{} z])} creates a table consisting of entries \\spad{x,{} y,{} ...,{} z}.")
  (($)
   "\\spad{table()}\\$\\spad{T} creates an empty table of type \\spad{T}."))
 (|setelt!|
  ((|#2| $ |#1| |#2|)
   "\\spad{setelt!(t,{} k,{} e)} (also written \\spad{t.k := e}) is equivalent to \\spad{(insert!([k,{} e],{} t); e)}."))) 
NIL 
(|TabulatedComputationPackage| |Key| |Entry|) 
((|constructor|
  (NIL
   "\\spad{TabulatedComputationPackage(Key ,{} Entry)} provides some modest support for dealing with operations with type \\spad{Key -> Entry}. The result of such operations can be stored and retrieved with this package by using a hash-table. The user does not need to worry about the management of this hash-table. However,{} only one hash-table is built by calling \\spad{TabulatedComputationPackage(Key ,{} Entry)}."))
 (|insert!|
  (((|Void|) |#1| |#2|)
   "\\spad{insert!(x,{} y)} stores the item whose key is \\spad{x} and whose entry is \\spad{y}."))
 (|extractIfCan|
  (((|Union| |#2| "failed") |#1|)
   "\\spad{extractIfCan(x)} searches the item whose key is \\spad{x}."))
 (|makingStats?|
  (((|Boolean|))
   "\\spad{makingStats?()} returns \\spad{true} iff the statistics process is running."))
 (|printingInfo?|
  (((|Boolean|))
   "\\spad{printingInfo?()} returns \\spad{true} iff messages are printed when manipulating items from the hash-table."))
 (|usingTable?|
  (((|Boolean|))
   "\\spad{usingTable?()} returns \\spad{true} iff the hash-table is used"))
 (|clearTable!|
  (((|Void|))
   "\\spad{clearTable!()} clears the hash-table and assumes that it will no longer be used."))
 (|printStats!| (((|Void|)) "\\spad{printStats!()} prints the statistics."))
 (|startStats!|
  (((|Void|) (|String|))
   "\\spad{startStats!(x)} initializes the statistics process and sets the comments to display when statistics are printed"))
 (|printInfo!|
  (((|Void|) (|String|) (|String|))
   "\\spad{printInfo!(x,{} y)} initializes the messages to be printed when manipulating items from the hash-table. If a key is retrieved then \\spad{x} is displayed. If an item is stored then \\spad{y} is displayed."))
 (|initTable!| (((|Void|)) "\\spad{initTable!()} initializes the hash-table."))) 
NIL 
(|TemplateUtilities|) 
((|constructor|
  (NIL "This package provides functions for template manipulation"))
 (|stripCommentsAndBlanks|
  (((|String|) (|String|))
   "\\spad{stripCommentsAndBlanks(s)} treats \\spad{s} as a piece of FriCAS input,{} and removes comments,{} and leading and trailing blanks."))
 (|interpretString|
  (((|Any|) (|String|))
   "\\spad{interpretString(s)} treats a string as a piece of FriCAS input,{} by parsing and interpreting it."))) 
NIL 
(|TensorProductCategory| R M N) 
((|constructor|
  (NIL "Category of tensor products of modules over commutative rings."))
 (|tensor|
  (($ |#2| |#3|)
   "\\spad{tensor(x,{} y)} constructs the tensor product of the elements \\spad{x} and \\spad{y}."))) 
NIL 
(|TensorProduct| R B1 B2 M1 M2) 
((|constructor|
  (NIL
   "Tensor product of free modules over a commutative ring. It is represented as a free module over the direct product of the respective bases. The factor domains must provide operations \\spad{listOfTerms},{} whose result is assumed to be stored in reverse order."))) 
((AND (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#1|)))
      (|HasCategory| |#5| (LIST '|Algebra| (|devaluate| |#1|))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#1|)))
          (|HasCategory| |#5| (LIST '|Algebra| (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianMonoid|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#1|)))
          (|HasCategory| |#5| (LIST '|Algebra| (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#1|)))
          (|HasCategory| |#5| (LIST '|Algebra| (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| (|Product| |#2| |#3|) '(|Comparable|))
 (AND (|HasCategory| |#1| '(|Comparable|))
      (|HasCategory| (|Product| |#2| |#3|) '(|Comparable|)))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#1|)))
          (|HasCategory| |#5| (LIST '|Algebra| (|devaluate| |#1|)))))) 
(|TensorPowerCategory&| S |n| R M) 
((|constructor|
  (NIL "Category of tensor powers of modules over commutative rings."))
 (|tensor|
  (($ (|List| |#4|))
   "\\spad{tensor([x1,{} x2,{} ...,{} xn])} constructs the tensor product of \\spad{x1,{} x2,{} ...,{} xn}."))) 
((|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#3|)))) 
(|TensorPowerCategory| |n| R M) 
((|constructor|
  (NIL "Category of tensor powers of modules over commutative rings."))
 (|tensor|
  (($ (|List| |#3|))
   "\\spad{tensor([x1,{} x2,{} ...,{} xn])} constructs the tensor product of \\spad{x1,{} x2,{} ...,{} xn}."))) 
NIL 
(|TensorPowerFunctions2| |n| R B M1 M2) 
((|constructor| (NIL "linear extensions of maps on the basis"))
 (|linearExtend|
  ((|#5| (|Mapping| |#5| (|List| |#3|)) (|TensorPower| |#1| |#2| |#3| |#4|))
   "\\spad{linearExtend: (f,{} x)} returns the linear extension of a multilinear map defined on the basis of \\spad{M2} applied to a linear combination"))) 
NIL 
(|TensorPower| |n| R B M) 
((|constructor|
  (NIL
   "Tensor powers of a free module over a commutative ring. It is represented as a free module over the cartesian power of the basis."))) 
((|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#2|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#2|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#2|))))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
     (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#2|))))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (|HasCategory| |#4| (LIST '|Algebra| (|devaluate| |#2|))))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| (|Vector| |#3|) '(|Comparable|))
 (AND (|HasCategory| |#2| '(|Comparable|))
      (|HasCategory| (|Vector| |#3|) '(|Comparable|)))) 
(|TensorProductProperty| R M N |MxN| S) 
((|constructor| (NIL "Universal property of tensor products."))
 (|eval|
  ((|#5| |#4| (|Mapping| |#5| |#2| |#3|))
   "\\spad{eval(x,{} f)} evaluates the bivariate function \\spad{f} linearly on the tensor product."))) 
NIL 
(|UnittestAux| R) 
((|constructor|
  (NIL
   "UnittestAux is an auxiliary package to Unittest,{} that performs \\indented{13}{checking of tests,{} dealing also with fatal errors.}"))
 (|testRelativePrecision|
  ((|#1| |#1|)
   "\\spad{testRelativePrecision(eps)} returns the current absolute precision used for floating point comparison,{} and then sets it to \\spad{eps}. The default value is 1.0e-15."))
 (|testAbsolutePrecision|
  ((|#1| |#1|)
   "\\spad{testAbsolutePrecision(eps)} returns the current absolute precision used for floating point comparison,{} and then sets it to \\spad{eps}. The default value is 1.0e-15."))
 (|xftestComplexEqualsAux|
  (((|Void|) (|String|) (|Complex| |#1|) (|Complex| |#1|))
   "like testEquals,{} but expects failure."))
 (|testComplexEqualsAux|
  (((|Void|) (|String|) (|Complex| |#1|) (|Complex| |#1|))
   "\\spad{testComplexEqualsAux(inp ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be approximately equal as complex numbers,{} taking into acount \\spadfun{testAbsolutePrecision} and \\spadfun{testRelativePrecision}."))
 (|xftestRealEqualsAux|
  (((|Void|) (|String|) |#1| |#1|) "like testEquals,{} but expects failure."))
 (|testRealEqualsAux|
  (((|Void|) (|String|) |#1| |#1|)
   "\\spad{testRealEqualsAux(inp,{} ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be approximately equal as real numbers,{} taking into acount \\spadfun{testAbsolutePrecision} and \\spadfun{testRelativePrecision}."))
 (|testEqualsAuxCmp|
  (((|Boolean|) |#1| |#1|)
   "\\spad{testEqualsAuxCmp should} be local but is conditional"))
 (|xftestLibraryErrorAux|
  (((|Void|) (|String|) |#1|) "like testEquals,{} but expects failure."))
 (|testLibraryErrorAux|
  (((|Void|) (|String|) |#1|)
   "\\spad{testLibraryErrorAux(inp,{} ex)} states that ex should throw an error. Such a test will never count as a fatal error."))
 (|xftestTrueAux|
  (((|Void|) (|String|) |#1|) "like testEquals,{} but expects failure."))
 (|testTrueAux|
  (((|Void|) (|String|) |#1|)
   "\\spad{testTrueAux(inp,{} ex)} states that ex should be \\spad{true}."))
 (|xftestNotEqualsAux|
  (((|Void|) (|String|) |#1| |#1|) "like testEquals,{} but expects failure."))
 (|testNotEqualsAux|
  (((|Void|) (|String|) |#1| |#1|)
   "testNotEquals(inp,{} \\spad{ex1},{} \\spad{ex2}) states that \\spad{ex1} and \\spad{ex2} should be different."))
 (|xftestEqualsAux|
  (((|Void|) (|String|) |#1| |#1|) "like testEquals,{} but expects failure."))
 (|testEqualsAux|
  (((|Void|) (|String|) |#1| |#1|)
   "testEquals(inp,{} \\spad{ex1},{} \\spad{ex2}) states that \\spad{ex1} and \\spad{ex2} should be equal. To sidestep the possibility that the equality function of the domain \\spad{R} performs some simplifications,{} we convert \\spad{ex1} and \\spad{ex2} to \\spad{InputForm},{} if possible."))) 
((|HasCategory| |#1| '(|RealNumberSystem|))) 
(|UnittestCount|) 
((|constructor|
  (NIL
   "UnittestCount is a package that keeps track of statistics \\indented{13}{collected during testing.\\space{2}It is separate from} \\indented{13}{\\spadtype{UnittestAux} because the latter takes an argument,{}} \\indented{13}{and we want the state to be common for all arguments.}"))
 (|addWarning|
  (((|Void|) (|OutputForm|))
   "\\spad{addWarning s} is an internal function that adds \\spad{s},{} together with an indication of the current testcase and the current testsuite to the list of warnings."))
 (|decXfFatal| (((|Void|)) "like decFatal,{} but for expected failures."))
 (|decFatal|
  (((|Void|))
   "decFatal is an internal function that declares that the preceding test did not fail with a fatal error."))
 (|incXfFatal|
  (((|Void|) (|String|)) "like incFatal,{} but for expected failures."))
 (|incFatal|
  (((|Void|) (|String|))
   "\\spad{incFatal s} is an internal function that steps the number of fatal tests and records input."))
 (|incXfLibraryError|
  (((|Void|) (|String|) (|List| (|OutputForm|)))
   "like incLibraryError,{} but using expected failures."))
 (|incLibraryError|
  (((|Void|) (|String|) (|List| (|OutputForm|)))
   "incLibraryError is an internal function that steps the number of failed tests,{} but not the number of tests."))
 (|chkLibraryError|
  (((|Void|))
   "chkLibraryError is an internal function that steps the number of tests."))
 (|incXfFail|
  (((|Void|))
   "\\spad{incXfFail()} is an internal function that steps the number expected failures."))
 (|decXfPass|
  (((|Void|))
   "\\spad{decXfPass()} is an internal function that declares that the preceding test did not pass unexpectedly. This function should only be used for testing library errors"))
 (|incXfPass|
  (((|Void|) (|String|) (|List| (|OutputForm|)))
   "\\spad{incXfPass(s,{} o)} is an internal function that steps the number of tests that passed but were expected to fail and records in- and output."))
 (|incFail|
  (((|Void|) (|String|) (|List| (|OutputForm|)))
   "\\spad{incFail(s,{} o)} is an internal function that steps the number of failed tests and records in- and output."))
 (|incPass|
  (((|Void|))
   "incPass is an internal function that steps the number of passed tests."))
 (|statistics|
  (((|Void|))
   "\\spad{statistics()} prints out a summary of the outcome of the testcases so far. Use \\spad{clear completely} to reset the statistics."))
 (|testcaseNoClear|
  (((|Void|) (|String|))
   "\\spad{testcaseNoClear s},{} starts a new testcase with \\spad{s} as title,{} without calling \\spad{clear all}. A testcase is composed of several tests."))
 (|testcase|
  (((|Void|) (|String|))
   "\\spad{testcase s} starts a new testcase with \\spad{s} as title. It also calls \\spad{clear all}. A testcase is composed of several tests."))
 (|testsuiteNoClear|
  (((|Void|) (|String|))
   "\\spad{testsuiteNoClear s} starts a new testsuite with \\spad{s} as title,{} without calling \\spad{clear all}. A testsuite is composed of several testcases."))
 (|testsuite|
  (((|Void|) (|String|))
   "\\spad{testsuite s} starts a new testsuite with \\spad{s} as title. It also calls \\spad{clear all}. A testsuite is composed of several testcases."))) 
NIL 
(|Unittest|) 
((|constructor|
  (NIL
   "Unittest is a package that provides functions for regression \\indented{13}{testing.\\space{2}Note that it calls the interpreter,{} thus,{} all} \\indented{13}{functions require that their arguments be passed as strings.}"))
 (|xftestLibraryError|
  (((|Void|) (|String|)) "like testLibraryError,{} but expects failure."))
 (|testLibraryError|
  (((|Void|) (|String|))
   "\\spad{testLibraryError ex} states that ex should throw an error. Such a test will never count as a fatal error."))
 (|xftestTrue| (((|Void|) (|String|)) "like testTrue,{} but expects failure."))
 (|testTrue|
  (((|Void|) (|String|))
   "\\spad{testTrue ex} states that ex should be \\spad{true}."))
 (|xftestNotEquals|
  (((|Void|) (|String|) (|String|))
   "like testNotEquals,{} but expects failure."))
 (|testNotEquals|
  (((|Void|) (|String|) (|String|))
   "\\spad{testNotEquals(ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be different."))
 (|xftestComplexEquals|
  (((|Void|) (|String|) (|String|))
   "like testComplexEquals,{} but expects failure."))
 (|testComplexEquals|
  (((|Void|) (|String|) (|String|))
   "\\spad{testComplexEquals(ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be approximately equal as complex numbers,{} taking into acount \\spadfun{testAbsolutePrecision} and \\spadfun{testRelativePrecision}."))
 (|xftestRealEquals|
  (((|Void|) (|String|) (|String|))
   "like testRealEquals,{} but expects failure."))
 (|testRealEquals|
  (((|Void|) (|String|) (|String|))
   "\\spad{testRealEquals(ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be approximately equal as real numbers,{} taking into acount \\spadfun{testAbsolutePrecision} and \\spadfun{testRelativePrecision}."))
 (|xftestEquals|
  (((|Void|) (|String|) (|String|)) "like testEquals,{} but expects failure."))
 (|testEquals|
  (((|Void|) (|String|) (|String|))
   "\\spad{testEquals(ex1,{} ex2)} states that \\spad{ex1} and \\spad{ex2} should be equal. To sidestep the possibility that the equality function of the domain \\spad{R} performs some simplifications,{} we convert \\spad{ex1} and \\spad{ex2} to \\spad{InputForm},{} if possible."))) 
NIL 
(|TexFormat|) 
((|constructor|
  (NIL
   "\\spadtype{TexFormat} provides a coercion from \\spadtype{OutputForm} to \\TeX{} format. The particular dialect of \\TeX{} used is \\LaTeX{}. The basic object consists of three parts: a prologue,{} a tex part and an epilogue. The functions \\spadfun{prologue},{} \\spadfun{tex} and \\spadfun{epilogue} extract these parts,{} respectively. The main guts of the expression go into the tex part. The other parts can be set (\\spadfun{setPrologue!},{} \\spadfun{setEpilogue!}) so that contain the appropriate tags for printing. For example,{} the prologue and epilogue might simply contain \\spad{``}\\verb+\\spad{\\[}+\\spad{''} and \\spad{``}\\verb+\\spad{\\]}+\\spad{''},{} respectively,{} so that the TeX section will be printed in LaTeX display math mode."))
 (|setPrologue!|
  (((|List| (|String|)) $ (|List| (|String|)))
   "\\spad{setPrologue!(t,{} strings)} sets the prologue section of a TeX form \\spad{t} to strings."))
 (|setTex!|
  (((|List| (|String|)) $ (|List| (|String|)))
   "\\spad{setTex!(t,{} strings)} sets the TeX section of a TeX form \\spad{t} to strings."))
 (|setEpilogue!|
  (((|List| (|String|)) $ (|List| (|String|)))
   "\\spad{setEpilogue!(t,{} strings)} sets the epilogue section of a TeX form \\spad{t} to strings."))
 (|setDialect|
  (((|Symbol|) (|Symbol|))
   "\\spad{setDialect(d)} sets \\spad{s} as current dialect and returns previous setting. Possible values are \\spad{tex} meaning using mostly plain TeX constructs and \\spad{latex} which means more idiomatic LaTeX."))
 (|getDialect|
  (((|Symbol|)) "\\spad{getDialect()} return current dialect setting."))
 (|prologue|
  (((|List| (|String|)) $)
   "\\spad{prologue(t)} extracts the prologue section of a TeX form \\spad{t}."))
 (|new|
  (($)
   "\\spad{new()} create a new,{} empty object. Use \\spadfun{setPrologue!},{} \\spadfun{setTex!} and \\spadfun{setEpilogue!} to set the various components of this object."))
 (|tex|
  (((|List| (|String|)) $)
   "\\spad{tex(t)} extracts the TeX section of a TeX form \\spad{t}."))
 (|epilogue|
  (((|List| (|String|)) $)
   "\\spad{epilogue(t)} extracts the epilogue section of a TeX form \\spad{t}."))
 (|display|
  (((|Void|) $)
   "\\spad{display(t)} outputs the TeX formatted code \\spad{t} so that each line has length less than or equal to the value set by the system command \\spadsyscom{set output length}.")
  (((|Void|) $ (|Integer|))
   "\\spad{display(t,{} width)} outputs the TeX formatted code \\spad{t} so that each line has length less than or equal to \\spadvar{width}."))
 (|convert|
  (($ (|OutputForm|) (|Integer|) (|OutputForm|))
   "\\spad{convert(o,{} step,{} type)} changes \\spad{o} in standard output format to TeX format and also adds the given \\spad{step} number and type. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \\spad{step} numbers.")
  (($ (|OutputForm|) (|Integer|))
   "\\spad{convert(o,{} step)} changes \\spad{o} in standard output format to TeX format and also adds the given step number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter step numbers."))
 (|coerce|
  (($ (|OutputForm|))
   "\\spad{coerce(o)} changes \\spad{o} in the standard output format to TeX format."))) 
NIL 
(|TexFormat1| S) 
((|constructor|
  (NIL
   "\\spadtype{TexFormat1} provides a utility coercion for changing to TeX format anything that has a coercion to the standard output format."))
 (|coerce|
  (((|TexFormat|) |#1|)
   "\\spad{coerce(s)} provides a direct coercion from a domain \\spad{S} to TeX format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to TeX format."))) 
NIL 
(|TextFile|) 
((|constructor|
  (NIL
   "This domain provides an implementation of text files. Text is stored in these files using the native character set of the computer."))
 (|endOfFile?|
  (((|Boolean|) $)
   "\\spad{endOfFile?(f)} tests whether the file \\spad{f} is positioned after the end of all text. If the file is open for output,{} then this test is always \\spad{true}."))
 (|readIfCan!|
  (((|Union| (|String|) "failed") $)
   "\\spad{readIfCan!(f)} returns a string of the contents of a line from file \\spad{f},{} if possible. If \\spad{f} is not readable or if it is positioned at the end of file,{} then \\spad{\"failed\"} is returned."))
 (|readLineIfCan!|
  (((|Union| (|String|) "failed") $)
   "\\spad{readLineIfCan!(f)} returns a string of the contents of a line from file \\spad{f},{} if possible. If \\spad{f} is not readable or if it is positioned at the end of file,{} then \\spad{\"failed\"} is returned."))
 (|readLine!|
  (((|String|) $)
   "\\spad{readLine!(f)} returns a string of the contents of a line from the file \\spad{f}."))
 (|writeLine!|
  (((|String|) $)
   "\\spad{writeLine!(f)} finishes the current line in the file \\spad{f}. An empty string is returned. The call \\spad{writeLine!(f)} is equivalent to \\spad{writeLine!(f,{}\"\")}.")
  (((|String|) $ (|String|))
   "\\spad{writeLine!(f,{} s)} writes the contents of the string \\spad{s} and finishes the current line in the file \\spad{f}. The value of \\spad{s} is returned."))) 
NIL 
(|TimeoutPackage| S) 
((|constructor| (NIL "This package supports evaluation with timeout."))
 (|eval_with_timeout|
  (((|Union| |#1| "failed") (|Mapping| |#1|) (|Integer|))
   "\\spad{eval_with_timeout(f,{} t)} calls \\spad{f} with timeout of \\spad{t} seconds. Returns value computed by \\spad{f} or \"failed\" if \\spad{f} did not finish within \\spad{t} seconds."))) 
NIL 
(|TexmacsFormat|) 
((|constructor|
  (NIL
   "\\spadtype{TexmacsFormat} provides a coercion from \\spadtype{OutputForm} to TeXmacs format."))
 (|display|
  (((|Void|) (|String|))
   "prints the string returned by coerce,{} adding <math ...> tags."))
 (|coerceL|
  (((|String|) (|OutputForm|))
   "\\spad{coerceL(o)} changes \\spad{o} in the standard output format to Texmacs format and displays result as one long string."))
 (|coerce|
  (((|String|) (|OutputForm|))
   "\\spad{coerce(o)} changes \\spad{o} in the standard output format to Texmacs format."))) 
NIL 
(|ToolsForSign| R) 
((|constructor| (NIL "Tools for the sign finding utilities."))
 (|direction| (((|Integer|) (|String|)) "\\spad{direction(s)} \\undocumented"))
 (|nonQsign|
  (((|Union| (|Integer|) "failed") |#1|) "\\spad{nonQsign(r)} \\undocumented"))
 (|sign|
  (((|Union| (|Integer|) "failed") |#1|) "\\spad{sign(r)} \\undocumented"))) 
NIL 
(|TopLevelThreeSpace|) 
((|constructor|
  (NIL "This package exports a function for making a \\spadtype{ThreeSpace}"))
 (|createThreeSpace|
  (((|ThreeSpace| (|DoubleFloat|)))
   "\\spad{createThreeSpace()} creates a \\spadtype{ThreeSpace(DoubleFloat)} object capable of holding point,{} curve,{} mesh components and any combination."))) 
NIL 
(|TranscendentalFunctionCategory&| S) 
((|constructor| (NIL "Category for the transcendental elementary functions."))
 (|pi| (($) "\\spad{\\spad{pi}()} returns the constant \\spad{pi}."))) 
NIL 
(|TranscendentalFunctionCategory|) 
((|constructor| (NIL "Category for the transcendental elementary functions."))
 (|pi| (($) "\\spad{\\spad{pi}()} returns the constant \\spad{pi}."))) 
NIL 
(|Tree| S) 
((|constructor|
  (NIL
   "\\spadtype{Tree(S)} is a basic domain of tree structures. Each tree is either empty or has a {\\it node} consisting of a value and a list of (sub)trees."))
 (|tree|
  (($ |#1|)
   "\\spad{tree(nd)} creates a tree with value \\spad{nd},{} and no children.")
  (($ (|List| |#1|))
   "\\spad{tree(ls)} creates a tree from a list of elements of \\spad{s}.")
  (($ |#1| (|List| $))
   "\\spad{tree(nd,{} ls)} creates a tree with value \\spad{nd},{} and children \\spad{ls}."))) 
((|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|BasicType|))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
          (|HasCategory| |#1| '(|SetCategory|))))
 (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|TrigonometricFunctionCategory&| S) 
((|constructor| (NIL "Category for the trigonometric functions."))
 (|tan| (($ $) "\\spad{tan(x)} returns the tangent of \\spad{x}."))
 (|sin| (($ $) "\\spad{sin(x)} returns the sine of \\spad{x}."))
 (|sec| (($ $) "\\spad{sec(x)} returns the secant of \\spad{x}."))
 (|csc| (($ $) "\\spad{csc(x)} returns the cosecant of \\spad{x}."))
 (|cot| (($ $) "\\spad{cot(x)} returns the cotangent of \\spad{x}."))
 (|cos| (($ $) "\\spad{cos(x)} returns the cosine of \\spad{x}."))) 
NIL 
(|TrigonometricFunctionCategory|) 
((|constructor| (NIL "Category for the trigonometric functions."))
 (|tan| (($ $) "\\spad{tan(x)} returns the tangent of \\spad{x}."))
 (|sin| (($ $) "\\spad{sin(x)} returns the sine of \\spad{x}."))
 (|sec| (($ $) "\\spad{sec(x)} returns the secant of \\spad{x}."))
 (|csc| (($ $) "\\spad{csc(x)} returns the cosecant of \\spad{x}."))
 (|cot| (($ $) "\\spad{cot(x)} returns the cotangent of \\spad{x}."))
 (|cos| (($ $) "\\spad{cos(x)} returns the cosine of \\spad{x}."))) 
NIL 
(|TrigonometricManipulations| R F) 
((|constructor|
  (NIL
   "\\spadtype{TrigonometricManipulations} provides transformations from trigonometric functions to complex exponentials and logarithms,{} and back."))
 (|complexForm|
  (((|Complex| |#2|) |#2|)
   "\\spad{complexForm(f)} returns \\spad{[real f,{} imag f]}."))
 (|real?|
  (((|Boolean|) |#2|)
   "\\spad{real?(f)} returns \\spad{true} if \\spad{f = real f}."))
 (|imag|
  ((|#2| |#2|)
   "\\spad{imag(f)} returns the imaginary part of \\spad{f} where \\spad{f} is a complex function."))
 (|real|
  ((|#2| |#2|)
   "\\spad{real(f)} returns the real part of \\spad{f} where \\spad{f} is a complex function."))
 (|trigs|
  ((|#2| |#2|)
   "\\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions."))
 (|complexElementary|
  ((|#2| |#2| (|Symbol|))
   "\\spad{complexElementary(f,{} x)} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log,{} exp}.")
  ((|#2| |#2|)
   "\\spad{complexElementary(f)} rewrites \\spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log,{} exp}."))
 (|complexNormalize|
  ((|#2| |#2| (|Symbol|))
   "\\spad{complexNormalize(f,{} x)} rewrites \\spad{f} using the least possible number of complex independent kernels involving \\spad{x}.")
  ((|#2| |#2|)
   "\\spad{complexNormalize(f)} rewrites \\spad{f} using the least possible number of complex independent kernels."))) 
NIL 
(|TrigonometricManipulationsAux| G FG) 
((|constructor|
  (NIL
   "This package provides transformations from trigonometric functions to exponentials and logarithms,{} and back. \\spad{F} and \\spad{FG} should be the same type of function space."))
 (|trigs2explogs|
  ((|#2| |#2| (|List| (|Kernel| |#2|)))
   "\\spad{trigs2explogs(f,{} [k1,{} ...,{} kn])} rewrites all the trigonometric functions appearing in \\spad{f} in terms of complex logarithms and exponentials. A kernel of the form \\spad{tan(u)} is expressed using \\spad{exp(u)^2} if it is one of the \\spad{\\spad{ki}'s},{} in terms of \\spad{exp(2*u)} otherwise."))) 
NIL 
(|TriangularMatrixOperations| R |Row| |Col| M) 
((|constructor|
  (NIL
   "This package provides functions that compute \"fraction-free\" inverses of upper and lower triangular matrices over a integral domain. By \"fraction-free inverses\" we mean the following: given a matrix \\spad{B} with entries in \\spad{R} and an element \\spad{d} of \\spad{R} such that \\spad{d} * inv(\\spad{B}) also has entries in \\spad{R},{} we return \\spad{d} * inv(\\spad{B}). Thus,{} it is not necessary to pass to the quotient field in any of our computations."))
 (|LowTriBddDenomInv|
  ((|#4| |#4| |#1|)
   "\\spad{LowTriBddDenomInv(B,{} d)} returns \\spad{M},{} where \\spad{B} is a non-singular lower triangular matrix and \\spad{d} is an element of \\spad{R} such that \\spad{M = d * inv(B)} has entries in \\spad{R}."))
 (|UpTriBddDenomInv|
  ((|#4| |#4| |#1|)
   "\\spad{UpTriBddDenomInv(B,{} d)} returns \\spad{M},{} where \\spad{B} is a non-singular upper triangular matrix and \\spad{d} is an element of \\spad{R} such that \\spad{M = d * inv(B)} has entries in \\spad{R}."))) 
NIL 
(|TranscendentalManipulations| R F) 
((|constructor|
  (NIL
   "TranscendentalManipulations provides functions to simplify and expand expressions involving transcendental operators."))
 (|expandTrigProducts|
  ((|#2| |#2|)
   "\\spad{expandTrigProducts(e)} replaces \\spad{sin(x)*sin(y)} by \\spad{(cos(x-y)-cos(x+y))/2},{} \\spad{cos(x)*cos(y)} by \\spad{(cos(x-y)+cos(x+y))/2},{} and \\spad{sin(x)*cos(y)} by \\spad{(sin(x-y)+sin(x+y))/2}. Note: this operation uses pattern matcher,{} so it is relatively expensive. To avoid getting into an infinite loop the transformations are applied at most ten times."))
 (|removeSinhSq|
  ((|#2| |#2|)
   "\\spad{removeSinhSq(f)} converts every \\spad{sinh(u)^2} appearing in \\spad{f} into \\spad{1 - cosh(u)^2},{} and also reduces higher powers of \\spad{sinh(u)} with that formula."))
 (|removeCoshSq|
  ((|#2| |#2|)
   "\\spad{removeCoshSq(f)} converts every \\spad{cosh(u)^2} appearing in \\spad{f} into \\spad{1 - sinh(u)^2},{} and also reduces higher powers of \\spad{cosh(u)} with that formula."))
 (|removeSinSq|
  ((|#2| |#2|)
   "\\spad{removeSinSq(f)} converts every \\spad{sin(u)^2} appearing in \\spad{f} into \\spad{1 - cos(u)^2},{} and also reduces higher powers of \\spad{sin(u)} with that formula."))
 (|removeCosSq|
  ((|#2| |#2|)
   "\\spad{removeCosSq(f)} converts every \\spad{cos(u)^2} appearing in \\spad{f} into \\spad{1 - sin(u)^2},{} and also reduces higher powers of \\spad{cos(u)} with that formula."))
 (|coth2tanh|
  ((|#2| |#2|)
   "\\spad{coth2tanh(f)} converts every \\spad{coth(u)} appearing in \\spad{f} into \\spad{1/tanh(u)}."))
 (|cot2tan|
  ((|#2| |#2|)
   "\\spad{cot2tan(f)} converts every \\spad{cot(u)} appearing in \\spad{f} into \\spad{1/tan(u)}."))
 (|tanh2coth|
  ((|#2| |#2|)
   "\\spad{tanh2coth(f)} converts every \\spad{tanh(u)} appearing in \\spad{f} into \\spad{1/coth(u)}."))
 (|tan2cot|
  ((|#2| |#2|)
   "\\spad{tan2cot(f)} converts every \\spad{tan(u)} appearing in \\spad{f} into \\spad{1/cot(u)}."))
 (|tanh2trigh|
  ((|#2| |#2|)
   "\\spad{tanh2trigh(f)} converts every \\spad{tanh(u)} appearing in \\spad{f} into \\spad{sinh(u)/cosh(u)}."))
 (|tan2trig|
  ((|#2| |#2|)
   "\\spad{tan2trig(f)} converts every \\spad{tan(u)} appearing in \\spad{f} into \\spad{sin(u)/cos(u)}."))
 (|sinh2csch|
  ((|#2| |#2|)
   "\\spad{sinh2csch(f)} converts every \\spad{sinh(u)} appearing in \\spad{f} into \\spad{1/csch(u)}."))
 (|sin2csc|
  ((|#2| |#2|)
   "\\spad{sin2csc(f)} converts every \\spad{sin(u)} appearing in \\spad{f} into \\spad{1/csc(u)}."))
 (|sech2cosh|
  ((|#2| |#2|)
   "\\spad{sech2cosh(f)} converts every \\spad{sech(u)} appearing in \\spad{f} into \\spad{1/cosh(u)}."))
 (|sec2cos|
  ((|#2| |#2|)
   "\\spad{sec2cos(f)} converts every \\spad{sec(u)} appearing in \\spad{f} into \\spad{1/cos(u)}."))
 (|csch2sinh|
  ((|#2| |#2|)
   "\\spad{csch2sinh(f)} converts every \\spad{csch(u)} appearing in \\spad{f} into \\spad{1/sinh(u)}."))
 (|csc2sin|
  ((|#2| |#2|)
   "\\spad{csc2sin(f)} converts every \\spad{csc(u)} appearing in \\spad{f} into \\spad{1/sin(u)}."))
 (|coth2trigh|
  ((|#2| |#2|)
   "\\spad{coth2trigh(f)} converts every \\spad{coth(u)} appearing in \\spad{f} into \\spad{cosh(u)/sinh(u)}."))
 (|cot2trig|
  ((|#2| |#2|)
   "\\spad{cot2trig(f)} converts every \\spad{cot(u)} appearing in \\spad{f} into \\spad{cos(u)/sin(u)}."))
 (|cosh2sech|
  ((|#2| |#2|)
   "\\spad{cosh2sech(f)} converts every \\spad{cosh(u)} appearing in \\spad{f} into \\spad{1/sech(u)}."))
 (|cos2sec|
  ((|#2| |#2|)
   "\\spad{cos2sec(f)} converts every \\spad{cos(u)} appearing in \\spad{f} into \\spad{1/sec(u)}."))
 (|expandLog|
  ((|#2| |#2|)
   "\\spad{expandLog(f)} converts every \\spad{log(a/b)} appearing in \\spad{f} into \\spad{log(a) - log(b)},{} and every \\spad{log(a*b)} into \\spad{log(a) + log(b)}."))
 (|expandPower|
  ((|#2| |#2|)
   "\\spad{expandPower(f)} converts every power \\spad{(a/b)^c} appearing in \\spad{f} into \\spad{a^c * b^(-c)}."))
 (|simplifyLog|
  ((|#2| |#2|)
   "\\spad{simplifyLog(f)} converts every \\spad{log(a) - log(b)} appearing in \\spad{f} into \\spad{log(a/b)},{} every \\spad{log(a) + log(b)} into \\spad{log(a*b)} and every \\spad{n*log(a)} into \\spad{log(a^n)}."))
 (|simplifyExp|
  ((|#2| |#2|)
   "\\spad{simplifyExp(f)} performs the following simplifications on \\spad{f:} \\begin{items} \\item 1. rewrites \\spad{exp(a)*exp(b)} as \\spad{exp(a+b)}. \\item 2. rewrites \\spad{a^b*a^c} as \\spad{a^(b+c)}. \\item 3. rewrites \\spad{exp(a)/exp(b)} as \\spad{exp(a-b)}. \\item 4. rewrites \\spad{a^b/a^c} as \\spad{a^(b-c)}. \\end{items}"))
 (|htrigs|
  ((|#2| |#2|)
   "\\spad{htrigs(f)} converts all the exponentials in \\spad{f} into hyperbolic sines and cosines."))
 (|simplify|
  ((|#2| |#2|)
   "\\spad{simplify(f)} performs the following simplifications on \\spad{f:} \\begin{items} \\item 1. rewrites trigs and hyperbolic trigs in terms of \\spad{sin} ,{} \\spad{cos},{} \\spad{sinh},{} \\spad{cosh}. \\item 2. rewrites \\spad{sin^2} and \\spad{sinh^2} in terms of \\spad{cos} and \\spad{cosh},{} \\item 3. rewrites \\spad{exp(a)*exp(b)} as \\spad{exp(a+b)}. \\item 4. rewrites \\spad{(a^(1/n))^m * (a^(1/s))^t} as a single power of a single radical of \\spad{a}. \\end{items}"))
 (|expand|
  ((|#2| |#2|)
   "\\spad{expand(f)} performs the following expansions on \\spad{f:} \\begin{items} \\item 1. logs of products are expanded into sums of logs. \\item 2. trigonometric and hyperbolic trigonometric functions of sums are expanded into sums of products of trigonometric and hyperbolic trigonometric functions. \\item 3. formal powers of the form \\spad{(a/b)^c} are expanded into \\spad{a^c * b^(-c)}. \\end{items}"))) 
((AND
  (|HasCategory| |#1|
                 (LIST '|ConvertibleTo| (LIST '|Pattern| (|devaluate| |#1|))))
  (|HasCategory| |#1| (LIST '|PatternMatchable| (|devaluate| |#1|)))
  (|HasCategory| |#2|
                 (LIST '|ConvertibleTo| (LIST '|Pattern| (|devaluate| |#1|))))
  (|HasCategory| |#2| (LIST '|PatternMatchable| (|devaluate| |#1|))))) 
(|TaylorSeries| |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{TaylorSeries} is a general multivariate Taylor series domain over the ring Coef and with variables of type Symbol."))
 (|fintegrate|
  (($ (|Mapping| $) (|Symbol|) |#1|)
   "\\spad{fintegrate(f,{} v,{} c)} is the integral of \\spad{f()} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.} \\indented{1}{The evaluation of \\spad{f()} is delayed.}"))
 (|integrate|
  (($ $ (|Symbol|) |#1|)
   "\\spad{integrate(s,{} v,{} c)} is the integral of \\spad{s} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.}"))
 (|coerce|
  (($ (|Polynomial| |#1|))
   "\\spad{coerce(s)} regroups terms of \\spad{s} by total degree \\indented{1}{and forms a series.}")
  (($ (|Symbol|)) "\\spad{coerce(s)} converts a variable to a Taylor series"))
 (|coefficient|
  (((|Polynomial| |#1|) $ (|NonNegativeInteger|))
   "\\spad{coefficient(s,{} n)} gives the terms of total degree \\spad{n}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|IndexedExponents| (|Symbol|)) '(|Comparable|))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))) 
(|TaylorSeriesExpansion&| S |Coef| |Expon| |Var| PS UTS) 
((|constructor| (NIL "Author: Waldek Hebisch"))
 (|apply_taylor|
  ((|#5| |#6| |#5|)
   "\\spad{apply_taylor(g,{} f)} applies \\spad{g} to \\spad{f}"))
 (|applyTaylor|
  ((|#5| (|Mapping| |#6| |#6|) |#5|)
   "\\spad{applyTaylor(g,{} f)} applies \\spad{g} to \\spad{f}"))
 (|taylor_via_lode|
  ((|#5| (|List| |#6|) |#5| (|List| |#2|))
   "\\spad{taylor_via_lode([a0,{} ...,{} ak],{} z,{} [c0,{} ...,{} ck])} expands into Taylor series solution of the linear ordinary differential equation"))
 (|taylor_via_deriv|
  ((|#5| |#5| (|List| |#5|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{taylor_via_deriv(f,{} [x1,{} ...,{} xn],{} [D1,{} ...,{} Dn])} expands \\spad{f} into Taylor series at (\\spad{x1},{} ...,{} \\spad{xn}) using \\spad{D1},{} ...,{} \\spad{Dn} as partial derivatives")
  ((|#5| |#2| (|List| |#5|) (|List| (|Mapping| |#2| |#2|)))
   "\\spad{taylor_via_deriv(f,{} [x1,{} ...,{} xn],{} [D1,{} ...,{} Dn])} expands \\spad{f} into Taylor series at (\\spad{x1},{} ...,{} \\spad{xn}) using \\spad{D1},{} ...,{} \\spad{Dn} as partial derivatives"))) 
NIL 
(|TaylorSeriesExpansion| |Coef| |Expon| |Var| PS UTS) 
((|constructor| (NIL "Author: Waldek Hebisch"))
 (|apply_taylor|
  ((|#4| |#5| |#4|)
   "\\spad{apply_taylor(g,{} f)} applies \\spad{g} to \\spad{f}"))
 (|applyTaylor|
  ((|#4| (|Mapping| |#5| |#5|) |#4|)
   "\\spad{applyTaylor(g,{} f)} applies \\spad{g} to \\spad{f}"))
 (|taylor_via_lode|
  ((|#4| (|List| |#5|) |#4| (|List| |#1|))
   "\\spad{taylor_via_lode([a0,{} ...,{} ak],{} z,{} [c0,{} ...,{} ck])} expands into Taylor series solution of the linear ordinary differential equation"))
 (|taylor_via_deriv|
  ((|#4| |#4| (|List| |#4|) (|List| (|Mapping| |#1| |#1|)))
   "\\spad{taylor_via_deriv(f,{} [x1,{} ...,{} xn],{} [D1,{} ...,{} Dn])} expands \\spad{f} into Taylor series at (\\spad{x1},{} ...,{} \\spad{xn}) using \\spad{D1},{} ...,{} \\spad{Dn} as partial derivatives")
  ((|#4| |#1| (|List| |#4|) (|List| (|Mapping| |#1| |#1|)))
   "\\spad{taylor_via_deriv(f,{} [x1,{} ...,{} xn],{} [D1,{} ...,{} Dn])} expands \\spad{f} into Taylor series at (\\spad{x1},{} ...,{} \\spad{xn}) using \\spad{D1},{} ...,{} \\spad{Dn} as partial derivatives"))) 
NIL 
(|TaylorSeriesExpansionGeneralized| |Coef| |Expon| UPS UTS) 
NIL 
NIL 
(|TaylorSeriesExpansionLaurent| |Coef| UTS ULS) 
NIL 
NIL 
(|TaylorSeriesExpansionPuiseux| |Coef| UTS ULS UPS) 
NIL 
NIL 
(|TaylorSeriesExpansionTaylor| |Coef| UTS) 
NIL 
NIL 
(|TriangularSetCategory&| S R E V P) 
((|constructor|
  (NIL
   "The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \\spad{R} be an integral domain and \\spad{V} a finite ordered set of variables,{} say \\spad{X1 < X2 < ... < Xn}. A set \\spad{S} of polynomials in \\spad{R[X1,{} X2,{} ...,{} Xn]} is triangular if no elements of \\spad{S} lies in \\spad{R},{} and if two distinct elements of \\spad{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \\spad{P} is reduced \\spad{w}.\\spad{r}.\\spad{t} a non-constant polynomial \\spad{Q} if the degree of \\spad{P} in the main variable of \\spad{Q} is less than the main degree of \\spad{Q}. A polynomial \\spad{P} is reduced \\spad{w}.\\spad{r}.\\spad{t} a triangular set \\spad{T} if it is reduced \\spad{w}.\\spad{r}.\\spad{t}. every polynomial of \\spad{T}. \\newline"))
 (|coHeight|
  (((|NonNegativeInteger|) $)
   "\\spad{coHeight(ts)} returns \\spad{size()\\$V} minus \\spad{\\#ts}."))
 (|extend|
  (($ $ |#5|)
   "\\spad{extend(ts,{} p)} returns a triangular set which encodes the simple extension by \\spad{p} of the extension of the base field defined by \\spad{ts},{} according to the properties of triangular sets of the current category If the required properties do not hold an error is returned."))
 (|extendIfCan|
  (((|Union| $ "failed") $ |#5|)
   "\\spad{extendIfCan(ts,{} p)} returns a triangular set which encodes the simple extension by \\spad{p} of the extension of the base field defined by \\spad{ts},{} according to the properties of triangular sets of the current domain. If the required properties do not hold then \"failed\" is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the \\spad{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties."))
 (|select|
  (((|Union| |#5| "failed") $ |#4|)
   "\\spad{select(ts,{} v)} returns the polynomial of \\spad{ts} with \\spad{v} as main variable,{} if any."))
 (|algebraic?|
  (((|Boolean|) |#4| $)
   "\\spad{algebraic?(v,{} ts)} returns \\spad{true} iff \\spad{v} is the main variable of some polynomial in \\spad{ts}."))
 (|algebraicVariables|
  (((|List| |#4|) $)
   "\\spad{algebraicVariables(ts)} returns the decreasingly sorted list of the main variables of the polynomials of \\spad{ts}."))
 (|rest|
  (((|Union| $ "failed") $)
   "\\spad{rest(ts)} returns the polynomials of \\spad{ts} with smaller main variable than \\spad{mvar(ts)} if \\spad{ts} is not empty,{} otherwise returns \"failed\""))
 (|last|
  (((|Union| |#5| "failed") $)
   "\\spad{last(ts)} returns the polynomial of \\spad{ts} with smallest main variable if \\spad{ts} is not empty,{} otherwise returns \\spad{\"failed\"}."))
 (|first|
  (((|Union| |#5| "failed") $)
   "\\spad{first(ts)} returns the polynomial of \\spad{ts} with greatest main variable if \\spad{ts} is not empty,{} otherwise returns \\spad{\"failed\"}."))
 (|zeroSetSplitIntoTriangularSystems|
  (((|List| (|Record| (|:| |close| $) (|:| |open| (|List| |#5|))))
    (|List| |#5|))
   "\\spad{zeroSetSplitIntoTriangularSystems(lp)} returns a list of triangular systems \\spad{[[ts1,{} qs1],{} ...,{} [tsn,{} qsn]]} such that the zero set of \\spad{lp} is the union of the closures of the \\spad{W_i} where \\spad{W_i} consists of the zeros of \\spad{ts} which do not cancel any polynomial in \\spad{qsi}."))
 (|zeroSetSplit|
  (((|List| $) (|List| |#5|))
   "\\spad{zeroSetSplit(lp)} returns a list \\spad{lts} of triangular sets such that the zero set of \\spad{lp} is the union of the closures of the regular zero sets of the members of \\spad{lts}."))
 (|reduceByQuasiMonic|
  ((|#5| |#5| $)
   "\\spad{reduceByQuasiMonic(p,{} ts)} returns the same as \\spad{remainder(p,{} collectQuasiMonic(ts)).polnum}."))
 (|collectQuasiMonic|
  (($ $)
   "\\spad{collectQuasiMonic(ts)} returns the subset of \\spad{ts} consisting of the polynomials with initial in \\spad{R}."))
 (|removeZero|
  ((|#5| |#5| $)
   "\\spad{removeZero(p,{} ts)} returns \\spad{0} if \\spad{p} reduces to \\spad{0} by pseudo-division \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts} otherwise returns a polynomial \\spad{q} computed from \\spad{p} by removing any coefficient in \\spad{p} reducing to \\spad{0}."))
 (|initiallyReduce|
  ((|#5| |#5| $)
   "\\spad{initiallyReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{initiallyReduced?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|headReduce|
  ((|#5| |#5| $)
   "\\spad{headReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{headReduce?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|stronglyReduce|
  ((|#5| |#5| $)
   "\\spad{stronglyReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{stronglyReduced?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|rewriteSetWithReduction|
  (((|List| |#5|) (|List| |#5|) $ (|Mapping| |#5| |#5| |#5|)
    (|Mapping| (|Boolean|) |#5| |#5|))
   "\\spad{rewriteSetWithReduction(lp,{} ts,{} redOp,{} redOp?)} returns a list \\spad{lq} of polynomials such that \\spad{[reduce(p,{} ts,{} redOp,{} redOp?) for p in lp]} and \\spad{lp} have the same zeros inside the regular zero set of \\spad{ts}. Moreover,{} for every polynomial \\spad{q} in \\spad{lq} and every polynomial \\spad{t} in \\spad{ts} \\spad{redOp?(q,{} t)} holds and there exists a polynomial \\spad{p} in the ideal generated by \\spad{lp} and a product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}. The operation \\spad{redOp} must satisfy the following conditions. For every \\spad{p} and \\spad{q} we have \\spad{redOp?(redOp(p,{} q),{} q)} and there exists an integer \\spad{e} and a polynomial \\spad{f} such that \\spad{init(q)^e*p = f*q + redOp(p,{} q)}."))
 (|reduce|
  ((|#5| |#5| $ (|Mapping| |#5| |#5| |#5|) (|Mapping| (|Boolean|) |#5| |#5|))
   "\\spad{reduce(p,{} ts,{} redOp,{} redOp?)} returns a polynomial \\spad{r} such that \\spad{redOp?(r,{} p)} holds for every \\spad{p} of \\spad{ts} and there exists some product \\spad{h} of the initials of the members of \\spad{ts} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}. The operation \\spad{redOp} must satisfy the following conditions. For every \\spad{p} and \\spad{q} we have \\spad{redOp?(redOp(p,{} q),{} q)} and there exists an integer \\spad{e} and a polynomial \\spad{f} such that \\spad{init(q)^e*p = f*q + redOp(p,{} q)}."))
 (|autoReduced?|
  (((|Boolean|) $ (|Mapping| (|Boolean|) |#5| (|List| |#5|)))
   "\\spad{autoReduced?(ts,{} redOp?)} returns \\spad{true} iff every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to every other in the sense of \\spad{redOp?}"))
 (|initiallyReduced?|
  (((|Boolean|) $)
   "\\spad{initiallyReduced?(ts)} returns \\spad{true} iff for every element \\spad{p} of \\spad{ts} \\spad{p} and all its iterated initials are reduced \\spad{w}.\\spad{r}.\\spad{t}. to the other elements of \\spad{ts} with the same main variable.")
  (((|Boolean|) |#5| $)
   "\\spad{initiallyReduced?(p,{} ts)} returns \\spad{true} iff \\spad{p} and all its iterated initials are reduced \\spad{w}.\\spad{r}.\\spad{t}. to the elements of \\spad{ts} with the same main variable."))
 (|headReduced?|
  (((|Boolean|) $)
   "\\spad{headReduced?(ts)} returns \\spad{true} iff the head of every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to any other element of \\spad{ts}.")
  (((|Boolean|) |#5| $)
   "\\spad{headReduced?(p,{} ts)} returns \\spad{true} iff the head of \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|stronglyReduced?|
  (((|Boolean|) $)
   "\\spad{stronglyReduced?(ts)} returns \\spad{true} iff every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to any other element of \\spad{ts}.")
  (((|Boolean|) |#5| $)
   "\\spad{stronglyReduced?(p,{} ts)} returns \\spad{true} iff \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|reduced?|
  (((|Boolean|) |#5| $ (|Mapping| (|Boolean|) |#5| |#5|))
   "\\spad{reduced?(p,{} ts,{} redOp?)} returns \\spad{true} iff \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. in the sense of the operation \\spad{redOp?},{} that is if for every \\spad{t} in \\spad{ts} \\spad{redOp?(p,{} t)} holds."))
 (|normalized?|
  (((|Boolean|) $)
   "\\spad{normalized?(ts)} returns \\spad{true} iff for every \\spad{p} in \\spad{ts} we have \\spad{normalized?(p,{} us)} where \\spad{us} is \\spad{collectUnder(ts,{} mvar(p))}.")
  (((|Boolean|) |#5| $)
   "\\spad{normalized?(p,{} ts)} returns \\spad{true} iff \\spad{p} and all its iterated initials have degree zero \\spad{w}.\\spad{r}.\\spad{t}. the main variables of the polynomials of \\spad{ts}"))
 (|quasiComponent|
  (((|Record| (|:| |close| (|List| |#5|)) (|:| |open| (|List| |#5|))) $)
   "\\spad{quasiComponent(ts)} returns \\spad{[lp,{} lq]} where \\spad{lp} is the list of the members of \\spad{ts} and \\spad{lq}is \\spad{initials(ts)}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(ts)} returns the product of main degrees of the members of \\spad{ts}."))
 (|initials|
  (((|List| |#5|) $)
   "\\spad{initials(ts)} returns the list of the non-constant initials of the members of \\spad{ts}."))
 (|basicSet|
  (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#5|))) "failed")
    (|List| |#5|) (|Mapping| (|Boolean|) |#5|)
    (|Mapping| (|Boolean|) |#5| |#5|))
   "\\spad{basicSet(ps,{} pred?,{} redOp?)} returns the same as \\spad{basicSet(qs,{} redOp?)} where \\spad{qs} consists of the polynomials of \\spad{ps} satisfying property \\spad{pred?}.")
  (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#5|))) "failed")
    (|List| |#5|) (|Mapping| (|Boolean|) |#5| |#5|))
   "\\spad{basicSet(ps,{} redOp?)} returns \\spad{[bs,{} ts]} where \\spad{concat(bs,{} ts)} is \\spad{ps} and \\spad{bs} is a basic set in Wu Wen Tsun sense of \\spad{ps} \\spad{w}.\\spad{r}.\\spad{t} the reduction-test \\spad{redOp?},{} if no non-zero constant polynomial lie in \\spad{ps},{} otherwise \\spad{\"failed\"} is returned."))
 (|infRittWu?|
  (((|Boolean|) $ $)
   "\\spad{infRittWu?(ts1,{} ts2)} returns \\spad{true} iff \\spad{ts2} has higher rank than \\spad{ts1} in Wu Wen Tsun sense."))) 
((|HasCategory| |#4| '(|Finite|))) 
(|TriangularSetCategory| R E V P) 
((|constructor|
  (NIL
   "The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \\spad{R} be an integral domain and \\spad{V} a finite ordered set of variables,{} say \\spad{X1 < X2 < ... < Xn}. A set \\spad{S} of polynomials in \\spad{R[X1,{} X2,{} ...,{} Xn]} is triangular if no elements of \\spad{S} lies in \\spad{R},{} and if two distinct elements of \\spad{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \\spad{P} is reduced \\spad{w}.\\spad{r}.\\spad{t} a non-constant polynomial \\spad{Q} if the degree of \\spad{P} in the main variable of \\spad{Q} is less than the main degree of \\spad{Q}. A polynomial \\spad{P} is reduced \\spad{w}.\\spad{r}.\\spad{t} a triangular set \\spad{T} if it is reduced \\spad{w}.\\spad{r}.\\spad{t}. every polynomial of \\spad{T}. \\newline"))
 (|coHeight|
  (((|NonNegativeInteger|) $)
   "\\spad{coHeight(ts)} returns \\spad{size()\\$V} minus \\spad{\\#ts}."))
 (|extend|
  (($ $ |#4|)
   "\\spad{extend(ts,{} p)} returns a triangular set which encodes the simple extension by \\spad{p} of the extension of the base field defined by \\spad{ts},{} according to the properties of triangular sets of the current category If the required properties do not hold an error is returned."))
 (|extendIfCan|
  (((|Union| $ "failed") $ |#4|)
   "\\spad{extendIfCan(ts,{} p)} returns a triangular set which encodes the simple extension by \\spad{p} of the extension of the base field defined by \\spad{ts},{} according to the properties of triangular sets of the current domain. If the required properties do not hold then \"failed\" is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the \\spad{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties."))
 (|select|
  (((|Union| |#4| "failed") $ |#3|)
   "\\spad{select(ts,{} v)} returns the polynomial of \\spad{ts} with \\spad{v} as main variable,{} if any."))
 (|algebraic?|
  (((|Boolean|) |#3| $)
   "\\spad{algebraic?(v,{} ts)} returns \\spad{true} iff \\spad{v} is the main variable of some polynomial in \\spad{ts}."))
 (|algebraicVariables|
  (((|List| |#3|) $)
   "\\spad{algebraicVariables(ts)} returns the decreasingly sorted list of the main variables of the polynomials of \\spad{ts}."))
 (|rest|
  (((|Union| $ "failed") $)
   "\\spad{rest(ts)} returns the polynomials of \\spad{ts} with smaller main variable than \\spad{mvar(ts)} if \\spad{ts} is not empty,{} otherwise returns \"failed\""))
 (|last|
  (((|Union| |#4| "failed") $)
   "\\spad{last(ts)} returns the polynomial of \\spad{ts} with smallest main variable if \\spad{ts} is not empty,{} otherwise returns \\spad{\"failed\"}."))
 (|first|
  (((|Union| |#4| "failed") $)
   "\\spad{first(ts)} returns the polynomial of \\spad{ts} with greatest main variable if \\spad{ts} is not empty,{} otherwise returns \\spad{\"failed\"}."))
 (|zeroSetSplitIntoTriangularSystems|
  (((|List| (|Record| (|:| |close| $) (|:| |open| (|List| |#4|))))
    (|List| |#4|))
   "\\spad{zeroSetSplitIntoTriangularSystems(lp)} returns a list of triangular systems \\spad{[[ts1,{} qs1],{} ...,{} [tsn,{} qsn]]} such that the zero set of \\spad{lp} is the union of the closures of the \\spad{W_i} where \\spad{W_i} consists of the zeros of \\spad{ts} which do not cancel any polynomial in \\spad{qsi}."))
 (|zeroSetSplit|
  (((|List| $) (|List| |#4|))
   "\\spad{zeroSetSplit(lp)} returns a list \\spad{lts} of triangular sets such that the zero set of \\spad{lp} is the union of the closures of the regular zero sets of the members of \\spad{lts}."))
 (|reduceByQuasiMonic|
  ((|#4| |#4| $)
   "\\spad{reduceByQuasiMonic(p,{} ts)} returns the same as \\spad{remainder(p,{} collectQuasiMonic(ts)).polnum}."))
 (|collectQuasiMonic|
  (($ $)
   "\\spad{collectQuasiMonic(ts)} returns the subset of \\spad{ts} consisting of the polynomials with initial in \\spad{R}."))
 (|removeZero|
  ((|#4| |#4| $)
   "\\spad{removeZero(p,{} ts)} returns \\spad{0} if \\spad{p} reduces to \\spad{0} by pseudo-division \\spad{w}.\\spad{r}.\\spad{t} \\spad{ts} otherwise returns a polynomial \\spad{q} computed from \\spad{p} by removing any coefficient in \\spad{p} reducing to \\spad{0}."))
 (|initiallyReduce|
  ((|#4| |#4| $)
   "\\spad{initiallyReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{initiallyReduced?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|headReduce|
  ((|#4| |#4| $)
   "\\spad{headReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{headReduce?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|stronglyReduce|
  ((|#4| |#4| $)
   "\\spad{stronglyReduce(p,{} ts)} returns a polynomial \\spad{r} such that \\spad{stronglyReduced?(r,{} ts)} holds and there exists some product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}."))
 (|rewriteSetWithReduction|
  (((|List| |#4|) (|List| |#4|) $ (|Mapping| |#4| |#4| |#4|)
    (|Mapping| (|Boolean|) |#4| |#4|))
   "\\spad{rewriteSetWithReduction(lp,{} ts,{} redOp,{} redOp?)} returns a list \\spad{lq} of polynomials such that \\spad{[reduce(p,{} ts,{} redOp,{} redOp?) for p in lp]} and \\spad{lp} have the same zeros inside the regular zero set of \\spad{ts}. Moreover,{} for every polynomial \\spad{q} in \\spad{lq} and every polynomial \\spad{t} in \\spad{ts} \\spad{redOp?(q,{} t)} holds and there exists a polynomial \\spad{p} in the ideal generated by \\spad{lp} and a product \\spad{h} of \\spad{initials(ts)} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}. The operation \\spad{redOp} must satisfy the following conditions. For every \\spad{p} and \\spad{q} we have \\spad{redOp?(redOp(p,{} q),{} q)} and there exists an integer \\spad{e} and a polynomial \\spad{f} such that \\spad{init(q)^e*p = f*q + redOp(p,{} q)}."))
 (|reduce|
  ((|#4| |#4| $ (|Mapping| |#4| |#4| |#4|) (|Mapping| (|Boolean|) |#4| |#4|))
   "\\spad{reduce(p,{} ts,{} redOp,{} redOp?)} returns a polynomial \\spad{r} such that \\spad{redOp?(r,{} p)} holds for every \\spad{p} of \\spad{ts} and there exists some product \\spad{h} of the initials of the members of \\spad{ts} such that \\spad{h*p - r} lies in the ideal generated by \\spad{ts}. The operation \\spad{redOp} must satisfy the following conditions. For every \\spad{p} and \\spad{q} we have \\spad{redOp?(redOp(p,{} q),{} q)} and there exists an integer \\spad{e} and a polynomial \\spad{f} such that \\spad{init(q)^e*p = f*q + redOp(p,{} q)}."))
 (|autoReduced?|
  (((|Boolean|) $ (|Mapping| (|Boolean|) |#4| (|List| |#4|)))
   "\\spad{autoReduced?(ts,{} redOp?)} returns \\spad{true} iff every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to every other in the sense of \\spad{redOp?}"))
 (|initiallyReduced?|
  (((|Boolean|) $)
   "\\spad{initiallyReduced?(ts)} returns \\spad{true} iff for every element \\spad{p} of \\spad{ts} \\spad{p} and all its iterated initials are reduced \\spad{w}.\\spad{r}.\\spad{t}. to the other elements of \\spad{ts} with the same main variable.")
  (((|Boolean|) |#4| $)
   "\\spad{initiallyReduced?(p,{} ts)} returns \\spad{true} iff \\spad{p} and all its iterated initials are reduced \\spad{w}.\\spad{r}.\\spad{t}. to the elements of \\spad{ts} with the same main variable."))
 (|headReduced?|
  (((|Boolean|) $)
   "\\spad{headReduced?(ts)} returns \\spad{true} iff the head of every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to any other element of \\spad{ts}.")
  (((|Boolean|) |#4| $)
   "\\spad{headReduced?(p,{} ts)} returns \\spad{true} iff the head of \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|stronglyReduced?|
  (((|Boolean|) $)
   "\\spad{stronglyReduced?(ts)} returns \\spad{true} iff every element of \\spad{ts} is reduced \\spad{w}.\\spad{r}.\\spad{t} to any other element of \\spad{ts}.")
  (((|Boolean|) |#4| $)
   "\\spad{stronglyReduced?(p,{} ts)} returns \\spad{true} iff \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|reduced?|
  (((|Boolean|) |#4| $ (|Mapping| (|Boolean|) |#4| |#4|))
   "\\spad{reduced?(p,{} ts,{} redOp?)} returns \\spad{true} iff \\spad{p} is reduced \\spad{w}.\\spad{r}.\\spad{t}. in the sense of the operation \\spad{redOp?},{} that is if for every \\spad{t} in \\spad{ts} \\spad{redOp?(p,{} t)} holds."))
 (|normalized?|
  (((|Boolean|) $)
   "\\spad{normalized?(ts)} returns \\spad{true} iff for every \\spad{p} in \\spad{ts} we have \\spad{normalized?(p,{} us)} where \\spad{us} is \\spad{collectUnder(ts,{} mvar(p))}.")
  (((|Boolean|) |#4| $)
   "\\spad{normalized?(p,{} ts)} returns \\spad{true} iff \\spad{p} and all its iterated initials have degree zero \\spad{w}.\\spad{r}.\\spad{t}. the main variables of the polynomials of \\spad{ts}"))
 (|quasiComponent|
  (((|Record| (|:| |close| (|List| |#4|)) (|:| |open| (|List| |#4|))) $)
   "\\spad{quasiComponent(ts)} returns \\spad{[lp,{} lq]} where \\spad{lp} is the list of the members of \\spad{ts} and \\spad{lq}is \\spad{initials(ts)}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(ts)} returns the product of main degrees of the members of \\spad{ts}."))
 (|initials|
  (((|List| |#4|) $)
   "\\spad{initials(ts)} returns the list of the non-constant initials of the members of \\spad{ts}."))
 (|basicSet|
  (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#4|))) "failed")
    (|List| |#4|) (|Mapping| (|Boolean|) |#4|)
    (|Mapping| (|Boolean|) |#4| |#4|))
   "\\spad{basicSet(ps,{} pred?,{} redOp?)} returns the same as \\spad{basicSet(qs,{} redOp?)} where \\spad{qs} consists of the polynomials of \\spad{ps} satisfying property \\spad{pred?}.")
  (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#4|))) "failed")
    (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|))
   "\\spad{basicSet(ps,{} redOp?)} returns \\spad{[bs,{} ts]} where \\spad{concat(bs,{} ts)} is \\spad{ps} and \\spad{bs} is a basic set in Wu Wen Tsun sense of \\spad{ps} \\spad{w}.\\spad{r}.\\spad{t} the reduction-test \\spad{redOp?},{} if no non-zero constant polynomial lie in \\spad{ps},{} otherwise \\spad{\"failed\"} is returned."))
 (|infRittWu?|
  (((|Boolean|) $ $)
   "\\spad{infRittWu?(ts1,{} ts2)} returns \\spad{true} iff \\spad{ts2} has higher rank than \\spad{ts1} in Wu Wen Tsun sense."))) 
NIL 
(|TubePlot| |Curve|) 
((|constructor|
  (NIL
   "\\indented{2}{Package for constructing tubes around 3-dimensional parametric curves.} Domain of tubes around 3-dimensional parametric curves."))
 (|tube|
  (($ |#1| (|List| (|List| (|Point| (|DoubleFloat|)))) (|Boolean|))
   "\\spad{tube(c,{} ll,{} b)} creates a tube of the domain \\spadtype{TubePlot} from a space curve \\spad{c} of the category \\spadtype{PlottableSpaceCurveCategory},{} a list of lists of points (loops) \\spad{ll} and a boolean \\spad{b} which if \\spad{true} indicates a closed tube,{} or if \\spad{false} an open tube."))
 (|setClosed|
  (((|Boolean|) $ (|Boolean|))
   "\\spad{setClosed(t,{} b)} declares the given tube plot \\spad{t} to be closed if \\spad{b} is \\spad{true},{} or if \\spad{b} is \\spad{false},{} \\spad{t} is set to be open."))
 (|open?|
  (((|Boolean|) $)
   "\\spad{open?(t)} tests whether the given tube plot \\spad{t} is open."))
 (|closed?|
  (((|Boolean|) $)
   "\\spad{closed?(t)} tests whether the given tube plot \\spad{t} is closed."))
 (|listLoops|
  (((|List| (|List| (|Point| (|DoubleFloat|)))) $)
   "\\spad{listLoops(t)} returns the list of lists of points,{} or the 'loops',{} of the given tube plot \\spad{t}."))
 (|getCurve|
  ((|#1| $)
   "\\spad{getCurve(t)} returns the \\spadtype{PlottableSpaceCurveCategory} representing the parametric curve of the given tube plot \\spad{t}."))) 
NIL 
(|TubePlotTools|) 
((|constructor|
  (NIL "Tools for constructing tubes around 3-dimensional parametric curves."))
 (|loopPoints|
  (((|List| (|Point| (|DoubleFloat|))) (|Point| (|DoubleFloat|))
    (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|DoubleFloat|)
    (|List| (|List| (|DoubleFloat|))))
   "\\spad{loopPoints(p,{} n,{} b,{} r,{} lls)} creates and returns a list of points which form the loop with radius \\spad{r},{} around the center point indicated by the point \\spad{p},{} with the principal normal vector of the space curve at point \\spad{p} given by the point(vector) \\spad{n},{} and the binormal vector given by the point(vector) \\spad{b},{} and a list of lists,{} \\spad{lls},{} which is the \\spadfun{cosSinInfo} of the number of points defining the loop."))
 (|cosSinInfo|
  (((|List| (|List| (|DoubleFloat|))) (|Integer|))
   "\\spad{cosSinInfo(n)} returns the list of lists of values for \\spad{n},{} in the form: \\spad{[[cos(n - 1) a,{} sin(n - 1) a],{} ...,{} [cos 2 a,{} sin 2 a],{} [cos a,{} sin a]]} where \\spad{a = 2 pi/n}. Note: \\spad{n} should be greater than 2."))
 (|unitVector|
  (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))
   "\\spad{unitVector(p)} creates the unit vector of the point \\spad{p} and returns the result as a point. Note: \\spad{unitVector(p) = p/|p|}."))
 (|cross|
  (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))
    (|Point| (|DoubleFloat|)))
   "\\spad{cross(p,{} q)} computes the cross product of the two points \\spad{p} and \\spad{q} using only the first three coordinates,{} and keeping the color of the first point \\spad{p}. The result is returned as a point."))
 (|dot|
  (((|DoubleFloat|) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))
   "\\spad{dot(p,{} q)} computes the dot product of the two points \\spad{p} and \\spad{q} using only the first three coordinates,{} and returns the resulting \\spadtype{DoubleFloat}."))
 (-
  (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))
    (|Point| (|DoubleFloat|)))
   "\\spad{p - q} computes and returns a point whose coordinates are the differences of the coordinates of two points \\spad{p} and \\spad{q},{} using the color,{} or fourth coordinate,{} of the first point \\spad{p} as the color also of the point \\spad{q}."))
 (+
  (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))
    (|Point| (|DoubleFloat|)))
   "\\spad{p + q} computes and returns a point whose coordinates are the sums of the coordinates of the two points \\spad{p} and \\spad{q},{} using the color,{} or fourth coordinate,{} of the first point \\spad{p} as the color also of the point \\spad{q}."))
 (*
  (((|Point| (|DoubleFloat|)) (|DoubleFloat|) (|Point| (|DoubleFloat|)))
   "\\spad{s * p} returns a point whose coordinates are the scalar multiple of the point \\spad{p} by the scalar \\spad{s},{} preserving the color,{} or fourth coordinate,{} of \\spad{p}."))
 (|point|
  (((|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)
    (|DoubleFloat|))
   "\\spad{point(x1,{} x2,{} x3,{} c)} creates and returns a point from the three specified coordinates \\spad{x1},{} \\spad{x2},{} \\spad{x3},{} and also a fourth coordinate,{} \\spad{c},{} which is generally used to specify the color of the point."))) 
NIL 
(|Tuple| S) 
((|constructor|
  (NIL
   "\\indented{1}{This domain is used to interface with the interpreter\\spad{'s} notion} of comma-delimited sequences of values."))
 (|#|
  (((|NonNegativeInteger|) $)
   "\\spad{\\#(x)} returns the number of elements in tuple \\spad{x}"))
 (|select|
  ((|#1| $ (|NonNegativeInteger|))
   "\\spad{select(x,{} n)} returns the \\spad{n}-th element of tuple \\spad{x}. tuples are 0-based"))
 (|coerce|
  (($ (|PrimitiveArray| |#1|))
   "\\spad{coerce(a)} makes a tuple from primitive array a"))) 
((|HasCategory| |#1| '(|SetCategory|))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))) 
(|TwoFactorize| F) 
((|constructor|
  (NIL
   "A basic package for the factorization of bivariate polynomials over a finite field. The functions here represent the base step for the multivariate factorizer."))
 (|doFactor|
  (((|Factored|
     (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
    (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))
    (|Integer|) (|Boolean|))
   "\\spad{doFactor(p,{} n,{} ext?)} returns the factorisation of polynomial \\spad{p},{} \\spad{p} is assumed to be primitive and squarefree,{} \\spad{n} is degree in auxilary variable,{} ext? if \\spad{false} inhibits use of extension field."))
 (|twoFactor|
  (((|Factored|
     (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
    (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))
    (|Integer|))
   "\\spad{twoFactor(p,{} n)} returns the factorisation of polynomial \\spad{p},{} a sparse univariate polynomial (sup) over a sup over \\spad{F}. Also,{} \\spad{p} is assumed primitive and square-free and \\spad{n} is the degree of the inner variable of \\spad{p} (maximum of the degrees of the coefficients of \\spad{p})."))
 (|tryTwoFactor|
  (((|Factored|
     (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
    (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{tryTwoFactor(p)} returns the factorisation of polynomial \\spad{p},{} if it does not require using field extensions,{} otherwise returns \\spad{p} unfactored (nil factorization)."))
 (|generalTwoFactor|
  (((|Factored|
     (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
    (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)))
   "\\spad{generalTwoFactor(p)} returns the factorisation of polynomial \\spad{p},{} a sparse univariate polynomial (sup) over a sup over \\spad{F}."))) 
NIL 
(|Type|) 
((|constructor| (NIL "The fundamental Type."))) 
NIL 
(|Typed|) 
((|constructor| (NIL "\\indented{1}{name of variable} and type of variable"))) 
NIL 
(|U16Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 16-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|U16Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 16-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|U32Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 32-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|U32Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 32-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|U64Int|) 
((|constructor|
  (NIL
   "Domain of unsigned 64-bit integers. It is used \\indented{1}{to declare that values of local variables fit into 64 bits.}"))) 
NIL 
(|U8Matrix|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 8-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
       (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
          (|HasCategory| (|Integer|) '(|SetCategory|))))
 (|HasCategory| (|Integer|) '(|AbelianGroup|))
 (|HasCategory| (|Integer|) '(|SemiRng|))
 (AND (|HasCategory| (|Integer|) '(|Monoid|))
      (|HasCategory| (|Integer|) '(|SemiRng|)))
 (|HasCategory| (|Integer|) '(|EuclideanDomain|))
 (|HasCategory| (|Integer|) '(|IntegralDomain|))
 (|HasCategory| (|Integer|) '(|CommutativeRing|))
 (|HasCategory| (|Integer|) '(|Field|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|U8Vector|) 
((|constructor|
  (NIL
   "This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 8-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level)."))) 
((|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| (|Integer|) (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|BasicType|))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (|HasCategory| (|Integer|) '(|SetCategory|))
 (AND (|HasCategory| (|Integer|) (LIST '|Evalable| '(|Integer|)))
      (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|BasicType|))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Integer|) '(|Comparable|))
     (|HasCategory| (|Integer|) '(|OrderedSet|))
     (|HasCategory| (|Integer|) '(|SetCategory|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|BasicType|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Integer|) '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) (LIST '|CoercibleTo| '(|OutputForm|))))
 (OR
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|BasicType|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|Comparable|)))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Integer|) '(|OrderedSet|)))
  (|HasCategory| (|Integer|) '(|SetCategory|)))) 
(|UndirectedGraph| S) 
((|constructor| (NIL "allows us to model graph theory \\blankline"))
 (|coerce| (($ (|FinitePoset| |#1|)) "\\spad{coerce FinitePoset} to graph"))
 (|diagramSvg2|
  (((|Void|) (|String|) $ (|Boolean|))
   "diagramSvg(fileName,{} \\spad{n},{} dispArrowName) creates an \\spad{SVG} diagram. This is an alternative version which does not shorten lines. fileName: String is the name of the \\spad{SVG} file that will be created \\spad{n:} \\% is the graph that will be written dispArrowName: Boolean is \\spad{true} to include the name of each arrow"))
 (|closedCartesian|
  (($ $ $ (|Mapping| |#1| |#1| |#1|)) "as Cartesian product but returns \\%."))
 (|closedTensor|
  (($ $ $ (|Mapping| |#1| |#1| |#1|)) "as tensor product but returns \\%."))
 (|cartesian|
  (((|UndirectedGraph| (|Product| |#1| |#1|)) $ $)
   "Cartesian product: the vertex set of \\spad{G} \\spad{o} \\spad{H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}) and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) \\indented{1}{are adjacent in \\spad{G} \\spad{o} \\spad{H} if and only if either} \\spad{u} = \\spad{v} and u' is adjacent with \\spad{v'} in \\spad{H},{} or u' = \\spad{v'} and \\spad{u} is adjacent with \\spad{v} in \\spad{G}."))
 (*
  (((|UndirectedGraph| (|Product| |#1| |#1|)) $ $)
   "tensor product : the tensor product \\spad{G*H} of graphs \\spad{G} and \\spad{H} is a graph such that the vertex set of \\spad{G*H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}); and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) are adjacent in \\spad{G} \\times \\spad{H} if and only if u' is adjacent with \\spad{v'} and \\spad{u} is adjacent with \\spad{v}."))
 (|undirectedGraph|
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "constructor for graph with given objects and adjacency matrix.")
  (($ (|FinitePoset| |#1|))
   "\\spad{undirectedGraph(poset)} constructs graph from a partially ordered set. This will be a graph with,{} at most,{} one arrow between any two nodes (in each direction).")
  (($ (|List| |#1|)
    (|List|
     (|Record| (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)))))
   "\\spad{undirectedGraph(obs,{} ars)} constructs graph with objects \\spad{obs} and arrows ars. This constructor just has pure abstract graph information without decoration information.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "constructor for graph with given objects and arrows more objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|)))))
   "constructor for graph with given objects more objects and arrows can be added later if required.")
  (($ (|List| |#1|))
   "constructor for graph with given list of object names. Use this version of the constructor if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates. more objects and arrows can be added later if required."))) 
NIL 
(|UserDefinedPartialOrdering| S) 
((|constructor|
  (NIL "Provides functions to force a partial ordering on any set."))
 (|more?|
  (((|Boolean|) |#1| |#1|)
   "\\spad{more?(a,{} b)} compares \\spad{a} and \\spad{b} in the partial ordering induced by setOrder,{} and uses the ordering on \\spad{S} if \\spad{a} and \\spad{b} are not comparable in the partial ordering."))
 (|userOrdered?|
  (((|Boolean|))
   "\\spad{userOrdered?()} tests if the partial ordering induced by \\spadfunFrom{setOrder}{UserDefinedPartialOrdering} is not empty."))
 (|largest|
  ((|#1| (|List| |#1|))
   "\\spad{largest l} returns the largest element of \\spad{l} where the partial ordering induced by setOrder is completed into a total one by the ordering on \\spad{S}.")
  ((|#1| (|List| |#1|) (|Mapping| (|Boolean|) |#1| |#1|))
   "\\spad{largest(l,{} fn)} returns the largest element of \\spad{l} where the partial ordering induced by setOrder is completed into a total one by \\spad{fn}."))
 (|less?|
  (((|Boolean|) |#1| |#1| (|Mapping| (|Boolean|) |#1| |#1|))
   "\\spad{less?(a,{} b,{} fn)} compares \\spad{a} and \\spad{b} in the partial ordering induced by setOrder,{} and returns \\spad{fn(a,{} b)} if \\spad{a} and \\spad{b} are not comparable in that ordering.")
  (((|Union| (|Boolean|) "failed") |#1| |#1|)
   "\\spad{less?(a,{} b)} compares \\spad{a} and \\spad{b} in the partial ordering induced by setOrder."))
 (|getOrder|
  (((|Record| (|:| |low| (|List| |#1|)) (|:| |high| (|List| |#1|))))
   "\\spad{getOrder()} returns \\spad{[[b1,{} ...,{} bm],{} [a1,{} ...,{} an]]} such that the partial ordering on \\spad{S} was given by \\spad{setOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])}."))
 (|setOrder|
  (((|Void|) (|List| |#1|) (|List| |#1|))
   "\\spad{setOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])} defines a partial ordering on \\spad{S} given \\spad{by:} \\indented{3}{(1)\\space{2}\\spad{b1 < b2 < ... < bm < a1 < a2 < ... < an}.} \\indented{3}{(2)\\space{2}\\spad{bj < c < \\spad{ai}}\\space{2}for \\spad{c} not among the \\spad{ai}\\spad{'s} and \\spad{bj}\\spad{'s}.} \\indented{3}{(3)\\space{2}undefined on \\spad{(c,{} d)} if neither is among the \\spad{ai}\\spad{'s},{} \\spad{bj}\\spad{'s}.}")
  (((|Void|) (|List| |#1|))
   "\\spad{setOrder([a1,{} ...,{} an])} defines a partial ordering on \\spad{S} given \\spad{by:} \\indented{3}{(1)\\space{2}\\spad{a1 < a2 < ... < an}.} \\indented{3}{(2)\\space{2}\\spad{b < \\spad{ai}\\space{3}for i = 1..n} and \\spad{b} not among the \\spad{ai}\\spad{'s}.} \\indented{3}{(3)\\space{2}undefined on \\spad{(b,{} c)} if neither is among the \\spad{ai}\\spad{'s}.}"))) 
((|HasCategory| |#1| '(|OrderedSet|))) 
(|UserDefinedVariableOrdering|) 
((|constructor|
  (NIL
   "This packages provides functions to allow the user to select the ordering on the variables and operators for displaying polynomials,{} fractions and expressions. The ordering affects the display only and not the computations."))
 (|resetVariableOrder|
  (((|Void|))
   "\\spad{resetVariableOrder()} cancels any previous use of setVariableOrder and returns to the default system ordering."))
 (|getVariableOrder|
  (((|Record| (|:| |high| (|List| (|Symbol|)))
              (|:| |low| (|List| (|Symbol|)))))
   "\\spad{getVariableOrder()} returns \\spad{[[b1,{} ...,{} bm],{} [a1,{} ...,{} an]]} such that the ordering on the variables was given by \\spad{setVariableOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])}."))
 (|setVariableOrder|
  (((|Void|) (|List| (|Symbol|)) (|List| (|Symbol|)))
   "\\spad{setVariableOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])} defines an ordering on the variables given by \\spad{b1 > b2 > ... > bm >} other variables \\spad{> a1 > a2 > ... > an}.")
  (((|Void|) (|List| (|Symbol|)))
   "\\spad{setVariableOrder([a1,{} ...,{} an])} defines an ordering on the variables given by \\spad{a1 > a2 > ... > an > other variables}."))) 
NIL 
(|UniqueFactorizationDomain&| S) 
((|constructor|
  (NIL
   "A constructive unique factorization domain,{} \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements."))
 (|factor|
  (((|Factored| $) $)
   "\\spad{factor(x)} returns the factorization of \\spad{x} into irreducibles."))
 (|squareFreePart|
  (($ $)
   "\\spad{squareFreePart(x)} returns a product of prime factors of \\spad{x} each taken with multiplicity one."))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors."))
 (|prime?|
  (((|Boolean|) $)
   "\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring,{} \\spadignore{i.e.} \\spad{x} is an irreducible element."))) 
NIL 
(|UniqueFactorizationDomain|) 
((|constructor|
  (NIL
   "A constructive unique factorization domain,{} \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements."))
 (|factor|
  (((|Factored| $) $)
   "\\spad{factor(x)} returns the factorization of \\spad{x} into irreducibles."))
 (|squareFreePart|
  (($ $)
   "\\spad{squareFreePart(x)} returns a product of prime factors of \\spad{x} each taken with multiplicity one."))
 (|squareFree|
  (((|Factored| $) $)
   "\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors."))
 (|prime?|
  (((|Boolean|) $)
   "\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring,{} \\spadignore{i.e.} \\spad{x} is an irreducible element."))) 
NIL 
(|UnivariateFormalPowerSeries| |Coef|) 
NIL 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|NonNegativeInteger|) '(|SemiGroup|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|NonNegativeInteger|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|NonNegativeInteger|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))) 
(|UnivariateFormalPowerSeriesFunctions| |Coef|) 
NIL 
NIL 
(|UnitGaussianElimination|) 
((|constructor|
  (NIL
   "Gaussian elimination using only 1 or \\spad{-1} as pivots \\blankline"))
 (|pre_lr|
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Vector| (|Integer|))
    (|Vector| (|Integer|)))
   "\\spad{pre_lr(m,{} \\spad{pi},{} pj)} is like pre_gauss,{} but records positions of pivots in \\spad{pi} and \\spad{pj} and returns transformation matrix. \\spad{m},{} \\spad{pi},{} \\spad{pj} are modified in place"))
 (|pre_smith|
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)))
   "\\spad{pre_smith(m)} first performs pre_gauss(\\spad{m}) and then drops all rows and colums of \\spad{m} contaning pivots."))
 (|pre_gauss|
  (((|Matrix| (|Integer|)) (|Matrix| (|Integer|)))
   "\\spad{pre_gauss(m)} performs Gaussian eliminaton on rows of \\spad{m} using only 1 and \\spad{-1} as pivots. Note: \\spad{m} is modified in place"))) 
NIL 
(|UnivariateLaurentSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Dense Laurent series in one variable \\indented{2}{\\spadtype{UnivariateLaurentSeries} is a domain representing Laurent} \\indented{2}{series in one variable with coefficients in an arbitrary ring.\\space{2}The} \\indented{2}{parameters of the type specify the coefficient ring,{} the power series} \\indented{2}{variable,{} and the center of the power series expansion.\\space{2}For example,{}} \\indented{2}{\\spad{UnivariateLaurentSeries(Integer,{} x,{} 3)} represents Laurent series in} \\indented{2}{\\spad{(x - 3)} with integer coefficients.}"))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a Laurent series."))) 
((|HasCategory| (|Integer|) '(|SemiGroup|)) (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|RetractableTo| '(|Symbol|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|RealConstant|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|OrderedIntegralDomain|)))
 (OR (|HasCategory| |#1| '(|CharacteristicZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicZero|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedIntegralDomain|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|RetractableTo| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|StepThrough|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|InnerEvalable| '(|Symbol|)
                           (LIST '|UnivariateTaylorSeries| (|devaluate| |#1|)
                                 (|devaluate| |#2|) (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|Evalable|
                           (LIST '|UnivariateTaylorSeries| (|devaluate| |#1|)
                                 (|devaluate| |#2|) (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|Eltable|
                           (LIST '|UnivariateTaylorSeries| (|devaluate| |#1|)
                                 (|devaluate| |#2|) (|devaluate| |#3|))
                           (LIST '|UnivariateTaylorSeries| (|devaluate| |#1|)
                                 (|devaluate| |#2|) (|devaluate| |#3|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|LinearlyExplicitOver| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|Integer|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|Integer|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|Comparable|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedIntegralDomain|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedSet|))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|Comparable|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedIntegralDomain|)))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|OrderedSet|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|PolynomialFactorizationExplicit|)))
 (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                '(|CharacteristicNonZero|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicNonZero|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|IntegerNumberSystem|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|EuclideanDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|Integer|)
                             (|devaluate| |#1|))))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasSignature| |#1|
                       (LIST '*
                             (LIST (|devaluate| |#1|) '(|Integer|)
                                   (|devaluate| |#1|)))))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      (LIST '|PartialDifferentialRing| '(|Symbol|)))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                      '(|DifferentialRing|)))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo|
                               (LIST '|Pattern| '(|Integer|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|ConvertibleTo| '(|InputForm|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|Eltable|
                               (LIST '|UnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|))
                               (LIST '|UnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|Evalable|
                               (LIST '|UnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|InnerEvalable| '(|Symbol|)
                               (LIST '|UnivariateTaylorSeries|
                                     (|devaluate| |#1|) (|devaluate| |#2|)
                                     (|devaluate| |#3|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|LinearlyExplicitOver| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|PatternMatchable| '(|Float|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|PatternMatchable| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|RetractableTo| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         (LIST '|RetractableTo| '(|Symbol|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedIntegralDomain|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|PolynomialFactorizationExplicit|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|RealConstant|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|StepThrough|))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| $ '(|CharacteristicNonZero|))
      (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                     '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| $ '(|CharacteristicNonZero|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|PolynomialFactorizationExplicit|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|)
                         '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))) 
(|UnivariateLaurentSeriesFunctions2| |Coef1| |Coef2| |var1| |var2| |cen1|
                                     |cen2|) 
((|constructor|
  (NIL
   "Mapping package for univariate Laurent series \\indented{2}{This package allows one to apply a function to the coefficients of} \\indented{2}{a univariate Laurent series.}"))
 (|map|
  (((|UnivariateLaurentSeries| |#2| |#4| |#6|) (|Mapping| |#2| |#1|)
    (|UnivariateLaurentSeries| |#1| |#3| |#5|))
   "\\spad{map(f,{} g(x))} applies the map \\spad{f} to the coefficients of the Laurent series \\spad{g(x)}."))) 
NIL 
(|UnivariateLaurentSeriesCategory&| S |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable."))
 (|rationalFunction|
  (((|Fraction| (|Polynomial| |#2|)) $ (|Integer|) (|Integer|))
   "\\spad{rationalFunction(f,{} k1,{} k2)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Fraction| (|Polynomial| |#2|)) $ (|Integer|))
   "\\spad{rationalFunction(f,{} k)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{<=} \\spad{k}."))
 (|multiplyCoefficients|
  (($ (|Mapping| |#2| (|Integer|)) $)
   "\\spad{multiplyCoefficients(f,{} sum(n = n0..infinity,{} a[n] * x^n)) = sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Puiseux series are represented by a Laurent series and an exponent."))
 (|laurent|
  (($ (|Integer|) (|Stream| |#2|))
   "\\spad{laurent(n,{} st)} returns \\spad{xn * series st} where \\spad{xn = monomial(1,{} n)} and \\spad{series st} stands for the power series with coefficients given by the stream st."))
 (|series|
  (($ (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#2|))))
   "\\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
((|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|IntegralDomain|))) 
(|UnivariateLaurentSeriesCategory| |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable."))
 (|rationalFunction|
  (((|Fraction| (|Polynomial| |#1|)) $ (|Integer|) (|Integer|))
   "\\spad{rationalFunction(f,{} k1,{} k2)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Fraction| (|Polynomial| |#1|)) $ (|Integer|))
   "\\spad{rationalFunction(f,{} k)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{<=} \\spad{k}."))
 (|multiplyCoefficients|
  (($ (|Mapping| |#1| (|Integer|)) $)
   "\\spad{multiplyCoefficients(f,{} sum(n = n0..infinity,{} a[n] * x^n)) = sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Puiseux series are represented by a Laurent series and an exponent."))
 (|laurent|
  (($ (|Integer|) (|Stream| |#1|))
   "\\spad{laurent(n,{} st)} returns \\spad{xn * series st} where \\spad{xn = monomial(1,{} n)} and \\spad{series st} stands for the power series with coefficients given by the stream st."))
 (|series|
  (($ (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))))
   "\\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
NIL 
(|UnivariateLaurentSeriesConstructorCategory&| S |Coef| UTS) 
((|constructor|
  (NIL
   "This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \\spad{[n,{} f(x)]},{} where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x^n * f(x)}."))
 (|taylorIfCan|
  (((|Union| |#3| "failed") $)
   "\\spad{taylorIfCan(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series,{} if possible. If this is not possible,{} \"failed\" is returned."))
 (|taylor|
  ((|#3| $)
   "\\spad{taylor(f(x))} converts the Laurent series \\spad{f}(\\spad{x}) to a Taylor series,{} if possible. Error: if this is not possible."))
 (|coerce|
  (($ |#3|)
   "\\spad{coerce(f(x))} converts the Taylor series \\spad{f(x)} to a Laurent series."))
 (|removeZeroes|
  (($ (|Integer|) $)
   "\\spad{removeZeroes(n,{} f(x))} removes up to \\spad{n} leading zeroes from the Laurent series \\spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable.")
  (($ $)
   "\\spad{removeZeroes(f(x))} removes leading zeroes from the representation of the Laurent series \\spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable. Note: \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f}"))
 (|taylorRep|
  ((|#3| $)
   "\\spad{taylorRep(f(x))} returns \\spad{g(x)},{} where \\spad{f = x^n * g(x)} is represented by \\spad{[n,{} g(x)]}."))
 (|degree|
  (((|Integer|) $)
   "\\spad{degree(f(x))} returns the degree of the lowest order term of \\spad{f(x)},{} which may have zero as a coefficient."))
 (|laurent|
  (($ (|Integer|) |#3|)
   "\\spad{laurent(n,{} f(x))} returns \\spad{x^n * f(x)}."))) 
((|HasCategory| |#2| '(|Field|))) 
(|UnivariateLaurentSeriesConstructorCategory| |Coef| UTS) 
((|constructor|
  (NIL
   "This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \\spad{[n,{} f(x)]},{} where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x^n * f(x)}."))
 (|taylorIfCan|
  (((|Union| |#2| "failed") $)
   "\\spad{taylorIfCan(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series,{} if possible. If this is not possible,{} \"failed\" is returned."))
 (|taylor|
  ((|#2| $)
   "\\spad{taylor(f(x))} converts the Laurent series \\spad{f}(\\spad{x}) to a Taylor series,{} if possible. Error: if this is not possible."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(f(x))} converts the Taylor series \\spad{f(x)} to a Laurent series."))
 (|removeZeroes|
  (($ (|Integer|) $)
   "\\spad{removeZeroes(n,{} f(x))} removes up to \\spad{n} leading zeroes from the Laurent series \\spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable.")
  (($ $)
   "\\spad{removeZeroes(f(x))} removes leading zeroes from the representation of the Laurent series \\spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable. Note: \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f}"))
 (|taylorRep|
  ((|#2| $)
   "\\spad{taylorRep(f(x))} returns \\spad{g(x)},{} where \\spad{f = x^n * g(x)} is represented by \\spad{[n,{} g(x)]}."))
 (|degree|
  (((|Integer|) $)
   "\\spad{degree(f(x))} returns the degree of the lowest order term of \\spad{f(x)},{} which may have zero as a coefficient."))
 (|laurent|
  (($ (|Integer|) |#2|)
   "\\spad{laurent(n,{} f(x))} returns \\spad{x^n * f(x)}."))) 
NIL 
(|UnivariateLaurentSeriesConstructor| |Coef| UTS) 
((|constructor|
  (NIL
   "This package enables one to construct a univariate Laurent series domain from a univariate Taylor series domain. Univariate Laurent series are represented by a pair \\spad{[n,{} f(x)]},{} where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x^n * f(x)}."))) 
((|HasCategory| (|Integer|) '(|SemiGroup|)) (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|RealConstant|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| '(|OrderedIntegralDomain|)))
 (OR (|HasCategory| |#1| '(|CharacteristicZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|CharacteristicZero|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|OrderedIntegralDomain|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|StepThrough|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#2|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|Eltable| (|devaluate| |#2|) (|devaluate| |#2|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2|
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
 (|HasCategory| (|Integer|) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|Integer|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|Integer|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|Comparable|)))
 (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|OrderedSet|)))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| |#2| '(|OrderedIntegralDomain|)))
  (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|OrderedSet|))))
 (OR (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|OrderedIntegralDomain|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|OrderedSet|))))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|CharacteristicNonZero|))))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| '(|IntegerNumberSystem|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| '(|EuclideanDomain|)))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2|
                         (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2|
                         (LIST '|ConvertibleTo|
                               (LIST '|Pattern| '(|Integer|)))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2|
                         (LIST '|Eltable| (|devaluate| |#2|)
                               (|devaluate| |#2|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2|
                         (LIST '|InnerEvalable| '(|Symbol|)
                               (|devaluate| |#2|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|))))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| (LIST '|RetractableTo| '(|Symbol|))))
     (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|Comparable|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|OrderedIntegralDomain|)))
     (AND (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#2| '(|OrderedSet|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|RealConstant|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|StepThrough|))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|Integer|)
                             (|devaluate| |#1|))))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasSignature| |#1|
                       (LIST '*
                             (LIST (|devaluate| |#1|) '(|Integer|)
                                   (|devaluate| |#1|)))))
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))))
 (OR
  (AND (|HasCategory| |#1| '(|Field|))
       (|HasCategory| |#2| '(|DifferentialRing|)))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|Field|))
      (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|CharacteristicNonZero|)))
     (AND (|HasCategory| |#1| '(|Field|))
          (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|Integer|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|Integer|)
                                 (|devaluate| |#1|)))))) 
(|UniversalSegment| S) 
((|constructor|
  (NIL
   "This domain provides segments which may be half open. That is,{} ranges of the form \\spad{a..} or \\spad{a..b}."))
 (|hasHi|
  (((|Boolean|) $)
   "\\spad{hasHi(s)} tests whether the segment \\spad{s} has an upper bound."))
 (|coerce|
  (($ (|Segment| |#1|))
   "\\spad{coerce(x)} allows \\spadtype{Segment} values to be used as \\%."))
 (|segment|
  (($ |#1|)
   "\\spad{segment(l)} is an alternate way to construct the segment \\spad{l..}."))
 (SEGMENT
  (($ |#1|)
   "\\spad{l..} produces a half open segment,{} that is,{} one with no upper bound."))) 
((|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#1| '(|OrderedRing|)) (|HasCategory| |#1| '(|SetCategory|))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (|HasCategory| |#1| '(|AbelianGroup|))) 
(|UniversalSegmentFunctions2| R S) 
((|constructor|
  (NIL
   "This package provides operations for mapping functions onto segments."))
 (|map|
  (((|Stream| |#2|) (|Mapping| |#2| |#1|) (|UniversalSegment| |#1|))
   "\\spad{map(f,{} s)} expands the segment \\spad{s},{} applying \\spad{f} to each value.")
  (((|UniversalSegment| |#2|) (|Mapping| |#2| |#1|) (|UniversalSegment| |#1|))
   "\\spad{map(f,{} seg)} returns the new segment obtained by applying \\spad{f} to the endpoints of seg."))) 
((|HasCategory| |#1| '(|OrderedRing|))) 
(|Untyped|) 
((|constructor|
  (NIL
   "\\indented{1}{At the moment an untyped variable is represented by a string} representing the name of the variable. So why wrap it in a Record structure. The main reason is because \\spad{I} am planning to expand this as explained in the text part of this pamphlet. Also it seems like a good idea to keep a similar structure to typed variables. Also \\spad{I} could not get it to work unwrapped. \\spad{I} vaguely recall that \\spad{I} couldn\\spad{'t} get the constructor to return an unwrapped value,{} but it may have been some other issue and that\\spad{'s} not the main reason."))) 
NIL 
(|UnivariatePolynomial| |x| R) 
((|constructor|
  (NIL
   "This domain represents univariate polynomials in some symbol over arbitrary (not necessarily commutative) coefficient rings. The representation is sparse in the sense that only non-zero terms are represented."))
 (|coerce|
  (($ (|Variable| |#1|))
   "\\spad{coerce(x)} converts the variable \\spad{x} to a univariate polynomial."))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| |#2| '(|canonicalUnitNormal|))
 (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
 (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| '(|InputForm|)))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| '(|InputForm|))))
 (|HasCategory| |#2| '(|SemiRing|)) (|HasCategory| |#2| '(|Field|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|EntireRing|))
 (|HasCategory| |#2| '(|GcdDomain|))
 (OR (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|GcdDomain|)))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (OR (|HasCategory| |#2| '(|CommutativeRing|)) (|HasCategory| |#2| '(|Field|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|)))
 (OR (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|)))
 (|HasCategory| |#2| '(|StepThrough|))
 (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
     (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (|HasCategory| |#2| '(|CharacteristicZero|))
     (|HasCategory| |#2| '(|CommutativeRing|))
     (|HasCategory| |#2| '(|EntireRing|)) (|HasCategory| |#2| '(|Field|))
     (|HasCategory| |#2| '(|GcdDomain|))
     (|HasCategory| |#2| '(|IntegralDomain|))
     (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
     (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (OR (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#2|
                    (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|)))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Float|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Float|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Float|)))))
 (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|PatternMatchable| '(|Integer|))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
       (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicNonZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CharacteristicZero|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Field|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|GcdDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|))))
  (AND (|HasCategory| |#2| (LIST '|PatternMatchable| '(|Integer|)))
       (|HasCategory| |#2| '(|Ring|))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|PatternMatchable| '(|Integer|)))))
 (AND (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
      (|HasCategory| |#2| '(|Ring|))
      (|HasCategory| (|SingletonAsOrderedSet|)
                     (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Float|))))))
 (AND
  (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
  (|HasCategory| |#2| '(|Ring|))
  (|HasCategory| (|SingletonAsOrderedSet|)
                 (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| |#2|
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
       (|HasCategory| (|SingletonAsOrderedSet|)
                      (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|LinearlyExplicitOver| '(|Integer|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicNonZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CharacteristicZero|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|CommutativeRing|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Field|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|GcdDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|IntegralDomain|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|)))))
  (AND
   (|HasCategory| |#2| (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))
   (|HasCategory| |#2| '(|Ring|))
   (|HasCategory| (|SingletonAsOrderedSet|)
                  (LIST '|ConvertibleTo| (LIST '|Pattern| '(|Integer|))))))
 (AND (|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasCategory| |#2| '(|Ring|)))
 (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
 (OR
  (AND (|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#2| '(|AbelianGroup|))
  (|HasCategory| |#2| '(|AbelianMonoid|))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (|HasCategory| |#2| '(|CancellationAbelianMonoid|)))
 (|HasCategory| $ '(|CommutativeRing|))
 (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
      (|HasCategory| $ '(|CharacteristicNonZero|)))
 (OR (|HasCategory| |#2| '(|CharacteristicNonZero|))
     (AND (|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))
          (|HasCategory| $ '(|CharacteristicNonZero|))))
 (OR (|HasCategory| |#2| '(|EntireRing|))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|GcdDomain|))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR (|HasCategory| |#2| (LIST '|RetractableTo| '(|Integer|)))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| |#2| '(|Ring|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|SemiRing|)))
 (OR
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#2| '(|Ring|)))
 (OR (|HasCategory| |#2| '(|AbelianMonoid|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|)))
 (OR
  (AND (|HasCategory| |#2| '(|AbelianGroup|))
       (|HasCategory| |#2| '(|CommutativeRing|)))
  (|HasCategory| |#2| '(|CancellationAbelianMonoid|))
  (AND (|HasCategory| |#2| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#2| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| $ '(|AbelianGroup|)))
 (OR (|HasCategory| |#2| '(|AbelianGroup|))
     (AND (|HasCategory| |#2| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#2| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|)))) 
(|UnivariatePolynomialFunctions2| |x| R |y| S) 
((|constructor|
  (NIL
   "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from \\spadtype{UnivariatePolynomial}(\\spad{x},{} \\spad{R}) to \\spadtype{UnivariatePolynomial}(\\spad{y},{} \\spad{S}). Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial."))
 (|map|
  (((|UnivariatePolynomial| |#3| |#4|) (|Mapping| |#4| |#2|)
    (|UnivariatePolynomial| |#1| |#2|))
   "\\spad{map(func,{} poly)} creates a new polynomial by applying \\spad{func} to every non-zero coefficient of the polynomial poly."))) 
NIL 
(|UnivariatePolynomialCommonDenominator| R Q UP) 
NIL 
NIL 
(|UnivariatePolynomialDecompositionPackage| R UP) 
((|constructor|
  (NIL
   "UnivariatePolynomialDecompositionPackage implements functional decomposition of univariate polynomial with coefficients in an \\spad{IntegralDomain} of \\spad{CharacteristicZero}."))
 (|completeDecompose|
  (((|List| |#2|) |#2|)
   "\\spad{completeDecompose(f)} returns a list of factors of \\spad{f} for the functional decomposition of \\spad{f}. [\\spad{f1},{} ...,{} \\spad{fn}] means \\spad{f} = \\spad{f1} \\spad{o} ... \\spad{o} \\spad{fn}."))
 (|decomposeIfCan|
  (((|Union| (|Record| (|:| |left| |#2|) (|:| |right| |#2|)) "failed") |#2|)
   "\\spad{decomposeIfCan(f)} returns a functional decomposition of the polynomial \\spad{f} or \"failed\" if it has not found any."))
 (|monicCompleteDecompose|
  (((|List| |#2|) |#2|)
   "\\spad{monicCompleteDecompose(f)} returns a list of factors of \\spad{f} for the functional decomposition of monic polynomial \\spad{f}. [\\spad{f1},{} ...,{} \\spad{fn}] means \\spad{f} = \\spad{f1} \\spad{o} ... \\spad{o} \\spad{fn}."))
 (|monicDecomposeIfCan|
  (((|Union| (|Record| (|:| |left| |#2|) (|:| |right| |#2|)) "failed") |#2|)
   "\\spad{monicDecomposeIfCan(f)} returns a functional decomposition of the monic polynomial \\spad{f} or \"failed\" if it has not found any."))
 (|leftFactorIfCan|
  (((|Union| |#2| "failed") |#2| |#2|)
   "\\spad{leftFactorIfCan(f,{} h)} returns the left factor (\\spad{g} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h}) of the functional decomposition of the polynomial \\spad{f} with given \\spad{h} or \\spad{\"failed\"} if \\spad{g} does not exist."))
 (|rightFactorIfCan|
  (((|Union| |#2| "failed") |#2| (|NonNegativeInteger|) |#1|)
   "\\spad{rightFactorIfCan(f,{} d,{} c)} returns a candidate to be the right factor (\\spad{h} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h}) of degree \\spad{d} with leading coefficient \\spad{c} of a functional decomposition of the polynomial \\spad{f} or \\spad{\"failed\"} if no such candidate."))
 (|monicRightFactorIfCan|
  (((|Union| |#2| "failed") |#2| (|NonNegativeInteger|))
   "\\spad{monicRightFactorIfCan(f,{} d)} returns a candidate to be the monic right factor (\\spad{h} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h}) of degree \\spad{d} of a functional decomposition of the polynomial \\spad{f} or \\spad{\"failed\"} if no such candidate."))) 
((|HasCategory| |#1| '(|Field|))) 
(|UnivariatePolynomialDivisionPackage| R UP) 
((|constructor|
  (NIL
   "UnivariatePolynomialDivisionPackage provides a division for non monic univarite polynomials with coefficients in an \\spad{IntegralDomain}."))
 (|divideIfCan|
  (((|Union| (|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) "failed")
    |#2| |#2|)
   "\\spad{divideIfCan(f,{} g)} returns quotient and remainder of the division of \\spad{f} by \\spad{g} or \"failed\" if it has not succeeded."))) 
NIL 
(|UnivariatePolynomialMultiplicationPackage| R U) 
((|constructor|
  (NIL
   "This package implements Karatsuba\\spad{'s} trick for multiplying (large) univariate polynomials. It could be improved with a version doing the work on place and also with a special case for squares. We've done this in Basicmath,{} but we believe that this out of the scope of FriCAS."))
 (|karatsuba|
  ((|#2| |#2| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{karatsuba(a,{} b,{} l,{} k)} returns \\spad{a*b} by applying Karatsuba\\spad{'s} trick provided that both \\spad{a} and \\spad{b} have at least \\spad{l} terms and \\spad{k > 0} holds and by calling \\spad{noKaratsuba} otherwise. The other multiplications are performed by recursive calls with the same third argument and \\spad{k-1} as fourth argument."))
 (|karatsubaOnce|
  ((|#2| |#2| |#2|)
   "\\spad{karatsuba(a,{} b)} returns \\spad{a*b} by applying Karatsuba\\spad{'s} trick once. The other multiplications are performed by calling \\spad{*} from \\spad{U}."))
 (|noKaratsuba|
  ((|#2| |#2| |#2|)
   "\\spad{noKaratsuba(a,{} b)} returns \\spad{a*b} without using Karatsuba\\spad{'s} trick at all."))) 
NIL 
(|UnivariatePolynomialCategory&| S R) 
((|constructor|
  (NIL
   "The category of univariate polynomials over a ring \\spad{R}. No particular model is assumed - implementations can be either sparse or dense."))
 (|integrate|
  (($ $)
   "\\spad{integrate(p)} integrates the univariate polynomial \\spad{p} with respect to its distinguished variable."))
 (|separate|
  (((|Record| (|:| |primePart| $) (|:| |commonPart| $)) $ $)
   "\\spad{separate(p,{} q)} returns \\spad{[a,{} b]} such that \\spad{p = a b},{} \\spad{a} is relatively prime to \\spad{q} and \\spad{b} divides some power of \\spad{q}."))
 (|pseudoDivide|
  (((|Record| (|:| |coef| |#2|) (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{pseudoDivide(p,{} q)} returns \\spad{[c,{} s,{} r]},{} when \\spad{p' := p*lc(q)^(deg p - deg q + 1) = c * p} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|pseudoQuotient|
  (($ $ $)
   "\\spad{pseudoQuotient(p,{} q)} returns \\spad{s},{} the quotient when \\spad{p' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|composite|
  (((|Union| (|Fraction| $) "failed") (|Fraction| $) $)
   "\\spad{composite(f,{} q)} returns \\spad{h} if \\spad{f} = \\spad{h}(\\spad{q}),{} and \"failed\" is no such \\spad{h} exists.")
  (((|Union| $ "failed") $ $)
   "\\spad{composite(p,{} q)} returns \\spad{h} if \\spad{p = h(q)},{} and \"failed\" no such \\spad{h} exists."))
 (|subResultantGcd|
  (($ $ $)
   "\\spad{subResultantGcd(p,{} q)} computes the \\spad{gcd} of the polynomials \\spad{p} and \\spad{q} using the SubResultant \\spad{GCD} algorithm."))
 (|order|
  (((|NonNegativeInteger|) $ $)
   "\\spad{order(p,{} q)} returns the largest \\spad{n} such that \\spad{q^n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}."))
 (|elt|
  ((|#2| (|Fraction| $) |#2|)
   "\\spad{elt(a,{} r)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by the constant \\spad{r}.")
  (((|Fraction| $) (|Fraction| $) (|Fraction| $))
   "\\spad{elt(a,{} b)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by \\spad{b}."))
 (|resultant|
  ((|#2| $ $)
   "\\spad{resultant(p,{} q)} returns the resultant of the polynomials \\spad{p} and \\spad{q}."))
 (|discriminant|
  ((|#2| $)
   "\\spad{discriminant(p)} returns the discriminant of the polynomial \\spad{p}."))
 (|differentiate|
  (($ $ (|Mapping| |#2| |#2|) $)
   "\\spad{differentiate(p,{} d,{} x')} extends the \\spad{R}-derivation \\spad{d} to an extension \\spad{D} in \\spad{R[x]} where \\spad{Dx} is given by \\spad{x'},{} and returns \\spad{Dp}."))
 (|pseudoRemainder|
  (($ $ $)
   "\\spad{pseudoRemainder(p,{} q)} = \\spad{r},{} for polynomials \\spad{p} and \\spad{q},{} returns the remainder \\spad{r} when \\spad{p' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|shiftRight|
  (($ $ (|NonNegativeInteger|))
   "\\spad{shiftRight(p,{} n)} returns \\spad{monicDivide(p,{} monomial(1,{} n)).quotient}"))
 (|karatsubaDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ (|NonNegativeInteger|))
   "\\spad{karatsubaDivide(p,{} n)} returns the same as \\spad{monicDivide(p,{} monomial(1,{} n))}"))
 (|monicDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicDivide(p,{} q)} divide the polynomial \\spad{p} by the monic polynomial \\spad{q},{} returning the pair \\spad{[quotient,{} remainder]}. Error: if \\spad{q} isn\\spad{'t} monic."))
 (|shiftLeft|
  (($ $ (|NonNegativeInteger|))
   "\\spad{shiftLeft(p,{} n)} returns \\spad{p * monomial(1,{} n)}"))
 (|divideExponents|
  (((|Union| $ "failed") $ (|NonNegativeInteger|))
   "\\spad{divideExponents(p,{} n)} returns a new polynomial resulting from dividing all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n},{} or \"failed\" if some exponent is not exactly divisible by \\spad{n}."))
 (|multiplyExponents|
  (($ $ (|NonNegativeInteger|))
   "\\spad{multiplyExponents(p,{} n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n}."))
 (|unmakeSUP|
  (($ (|SparseUnivariatePolynomial| |#2|))
   "\\spad{unmakeSUP(sup)} converts \\spad{sup} of type \\spadtype{SparseUnivariatePolynomial(R)} to be a member of the given type. Note: converse of makeSUP."))
 (|makeSUP|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{makeSUP(p)} converts the polynomial \\spad{p} to be of type SparseUnivariatePolynomial over the same coefficients."))
 (|unvectorise|
  (($ (|Vector| |#2|))
   "\\spad{unvectorise(v)} returns the polynomial which has for coefficients the entries of \\spad{v} in the increasing order."))
 (|vectorise|
  (((|Vector| |#2|) $ (|NonNegativeInteger|))
   "\\spad{vectorise(p,{} n)} returns \\spad{[a0,{} ...,{} a(n-1)]} where \\spad{p = a0 + a1*x + ... + a(n-1)*x^(n-1)} + higher order terms. The degree of polynomial \\spad{p} can be different from \\spad{n-1}."))
 (|additiveValuation|
  ((|attribute|)
   "euclideanSize(a*b) = euclideanSize(a) + euclideanSize(\\spad{b})"))) 
((|HasCategory| |#2| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#2| '(|Field|)) (|HasCategory| |#2| '(|GcdDomain|))
 (|HasCategory| |#2| '(|IntegralDomain|))
 (|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|StepThrough|)) (|HasCategory| |#2| '(|Ring|))) 
(|UnivariatePolynomialCategory| R) 
((|constructor|
  (NIL
   "The category of univariate polynomials over a ring \\spad{R}. No particular model is assumed - implementations can be either sparse or dense."))
 (|integrate|
  (($ $)
   "\\spad{integrate(p)} integrates the univariate polynomial \\spad{p} with respect to its distinguished variable."))
 (|separate|
  (((|Record| (|:| |primePart| $) (|:| |commonPart| $)) $ $)
   "\\spad{separate(p,{} q)} returns \\spad{[a,{} b]} such that \\spad{p = a b},{} \\spad{a} is relatively prime to \\spad{q} and \\spad{b} divides some power of \\spad{q}."))
 (|pseudoDivide|
  (((|Record| (|:| |coef| |#1|) (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{pseudoDivide(p,{} q)} returns \\spad{[c,{} s,{} r]},{} when \\spad{p' := p*lc(q)^(deg p - deg q + 1) = c * p} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|pseudoQuotient|
  (($ $ $)
   "\\spad{pseudoQuotient(p,{} q)} returns \\spad{s},{} the quotient when \\spad{p' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|composite|
  (((|Union| (|Fraction| $) "failed") (|Fraction| $) $)
   "\\spad{composite(f,{} q)} returns \\spad{h} if \\spad{f} = \\spad{h}(\\spad{q}),{} and \"failed\" is no such \\spad{h} exists.")
  (((|Union| $ "failed") $ $)
   "\\spad{composite(p,{} q)} returns \\spad{h} if \\spad{p = h(q)},{} and \"failed\" no such \\spad{h} exists."))
 (|subResultantGcd|
  (($ $ $)
   "\\spad{subResultantGcd(p,{} q)} computes the \\spad{gcd} of the polynomials \\spad{p} and \\spad{q} using the SubResultant \\spad{GCD} algorithm."))
 (|order|
  (((|NonNegativeInteger|) $ $)
   "\\spad{order(p,{} q)} returns the largest \\spad{n} such that \\spad{q^n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}."))
 (|elt|
  ((|#1| (|Fraction| $) |#1|)
   "\\spad{elt(a,{} r)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by the constant \\spad{r}.")
  (((|Fraction| $) (|Fraction| $) (|Fraction| $))
   "\\spad{elt(a,{} b)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by \\spad{b}."))
 (|resultant|
  ((|#1| $ $)
   "\\spad{resultant(p,{} q)} returns the resultant of the polynomials \\spad{p} and \\spad{q}."))
 (|discriminant|
  ((|#1| $)
   "\\spad{discriminant(p)} returns the discriminant of the polynomial \\spad{p}."))
 (|differentiate|
  (($ $ (|Mapping| |#1| |#1|) $)
   "\\spad{differentiate(p,{} d,{} x')} extends the \\spad{R}-derivation \\spad{d} to an extension \\spad{D} in \\spad{R[x]} where \\spad{Dx} is given by \\spad{x'},{} and returns \\spad{Dp}."))
 (|pseudoRemainder|
  (($ $ $)
   "\\spad{pseudoRemainder(p,{} q)} = \\spad{r},{} for polynomials \\spad{p} and \\spad{q},{} returns the remainder \\spad{r} when \\spad{p' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \\spad{q},{} \\spadignore{i.e.} \\spad{p' = s q + r}."))
 (|shiftRight|
  (($ $ (|NonNegativeInteger|))
   "\\spad{shiftRight(p,{} n)} returns \\spad{monicDivide(p,{} monomial(1,{} n)).quotient}"))
 (|karatsubaDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ (|NonNegativeInteger|))
   "\\spad{karatsubaDivide(p,{} n)} returns the same as \\spad{monicDivide(p,{} monomial(1,{} n))}"))
 (|monicDivide|
  (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $)
   "\\spad{monicDivide(p,{} q)} divide the polynomial \\spad{p} by the monic polynomial \\spad{q},{} returning the pair \\spad{[quotient,{} remainder]}. Error: if \\spad{q} isn\\spad{'t} monic."))
 (|shiftLeft|
  (($ $ (|NonNegativeInteger|))
   "\\spad{shiftLeft(p,{} n)} returns \\spad{p * monomial(1,{} n)}"))
 (|divideExponents|
  (((|Union| $ "failed") $ (|NonNegativeInteger|))
   "\\spad{divideExponents(p,{} n)} returns a new polynomial resulting from dividing all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n},{} or \"failed\" if some exponent is not exactly divisible by \\spad{n}."))
 (|multiplyExponents|
  (($ $ (|NonNegativeInteger|))
   "\\spad{multiplyExponents(p,{} n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n}."))
 (|unmakeSUP|
  (($ (|SparseUnivariatePolynomial| |#1|))
   "\\spad{unmakeSUP(sup)} converts \\spad{sup} of type \\spadtype{SparseUnivariatePolynomial(R)} to be a member of the given type. Note: converse of makeSUP."))
 (|makeSUP|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{makeSUP(p)} converts the polynomial \\spad{p} to be of type SparseUnivariatePolynomial over the same coefficients."))
 (|unvectorise|
  (($ (|Vector| |#1|))
   "\\spad{unvectorise(v)} returns the polynomial which has for coefficients the entries of \\spad{v} in the increasing order."))
 (|vectorise|
  (((|Vector| |#1|) $ (|NonNegativeInteger|))
   "\\spad{vectorise(p,{} n)} returns \\spad{[a0,{} ...,{} a(n-1)]} where \\spad{p = a0 + a1*x + ... + a(n-1)*x^(n-1)} + higher order terms. The degree of polynomial \\spad{p} can be different from \\spad{n-1}."))
 (|additiveValuation|
  ((|attribute|)
   "euclideanSize(a*b) = euclideanSize(a) + euclideanSize(\\spad{b})"))) 
NIL 
(|UnivariatePolynomialCategoryFunctions2| R PR S PS) 
((|constructor|
  (NIL
   "Mapping from polynomials over \\spad{R} to polynomials over \\spad{S} given a map from \\spad{R} to \\spad{S} assumed to send zero to zero."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} p)} takes a function \\spad{f} from \\spad{R} to \\spad{S},{} and applies it to each (non-zero) coefficient of a polynomial \\spad{p} over \\spad{R},{} getting a new polynomial over \\spad{S}. Note: since the map is not applied to zero elements,{} it may map zero to zero."))) 
NIL 
(|UnivariatePowerSeriesCategory&| S |Coef| |Expon|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents."))
 (|eval|
  (((|Stream| |#2|) $ |#2|)
   "\\spad{eval(f,{} a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums."))
 (|extend|
  (($ $ |#3|)
   "\\spad{extend(f,{} n)} causes all terms of \\spad{f} of degree \\spad{<=} \\spad{n} to be computed."))
 (|approximate|
  ((|#2| $ |#3|)
   "\\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain."))
 (|truncate|
  (($ $ |#3| |#3|)
   "\\spad{truncate(f,{} k1,{} k2)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (($ $ |#3|)
   "\\spad{truncate(f,{} k)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|order|
  ((|#3| $ |#3|)
   "\\spad{order(f,{} n) = min(m,{} n)},{} where \\spad{m} is the degree of the lowest order non-zero term in \\spad{f}.")
  ((|#3| $)
   "\\spad{order(f)} is the degree of the lowest order non-zero term in \\spad{f}. This will result in an infinite loop if \\spad{f} has no non-zero terms."))
 (|multiplyExponents|
  (($ $ (|PositiveInteger|))
   "\\spad{multiplyExponents(f,{} n)} multiplies all exponents of the power series \\spad{f} by the positive integer \\spad{n}."))
 (|center|
  ((|#2| $)
   "\\spad{center(f)} returns the point about which the series \\spad{f} is expanded."))
 (|variable|
  (((|Symbol|) $)
   "\\spad{variable(f)} returns the (unique) power series variable of the power series \\spad{f}."))
 (|elt|
  ((|#2| $ |#3|)
   "\\spad{elt(f(x),{} r)} returns the coefficient of the term of degree \\spad{r} in \\spad{f(x)}. This is the same as the function \\spadfun{coefficient}."))
 (|terms|
  (((|Stream| (|Record| (|:| |k| |#3|) (|:| |c| |#2|))) $)
   "\\spad{terms(f(x))} returns a stream of non-zero terms,{} where a a term is an exponent-coefficient pair. The terms in the stream are ordered by increasing order of exponents. Warning: If the series \\spad{f} has only finitely many non-zero terms,{} then accessing the resulting stream might lead to an infinite search for the next non-zero coefficient."))) 
((|HasCategory| |#2| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (|HasSignature| |#2|
                 (LIST '*
                       (LIST (|devaluate| |#2|) (|devaluate| |#3|)
                             (|devaluate| |#2|))))
 (|HasCategory| |#3| '(|SemiGroup|))
 (|HasSignature| |#2|
                 (LIST '^
                       (LIST (|devaluate| |#2|) (|devaluate| |#2|)
                             (|devaluate| |#3|))))
 (|HasSignature| |#2| (LIST '|coerce| (LIST (|devaluate| |#2|) '(|Symbol|))))) 
(|UnivariatePowerSeriesCategory| |Coef| |Expon|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents."))
 (|eval|
  (((|Stream| |#1|) $ |#1|)
   "\\spad{eval(f,{} a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums."))
 (|extend|
  (($ $ |#2|)
   "\\spad{extend(f,{} n)} causes all terms of \\spad{f} of degree \\spad{<=} \\spad{n} to be computed."))
 (|approximate|
  ((|#1| $ |#2|)
   "\\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain."))
 (|truncate|
  (($ $ |#2| |#2|)
   "\\spad{truncate(f,{} k1,{} k2)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (($ $ |#2|)
   "\\spad{truncate(f,{} k)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|order|
  ((|#2| $ |#2|)
   "\\spad{order(f,{} n) = min(m,{} n)},{} where \\spad{m} is the degree of the lowest order non-zero term in \\spad{f}.")
  ((|#2| $)
   "\\spad{order(f)} is the degree of the lowest order non-zero term in \\spad{f}. This will result in an infinite loop if \\spad{f} has no non-zero terms."))
 (|multiplyExponents|
  (($ $ (|PositiveInteger|))
   "\\spad{multiplyExponents(f,{} n)} multiplies all exponents of the power series \\spad{f} by the positive integer \\spad{n}."))
 (|center|
  ((|#1| $)
   "\\spad{center(f)} returns the point about which the series \\spad{f} is expanded."))
 (|variable|
  (((|Symbol|) $)
   "\\spad{variable(f)} returns the (unique) power series variable of the power series \\spad{f}."))
 (|elt|
  ((|#1| $ |#2|)
   "\\spad{elt(f(x),{} r)} returns the coefficient of the term of degree \\spad{r} in \\spad{f(x)}. This is the same as the function \\spadfun{coefficient}."))
 (|terms|
  (((|Stream| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))) $)
   "\\spad{terms(f(x))} returns a stream of non-zero terms,{} where a a term is an exponent-coefficient pair. The terms in the stream are ordered by increasing order of exponents. Warning: If the series \\spad{f} has only finitely many non-zero terms,{} then accessing the resulting stream might lead to an infinite search for the next non-zero coefficient."))) 
NIL 
(|UnivariatePolynomialSquareFree| RC P) 
((|constructor|
  (NIL
   "This package provides for square-free decomposition of univariate polynomials over arbitrary rings,{} \\spadignore{i.e.} a partial factorization such that each factor is a product of irreducibles with multiplicity one and the factors are pairwise relatively prime. If the ring has characteristic zero,{} the result is guaranteed to satisfy this condition. If the ring is an infinite ring of finite characteristic,{} then it may not be possible to decide when polynomials contain factors which are \\spad{p}th powers. In this case,{} the flag associated with that polynomial is set to \"nil\" (meaning that that polynomials are not guaranteed to be square-free)."))
 (|BumInSepFFE|
  (((|Record| (|:| |flag| (|Union| #1="nil" #2="sqfr" #3="irred" #4="prime"))
              (|:| |factor| |#2|) (|:| |exponent| (|NonNegativeInteger|)))
    (|Record| (|:| |flag| (|Union| #1# #2# #3# #4#)) (|:| |factor| |#2|)
              (|:| |exponent| (|NonNegativeInteger|))))
   "\\spad{BumInSepFFE(f)} is a local function,{} exported only because it has multiple conditional definitions."))
 (|squareFreePart|
  ((|#2| |#2|)
   "\\spad{squareFreePart(p)} returns a polynomial which has the same irreducible factors as the univariate polynomial \\spad{p},{} but each factor has multiplicity one."))
 (|squareFree|
  (((|Factored| |#2|) |#2|)
   "\\spad{squareFree(p)} computes the square-free factorization of the univariate polynomial \\spad{p}. Each factor has no repeated roots,{} and the factors are pairwise relatively prime."))
 (|gcd|
  (($ $ $)
   "\\spad{gcd(p,{} q)} computes the greatest-common-divisor of \\spad{p} and \\spad{q}."))) 
NIL 
(|UnivariatePuiseuxSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Dense Puiseux series in one variable \\indented{2}{\\spadtype{UnivariatePuiseuxSeries} is a domain representing Puiseux} \\indented{2}{series in one variable with coefficients in an arbitrary ring.\\space{2}The} \\indented{2}{parameters of the type specify the coefficient ring,{} the power series} \\indented{2}{variable,{} and the center of the power series expansion.\\space{2}For example,{}} \\indented{2}{\\spad{UnivariatePuiseuxSeries(Integer,{} x,{} 3)} represents Puiseux series in} \\indented{2}{\\spad{(x - 3)} with \\spadtype{Integer} coefficients.}"))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (LIST '|Fraction| '(|Integer|))
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|)
                                  (LIST '|Fraction| '(|Integer|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Fraction| (|Integer|)) '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (LIST '|Fraction| '(|Integer|)))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|)))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))) 
(|UnivariatePuiseuxSeriesFunctions2| |Coef1| |Coef2| |var1| |var2| |cen1|
                                     |cen2|) 
((|constructor|
  (NIL
   "Mapping package for univariate Puiseux series. This package allows one to apply a function to the coefficients of a univariate Puiseux series."))
 (|map|
  (((|UnivariatePuiseuxSeries| |#2| |#4| |#6|) (|Mapping| |#2| |#1|)
    (|UnivariatePuiseuxSeries| |#1| |#3| |#5|))
   "\\spad{map(f,{} g(x))} applies the map \\spad{f} to the coefficients of the Puiseux series \\spad{g(x)}."))) 
NIL 
(|UnivariatePuiseuxSeriesCategory| |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariatePuiseuxSeriesCategory} is the category of Puiseux series in one variable."))
 (|multiplyExponents|
  (($ $ (|Fraction| (|Integer|)))
   "\\spad{multiplyExponents(f,{} r)} multiplies all exponents of the power series \\spad{f} by the positive rational number \\spad{r}."))
 (|series|
  (($ (|NonNegativeInteger|)
    (|Stream| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#1|))))
   "\\spad{series(n,{} st)} creates a series from a common denomiator and a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents and \\spad{n} should be a common denominator for the exponents in the stream of terms."))) 
NIL 
(|UnivariatePuiseuxSeriesConstructorCategory&| S |Coef| ULS) 
((|constructor|
  (NIL
   "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,{} f(x)]},{} where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}."))
 (|laurentIfCan|
  (((|Union| |#3| "failed") $)
   "\\spad{laurentIfCan(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. If this is not possible,{} \"failed\" is returned."))
 (|laurent|
  ((|#3| $)
   "\\spad{laurent(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. Error: if this is not possible."))
 (|coerce|
  (($ |#3|)
   "\\spad{coerce(f(x))} converts the Laurent series \\spad{f(x)} to a Puiseux series."))
 (|degree|
  (((|Fraction| (|Integer|)) $)
   "\\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \\spad{f(x)},{} which may have zero as a coefficient."))
 (|laurentRep|
  ((|#3| $)
   "\\spad{laurentRep(f(x))} returns \\spad{g(x)} where the Puiseux series \\spad{f(x) = g(x^r)} is represented by \\spad{[r,{} g(x)]}."))
 (|rationalPower|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rationalPower(f(x))} returns \\spad{r} where the Puiseux series \\spad{f(x) = g(x^r)}."))
 (|puiseux|
  (($ (|Fraction| (|Integer|)) |#3|)
   "\\spad{puiseux(r,{} f(x))} returns \\spad{f(x^r)}."))) 
NIL 
(|UnivariatePuiseuxSeriesConstructorCategory| |Coef| ULS) 
((|constructor|
  (NIL
   "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,{} f(x)]},{} where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}."))
 (|laurentIfCan|
  (((|Union| |#2| "failed") $)
   "\\spad{laurentIfCan(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. If this is not possible,{} \"failed\" is returned."))
 (|laurent|
  ((|#2| $)
   "\\spad{laurent(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. Error: if this is not possible."))
 (|coerce|
  (($ |#2|)
   "\\spad{coerce(f(x))} converts the Laurent series \\spad{f(x)} to a Puiseux series."))
 (|degree|
  (((|Fraction| (|Integer|)) $)
   "\\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \\spad{f(x)},{} which may have zero as a coefficient."))
 (|laurentRep|
  ((|#2| $)
   "\\spad{laurentRep(f(x))} returns \\spad{g(x)} where the Puiseux series \\spad{f(x) = g(x^r)} is represented by \\spad{[r,{} g(x)]}."))
 (|rationalPower|
  (((|Fraction| (|Integer|)) $)
   "\\spad{rationalPower(f(x))} returns \\spad{r} where the Puiseux series \\spad{f(x) = g(x^r)}."))
 (|puiseux|
  (($ (|Fraction| (|Integer|)) |#2|)
   "\\spad{puiseux(r,{} f(x))} returns \\spad{f(x^r)}."))) 
NIL 
(|UnivariatePuiseuxSeriesConstructor| |Coef| ULS) 
((|constructor|
  (NIL
   "This package enables one to construct a univariate Puiseux series domain from a univariate Laurent series domain. Univariate Puiseux series are represented by a pair \\spad{[r,{} f(x)]},{} where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}."))) 
((|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) (LIST '|Fraction| '(|Integer|))
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|)
                                  (LIST '|Fraction| '(|Integer|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|Fraction| (|Integer|)) '(|SemiGroup|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|Field|))
 (|HasCategory| (|Fraction| (|Integer|)) '(|Comparable|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|)))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             (LIST '|Fraction| '(|Integer|)))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|)))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR (|HasCategory| |#1| '(|Field|))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Field|))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|)
                              (LIST '|Fraction| '(|Integer|))
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|)
                                 (LIST '|Fraction| '(|Integer|))
                                 (|devaluate| |#1|)))))) 
(|UnivariatePuiseuxSeriesWithExponentialSingularity| R FE |var| |cen|) 
((|constructor|
  (NIL
   "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent functions with essential singularities. Objects in this domain are sums,{} where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series. Thus,{} the elements of this domain are sums of expressions of the form \\spad{g(x) * exp(f(x))},{} where \\spad{g}(\\spad{x}) is a univariate Puiseux series and \\spad{f}(\\spad{x}) is a univariate Puiseux series with no terms of non-negative degree."))
 (|dominantTerm|
  (((|Union|
     (|Record|
      (|:| |%term|
           (|Record| (|:| |%coef| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|))
                     (|:| |%expon|
                          (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3|
                                                                  |#4|))
                     (|:| |%expTerms|
                          (|List|
                           (|Record| (|:| |k| (|Fraction| (|Integer|)))
                                     (|:| |c| |#2|))))))
      (|:| |%type| (|String|)))
     "failed")
    $)
   "\\spad{dominantTerm(f(var))} returns the term that dominates the limiting behavior of \\spad{f(var)} as \\spad{var -> cen+} together with a \\spadtype{String} which briefly describes that behavior. The value of the \\spadtype{String} will be \\spad{\"zero\"} (resp. \\spad{\"infinity\"}) if the term tends to zero (resp. infinity) exponentially and will \\spad{\"series\"} if the term is a Puiseux series."))
 (|limitPlus|
  (((|Union| (|OrderedCompletion| |#2|) "failed") $)
   "\\spad{limitPlus(f(var))} returns \\spad{limit(var -> cen+,{} f(var))}."))) 
((|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                '(|CharacteristicNonZero|))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                '(|CharacteristicZero|))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                '(|CommutativeRing|))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                (LIST '|RetractableTo| '(|Integer|)))
 (|HasCategory| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)
                '(|Comparable|))
 (AND
  (|HasCategory| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)
                 '(|Comparable|))
  (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) '(|Comparable|)))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) '(|Field|))
 (OR
  (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                 (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
  (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)
                 (LIST '|RetractableTo| (LIST '|Fraction| '(|Integer|)))))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) '(|Ring|))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) '(|EntireRing|))
 (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) '(|GcdDomain|))
 (|HasCategory| $ '(|CommutativeRing|))) 
(|UnaryRecursiveAggregate&| A S) 
((|constructor|
  (NIL
   "A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \\spadfun{value} of the list designating the head,{} or \\spadfun{first},{} of the list,{} and the child designating the tail,{} or \\spadfun{rest},{} of the list. Since these aggregates are recursive aggregates,{} they may be cyclic."))
 (|split!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{split!(u,{} n)} splits \\spad{u} into two aggregates: \\spad{v = rest(u,{} n)} and \\spad{w = first(u,{} n)},{} returning \\spad{v} and setting \\spad{u} to \\spad{w}. If \\spad{n} is 0,{} split! currently only works for Stream and gives error for List. Note: afterwards \\spad{rest(u,{} n)} returns \\spad{empty()}."))
 (|setlast!|
  ((|#2| $ |#2|)
   "\\spad{setlast!(u,{} x)} destructively changes the last element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|qsetrest!|
  (($ $ $)
   "\\spad{qsetrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v} without checking for errors."))
 (|setrest!|
  (($ $ $)
   "\\spad{setrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v}. Error if \\spad{u} is empty."))
 (|setelt!|
  ((|#2| $ "last" |#2|)
   "\\spad{setelt!(u,{} \"last\",{} x)} (also written: \\spad{u.last := x}) is equivalent to \\spad{setlast!(u,{} x)}.")
  (($ $ "rest" $)
   "\\spad{setelt!(u,{} \"rest\",{} v)} (also written: \\spad{u.rest := v}) is equivalent to \\spad{setrest!(u,{} v)}.")
  ((|#2| $ "first" |#2|)
   "\\spad{setelt!(u,{} \"first\",{} x)} (also written: \\spad{u.first := x}) is equivalent to \\spad{setfirst!(u,{} x)}."))
 (|qsetfirst!|
  ((|#2| $ |#2|)
   "\\spad{qsetfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x} without checking for errors."))
 (|setfirst!|
  ((|#2| $ |#2|)
   "\\spad{setfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|cycleSplit!|
  (($ $)
   "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or empty() if none exists. For example,{} if \\spad{w = concat(u,{} v)} is the cyclic list where \\spad{v} is the head of the cycle,{} \\spad{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to \\spad{u},{} and returning \\spad{v}."))
 (|concat!|
  (($ (|List| $))
   "\\spad{concat!(lu)},{} where \\spad{lu} is a list of aggregates \\spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \\spad{a} followed by those of \\spad{b} followed ... by the elements of \\spad{c}. This function may destructively modify the aggregates in \\spad{lu}.")
  (($ $ |#2|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}. Note: \\spad{concat!(a,{} x) = concat!(a,{} [x])}.")
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively concatenates \\spad{v} to the end of \\spad{u}."))
 (|cycleTail|
  (($ $)
   "\\spad{cycleTail(u)} returns the last node in the cycle,{} or empty() if none exists."))
 (|cycleLength|
  (((|NonNegativeInteger|) $)
   "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \\spad{u},{} or 0 if \\spad{u} has no such cycle."))
 (|cycleEntry|
  (($ $)
   "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \\spad{u},{} or \\spad{empty()} if none exists."))
 (|third|
  ((|#2| $)
   "\\spad{third(u)} returns the third element of \\spad{u}. Note: \\spad{third(u) = first(rest(rest(u)))}."))
 (|second|
  ((|#2| $)
   "\\spad{second(u)} returns the second element of \\spad{u}. Note: \\spad{second(u) = first(rest(u))}."))
 (|tail|
  (($ $)
   "\\spad{tail(u)} returns the last node of \\spad{u}. Error if \\spad{u} is empty."))
 (|last|
  (($ $ (|NonNegativeInteger|))
   "\\spad{last(u,{} n)} returns a copy of the last \\spad{n} nodes of \\spad{u}. Note: \\spad{last(u,{} n)} is a list of \\spad{n} elements.")
  ((|#2| $)
   "\\spad{last(u)} returns the last element of \\spad{u}. Note: for lists,{} \\spad{last(u) = u.(maxIndex u)}."))
 (|rest|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rest(u,{} n)} returns the \\spad{n}th node of \\spad{u}. Note: \\spad{rest(u,{} 0) = u}.")
  (($ $)
   "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently,{} the next node of \\spad{u})."))
 (|elt|
  ((|#2| $ "last")
   "\\spad{elt(u,{} \"last\")} (also written: \\spad{u.last}) is equivalent to last(\\spad{u}).")
  (($ $ "rest")
   "\\spad{elt(\\%,{} \"rest\")} (also written: \\spad{u.rest}) is equivalent to \\spad{rest u}.")
  ((|#2| $ "first")
   "\\spad{elt(u,{} \"first\")} (also written: \\spad{u.first}) is equivalent to first(\\spad{u})."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}.")
  ((|#2| $)
   "\\spad{first(u)} returns the first element of \\spad{u} (equivalently,{} the value at the current node)."))
 (|concat|
  (($ |#2| $)
   "\\spad{concat(x,{} u)} returns aggregate consisting of \\spad{x} followed by the elements of \\spad{u}. Note: if \\spad{v = concat(x,{} u)} then \\spad{x = first v} and \\spad{u = rest v}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: \\spad{v = rest(w,{} \\#u)}."))) 
((|HasCategory| |#1| '(|shallowlyMutable|))) 
(|UnaryRecursiveAggregate| S) 
((|constructor|
  (NIL
   "A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \\spadfun{value} of the list designating the head,{} or \\spadfun{first},{} of the list,{} and the child designating the tail,{} or \\spadfun{rest},{} of the list. Since these aggregates are recursive aggregates,{} they may be cyclic."))
 (|split!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{split!(u,{} n)} splits \\spad{u} into two aggregates: \\spad{v = rest(u,{} n)} and \\spad{w = first(u,{} n)},{} returning \\spad{v} and setting \\spad{u} to \\spad{w}. If \\spad{n} is 0,{} split! currently only works for Stream and gives error for List. Note: afterwards \\spad{rest(u,{} n)} returns \\spad{empty()}."))
 (|setlast!|
  ((|#1| $ |#1|)
   "\\spad{setlast!(u,{} x)} destructively changes the last element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|qsetrest!|
  (($ $ $)
   "\\spad{qsetrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v} without checking for errors."))
 (|setrest!|
  (($ $ $)
   "\\spad{setrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v}. Error if \\spad{u} is empty."))
 (|setelt!|
  ((|#1| $ "last" |#1|)
   "\\spad{setelt!(u,{} \"last\",{} x)} (also written: \\spad{u.last := x}) is equivalent to \\spad{setlast!(u,{} x)}.")
  (($ $ "rest" $)
   "\\spad{setelt!(u,{} \"rest\",{} v)} (also written: \\spad{u.rest := v}) is equivalent to \\spad{setrest!(u,{} v)}.")
  ((|#1| $ "first" |#1|)
   "\\spad{setelt!(u,{} \"first\",{} x)} (also written: \\spad{u.first := x}) is equivalent to \\spad{setfirst!(u,{} x)}."))
 (|qsetfirst!|
  ((|#1| $ |#1|)
   "\\spad{qsetfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x} without checking for errors."))
 (|setfirst!|
  ((|#1| $ |#1|)
   "\\spad{setfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|cycleSplit!|
  (($ $)
   "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or empty() if none exists. For example,{} if \\spad{w = concat(u,{} v)} is the cyclic list where \\spad{v} is the head of the cycle,{} \\spad{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to \\spad{u},{} and returning \\spad{v}."))
 (|concat!|
  (($ (|List| $))
   "\\spad{concat!(lu)},{} where \\spad{lu} is a list of aggregates \\spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \\spad{a} followed by those of \\spad{b} followed ... by the elements of \\spad{c}. This function may destructively modify the aggregates in \\spad{lu}.")
  (($ $ |#1|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}. Note: \\spad{concat!(a,{} x) = concat!(a,{} [x])}.")
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively concatenates \\spad{v} to the end of \\spad{u}."))
 (|cycleTail|
  (($ $)
   "\\spad{cycleTail(u)} returns the last node in the cycle,{} or empty() if none exists."))
 (|cycleLength|
  (((|NonNegativeInteger|) $)
   "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \\spad{u},{} or 0 if \\spad{u} has no such cycle."))
 (|cycleEntry|
  (($ $)
   "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \\spad{u},{} or \\spad{empty()} if none exists."))
 (|third|
  ((|#1| $)
   "\\spad{third(u)} returns the third element of \\spad{u}. Note: \\spad{third(u) = first(rest(rest(u)))}."))
 (|second|
  ((|#1| $)
   "\\spad{second(u)} returns the second element of \\spad{u}. Note: \\spad{second(u) = first(rest(u))}."))
 (|tail|
  (($ $)
   "\\spad{tail(u)} returns the last node of \\spad{u}. Error if \\spad{u} is empty."))
 (|last|
  (($ $ (|NonNegativeInteger|))
   "\\spad{last(u,{} n)} returns a copy of the last \\spad{n} nodes of \\spad{u}. Note: \\spad{last(u,{} n)} is a list of \\spad{n} elements.")
  ((|#1| $)
   "\\spad{last(u)} returns the last element of \\spad{u}. Note: for lists,{} \\spad{last(u) = u.(maxIndex u)}."))
 (|rest|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rest(u,{} n)} returns the \\spad{n}th node of \\spad{u}. Note: \\spad{rest(u,{} 0) = u}.")
  (($ $)
   "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently,{} the next node of \\spad{u})."))
 (|elt|
  ((|#1| $ "last")
   "\\spad{elt(u,{} \"last\")} (also written: \\spad{u.last}) is equivalent to last(\\spad{u}).")
  (($ $ "rest")
   "\\spad{elt(\\%,{} \"rest\")} (also written: \\spad{u.rest}) is equivalent to \\spad{rest u}.")
  ((|#1| $ "first")
   "\\spad{elt(u,{} \"first\")} (also written: \\spad{u.first}) is equivalent to first(\\spad{u})."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}.")
  ((|#1| $)
   "\\spad{first(u)} returns the first element of \\spad{u} (equivalently,{} the value at the current node)."))
 (|concat|
  (($ |#1| $)
   "\\spad{concat(x,{} u)} returns aggregate consisting of \\spad{x} followed by the elements of \\spad{u}. Note: if \\spad{v = concat(x,{} u)} then \\spad{x = first v} and \\spad{u = rest v}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: \\spad{v = rest(w,{} \\#u)}."))) 
NIL 
(|UnivariateTaylorSeries| |Coef| |var| |cen|) 
((|constructor|
  (NIL
   "Dense Taylor series in one variable \\spadtype{UnivariateTaylorSeries} is a domain representing Taylor series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring,{} the power series variable,{} and the center of the power series expansion. For example,{} \\spadtype{UnivariateTaylorSeries}(Integer,{} \\spad{x},{} 3) represents Taylor series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients."))
 (|integrate|
  (($ $ (|Variable| |#2|))
   "\\spad{integrate(f(x),{} x)} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers."))
 (|invmultisect|
  (($ (|Integer|) (|Integer|) $)
   "\\spad{invmultisect(a,{} b,{} f(x))} substitutes \\spad{x^((a+b)*n)} \\indented{1}{for \\spad{x^n} and multiples by \\spad{x^b}.}"))
 (|multisect|
  (($ (|Integer|) (|Integer|) $)
   "\\spad{multisect(a,{} b,{} f(x))} selects the coefficients of \\indented{1}{\\spad{x^((a+b)*n+a)},{} and changes this monomial to \\spad{x^n}.}"))
 (|revert|
  (($ $)
   "\\spad{revert(f(x))} returns a Taylor series \\spad{g(x)} such that \\spad{f(g(x)) = g(f(x)) = x}. Series \\spad{f(x)} should have constant coefficient 0 and invertible 1st order coefficient."))
 (|generalLambert|
  (($ $ (|Integer|) (|Integer|))
   "\\spad{generalLambert(f(x),{} a,{} d)} returns \\spad{f(x^a) + f(x^(a + d)) + \\indented{1}{f(x^(a + 2 d)) + ... }. \\spad{f(x)} should have zero constant} \\indented{1}{coefficient and \\spad{a} and \\spad{d} should be positive.}"))
 (|evenlambert|
  (($ $)
   "\\spad{evenlambert(f(x))} returns \\spad{f(x^2) + f(x^4) + f(x^6) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1,{} then} \\indented{1}{\\spad{product(n=1..infinity,{} f(x^(2*n))) = exp(evenlambert(log(f(x))))}.}"))
 (|oddlambert|
  (($ $)
   "\\spad{oddlambert(f(x))} returns \\spad{f(x) + f(x^3) + f(x^5) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1,{} then} \\indented{1}{\\spad{product(n=1..infinity,{} f(x^(2*n-1)))=exp(oddlambert(log(f(x))))}.}"))
 (|lambert|
  (($ $)
   "\\spad{lambert(f(x))} returns \\spad{f(x) + f(x^2) + f(x^3) + ...}. \\indented{1}{\\spad{f(x)} should have zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1,{} then} \\indented{1}{\\spad{product(n = 1..infinity,{} f(x^n)) = exp(lambert(log(f(x))))}.}"))
 (|lagrange|
  (($ $)
   "\\spad{lagrange(g(x))} produces the Taylor series for \\spad{f(x)} \\indented{1}{where \\spad{f(x)} is implicitly defined as \\spad{f(x) = x*g(f(x))}.}"))
 (|differentiate|
  (($ $ (|Variable| |#2|))
   "\\spad{differentiate(f(x),{} x)} computes the derivative of \\spad{f(x)} with respect to \\spad{x}."))
 (|univariatePolynomial|
  (((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|))
   "\\spad{univariatePolynomial(f,{} k)} returns a univariate polynomial \\indented{1}{consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}.}"))
 (|coerce|
  (($ (|Variable| |#2|))
   "\\spad{coerce(var)} converts the series variable \\spad{var} into a \\indented{1}{Taylor series.}")
  (($ (|UnivariatePolynomial| |#2| |#1|))
   "\\spad{coerce(p)} converts a univariate polynomial \\spad{p} in the variable \\spad{var} to a univariate Taylor series in \\spad{var}."))) 
((|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|CharacteristicNonZero|))
 (|HasCategory| |#1| '(|CharacteristicZero|))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)))
 (|HasSignature| |#1|
                 (LIST '*
                       (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                             (|devaluate| |#1|))))
 (AND (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
      (|HasSignature| |#1|
                      (LIST '*
                            (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                  (|devaluate| |#1|)))))
 (|HasCategory| (|NonNegativeInteger|) '(|SemiGroup|))
 (|HasCategory| (|NonNegativeInteger|) '(|Comparable|))
 (|HasSignature| |#1|
                 (LIST '^
                       (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                             '(|NonNegativeInteger|))))
 (AND
  (|HasSignature| |#1|
                  (LIST '^
                        (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                              '(|NonNegativeInteger|))))
  (|HasSignature| |#1| (LIST '|coerce| (LIST (|devaluate| |#1|) '(|Symbol|)))))
 (|HasCategory| |#1| '(|SemiRing|))
 (OR (|HasCategory| |#1| '(|SemiRing|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Ring|))
 (OR (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
     (|HasCategory| |#1| '(|CharacteristicNonZero|))
     (|HasCategory| |#1| '(|CharacteristicZero|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#1| '(|Ring|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|AbelianMonoid|))
 (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR
  (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
       (|HasCategory| (|Fraction| (|Integer|)) '(|AbelianMonoid|)))
  (|HasCategory| |#1| '(|AbelianGroup|))
  (|HasCategory| |#1| '(|AbelianMonoid|))
  (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (AND (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|))))
      (|HasSignature| |#1|
                      (LIST '|integrate|
                            (LIST (|devaluate| |#1|) (|devaluate| |#1|)
                                  '(|Symbol|))))
      (|HasSignature| |#1|
                      (LIST '|variables|
                            (LIST (LIST '|List| '(|Symbol|))
                                  (|devaluate| |#1|)))))
 (|HasCategory| |#1| '(|Field|))
 (AND (|HasCategory| |#1| '(|IntegralDomain|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (AND (|HasCategory| |#1| '(|CommutativeRing|))
      (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|SemiRing|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR
  (AND (|HasCategory| |#1| '(|CommutativeRing|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (AND (|HasCategory| |#1| '(|IntegralDomain|))
       (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
  (|HasCategory| |#1| '(|Ring|))
  (|HasSignature| |#1|
                  (LIST '*
                        (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                              (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianMonoid|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|CancellationAbelianMonoid|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (AND (|HasCategory| |#1| '(|CommutativeRing|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (AND (|HasCategory| |#1| '(|IntegralDomain|))
          (|HasCategory| $ '(|VariablesCommuteWithCoefficients|)))
     (|HasCategory| $ '(|AbelianGroup|))
     (|HasSignature| |#1|
                     (LIST '*
                           (LIST (|devaluate| |#1|) '(|NonNegativeInteger|)
                                 (|devaluate| |#1|)))))) 
(|UnivariateTaylorSeriesFunctions2| |Coef1| |Coef2| UTS1 UTS2) 
((|constructor|
  (NIL
   "Mapping package for univariate Taylor series. \\indented{2}{This package allows one to apply a function to the coefficients of} \\indented{2}{a univariate Taylor series.}"))
 (|map|
  ((|#4| (|Mapping| |#2| |#1|) |#3|)
   "\\spad{map(f,{} g(x))} applies the map \\spad{f} to the coefficients of \\indented{1}{the Taylor series \\spad{g(x)}.}"))) 
NIL 
(|UnivariateTaylorSeriesCategory&| S |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable."))
 (^
  (($ $ |#2|)
   "\\spad{f(x) ^ a} computes a power of a power series. When the coefficient ring is a field,{} we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1."))
 (|polynomial|
  (((|Polynomial| |#2|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Polynomial| |#2|) $ (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|multiplyCoefficients|
  (($ (|Mapping| |#2| (|Integer|)) $)
   "\\spad{multiplyCoefficients(f,{} sum(n = 0..infinity,{} a[n] * x^n))} returns \\spad{sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Laurent series are represented by a Taylor series and an order."))
 (|quoByVar|
  (($ $)
   "\\spad{quoByVar(a0 + a1 x + a2 x^2 + ...)} returns \\spad{a1 + a2 x + a3 x^2 + ...} Thus,{} this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order."))
 (|coefficients|
  (((|Stream| |#2|) $)
   "\\spad{coefficients(a0 + a1 x + a2 x^2 + ...)} returns a stream of coefficients: \\spad{[a0,{} a1,{} a2,{} ...]}. The entries of the stream may be zero."))
 (|series|
  (($ (|Stream| |#2|))
   "\\spad{series([a0,{} a1,{} a2,{} ...])} is the Taylor series \\spad{a0 + a1 x + a2 x^2 + ...}.")
  (($ (|Stream| (|Record| (|:| |k| (|NonNegativeInteger|)) (|:| |c| |#2|))))
   "\\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
((|HasCategory| |#2| '(|Field|))) 
(|UnivariateTaylorSeriesCategory| |Coef|) 
((|constructor|
  (NIL
   "\\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable."))
 (^
  (($ $ |#1|)
   "\\spad{f(x) ^ a} computes a power of a power series. When the coefficient ring is a field,{} we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1."))
 (|polynomial|
  (((|Polynomial| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 <= d <= k2}.")
  (((|Polynomial| |#1|) $ (|NonNegativeInteger|))
   "\\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}."))
 (|multiplyCoefficients|
  (($ (|Mapping| |#1| (|Integer|)) $)
   "\\spad{multiplyCoefficients(f,{} sum(n = 0..infinity,{} a[n] * x^n))} returns \\spad{sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Laurent series are represented by a Taylor series and an order."))
 (|quoByVar|
  (($ $)
   "\\spad{quoByVar(a0 + a1 x + a2 x^2 + ...)} returns \\spad{a1 + a2 x + a3 x^2 + ...} Thus,{} this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order."))
 (|coefficients|
  (((|Stream| |#1|) $)
   "\\spad{coefficients(a0 + a1 x + a2 x^2 + ...)} returns a stream of coefficients: \\spad{[a0,{} a1,{} a2,{} ...]}. The entries of the stream may be zero."))
 (|series|
  (($ (|Stream| |#1|))
   "\\spad{series([a0,{} a1,{} a2,{} ...])} is the Taylor series \\spad{a0 + a1 x + a2 x^2 + ...}.")
  (($ (|Stream| (|Record| (|:| |k| (|NonNegativeInteger|)) (|:| |c| |#1|))))
   "\\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
NIL 
(|UnivariateTaylorSeriesODESolver| |Coef| UTS) 
((|constructor|
  (NIL
   "\\indented{1}{This package provides Taylor series solutions to regular} linear or non-linear ordinary differential equations of arbitrary order."))
 (|mpsode|
  (((|List| |#2|) (|List| |#1|) (|List| (|Mapping| |#2| (|List| |#2|))))
   "\\spad{mpsode(r,{} f)} solves the system of differential equations \\spad{dy[i]/dx =f[i] [x,{} y[1],{} y[2],{} ...,{} y[n]]},{} \\spad{y[i](a) = r[i]} for \\spad{i} in 1..\\spad{n}."))
 (|ode|
  ((|#2| (|Mapping| |#2| (|List| |#2|)) (|List| |#1|))
   "\\spad{ode(f,{} cl)} is the solution to \\spad{y<n>=f(y,{} y',{} ..,{} y<n-1>)} such that \\spad{y<i>(a) = cl.(i+1)} for \\spad{i} in 0..(\\spad{n} - 1)."))
 (|ode2|
  ((|#2| (|Mapping| |#2| |#2| |#2|) |#1| |#1|)
   "\\spad{ode2(f,{} c0,{} c1)} is the solution to \\spad{y'' = f(y,{} y')} such that \\spad{y(a) = c0} and \\spad{y'(a) = c1}."))
 (|ode1|
  ((|#2| (|Mapping| |#2| |#2|) |#1|)
   "\\spad{ode1(f,{} c)} is the solution to \\spad{y' = f(y)} such that \\spad{y(a) = c}."))
 (|fixedPointExquo|
  ((|#2| |#2| |#2|)
   "\\spad{fixedPointExquo(f,{} g)} computes the exact quotient of \\spad{f} and \\spad{g} using a fixed point computation."))
 (|stFuncN|
  (((|Mapping| (|Stream| |#1|) (|List| (|Stream| |#1|)))
    (|Mapping| |#2| (|List| |#2|)))
   "\\spad{stFuncN(f)} is a local function xported due to compiler problem. This function is of no interest to the top-level user."))
 (|stFunc2|
  (((|Mapping| (|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
    (|Mapping| |#2| |#2| |#2|))
   "\\spad{stFunc2(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user."))
 (|stFunc1|
  (((|Mapping| (|Stream| |#1|) (|Stream| |#1|)) (|Mapping| |#2| |#2|))
   "\\spad{stFunc1(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user."))) 
NIL 
(|UTSodetools| F UP L UTS) 
((|constructor|
  (NIL
   "\\spad{RUTSodetools} provides tools to interface with the series \\indented{1}{ODE solver when presented with linear ODEs.}"))
 (RF2UTS
  ((|#4| (|Fraction| |#2|))
   "\\spad{RF2UTS(f)} converts \\spad{f} to a Taylor series."))
 (LODO2FUN
  (((|Mapping| |#4| (|List| |#4|)) |#3|)
   "\\spad{LODO2FUN(op)} returns the function to pass to the series ODE solver in order to solve \\spad{op y = 0}."))
 (UTS2UP
  ((|#2| |#4| (|NonNegativeInteger|))
   "\\spad{UTS2UP(s,{} n)} converts the first \\spad{n} terms of \\spad{s} to a univariate polynomial."))
 (UP2UTS
  ((|#4| |#2|) "\\spad{UP2UTS(p)} converts \\spad{p} to a Taylor series."))) 
((|HasCategory| |#1| '(|IntegralDomain|))) 
(|TaylorSolve| F UTSF UTSSMPF) 
NIL 
NIL 
(|VarCat|) 
((|constructor|
  (NIL
   "VarCat represents a variable in Lambda and Ski domains. Since we are working in terms of functions then a variable will be a function (possibly a constant function) a variable has a name represented by a String. If the Lambda or Ski calculus is typed then the variable will also have a type."))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal,{} that is names are equal and if there is a type then they must also be equal"))
 (|parseVarTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "construct a variable by parsing a string pin is index to string at start of parse pout is index to string at end of parse"))
 (|parseVar| (($ (|String|)) "construct a variable by parsing a string"))
 (|toString| (((|String|) $) "returns the name and the type in string form."))
 (|getType|
  (((|ILogic|) $)
   "returns the type of the variable. This may be a compound type,{} for instance [\"a\",{}\\spad{\"b\"}] represents a-\\spad{>b} a function from type a to type \\spad{b} untyped implementations return []"))
 (|getName| (((|String|) $) "returns the name of the variable."))
 (|var|
  (($ (|String|) (|ILogic|))
   "constructs variable with a name and also a type.")
  (($ (|String|)) "constructs variable with a name but no type."))) 
NIL 
(|Variable| |sym|) 
((|constructor| (NIL "This domain implements variables"))
 (|variable| (((|Symbol|)) "\\spad{variable()} returns the symbol"))
 (|coerce| (((|Symbol|) $) "\\spad{coerce(x)} returns the symbol"))) 
NIL 
(|VectorModularReconstructor|) 
((|constructor|
  (NIL
   "This domain supports modular methods based on \\indented{1}{evaluation and rational reconstruction.\\space{2}All computation} \\indented{1}{are done on polynomials modulo machine sized prime \\spad{p} \\spad{--} \\spad{p} must} \\indented{1}{be chosen small enough to avoid overflow in intermediate} \\indented{1}{calculations. Each evaluation is supposed to produce vector of} \\indented{1}{values. Once enough evaluations are known rational reconstruction} \\indented{1}{produces vector of rational functions or multivariate polynomials.}"))
 (|reconstruct|
  (((|Union|
     (|Record| (|:| |nvars| (|Integer|))
               (|:| |offsetdata| (|Vector| (|Integer|)))
               (|:| |expdata| (|SortedExponentVector|))
               (|:| |coeffdata| (|U32Vector|)))
     "failed")
    $ (|Integer|) (|Vector| (|Integer|)) (|Vector| (|Integer|))
    (|SortedExponentVector|))
   "\\spad{reconstruct polynomials} in \\spad{n} + 1 variables")
  (((|Record| (|:| |nvars| (|Integer|))
              (|:| |offsetdata| (|Vector| (|Integer|)))
              (|:| |expdata| (|SortedExponentVector|))
              (|:| |coeffdata| (|U32Vector|)))
    (|Integer|) (|Vector| (|Integer|)) (|Vector| (|Integer|))
    (|SortedExponentVector|) (|PrimitiveArray| (|U32Vector|))
    (|PrimitiveArray| (|U32Vector|)) (|Integer|))
   "\\spad{reconstruct polynomials} in \\spad{n} + 1 variables from result of rational reconstruction"))
 (|remove_denoms|
  (((|PrimitiveArray| (|U32Vector|)) (|Vector| (|Integer|))
    (|PrimitiveArray| (|U32Vector|)) (|PrimitiveArray| (|U32Vector|))
    (|Integer|))
   "\\spad{remove_denoms(offsets,{} nums,{} denoms,{} p)} removes common denominator from vectors of rational functions. Several vectors of rational functions are packed into \\spad{nums} (storing numerators) and dens (storing denominators) Vector \\spad{i} starts at position \\spad{offsets}(\\spad{i}). Computations are done modulo \\spad{p}."))
 (|repack_polys|
  (((|Record| (|:| |nvars| (|Integer|))
              (|:| |offsetdata| (|Vector| (|Integer|)))
              (|:| |expdata| (|SortedExponentVector|))
              (|:| |coeffdata| (|U32Vector|)))
    (|Integer|) (|Vector| (|Integer|)) (|SortedExponentVector|)
    (|PrimitiveArray| (|U32Vector|)))
   "convert polynomials represented as parallel vector of exponents in \\spad{k} variables and vector of univariate polynomials to parallel vector of exponents in \\spad{k+1} variables and coefficients"))
 (|rational_reconstruction|
  (((|Union| (|Record| (|:| |numer| (|U32Vector|)) (|:| |denom| (|U32Vector|)))
             "failed")
    (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|))
   "reconstruct rational function")
  (((|Union|
     (|Record| (|:| |numers| (|PrimitiveArray| (|U32Vector|)))
               (|:| |denoms| (|PrimitiveArray| (|U32Vector|))))
     "failed")
    $)
   "reconstruct vector of rational functions based on information stored in reconstructor."))
 (|chinese_update|
  (((|Void|) (|U32Vector|) (|Integer|) $)
   "\\spad{chinese_update(v,{} pt,{} r)} informs \\spad{r} that evaluation at \\spad{pt} gave vector of values \\spad{v}"))
 (|add_slots|
  (((|Void|) (|List| (|Integer|)) $)
   "extend reconstructor adding zeros at specified positions."))
 (|empty|
  (($ (|Integer|) (|Integer|))
   "\\spad{empty(n,{} p)} initializes reconstructor with \\spad{n} slots working modulo \\spad{p}"))) 
NIL 
(|VectorIntegerReconstructor|) 
((|constructor|
  (NIL
   "This domain supports modular methods based on \\indented{1}{evaluation and rational reconstruction.\\space{2}Each evaluation} \\indented{1}{is done modulo machine sized prime \\spad{p}.\\space{2}Both Chinese} \\indented{1}{remaindering and (linear) Hensel lift are supported.} \\indented{1}{Once enough evaluations are known rational reconstruction} \\indented{1}{produces vector of rational numbers or integers.}"))
 (|reconstruct|
  (((|Union| (|PrimitiveArray| (|Integer|)) "failed") $ (|Vector| (|Integer|)))
   "combines rational reconstruction with removal of common denominators in blocks."))
 (|remove_denoms|
  (((|PrimitiveArray| (|Integer|)) (|Vector| (|Integer|))
    (|PrimitiveArray| (|Integer|)) (|PrimitiveArray| (|Integer|)))
   "remove common denominators in blocks"))
 (|hensel_update|
  (((|Void|) (|U32Vector|) (|Integer|) $) "one step of Hensel lifting"))
 (|chinese_update|
  (((|Void|) (|U32Vector|) (|Integer|) $)
   "\\spad{chinese_update(v,{} p,{} r)} informs \\spad{r} about evaluation at \\spad{p}"))
 (|empty|
  (($ (|Integer|))
   "\\spad{empty(n)} produces reconstructor with \\spad{n} slots"))) 
NIL 
(|VectorCategory&| S R) 
((|constructor|
  (NIL
   "\\spadtype{VectorCategory} represents the type of vector like objects,{} \\spadignore{i.e.} finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time."))
 (|length|
  ((|#2| $)
   "\\spad{length(v)} computes the sqrt(dot(\\spad{v},{} \\spad{v})),{} \\spadignore{i.e.} the euclidean length"))
 (|cross|
  (($ $ $)
   "\\spad{cross(u,{} v)} constructs the cross product of \\spad{u} and \\spad{v}. Error: if \\spad{u} and \\spad{v} are not of length 3."))
 (|outerProduct|
  (((|Matrix| |#2|) $ $)
   "\\spad{outerProduct(u,{} v)} constructs the matrix whose (\\spad{i},{} \\spad{j})\\spad{'}th element is \\spad{u}(\\spad{i})\\spad{*v}(\\spad{j})."))
 (|dot|
  ((|#2| $ $)
   "\\spad{dot(x,{} y)} computes the inner product of the two vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length."))
 (*
  (($ $ |#2|)
   "\\spad{y * r} multiplies each component of the vector \\spad{y} by the element \\spad{r}.")
  (($ |#2| $)
   "\\spad{r * y} multiplies the element \\spad{r} times each component of the vector \\spad{y}.")
  (($ (|Integer|) $)
   "\\spad{n * y} multiplies each component of the vector \\spad{y} by the integer \\spad{n}."))
 (-
  (($ $ $)
   "\\spad{x - y} returns the component-wise difference of the vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length.")
  (($ $) "\\spad{-x} negates all components of the vector \\spad{x}."))
 (|zero?|
  (((|Boolean|) $)
   "\\spad{zero?(x)} returns \\spad{true} if \\spad{x} is a zero vector,{} \\spad{false} otherwise."))
 (|zero|
  (($ (|NonNegativeInteger|))
   "\\spad{zero(n)} creates a zero vector of length \\spad{n}."))
 (+
  (($ $ $)
   "\\spad{x + y} returns the component-wise sum of the vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length."))) 
((|HasCategory| |#2| '(|RadicalCategory|)) (|HasCategory| |#2| '(|Ring|))
 (|HasCategory| |#2| '(|SemiRng|)) (|HasCategory| |#2| '(|SemiGroup|))
 (|HasCategory| |#2| '(|AbelianGroup|)) (|HasCategory| |#2| '(|AbelianMonoid|))
 (|HasCategory| |#2| '(|AbelianSemiGroup|))) 
(|VectorCategory| R) 
((|constructor|
  (NIL
   "\\spadtype{VectorCategory} represents the type of vector like objects,{} \\spadignore{i.e.} finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time."))
 (|length|
  ((|#1| $)
   "\\spad{length(v)} computes the sqrt(dot(\\spad{v},{} \\spad{v})),{} \\spadignore{i.e.} the euclidean length"))
 (|cross|
  (($ $ $)
   "\\spad{cross(u,{} v)} constructs the cross product of \\spad{u} and \\spad{v}. Error: if \\spad{u} and \\spad{v} are not of length 3."))
 (|outerProduct|
  (((|Matrix| |#1|) $ $)
   "\\spad{outerProduct(u,{} v)} constructs the matrix whose (\\spad{i},{} \\spad{j})\\spad{'}th element is \\spad{u}(\\spad{i})\\spad{*v}(\\spad{j})."))
 (|dot|
  ((|#1| $ $)
   "\\spad{dot(x,{} y)} computes the inner product of the two vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length."))
 (*
  (($ $ |#1|)
   "\\spad{y * r} multiplies each component of the vector \\spad{y} by the element \\spad{r}.")
  (($ |#1| $)
   "\\spad{r * y} multiplies the element \\spad{r} times each component of the vector \\spad{y}.")
  (($ (|Integer|) $)
   "\\spad{n * y} multiplies each component of the vector \\spad{y} by the integer \\spad{n}."))
 (-
  (($ $ $)
   "\\spad{x - y} returns the component-wise difference of the vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length.")
  (($ $) "\\spad{-x} negates all components of the vector \\spad{x}."))
 (|zero?|
  (((|Boolean|) $)
   "\\spad{zero?(x)} returns \\spad{true} if \\spad{x} is a zero vector,{} \\spad{false} otherwise."))
 (|zero|
  (($ (|NonNegativeInteger|))
   "\\spad{zero(n)} creates a zero vector of length \\spad{n}."))
 (+
  (($ $ $)
   "\\spad{x + y} returns the component-wise sum of the vectors \\spad{x} and \\spad{y}. Error: if \\spad{x} and \\spad{y} are not of the same length."))) 
NIL 
(|Vector| R) 
((|constructor|
  (NIL
   "This type represents vector like objects with varying lengths and indexed by a finite segment of integers starting at 1."))
 (|vector|
  (($ (|List| |#1|))
   "\\spad{vector(l)} converts the list \\spad{l} to a vector."))) 
((|HasCategory| |#1| '(|OrderedSet|))
 (|HasCategory| |#1| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Integer|) '(|OrderedSet|))
 (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|SetCategory|))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|BasicType|)) (|HasCategory| |#1| '(|Comparable|))
     (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|))
     (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (|HasCategory| |#1| '(|AbelianMonoid|)) (|HasCategory| |#1| '(|AbelianGroup|))
 (|HasCategory| |#1| '(|SemiGroup|))
 (AND (|HasCategory| |#1| '(|AbelianMonoid|))
      (|HasCategory| |#1| '(|SemiRng|)))
 (|HasCategory| |#1| '(|Ring|))
 (AND (|HasCategory| |#1| '(|RadicalCategory|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#1| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| $ '(|shallowlyMutable|)))
 (AND (|HasCategory| |#1| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))
 (OR (|HasCategory| |#1| (LIST '|CoercibleTo| '(|OutputForm|)))
     (AND (|HasCategory| |#1| '(|Comparable|))
          (|HasCategory| $ '(|finiteAggregate|)))
     (AND (|HasCategory| |#1| '(|OrderedSet|))
          (|HasCategory| $ '(|finiteAggregate|))))
 (OR
  (AND (|HasCategory| |#1| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|Comparable|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (AND (|HasCategory| |#1| '(|OrderedSet|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#1| '(|SetCategory|)))) 
(|VectorFunctions2| A B) 
((|constructor|
  (NIL
   "\\indented{2}{This package provides operations which all take as arguments} vectors of elements of some type \\spad{A} and functions from \\spad{A} to another of type \\spad{B}. The operations all iterate over their vector argument and either return a value of type \\spad{B} or a vector over \\spad{B}."))
 (|map|
  (((|Union| (|Vector| |#2|) "failed") (|Mapping| (|Union| |#2| "failed") |#1|)
    (|Vector| |#1|))
   "\\spad{map(f,{} v)} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values or \\spad{\"failed\"}.")
  (((|Vector| |#2|) (|Mapping| |#2| |#1|) (|Vector| |#1|))
   "\\spad{map(f,{} v)} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#1| |#2|) (|Vector| |#1|) |#2|)
   "\\spad{reduce(func,{} vec,{} ident)} combines the elements in \\spad{vec} using the binary function \\spad{func}. Argument ident is returned if \\spad{vec} is empty."))
 (|scan|
  (((|Vector| |#2|) (|Mapping| |#2| |#1| |#2|) (|Vector| |#1|) |#2|)
   "\\spad{scan(func,{} vec,{} ident)} creates a new vector whose elements are the result of applying reduce to the binary function \\spad{func},{} increasing initial subsequences of the vector \\spad{vec},{} and the element ident."))) 
NIL 
(|VectorHermitePadeSolver|) 
((|hp_solve|
  (((|Matrix| (|SparseUnivariatePolynomial| (|Expression| (|Integer|))))
    (|List|
     (|Vector| (|SparseUnivariatePolynomial| (|Expression| (|Integer|)))))
    (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|))
   "\\spad{hp_solve(lv,{} eta,{} K)} solves Hermite-Pade problem with degree bound \\spad{eta} up to order \\spad{K}."))) 
NIL 
(|ViewportPackage|) 
((|constructor|
  (NIL
   "ViewportPackage provides functions for creating GraphImages and TwoDimensionalViewports from lists of lists of points."))
 (|coerce|
  (((|TwoDimensionalViewport|) (|GraphImage|))
   "\\spad{coerce(\\spad{gi})} converts the indicated \\spadtype{GraphImage},{} \\spad{gi},{} into the \\spadtype{TwoDimensionalViewport} form."))
 (|drawCurves|
  (((|TwoDimensionalViewport|) (|List| (|List| (|Point| (|DoubleFloat|))))
    (|List| (|DrawOption|)))
   "\\spad{drawCurves([[p0],{} [p1],{} ...,{} [pn]],{} [options])} creates a \\spadtype{TwoDimensionalViewport} from the list of lists of points,{} \\spad{p0} throught \\spad{pn},{} using the options specified in the list \\spad{options}.")
  (((|TwoDimensionalViewport|) (|List| (|List| (|Point| (|DoubleFloat|))))
    (|Palette|) (|Palette|) (|PositiveInteger|) (|List| (|DrawOption|)))
   "\\spad{drawCurves([[p0],{} [p1],{} ...,{} [pn]],{} ptColor,{} lineColor,{} ptSize,{} [options])} creates a \\spadtype{TwoDimensionalViewport} from the list of lists of points,{} \\spad{p0} throught \\spad{pn},{} using the options specified in the list \\spad{options}. The point color is specified by \\spad{ptColor},{} the line color is specified by \\spad{lineColor},{} and the point size is specified by \\spad{ptSize}."))
 (|graphCurves|
  (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|))))
    (|List| (|DrawOption|)))
   "\\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]],{} [options])} creates a \\spadtype{GraphImage} from the list of lists of points,{} \\spad{p0} throught \\spad{pn},{} using the options specified in the list \\spad{options}.")
  (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|)))))
   "\\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]])} creates a \\spadtype{GraphImage} from the list of lists of points indicated by \\spad{p0} through \\spad{pn}.")
  (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|)))) (|Palette|)
    (|Palette|) (|PositiveInteger|) (|List| (|DrawOption|)))
   "\\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]],{} ptColor,{} lineColor,{} ptSize,{} [options])} creates a \\spadtype{GraphImage} from the list of lists of points,{} \\spad{p0} throught \\spad{pn},{} using the options specified in the list \\spad{options}. The graph point color is specified by \\spad{ptColor},{} the graph line color is specified by \\spad{lineColor},{} and the size of the points is specified by \\spad{ptSize}."))) 
NIL 
(|TwoDimensionalViewport|) 
((|constructor|
  (NIL "TwoDimensionalViewport creates viewports to display graphs."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(v)} returns the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport} as output of the domain \\spadtype{OutputForm}."))
 (|key|
  (((|Integer|) $)
   "\\spad{key(v)} returns the process ID number of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport}."))
 (|reset|
  (((|Void|) $)
   "\\spad{reset(v)} sets the current state of the graph characteristics of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} back to their initial settings."))
 (|write|
  (((|String|) $ (|String|) (|List| (|String|)))
   "\\spad{write(v,{} s,{} lf)} takes the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data files for \\spad{v} and the optional file types indicated by the list \\spad{lf}.")
  (((|String|) $ (|String|) (|String|))
   "\\spad{write(v,{} s,{} f)} takes the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data files for \\spad{v} and an optional file type \\spad{f}.")
  (((|String|) $ (|String|))
   "\\spad{write(v,{} s)} takes the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data files for \\spad{v}."))
 (|resize|
  (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{resize(v,{} w,{} h)} displays the two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} with a width of \\spad{w} and a height of \\spad{h},{} keeping the upper left-hand corner position unchanged."))
 (|update|
  (((|Void|) $ (|GraphImage|) (|PositiveInteger|))
   "\\spad{update(v,{} gr,{} n)} drops the graph \\spad{gr} in slot \\spad{n} of viewport \\spad{v}. The graph \\spad{gr} must have been transmitted already and acquired an integer key."))
 (|move|
  (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{move(v,{} x,{} y)} displays the two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \\spad{x},{} \\spad{y}."))
 (|show|
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{show(v,{} n,{} s)} displays the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the graph if \\spad{s} is \"off\"."))
 (|translate|
  (((|Void|) $ (|PositiveInteger|) (|Float|) (|Float|))
   "\\spad{translate(v,{} n,{} dx,{} dy)} displays the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} translated by \\spad{dx} in the \\spad{x}-coordinate direction from the center of the viewport,{} and by \\spad{dy} in the \\spad{y}-coordinate direction from the center. Setting \\spad{dx} and \\spad{dy} to \\spad{0} places the center of the graph at the center of the viewport."))
 (|scale|
  (((|Void|) $ (|PositiveInteger|) (|Float|) (|Float|))
   "\\spad{scale(v,{} n,{} sx,{} sy)} displays the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} scaled by the factor \\spad{sx} in the \\spad{x}-coordinate direction and by the factor \\spad{sy} in the \\spad{y}-coordinate direction."))
 (|dimensions|
  (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{dimensions(v,{} x,{} y,{} width,{} height)} sets the position of the upper left-hand corner of the two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} to the window coordinate \\spad{x},{} \\spad{y},{} and sets the dimensions of the window to that of \\spad{width},{} \\spad{height}. The new dimensions are not displayed until the function \\spadfun{makeViewport2D} is executed again for \\spad{v}."))
 (|close|
  (((|Void|) $)
   "\\spad{close(v)} closes the viewport window of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} and terminates the corresponding process ID."))
 (|controlPanel|
  (((|Void|) $ (|String|))
   "\\spad{controlPanel(v,{} s)} displays the control panel of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or hides the control panel if \\spad{s} is \"off\"."))
 (|connect|
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{connect(v,{} n,{} s)} displays the lines connecting the graph points in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the lines if \\spad{s} is \"off\"."))
 (|region|
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{region(v,{} n,{} s)} displays the bounding box of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the bounding box if \\spad{s} is \"off\"."))
 (|points|
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{points(v,{} n,{} s)} displays the points of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the points if \\spad{s} is \"off\"."))
 (|units|
  (((|Void|) $ (|PositiveInteger|) (|Palette|))
   "\\spad{units(v,{} n,{} c)} displays the units of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} with the units color set to the given palette color \\spad{c}.")
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{units(v,{} n,{} s)} displays the units of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the units if \\spad{s} is \"off\"."))
 (|axes|
  (((|Void|) $ (|PositiveInteger|) (|Palette|))
   "\\spad{axes(v,{} n,{} c)} displays the axes of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} with the axes color set to the given palette color \\spad{c}.")
  (((|Void|) $ (|PositiveInteger|) (|String|))
   "\\spad{axes(v,{} n,{} s)} displays the axes of the graph in field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the axes if \\spad{s} is \"off\"."))
 (|getGraph|
  (((|GraphImage|) $ (|PositiveInteger|))
   "\\spad{getGraph(v,{} n)} returns the graph which is of the domain \\spadtype{GraphImage} which is located in graph field \\spad{n} of the given two-dimensional viewport,{} \\spad{v},{} which is of the domain \\spadtype{TwoDimensionalViewport}."))
 (|putGraph|
  (((|Void|) $ (|GraphImage|) (|PositiveInteger|))
   "\\spad{putGraph(v,{} \\spad{gi},{} n)} sets the graph field indicated by \\spad{n},{} of the indicated two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport},{} to be the graph,{} \\spad{\\spad{gi}} of domain \\spadtype{GraphImage}. The contents of viewport,{} \\spad{v},{} will contain \\spad{\\spad{gi}} when the function \\spadfun{makeViewport2D} is called to create the an updated viewport \\spad{v}."))
 (|title|
  (((|Void|) $ (|String|))
   "\\spad{title(v,{} s)} changes the title which is shown in the two-dimensional viewport window,{} \\spad{v} of domain \\spadtype{TwoDimensionalViewport}."))
 (|graphs|
  (((|Vector| (|Union| (|GraphImage|) "undefined")) $)
   "\\spad{graphs(v)} returns a vector,{} or list,{} which is a union of all the graphs,{} of the domain \\spadtype{GraphImage},{} which are allocated for the two-dimensional viewport,{} \\spad{v},{} of domain \\spadtype{TwoDimensionalViewport}. Those graphs which have no data are labeled \"undefined\",{} otherwise their contents are shown."))
 (|graphStates|
  (((|Vector|
     (|Record| (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|))
               (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))
               (|:| |points| (|Integer|)) (|:| |connect| (|Integer|))
               (|:| |spline| (|Integer|)) (|:| |axes| (|Integer|))
               (|:| |axesColor| (|Palette|)) (|:| |units| (|Integer|))
               (|:| |unitsColor| (|Palette|)) (|:| |showing| (|Integer|))))
    $)
   "\\spad{graphStates(v)} returns and shows a listing of a record containing the current state of the characteristics of each of the ten graph records in the given two-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{TwoDimensionalViewport}."))
 (|graphState|
  (((|Void|) $ (|PositiveInteger|) (|DoubleFloat|) (|DoubleFloat|)
    (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|)
    (|Integer|) (|Palette|) (|Integer|) (|Palette|) (|Integer|))
   "\\spad{graphState(v,{} num,{} sX,{} sY,{} dX,{} dY,{} pts,{} lns,{} box,{} axes,{} axesC,{} un,{} unC,{} cP)} sets the state of the characteristics for the graph indicated by \\spad{num} in the given two-dimensional viewport \\spad{v},{} of domain \\spadtype{TwoDimensionalViewport},{} to the values given as parameters. The scaling of the graph in the \\spad{x} and \\spad{y} component directions is set to be \\spad{sX} and \\spad{sY}; the window translation in the \\spad{x} and \\spad{y} component directions is set to be \\spad{dX} and \\spad{dY}; The graph points,{} lines,{} bounding \\spad{box},{} \\spad{axes},{} or units will be shown in the viewport if their given parameters \\spad{pts},{} \\spad{lns},{} \\spad{box},{} \\spad{axes} or \\spad{un} are set to be \\spad{1},{} but will not be shown if they are set to \\spad{0}. The color of the \\spad{axes} and the color of the units are indicated by the palette colors \\spad{axesC} and \\spad{unC} respectively. To display the control panel when the viewport window is displayed,{} set \\spad{cP} to \\spad{1},{} otherwise set it to \\spad{0}."))
 (|options|
  (($ $ (|List| (|DrawOption|)))
   "\\spad{options(v,{} lopt)} takes the given two-dimensional viewport,{} \\spad{v},{} of the domain \\spadtype{TwoDimensionalViewport} and returns \\spad{v} with it\\spad{'s} draw options modified to be those which are indicated in the given list,{} \\spad{lopt} of domain \\spadtype{DrawOption}.")
  (((|List| (|DrawOption|)) $)
   "\\spad{options(v)} takes the given two-dimensional viewport,{} \\spad{v},{} of the domain \\spadtype{TwoDimensionalViewport} and returns a list containing the draw options from the domain \\spadtype{DrawOption} for \\spad{v}."))
 (|makeViewport2D|
  (($ (|GraphImage|) (|List| (|DrawOption|)))
   "\\spad{makeViewport2D(\\spad{gi},{} lopt)} creates and displays a viewport window of the domain \\spadtype{TwoDimensionalViewport} whose graph field is assigned to be the given graph,{} \\spad{\\spad{gi}},{} of domain \\spadtype{GraphImage},{} and whose options field is set to be the list of options,{} \\spad{lopt} of domain \\spadtype{DrawOption}.")
  (($ $)
   "\\spad{makeViewport2D(v)} takes the given two-dimensional viewport,{} \\spad{v},{} of the domain \\spadtype{TwoDimensionalViewport} and displays a viewport window on the screen which contains the contents of \\spad{v}."))
 (|viewport2D|
  (($)
   "\\spad{viewport2D()} returns an undefined two-dimensional viewport of the domain \\spadtype{TwoDimensionalViewport} whose contents are empty."))
 (|getPickedPoints|
  (((|List| (|Point| (|DoubleFloat|))) $)
   "\\spad{getPickedPoints(x)} returns a list of small floats for the points the user interactively picked on the viewport for full integration into the system,{} some design issues need to be addressed: \\spadignore{e.g.} how to go through the GraphImage interface,{} how to default to graphs,{} etc."))) 
NIL 
(|ThreeDimensionalViewport|) 
((|constructor|
  (NIL "ThreeDimensionalViewport creates viewports to display graphs"))
 (|key|
  (((|Integer|) $)
   "\\spad{key(v)} returns the process ID number of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|close|
  (((|Void|) $)
   "\\spad{close(v)} closes the viewport window of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} and terminates the corresponding process ID."))
 (|write|
  (((|String|) $ (|String|) (|List| (|String|)))
   "\\spad{write(v,{} s,{} lf)} takes the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data file for \\spad{v} and the optional file types indicated by the list \\spad{lf}.")
  (((|String|) $ (|String|) (|String|))
   "\\spad{write(v,{} s,{} f)} takes the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data file for \\spad{v} and an optional file type \\spad{f}.")
  (((|String|) $ (|String|))
   "\\spad{write(v,{} s)} takes the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \\spad{s},{} which contains the graph data file for \\spad{v}."))
 (|colorDef|
  (((|Void|) $ (|Color|) (|Color|))
   "\\spad{colorDef(v,{} c1,{} c2)} sets the range of colors along the colormap so that the lower end of the colormap is defined by \\spad{c1} and the top end of the colormap is defined by \\spad{c2},{} for the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|reset|
  (((|Void|) $)
   "\\spad{reset(v)} sets the current state of the graph characteristics of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} back to their initial settings."))
 (|intensity|
  (((|Void|) $ (|Float|))
   "\\spad{intensity(v,{} i)} sets the intensity of the light source to \\spad{i},{} for the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|lighting|
  (((|Void|) $ (|Float|) (|Float|) (|Float|))
   "\\spad{lighting(v,{} x,{} y,{} z)} sets the position of the light source to the coordinates \\spad{x},{} \\spad{y},{} and \\spad{z} and displays the graph for the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|clipSurface|
  (((|Void|) $ (|String|))
   "\\spad{clipSurface(v,{} s)} displays the graph with the specified clipping region removed if \\spad{s} is \"on\",{} or displays the graph without clipping implemented if \\spad{s} is \"off\",{} for the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|showClipRegion|
  (((|Void|) $ (|String|))
   "\\spad{showClipRegion(v,{} s)} displays the clipping region of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the region if \\spad{s} is \"off\"."))
 (|showRegion|
  (((|Void|) $ (|String|))
   "\\spad{showRegion(v,{} s)} displays the bounding box of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the box if \\spad{s} is \"off\"."))
 (|hitherPlane|
  (((|Void|) $ (|Float|))
   "\\spad{hitherPlane(v,{} h)} sets the hither clipping plane of the graph to \\spad{h},{} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}."))
 (|eyeDistance|
  (((|Void|) $ (|Float|))
   "\\spad{eyeDistance(v,{} d)} sets the distance of the observer from the center of the graph to \\spad{d},{} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}."))
 (|perspective|
  (((|Void|) $ (|String|))
   "\\spad{perspective(v,{}s)} displays the graph in perspective if \\spad{s} is \"on\",{} or does not display perspective if \\spad{s} is \"off\" for the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport}."))
 (|translate|
  (((|Void|) $ (|Float|) (|Float|))
   "\\spad{translate(v,{} dx,{} dy)} sets the horizontal viewport offset to \\spad{dx} and the vertical viewport offset to \\spad{dy},{} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}."))
 (|zoom|
  (((|Void|) $ (|Float|) (|Float|) (|Float|))
   "\\spad{zoom(v,{} sx,{} sy,{} sz)} sets the graph scaling factors for the \\spad{x}-coordinate axis to \\spad{sx},{} the \\spad{y}-coordinate axis to \\spad{sy} and the \\spad{z}-coordinate axis to \\spad{sz} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}.")
  (((|Void|) $ (|Float|))
   "\\spad{zoom(v,{} s)} sets the graph scaling factor to \\spad{s},{} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}."))
 (|rotate|
  (((|Void|) $ (|Integer|) (|Integer|))
   "\\spad{rotate(v,{} th,{} phi)} rotates the graph to the longitudinal view angle \\spad{th} degrees and the latitudinal view angle \\spad{phi} degrees for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new rotation position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v}.")
  (((|Void|) $ (|Float|) (|Float|))
   "\\spad{rotate(v,{} th,{} phi)} rotates the graph to the longitudinal view angle \\spad{th} radians and the latitudinal view angle \\spad{phi} radians for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}."))
 (|drawStyle|
  (((|Void|) $ (|String|))
   "\\spad{drawStyle(v,{} s)} displays the surface for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport} in the style of drawing indicated by \\spad{s}. If \\spad{s} is not a valid drawing style the style is wireframe by default. Possible styles are \\spad{\"shade\"},{} \\spad{\"solid\"} or \\spad{\"opaque\"},{} \\spad{\"smooth\"},{} and \\spad{\"wireMesh\"}."))
 (|outlineRender|
  (((|Void|) $ (|String|))
   "\\spad{outlineRender(v,{} s)} displays the polygon outline showing either triangularized surface or a quadrilateral surface outline depending on the whether the \\spadfun{diagonals} function has been set,{} for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the polygon outline if \\spad{s} is \"off\"."))
 (|diagonals|
  (((|Void|) $ (|String|))
   "\\spad{diagonals(v,{} s)} displays the diagonals of the polygon outline showing a triangularized surface instead of a quadrilateral surface outline,{} for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the diagonals if \\spad{s} is \"off\"."))
 (|axes|
  (((|Void|) $ (|String|))
   "\\spad{axes(v,{} s)} displays the axes of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or does not display the axes if \\spad{s} is \"off\"."))
 (|controlPanel|
  (((|Void|) $ (|String|))
   "\\spad{controlPanel(v,{} s)} displays the control panel of the given three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} if \\spad{s} is \"on\",{} or hides the control panel if \\spad{s} is \"off\"."))
 (|viewpoint|
  (((|Void|) $ (|Float|) (|Float|) (|Float|))
   "\\spad{viewpoint(v,{} rotx,{} roty,{} rotz)} sets the rotation about the \\spad{x}-axis to be \\spad{rotx} radians,{} sets the rotation about the \\spad{y}-axis to be \\spad{roty} radians,{} and sets the rotation about the \\spad{z}-axis to be \\spad{rotz} radians,{} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport} and displays \\spad{v} with the new view position.")
  (((|Void|) $ (|Float|) (|Float|))
   "\\spad{viewpoint(v,{} th,{} phi)} sets the longitudinal view angle to \\spad{th} radians and the latitudinal view angle to \\spad{phi} radians for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v}.")
  (((|Void|) $ (|Integer|) (|Integer|) (|Float|) (|Float|) (|Float|))
   "\\spad{viewpoint(v,{} th,{} phi,{} s,{} dx,{} dy)} sets the longitudinal view angle to \\spad{th} degrees,{} the latitudinal view angle to \\spad{phi} degrees,{} the scale factor to \\spad{s},{} the horizontal viewport offset to \\spad{dx},{} and the vertical viewport offset to \\spad{dy} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v}.")
  (((|Void|) $
    (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|))
              (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|))
              (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|))
              (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))))
   "\\spad{viewpoint(v,{} viewpt)} sets the viewpoint for the viewport. The viewport record consists of the latitudal and longitudal angles,{} the zoom factor,{} the \\spad{X},{} \\spad{Y},{} and \\spad{Z} scales,{} and the \\spad{X} and \\spad{Y} displacements.")
  (((|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|))
              (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|))
              (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|))
              (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)))
    $)
   "\\spad{viewpoint(v)} returns the current viewpoint setting of the given viewport,{} \\spad{v}. This function is useful in the situation where the user has created a viewport,{} proceeded to interact with it via the control panel and desires to save the values of the viewpoint as the default settings for another viewport to be created using the system.")
  (((|Void|) $ (|Float|) (|Float|) (|Float|) (|Float|) (|Float|))
   "\\spad{viewpoint(v,{} th,{} phi,{} s,{} dx,{} dy)} sets the longitudinal view angle to \\spad{th} radians,{} the latitudinal view angle to \\spad{phi} radians,{} the scale factor to \\spad{s},{} the horizontal viewport offset to \\spad{dx},{} and the vertical viewport offset to \\spad{dy} for the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v}."))
 (|dimensions|
  (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)
    (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{dimensions(v,{} x,{} y,{} width,{} height)} sets the position of the upper left-hand corner of the three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} to the window coordinate \\spad{x},{} \\spad{y},{} and sets the dimensions of the window to that of \\spad{width},{} \\spad{height}. The new dimensions are not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v}."))
 (|title|
  (((|Void|) $ (|String|))
   "\\spad{title(v,{} s)} changes the title which is shown in the three-dimensional viewport window,{} \\spad{v} of domain \\spadtype{ThreeDimensionalViewport}."))
 (|resize|
  (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|))
   "\\spad{resize(v,{} w,{} h)} displays the three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} with a width of \\spad{w} and a height of \\spad{h},{} keeping the upper left-hand corner position unchanged."))
 (|move|
  (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{move(v,{} x,{} y)} displays the three-dimensional viewport,{} \\spad{v},{} which is of domain \\spadtype{ThreeDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \\spad{x},{} \\spad{y}."))
 (|options|
  (($ $ (|List| (|DrawOption|)))
   "\\spad{options(v,{} lopt)} takes the viewport,{} \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport} and sets the draw options being used by \\spad{v} to those indicated in the list,{} \\spad{lopt},{} which is a list of options from the domain \\spad{DrawOption}.")
  (((|List| (|DrawOption|)) $)
   "\\spad{options(v)} takes the viewport,{} \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport} and returns a list of all the draw options from the domain \\spad{DrawOption} which are being used by \\spad{v}."))
 (|modifyPointData|
  (((|Void|) $ (|NonNegativeInteger|) (|Point| (|DoubleFloat|)))
   "\\spad{modifyPointData(v,{} ind,{} pt)} takes the viewport,{} \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport},{} and places the data point,{} \\spad{pt} into the list of points database of \\spad{v} at the index location given by \\spad{ind}."))
 (|subspace|
  (($ $ (|ThreeSpace| (|DoubleFloat|)))
   "\\spad{subspace(v,{} sp)} places the contents of the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport},{} in the subspace \\spad{sp},{} which is of the domain \\spad{ThreeSpace}.")
  (((|ThreeSpace| (|DoubleFloat|)) $)
   "\\spad{subspace(v)} returns the contents of the viewport \\spad{v},{} which is of the domain \\spadtype{ThreeDimensionalViewport},{} as a subspace of the domain \\spad{ThreeSpace}."))
 (|makeViewport3D|
  (($ (|ThreeSpace| (|DoubleFloat|)) (|List| (|DrawOption|)))
   "\\spad{makeViewport3D(sp,{} lopt)} takes the given space,{} \\spad{sp} which is of the domain \\spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \\spad{sp},{} and whose draw options are indicated by the list \\spad{lopt},{} which is a list of options from the domain \\spad{DrawOption}.")
  (($ (|ThreeSpace| (|DoubleFloat|)) (|String|))
   "\\spad{makeViewport3D(sp,{} s)} takes the given space,{} \\spad{sp} which is of the domain \\spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \\spad{sp},{} and whose title is given by \\spad{s}.")
  (($ $)
   "\\spad{makeViewport3D(v)} takes the given three-dimensional viewport,{} \\spad{v},{} of the domain \\spadtype{ThreeDimensionalViewport} and displays a viewport window on the screen which contains the contents of \\spad{v}."))
 (|viewport3D|
  (($)
   "\\spad{viewport3D()} returns an undefined three-dimensional viewport of the domain \\spadtype{ThreeDimensionalViewport} whose contents are empty."))
 (|viewDeltaYDefault|
  (((|Float|) (|Float|))
   "\\spad{viewDeltaYDefault(dy)} sets the current default vertical offset from the center of the viewport window to be \\spad{dy} and returns \\spad{dy}.")
  (((|Float|))
   "\\spad{viewDeltaYDefault()} returns the current default vertical offset from the center of the viewport window."))
 (|viewDeltaXDefault|
  (((|Float|) (|Float|))
   "\\spad{viewDeltaXDefault(dx)} sets the current default horizontal offset from the center of the viewport window to be \\spad{dx} and returns \\spad{dx}.")
  (((|Float|))
   "\\spad{viewDeltaXDefault()} returns the current default horizontal offset from the center of the viewport window."))
 (|viewZoomDefault|
  (((|Float|) (|Float|))
   "\\spad{viewZoomDefault(s)} sets the current default graph scaling value to \\spad{s} and returns \\spad{s}.")
  (((|Float|))
   "\\spad{viewZoomDefault()} returns the current default graph scaling value."))
 (|viewPhiDefault|
  (((|Float|) (|Float|))
   "\\spad{viewPhiDefault(p)} sets the current default latitudinal view angle in radians to the value \\spad{p} and returns \\spad{p}.")
  (((|Float|))
   "\\spad{viewPhiDefault()} returns the current default latitudinal view angle in radians."))
 (|viewThetaDefault|
  (((|Float|) (|Float|))
   "\\spad{viewThetaDefault(t)} sets the current default longitudinal view angle in radians to the value \\spad{t} and returns \\spad{t}.")
  (((|Float|))
   "\\spad{viewThetaDefault()} returns the current default longitudinal view angle in radians."))) 
NIL 
(|ViewDefaultsPackage|) 
((|constructor|
  (NIL
   "ViewportDefaultsPackage describes default and user definable values for graphics"))
 (|tubeRadiusDefault|
  (((|DoubleFloat|))
   "\\spad{tubeRadiusDefault()} returns the radius used for a 3D tube plot.")
  (((|DoubleFloat|) (|Float|))
   "\\spad{tubeRadiusDefault(r)} sets the default radius for a 3D tube plot to \\spad{r}."))
 (|tubePointsDefault|
  (((|PositiveInteger|))
   "\\spad{tubePointsDefault()} returns the number of points to be used when creating the circle to be used in creating a 3D tube plot.")
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{tubePointsDefault(i)} sets the number of points to use when creating the circle to be used in creating a 3D tube plot to \\spad{i}."))
 (|var2StepsDefault|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{var2StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} \\spad{x=0}..10)).")
  (((|PositiveInteger|))
   "\\spad{var2StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} \\spad{x=0}..10))."))
 (|var1StepsDefault|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{var1StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} \\spad{x=0}..10)).")
  (((|PositiveInteger|))
   "\\spad{var1StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} \\spad{x=0}..10))."))
 (|viewWriteAvailable|
  (((|List| (|String|)))
   "\\spad{viewWriteAvailable()} returns a list of available methods for writing,{} such as BITMAP,{} POSTSCRIPT,{} etc."))
 (|viewWriteDefault|
  (((|List| (|String|)) (|List| (|String|)))
   "\\spad{viewWriteDefault(l)} sets the default list of things to write in a viewport data file to the strings in \\spad{l}; a viewAlone file is always genereated.")
  (((|List| (|String|)))
   "\\spad{viewWriteDefault()} returns the list of things to write in a viewport data file; a viewAlone file is always generated."))
 (|viewDefaults|
  (((|Void|))
   "\\spad{viewDefaults()} resets all the default graphics settings."))
 (|viewSizeDefault|
  (((|List| (|PositiveInteger|)) (|List| (|PositiveInteger|)))
   "\\spad{viewSizeDefault([w,{} h])} sets the default viewport width to \\spad{w} and height to \\spad{h}.")
  (((|List| (|PositiveInteger|)))
   "\\spad{viewSizeDefault()} returns the default viewport width and height."))
 (|viewPosDefault|
  (((|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{viewPosDefault([x,{} y])} sets the default \\spad{X} and \\spad{Y} position of a viewport window unless overriden explicityly,{} newly created viewports will have th \\spad{X} and \\spad{Y} coordinates \\spad{x},{} \\spad{y}.")
  (((|List| (|NonNegativeInteger|)))
   "\\spad{viewPosDefault()} returns the default \\spad{X} and \\spad{Y} position of a viewport window unless overriden explicityly,{} newly created viewports will have this \\spad{X} and \\spad{Y} coordinate."))
 (|pointSizeDefault|
  (((|PositiveInteger|) (|PositiveInteger|))
   "\\spad{pointSizeDefault(i)} sets the default size of the points in a 2D viewport to \\spad{i}.")
  (((|PositiveInteger|))
   "\\spad{pointSizeDefault()} returns the default size of the points in a 2D viewport."))
 (|unitsColorDefault|
  (((|Palette|) (|Palette|))
   "\\spad{unitsColorDefault(p)} sets the default color of the unit ticks in a 2D viewport to the palette \\spad{p}.")
  (((|Palette|))
   "\\spad{unitsColorDefault()} returns the default color of the unit ticks in a 2D viewport."))
 (|axesColorDefault|
  (((|Palette|) (|Palette|))
   "\\spad{axesColorDefault(p)} sets the default color of the axes in a 2D viewport to the palette \\spad{p}.")
  (((|Palette|))
   "\\spad{axesColorDefault()} returns the default color of the axes in a 2D viewport."))
 (|lineColorDefault|
  (((|Palette|) (|Palette|))
   "\\spad{lineColorDefault(p)} sets the default color of lines connecting points in a 2D viewport to the palette \\spad{p}.")
  (((|Palette|))
   "\\spad{lineColorDefault()} returns the default color of lines connecting points in a 2D viewport."))
 (|pointColorDefault|
  (((|Palette|) (|Palette|))
   "\\spad{pointColorDefault(p)} sets the default color of points in a 2D viewport to the palette \\spad{p}.")
  (((|Palette|))
   "\\spad{pointColorDefault()} returns the default color of points in a 2D viewport."))) 
NIL 
(|Void|) 
((|constructor|
  (NIL
   "This type is used when no value is needed,{} \\spadignore{e.g.} in the \\spad{then} part of a one armed \\spad{if}. All values can be coerced to type Void. Once a value has been coerced to Void,{} it cannot be recovered."))
 (|coerce|
  (((|OutputForm|) $) "\\spad{coerce(v)} coerces void object to OutputForm."))
 (|void| (($) "\\spad{void()} produces a void object."))) 
NIL 
(|VectorSpaceBasis| R) 
((|constructor|
  (NIL
   "The domain \\spad{VectorSpaceBasis F} implements subspaces of finite dimensional vector spaces over a field \\spad{F}. A subspace is represented by a list of linearly independent coordinate vectors which constitute a basis. The empty list represents the space of dimension 0."))
 (|coordinates|
  (((|Vector| |#1|) (|Vector| |#1|) $)
   "\\spad{coordinates(v,{} B)} computes the coordinates of the vector \\spad{v} in the basis \\spad{B} if possible and produces an error otherwise."))
 (|coordinatesIfCan|
  (((|Union| (|Vector| |#1|) "failed") (|Vector| |#1|) $)
   "\\spad{coordinatesIfCan(v,{} B)} computes the coordinates of the vector \\spad{v} in the basis \\spad{B} if possible and returns \\spad{\"failed\"} otherwise."))
 (|member?|
  (((|Boolean|) (|Vector| |#1|) $)
   "\\spad{member?(v,{} B)} tests if the vector \\spad{v} is in the subspace spanned by \\spad{B}."))
 (|complementSpace|
  (($ (|List| (|Vector| |#1|)) (|NonNegativeInteger|))
   "\\spad{complementSpace(Lv,{} n)} builds a complement space of the subspace spanned by the list of vectors \\spad{LV}. The integer \\spad{n} provides the length of the vectors in the case of the empty basis.")
  (($ (|List| (|Vector| |#1|)))
   "\\spad{complementSpace Lv} builds a complement space of the subspace spanned by the list of vectors \\spad{LV}. This function fails with the empty basis.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{complementSpace(B,{} n)} builds a complement space of the basis \\spad{B} from some vectors of the canonical basis \\spad{B}. The integer \\spad{n} provides the length of the vectors in the case of the empty basis.")
  (($ $)
   "\\spad{complementSpace B} builds a complement space of the basis \\spad{B} from some vectors of the canonical basis. This function fails with the empty basis."))
 (|canonicalBasis|
  (($ (|NonNegativeInteger|))
   "\\spad{canonicalBasis n} builds the canonical basis of the vector space of dimension \\spad{n}."))
 ((|Zero|)
  (($)
   "\\spad{0} creates the empty basis describing the space with the zero vector. The length of this zero vector is undefined."))
 (|subspace?|
  (((|Boolean|) $ $)
   "\\spad{subspace?(B1,{} B2)} tests if the first space is included in the second."))
 (|isBasis?|
  (((|Boolean|) (|List| (|Vector| |#1|)))
   "\\spad{isBasis? Lv} tests for linear independence of a list of vectors."))
 (|rank|
  (((|NonNegativeInteger|) $)
   "\\spad{rank b} computes the rank of a basis,{} \\spadignore{i.e.} the number of vectors in the basis.")
  (((|NonNegativeInteger|) (|List| (|Vector| |#1|)))
   "\\spad{rank Lv} computes the rank of a list of vectors."))
 (*
  (($ $ $)
   "\\spad{b1*b2} computes a basis of the intersection of two subspaces."))
 (|intBasis|
  (($ (|List| (|List| (|Vector| |#1|))))
   "\\spad{intBasis LLv} computes a basis of the intersection of the list of subspaces represented by \\spad{LLv}.")
  (($ (|List| $))
   "\\spad{intBasis Lb} computes a basis of the intersection of the list of subspaces represented by \\spad{LLv}.")
  (($ $ $)
   "\\spad{intBasis(B1,{} B2)} computes a basis of the intersection of the two subspaces.")
  (($ (|List| (|Vector| |#1|)) (|List| (|Vector| |#1|)))
   "\\spad{intBasis(Lv1,{} Lv2)} computes a basis of the intersection of the two subspaces spanned by the vectors of \\spad{Lv1} and \\spad{Lv2}."))
 (+ (($ $ $) "\\spad{B1+B2} computes a basis of the sum of two subspaces."))
 (|sumBasis|
  (($ (|List| (|List| (|Vector| |#1|))))
   "\\spad{sumBasis LLv} computes a basis of the sum of the list of subspaces represented by \\spad{LLv}. This function is slightly more efficient than \\spad{reduce(sumBasis,{} LLv)}.")
  (($ (|List| $))
   "\\spad{sumBasis Lb} computes a basis of the sum of list of subspaces. This function is slightly more efficient than \\spad{reduce(sumBasis,{} Lb)}.")
  (($ (|List| (|Vector| |#1|)) (|List| (|Vector| |#1|)))
   "\\spad{sumBasis(Lv1,{} Lv2)} computes a basis of the sum of the two subspaces spanned by the vectors of \\spad{Lv1} and \\spad{Lv2}.")
  (($ $ $)
   "\\spad{sumBasis(B1,{} B2)} computes a basis of the sum of the two subspaces."))
 (|columnSpace|
  (($ (|Matrix| |#1|))
   "\\spad{columnSpace M} builds a basis of the image space of the linear transformation defined by the matrix \\spad{M}. This function calls the \\spad{columnSpace} from the \\spad{Matrix} domain. Only the signature changes."))
 (|nullSpace|
  (($ (|Matrix| |#1|))
   "\\spad{nullSpace M} builds a basis of the kernel of the linear transformation defined by the matrix \\spad{M}. This function calls the function \\spad{nullSpace} from the \\spad{Matrix} domain. Only the signature changes."))
 (|coerce|
  (((|List| (|Vector| |#1|)) $)
   "\\spad{coerce b} returns the basis as a list of vectors."))
 (|basis|
  (($ (|List| (|Vector| |#1|)))
   "\\spad{basis LV} extracts a basis of the subspace spanned by the list of vectors \\spad{LV}."))) 
NIL 
(|WeierstrassPreparation| R) 
((|constructor|
  (NIL
   "This package implements the Weierstrass preparation theorem \\spad{f} for multivariate power series. weierstrass(\\spad{v},{} \\spad{p}) where \\spad{v} is a variable,{} and \\spad{p} is a TaylorSeries(\\spad{R}) in which there is term of form c*v^s where \\spad{c} is a constant. Let \\spad{s} be minimal as above. The result is a list of TaylorSeries coefficients A[\\spad{i}] of the equivalent polynomial A = A[0] + A[1]\\spad{*v} + A[2]\\spad{*v^2} + ... + A[\\spad{s}-1]\\spad{*v^}(\\spad{s}-1) + \\spad{v^s} such that p=A*B ,{} \\spad{B} being a TaylorSeries of minimum degree 0"))
 (|weierstrass|
  (((|List| (|TaylorSeries| |#1|)) (|Symbol|) (|TaylorSeries| |#1|))
   "\\spad{weierstrass(v,{} ts)} where \\spad{v} is a variable and \\spad{ts} is \\indented{1}{a TaylorSeries,{} implements the Weierstrass Preparation} \\indented{1}{Theorem. The result is a list of TaylorSeries that} \\indented{1}{are the coefficients of the equivalent series.}"))) 
NIL 
(|WildFunctionFieldIntegralBasis| K R UP F) 
((|constructor|
  (NIL
   "In this package \\spad{K} is a finite field,{} \\spad{R} is a ring of univariate polynomials over \\spad{K},{} and \\spad{F} is a framed algebra over \\spad{R}. The package provides a function to compute the integral closure of \\spad{R} in the quotient field of \\spad{F} as well as a function to compute a \"local integral basis\" at a specific prime."))
 (|localIntegralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|)))
    |#2|)
   "\\spad{integralBasis(p)} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the local integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))
 (|integralBasis|
  (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|)
              (|:| |basisInv| (|Matrix| |#2|))))
   "\\spad{integralBasis()} returns a record \\spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F},{} where \\spad{F} is a framed algebra with \\spad{R}-module basis \\spad{w1,{} w2,{} ...,{} wn}. If \\spad{basis} is the matrix \\spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \\spad{i}th element of the integral basis is \\spad{\\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly,{} the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{\\spad{wi}} with respect to the basis \\spad{v1,{} ...,{} vn}: if \\spad{basisInv} is the matrix \\spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \\spad{\\spad{wi} = sum(bij * vj,{} j = 1..n)}."))) 
NIL 
(|WeightedGraph| S W) 
((|constructor|
  (NIL
   "allows us to model weighted graphs This graph assigns a weight to each arrow. This is used when calculating say,{} lowest 'cost' routes. An arrow with a higher weight is more 'costly' in some way and therefore we try to choose the minimum weight. For arrows in series the overall weight is the sum of the individual weights. For arrows in parallel the overall weight is the minimum of the individual weights. \\spad{I} may change this in future to allow different cost metrics to be plugged in. \\blankline"))
 (|coerce| (($ (|FinitePoset| |#1|)) "\\spad{coerce FinitePoset} to graph"))
 (|weightedDistanceMatrix|
  (((|TwoDimensionalArray| (|Union| |#2| #1="disjoint")) $)
   "The elements of the returned array will represent the distance weights between vertices. if there is no connection between the vertices then the element will be set to \"disjoint\""))
 (|closedCartesian|
  (($ $ $ (|Mapping| |#1| |#1| |#1|)) "as Cartesian product but returns \\%."))
 (|closedTensor|
  (($ $ $ (|Mapping| |#1| |#1| |#1|)) "as tensor product but returns \\%."))
 (|cartesian|
  (((|WeightedGraph| (|Product| |#1| |#1|) |#2|) $ $)
   "Cartesian product: the vertex set of \\spad{G} \\spad{o} \\spad{H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}) and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) \\indented{1}{are adjacent in \\spad{G} \\spad{o} \\spad{H} if and only if either} \\spad{u} = \\spad{v} and u' is adjacent with \\spad{v'} in \\spad{H},{} or u' = \\spad{v'} and \\spad{u} is adjacent with \\spad{v} in \\spad{G}."))
 (*
  (((|WeightedGraph| (|Product| |#1| |#1|) |#2|) $ $)
   "tensor product : the tensor product \\spad{G*H} of graphs \\spad{G} and \\spad{H} is a graph such that the vertex set of \\spad{G*H} is the Cartesian product \\spad{V}(\\spad{G}) \\times \\spad{V}(\\spad{H}); and any two vertices (\\spad{u},{} u') and (\\spad{v},{} \\spad{v'}) are adjacent in \\spad{G} \\times \\spad{H} if and only if u' is adjacent with \\spad{v'} and \\spad{u} is adjacent with \\spad{v}."))
 (|routeArrowWeight|
  ((|#2| $ (|List| (|NonNegativeInteger|)))
   "the cumulative weight of a given route. The route is given in terms of a sequence of arrow indexes."))
 (|routeNodeWeight|
  ((|#2| $ (|List| (|NonNegativeInteger|)))
   "the cumulative weight of a given route. The route is given in terms of a sequence of node indexes."))
 (|distanceWeighted|
  (((|Union| |#2| #1#) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "the shortest distance between 'a' and \\spad{'b'} in terms of weight."))
 (|addWArrow!|
  (($ $ (|String|) (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|)
   "\\spad{addWArrow!(s,{} name,{} n1,{} n2,{} w)} adds a weighted arrow to the graph \\spad{s},{} where \\spad{name} is \\spad{name} of the arrow,{} \\spad{w} is weight of the arrow,{} \\spad{n1} is starting point of the arrow,{} \\spad{n2} is endpoint of the arrow."))
 (|weightedGraph|
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "constructor for graph with given objects and adjacency matrix.")
  (($ (|FinitePoset| |#1|))
   "\\spad{weightedGraph(poset)} constructs graph from a partially ordered set. This will be a graph with,{} at most,{} one arrow between any two nodes.")
  (($ (|List| |#1|)
    (|List|
     (|Record| (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)))))
   "\\spad{weightedGraph(obs,{} ars)} constructs graph with objects \\spad{obs} and arrows ars. This constructor just has pure abstract graph information without decoration information.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|))))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |arrType| (|NonNegativeInteger|))
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "constructor for graph with given objects and arrows more objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|)) (|:| |weight| |#2|)))
    (|List|
     (|Record| (|:| |name| (|String|)) (|:| |weight| |#2|)
               (|:| |fromOb| (|NonNegativeInteger|))
               (|:| |toOb| (|NonNegativeInteger|)) (|:| |xOffset| (|Integer|))
               (|:| |yOffset| (|Integer|))
               (|:| |map| (|List| (|NonNegativeInteger|))))))
   "\\spad{weightedGraph(ob,{} ar)} constructs graph with objects on and arrows ar. More objects and arrows can be added later if required.")
  (($
    (|List|
     (|Record| (|:| |value| |#1|) (|:| |posX| (|NonNegativeInteger|))
               (|:| |posY| (|NonNegativeInteger|)) (|:| |weight| |#2|))))
   "constructor for graph with given objects more objects and arrows can be added later if required.")
  (($ (|List| |#1|))
   "constructor for graph with given list of object names. Use this version of the constructor if you don\\spad{'t} intend to create diagrams and therefore don\\spad{'t} care about \\spad{x},{} \\spad{y} coordinates. more objects and arrows can be added later if required."))) 
NIL 
(|WeightedPolynomials| R |VarSet| E P |vl| |wl| |wtlevel|) 
((|constructor|
  (NIL
   "This domain represents truncated weighted polynomials over a general (not necessarily commutative) polynomial type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented."))
 (|changeWeightLevel|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{changeWeightLevel(n)} changes the weight level to the new value given: \\spad{NB:} previously calculated terms are not affected"))
 (/
  (((|Union| $ "failed") $ $)
   "\\spad{x/y} division (only works if minimum weight of divisor is zero,{} and if \\spad{R} is a Field)"))
 (|coerce|
  (($ |#4|)
   "\\spad{coerce(p)} coerces \\spad{p} into Weighted form,{} applying weights and ignoring terms")
  ((|#4| $) "convert back into a \\spad{\"P\"},{} ignoring weights"))) 
((|HasCategory| |#1| '(|CommutativeRing|)) (|HasCategory| |#1| '(|Field|))) 
(|WuWenTsunTriangularSet| R E V P) 
((|constructor|
  (NIL
   "A domain constructor of the category \\spadtype{GeneralTriangularSet}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. The \\spadopFrom{construct}{WuWenTsunTriangularSet} operation does not check the previous requirement. Triangular sets are stored as sorted lists \\spad{w}.\\spad{r}.\\spad{t}. the main variables of their members. Furthermore,{} this domain exports operations dealing with the characteristic set method of Wu Wen Tsun and some optimizations mainly proposed by Dong Ming Wang.\\newline"))
 (|characteristicSerie|
  (((|List| $) (|List| |#4|))
   "\\spad{characteristicSerie(ps)} returns the same as \\spad{characteristicSerie(ps,{} initiallyReduced?,{} initiallyReduce)}.")
  (((|List| $) (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)
    (|Mapping| |#4| |#4| |#4|))
   "\\spad{characteristicSerie(ps,{} redOp?,{} redOp)} returns a list \\spad{lts} of triangular sets such that the zero set of \\spad{ps} is the union of the regular zero sets of the members of \\spad{lts}. This is made by the Ritt and Wu Wen Tsun process applying the operation \\spad{characteristicSet(ps,{} redOp?,{} redOp)} to compute characteristic sets in Wu Wen Tsun sense."))
 (|characteristicSet|
  (((|Union| $ "failed") (|List| |#4|))
   "\\spad{characteristicSet(ps)} returns the same as \\spad{characteristicSet(ps,{} initiallyReduced?,{} initiallyReduce)}.")
  (((|Union| $ "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)
    (|Mapping| |#4| |#4| |#4|))
   "\\spad{characteristicSet(ps,{} redOp?,{} redOp)} returns a non-contradictory characteristic set of \\spad{ps} in Wu Wen Tsun sense \\spad{w}.\\spad{r}.\\spad{t} the reduction-test \\spad{redOp?} (using \\spad{redOp} to reduce polynomials \\spad{w}.\\spad{r}.\\spad{t} a \\spad{redOp?} basic set),{} if no non-zero constant polynomial appear during those reductions,{} else \\spad{\"failed\"} is returned. The operations \\spad{redOp} and \\spad{redOp?} must satisfy the following conditions: \\spad{redOp?(redOp(p,{} q),{} q)} holds for every polynomials \\spad{p,{} q} and there exists an integer \\spad{e} and a polynomial \\spad{f} such that we have \\spad{init(q)^e*p = f*q + redOp(p,{} q)}."))
 (|medialSet|
  (((|Union| $ "failed") (|List| |#4|))
   "\\spad{medial(ps)} returns the same as \\spad{medialSet(ps,{} initiallyReduced?,{} initiallyReduce)}.")
  (((|Union| $ "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)
    (|Mapping| |#4| |#4| |#4|))
   "\\spad{medialSet(ps,{} redOp?,{} redOp)} returns \\spad{bs} a basic set (in Wu Wen Tsun sense \\spad{w}.\\spad{r}.\\spad{t} the reduction-test \\spad{redOp?}) of some set generating the same ideal as \\spad{ps} (with rank not higher than any basic set of \\spad{ps}),{} if no non-zero constant polynomials appear during the computations,{} else \\spad{\"failed\"} is returned. In the former case,{} \\spad{bs} has to be understood as a candidate for being a characteristic set of \\spad{ps}. In the original algorithm,{} \\spad{bs} is simply a basic set of \\spad{ps}."))) 
((AND (|HasCategory| |#4| (LIST '|Evalable| (|devaluate| |#4|)))
      (|HasCategory| |#4| '(|SetCategory|)))
 (|HasCategory| |#4| (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| |#4| '(|BasicType|)) (|HasCategory| |#4| '(|OrderedSet|))
 (|HasCategory| |#1| '(|IntegralDomain|)) (|HasCategory| |#3| '(|Finite|))
 (|HasCategory| $ '(|shallowlyMutable|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| |#4| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (AND (|HasCategory| |#4| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))) 
(|XAlgebra| R) 
((|constructor|
  (NIL
   "This is the category of algebras over non-commutative rings. It is used by constructors of non-commutative algebras such as: \\indented{4}{\\spadtype{XPolynomialRing}.} \\indented{4}{\\spadtype{XFreeAlgebra}} Author: Michel Petitot (petitot@lifl.\\spad{fr})"))
 (|coerce| (($ |#1|) "\\spad{coerce(r)} equals \\spad{r*1}."))) 
NIL 
(|XDistributedPolynomial| |vl| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports distributed multivariate polynomials} whose variables do not commute. The coefficient ring may be non-commutative too. However,{} coefficients and variables commute."))) 
((|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|noZeroDivisors|))
 (|HasCategory| (|FreeMonoid| |#1|) '(|Comparable|))
 (AND (|HasCategory| |#2| '(|Comparable|))
      (|HasCategory| (|FreeMonoid| |#1|) '(|Comparable|)))) 
(|XDistributedPolynomialFunctions| VAR F) 
((|constructor|
  (NIL
   "Using the Hankel matrix of a noncommutative polynomial one can determine the rank (Matrices de Hankel by Fliess). The extended Ho-Algorithmus (Fornasini+Marchesini) is used to create a minimal linear representation. Another approach is implemented in NonCommutativeRationalFunctions."))
 (|minimalRepresentation|
  (((|Record| (|:| |alpha| (|Matrix| |#2|)) (|:| |mu| (|List| (|Matrix| |#2|)))
              (|:| |var| (|List| |#1|)) (|:| |beta| (|Matrix| |#2|)))
    (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{minimalRepresentation(p)} returns a minimal representation using the generalized Ho algorithm [Fornasini,{} 1978] \\spad{p} = sum_w alpha*mu(\\spad{w})*beta*w [Theorem 3.3,{} Salomaa--Soittola 1978]"))
 (|transformationMatrices|
  (((|List| (|Matrix| |#2|)) (|Matrix| |#2|))
   "\\spad{transformationMatrices(A)} returns a list of two matrices \\spad{P} and \\spad{Q} such that P*A*Q = \\spad{J} where the upper diagonal block of \\spad{J} is I_k for \\spad{k} = rank(A)."))
 (|findNonZeroEntry|
  (((|List| (|NonNegativeInteger|)) (|Matrix| |#2|) (|NonNegativeInteger|)
    (|NonNegativeInteger|))
   "\\spad{findNonZeroEntry(A,{}i,{}j)} returns the indices [\\spad{k},{}\\spad{l}] with i<=k<=m and j<=l<=n such that A(\\spad{k},{}\\spad{l}) is non-zero and [0,{}0] otherwise. A is of size \\spad{m} \\spad{x} \\spad{n}."))
 (|minimalMatrix|
  (((|Matrix| |#2|) (|Matrix| |#2|) (|NonNegativeInteger|))
   "\\spad{minimalMatrix(A,{}r)} returns the minimal (upper-left) submatrix of A such that the rank corresponds to the given."))
 (|display|
  (((|OutputForm|)
    (|Record| (|:| |rows| (|List| (|FreeMonoid| |#1|)))
              (|:| |cols| (|List| (|FreeMonoid| |#1|)))
              (|:| H (|Matrix| |#2|))))
   "\\spad{display(sys)} prints the Hankel matrix in an extended form with row-indices as column 0 and column-indices as row 0."))
 (|hankelSystem|
  (((|Record| (|:| |rows| (|List| (|FreeMonoid| |#1|)))
              (|:| |cols| (|List| (|FreeMonoid| |#1|)))
              (|:| H (|Matrix| |#2|)))
    (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{hankelSystem(p)} creates a Hankel-matrix for the polynomial \\spad{p} with respect to the basis of all factors in \\spad{p}. Row- and column-indices can be different."))
 (|hankelMatrix|
  (((|Matrix| |#2|) (|XDistributedPolynomial| |#1| |#2|) |#1|)
   "\\spad{hankelMatrix(p,{}x)} returns a matrix with the entries of the coefficients of \\spad{p} at (\\spad{u},{}\\spad{v}) where the monomials factorizes through \\spad{w} = u*x*v. This matrix is indexed by all words of the Hankel matrix.")
  (((|Matrix| |#2|) (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{hankelMatrix(p)} returns the Hankel matrix \\spad{H}(\\spad{p}) of given polynomial \\spad{p},{} \\spadignore{i.e.} the entries at (\\spad{u},{}\\spad{v}) are the coefficients of the monomials \\spad{w} = u*v. Rows and columns are indexed by words."))
 (|hankelIndices|
  (((|List| (|FreeMonoid| |#1|)) (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{hankelIndices(p)} returns a list of all left and right factors of the monomials of a given multivariate noncommutative polynomial. Factorization: \\spad{w} = u*v"))) 
NIL 
(|XExponentialPackage| R |VarSet| XPOLY) 
((|constructor|
  (NIL
   "This package provides computations of logarithms and exponentials for polynomials in non-commutative variables. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|Hausdorff|
  ((|#3| |#3| |#3| (|NonNegativeInteger|))
   "\\spad{Hausdorff(a,{} b,{} n)} returns log(exp(a)*exp(\\spad{b})) truncated at order \\spad{n}."))
 (|log|
  ((|#3| |#3| (|NonNegativeInteger|))
   "\\spad{log(p,{} n)} returns the logarithm of \\spad{p} truncated at order \\spad{n}."))
 (|exp|
  ((|#3| |#3| (|NonNegativeInteger|))
   "\\spad{exp(p,{} n)} returns the exponential of \\spad{p} truncated at order \\spad{n}."))) 
NIL 
(|ExtensionField&| S F) 
((|constructor|
  (NIL
   "ExtensionField {\\em F} is the category of fields which extend the field \\spad{F}"))
 (|Frobenius|
  (($ $ (|NonNegativeInteger|))
   "\\spad{Frobenius(a,{} s)} returns \\spad{a^(q^s)} where \\spad{q} is the size()\\$\\spad{F}.")
  (($ $)
   "\\spad{Frobenius(a)} returns \\spad{a ^ q} where \\spad{q} is the \\spad{size()\\$F}."))
 (/ (($ $ |#2|) "\\spad{x/y} divides \\spad{x} by the scalar \\spad{y}."))
 (|transcendenceDegree|
  (((|NonNegativeInteger|))
   "\\spad{transcendenceDegree()} returns the transcendence degree of the field extension,{} 0 if the extension is algebraic."))
 (|extensionDegree|
  (((|OnePointCompletion| (|PositiveInteger|)))
   "\\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic,{} and \\spad{infinity} if it is not."))
 (|degree|
  (((|OnePointCompletion| (|PositiveInteger|)) $)
   "\\spad{degree(a)} returns the degree of minimal polynomial of an element \\spad{a} if \\spad{a} is algebraic with respect to the ground field \\spad{F},{} and \\spad{infinity} otherwise."))
 (|inGroundField?|
  (((|Boolean|) $)
   "\\spad{inGroundField?(a)} tests whether an element \\spad{a} is already in the ground field \\spad{F}."))
 (|transcendent?|
  (((|Boolean|) $)
   "\\spad{transcendent?(a)} tests whether an element \\spad{a} is transcendent with respect to the ground field \\spad{F}."))
 (|algebraic?|
  (((|Boolean|) $)
   "\\spad{algebraic?(a)} tests whether an element \\spad{a} is algebraic with respect to the ground field \\spad{F}."))) 
((|HasCategory| |#2| '(|Finite|))
 (|HasCategory| |#2| '(|CharacteristicNonZero|))
 (|HasCategory| |#2| '(|CharacteristicZero|))) 
(|ExtensionField| F) 
((|constructor|
  (NIL
   "ExtensionField {\\em F} is the category of fields which extend the field \\spad{F}"))
 (|Frobenius|
  (($ $ (|NonNegativeInteger|))
   "\\spad{Frobenius(a,{} s)} returns \\spad{a^(q^s)} where \\spad{q} is the size()\\$\\spad{F}.")
  (($ $)
   "\\spad{Frobenius(a)} returns \\spad{a ^ q} where \\spad{q} is the \\spad{size()\\$F}."))
 (/ (($ $ |#1|) "\\spad{x/y} divides \\spad{x} by the scalar \\spad{y}."))
 (|transcendenceDegree|
  (((|NonNegativeInteger|))
   "\\spad{transcendenceDegree()} returns the transcendence degree of the field extension,{} 0 if the extension is algebraic."))
 (|extensionDegree|
  (((|OnePointCompletion| (|PositiveInteger|)))
   "\\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic,{} and \\spad{infinity} if it is not."))
 (|degree|
  (((|OnePointCompletion| (|PositiveInteger|)) $)
   "\\spad{degree(a)} returns the degree of minimal polynomial of an element \\spad{a} if \\spad{a} is algebraic with respect to the ground field \\spad{F},{} and \\spad{infinity} otherwise."))
 (|inGroundField?|
  (((|Boolean|) $)
   "\\spad{inGroundField?(a)} tests whether an element \\spad{a} is already in the ground field \\spad{F}."))
 (|transcendent?|
  (((|Boolean|) $)
   "\\spad{transcendent?(a)} tests whether an element \\spad{a} is transcendent with respect to the ground field \\spad{F}."))
 (|algebraic?|
  (((|Boolean|) $)
   "\\spad{algebraic?(a)} tests whether an element \\spad{a} is algebraic with respect to the ground field \\spad{F}."))) 
NIL 
(|XFreeAlgebra| |vl| R) 
((|constructor|
  (NIL
   "This category specifies operations for polynomials and formal series with non-commutative variables."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of variables which appear in \\spad{x}."))
 (|map|
  (($ (|Mapping| |#2| |#2|) $)
   "\\spad{map(fn,{} x)} returns \\spad{Sum(fn(r_i) w_i)} if \\spad{x} writes \\spad{Sum(r_i w_i)}."))
 (|sh|
  (($ $ (|NonNegativeInteger|))
   "\\spad{sh(x,{} n)} returns the shuffle power of \\spad{x} to the \\spad{n}.")
  (($ $ $)
   "\\spad{sh(x,{} y)} returns the shuffle-product of \\spad{x} by \\spad{y}. This multiplication is associative and commutative."))
 (|quasiRegular|
  (($ $) "\\spad{quasiRegular(x)} return \\spad{x} minus its constant term."))
 (|quasiRegular?|
  (((|Boolean|) $)
   "\\spad{quasiRegular?(x)} return \\spad{true} if \\spad{constant(x)} is zero."))
 (|constant|
  ((|#2| $) "\\spad{constant(x)} returns the constant term of \\spad{x}."))
 (|constant?|
  (((|Boolean|) $)
   "\\spad{constant?(x)} returns \\spad{true} if \\spad{x} is constant."))
 (|coerce| (($ |#1|) "\\spad{coerce(v)} returns \\spad{v}."))
 (|mirror|
  (($ $)
   "\\spad{mirror(x)} returns \\spad{Sum(r_i mirror(w_i))} if \\spad{x} writes \\spad{Sum(r_i w_i)}."))
 (|monomial?|
  (((|Boolean|) $)
   "\\spad{monomial?(x)} returns \\spad{true} if \\spad{x} is a monomial"))
 (|monomial|
  (($ |#2| (|FreeMonoid| |#1|))
   "\\spad{monomial(r,{} w)} returns the product of the word \\spad{w} by the coefficient \\spad{r}."))
 (|rquo|
  (($ $ $)
   "\\spad{rquo(x,{} y)} returns the right simplification of \\spad{x} by \\spad{y}.")
  (($ $ (|FreeMonoid| |#1|))
   "\\spad{rquo(x,{} w)} returns the right simplification of \\spad{x} by \\spad{w}.")
  (($ $ |#1|)
   "\\spad{rquo(x,{} v)} returns the right simplification of \\spad{x} by the variable \\spad{v}."))
 (|lquo|
  (($ $ $)
   "\\spad{lquo(x,{} y)} returns the left simplification of \\spad{x} by \\spad{y}.")
  (($ $ (|FreeMonoid| |#1|))
   "\\spad{lquo(x,{} w)} returns the left simplification of \\spad{x} by the word \\spad{w}.")
  (($ $ |#1|)
   "\\spad{lquo(x,{} v)} returns the left simplification of \\spad{x} by the variable \\spad{v}."))
 (|coef|
  ((|#2| $ $)
   "\\spad{coef(x,{} y)} returns scalar product of \\spad{x} by \\spad{y},{} the set of words being regarded as an orthogonal basis.")
  ((|#2| $ (|FreeMonoid| |#1|))
   "\\spad{coef(x,{} w)} returns the coefficient of the word \\spad{w} in \\spad{x}."))
 (|mindegTerm|
  (((|Record| (|:| |k| (|FreeMonoid| |#1|)) (|:| |c| |#2|)) $)
   "\\spad{mindegTerm(x)} returns the term whose word is \\spad{mindeg(x)}."))
 (|mindeg|
  (((|FreeMonoid| |#1|) $)
   "\\spad{mindeg(x)} returns the little word which appears in \\spad{x}. Error if \\spad{x=0}."))
 (*
  (($ $ |#2|)
   "\\spad{x * r} returns the product of \\spad{x} by \\spad{r}. Usefull if \\spad{R} is a non-commutative Ring.")
  (($ |#1| $)
   "\\spad{v * x} returns the product of a variable \\spad{x} by \\spad{x}."))) 
NIL 
(|XHashTable| |Key| |Entry|) 
((|constructor|
  (NIL
   "An implementation of a hash table that uses equality of the key domain to decide upon equality of keys."))
 (|table|
  (($ (|Mapping| (|SingleInteger|) |#1|))
   "\\spad{table(h)} creates an empty hash table that uses \\spad{h} instead of hash\\$Key. Note that \\spad{h} should be a mathematical function in the sense that from \\spad{k1=k2} follows \\spad{h}(\\spad{k1})\\spad{=h}(\\spad{k2}). If that is not the case,{} \\spad{k1} and \\spad{k2} will internally be considered as being different keys."))) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                (LIST '|ConvertibleTo| '(|InputForm|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|OrderedSet|))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) '(|BasicType|))
 (|HasCategory| |#1| '(|OrderedSet|))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|))))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
 (AND (|HasCategory| |#2| (LIST '|Evalable| (|devaluate| |#2|)))
      (|HasCategory| |#2| '(|SetCategory|)))
 (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                '(|SetCategory|))
 (AND
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 (LIST '|Evalable|
                       (LIST '|Record| (LIST '|:| '|key| (|devaluate| |#1|))
                             (LIST '|:| '|entry| (|devaluate| |#2|)))))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|BasicType|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (OR (|HasCategory| |#2| (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| |#2| '(|SetCategory|))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    (LIST '|CoercibleTo| '(|OutputForm|)))
     (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                    '(|SetCategory|)))
 (|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| $ '(|finiteAggregate|))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|OrderedSet|)))
 (AND (|HasCategory| $ '(|finiteAggregate|))
      (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                     '(|BasicType|)))
 (AND (|HasCategory| |#2| '(|BasicType|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (OR
  (AND (|HasCategory| |#2| '(|BasicType|))
       (|HasCategory| $ '(|finiteAggregate|)))
  (|HasCategory| |#2| '(|SetCategory|))
  (AND (|HasCategory| $ '(|finiteAggregate|))
       (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                      '(|BasicType|)))
  (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|))
                 '(|SetCategory|)))
 (AND (|HasCategory| |#2| '(|OrderedSet|))
      (|HasCategory| $ '(|finiteAggregate|)))
 (|HasCategory| $ '(|shallowlyMutable|))) 
(|ExportXml|) 
((|constructor| (NIL "This package provides support for \\spad{XML} files"))
 (|writeVRML|
  (((|Void|) (|XmlElement|) (|String|))
   "\\spad{writeVRML(content,{} filename)} writes the element as \\spad{VRML2}. \\spad{VRML2} is not \\spad{xml} but it has the same semantics and node names as \\spad{X3D} but a different syntax so it makes sense to create an \\spad{XML} structure and then format the output differently."))
 (|writeXml|
  (((|Void|) (|XmlElement|) (|String|))
   "\\spad{writeXml(content,{} filename)} writes an \\spad{xml} element and all the elements below it to an \\spad{xml} file. This assumes that all elements,{} in a file,{} have a single root which is usually the case."))) 
NIL 
(|XmlAttribute|) 
((|constructor|
  (NIL
   "This package provides support for \\spad{XML} files \\spad{XML} attributes are inside the opening tag: <tagname attributes> and usually have the form: name=value"))
 (|outputVRML|
  (((|Void|) $ (|TextFile|))
   "\\spad{outputVRML(rp,{} f1)} writes the attribute as \\spad{VRML2}. \\spad{VRML2} is not \\spad{xml} but it has the same semantics and node names as \\spad{X3D} but a different syntax so it makes sense to create an \\spad{XML} structure and then format the output differently."))
 (|coerce| (((|String|) $) "\\spad{coerce(x)} outputs \\spad{x} as a string"))
 (|xmlAttribute|
  (($ (|String|) (|List| (|String|)))
   "xmlAttribute: (name: String,{} values: List String) constructs a xmlAttribute from its name and list of values")
  (($ (|String|) (|String|))
   "\\spad{xmlAttribute(name,{} value)} construct a xmlAttribute from its \\spad{name} and value"))) 
NIL 
(|XmlElement|) 
((|constructor|
  (NIL
   "This package provides support for \\spad{XML} files an \\spad{XML} element is something which either has the form: <tagname attributes> content </tagname> or <tagname attributes/> where content may be a sequence of sub-elements or unstructured text"))
 (|outputVRML|
  (((|Void|) $ (|TextFile|))
   "\\spad{outputVRML(rp,{} f1)} writes the element as \\spad{VRML2}. \\spad{VRML2} is not \\spad{xml} but it has the same semantics and node names as \\spad{X3D} but a different syntax so it makes sense to create an \\spad{XML} structure and then format the output differently."))
 (|coerce|
  (((|List| (|String|)) $)
   "\\spad{coerce(x)} outputs \\spad{x} as a list of strings. Each element in the list represents a new line. This is an alternative to creating a long single string with 'newline' embedded in it."))
 (|empty?|
  (((|Boolean|) $)
   "\\spad{empty?(el)} returns \\spad{true} is this element does not contain anything"))
 (|xmlElement|
  (($ (|String|) (|String|) (|List| (|XmlAttribute|)))
   "\\spad{xmlElement(name,{} txt,{} attributes)} construct an element with unstructured text")
  (($ (|String|) (|List| $) (|List| (|XmlAttribute|)))
   "\\spad{xmlElement(name,{} elements,{} attributes)} construct an element with structured \\spad{elements}"))) 
NIL 
(|XPBWPolynomial| |VarSet| R) 
((|constructor|
  (NIL
   "This domain constructor implements polynomials in non-commutative variables written in the Poincare-Birkhoff-Witt basis from the Lyndon basis. These polynomials can be used to compute Baker-Campbell-Hausdorff relations. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|log|
  (($ $ (|NonNegativeInteger|))
   "\\spad{log(p,{} n)} returns the logarithm of \\spad{p} (truncated up to order \\spad{n})."))
 (|exp|
  (($ $ (|NonNegativeInteger|))
   "\\spad{exp(p,{} n)} returns the exponential of \\spad{p} (truncated up to order \\spad{n})."))
 (|product|
  (($ $ $ (|NonNegativeInteger|))
   "\\spad{product(a,{} b,{} n)} returns \\spad{a*b} (truncated up to order \\spad{n})."))
 (|LiePolyIfCan|
  (((|Union| (|LiePolynomial| |#1| |#2|) "failed") $)
   "\\spad{LiePolyIfCan(p)} return \\spad{p} if \\spad{p} is a Lie polynomial."))
 (|coerce|
  (((|XRecursivePolynomial| |#1| |#2|) $)
   "\\spad{coerce(p)} returns \\spad{p} as a recursive polynomial.")
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{coerce(p)} returns \\spad{p} as a distributed polynomial.")
  (($ (|LiePolynomial| |#1| |#2|)) "\\spad{coerce(p)} returns \\spad{p}."))) 
((|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|noZeroDivisors|))
 (|HasCategory| (|PoincareBirkhoffWittLyndonBasis| |#1|) '(|Comparable|))
 (AND (|HasCategory| |#2| '(|Comparable|))
      (|HasCategory| (|PoincareBirkhoffWittLyndonBasis| |#1|) '(|Comparable|)))
 (|HasCategory| |#2| (LIST '|Module| (LIST '|Fraction| '(|Integer|))))) 
(|XPolynomialFactor| |vl| F) 
((|lift1|
  (((|Record| (|:| |l_fac| (|XDistributedPolynomial| |#1| (|Polynomial| |#2|)))
              (|:| |r_fac| (|XDistributedPolynomial| |#1| (|Polynomial| |#2|)))
              (|:| |residual|
                   (|XDistributedPolynomial| |#1| (|Polynomial| |#2|)))
              (|:| |nsym| (|Union| (|Symbol|) "none")))
    (|FreeMonoid| |#1|) (|XDistributedPolynomial| |#1| (|Polynomial| |#2|))
    (|Integer|) (|FreeMonoid| |#1|)
    (|XDistributedPolynomial| |#1| (|Polynomial| |#2|)) (|Integer|) |#2|
    (|XDistributedPolynomial| |#1| (|Polynomial| |#2|)) (|Boolean|))
   "\\spad{lift1(lw,{} lfy,{} d1,{} rw,{} rfy,{} j,{} lc,{} rp,{} o_case)}"))) 
((|HasCategory| |#2| '(|PolynomialFactorizationExplicit|))) 
(|XPolynomial| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports multivariate polynomials} whose set of variables is \\spadtype{Symbol}. The representation is recursive. The coefficient ring may be non-commutative and the variables do not commute. However,{} coefficients and variables commute."))) 
((|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|noZeroDivisors|))
 (|HasCategory| (|FreeMonoid| (|Symbol|)) '(|Comparable|))
 (AND (|HasCategory| |#1| '(|Comparable|))
      (|HasCategory| (|FreeMonoid| (|Symbol|)) '(|Comparable|)))) 
(|XPolynomialsCat| |vl| R) 
((|constructor|
  (NIL
   "The Category of polynomial rings with non-commutative variables. The coefficient ring may be non-commutative too. However coefficients commute with variables."))
 (|trunc|
  (($ $ (|NonNegativeInteger|))
   "\\spad{trunc(p,{} n)} returns the polynomial \\spad{p} truncated at order \\spad{n}."))
 (|degree|
  (((|NonNegativeInteger|) $)
   "\\spad{degree(p)} returns the degree of \\spad{p}. \\indented{1}{Note that the degree of a word is its length.}"))
 (|maxdeg|
  (((|FreeMonoid| |#1|) $)
   "\\spad{maxdeg(p)} returns the greatest leading word in the support of \\spad{p}."))) 
NIL 
(|XPolynomialRing| R E) 
((|constructor|
  (NIL
   "This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and words belonging to an arbitrary \\spadtype{OrderedMonoid}. This type is used,{} for instance,{} by the \\spadtype{XDistributedPolynomial} domain constructor where the Monoid is free."))
 (/ (($ $ |#1|) "\\spad{p/r} returns \\spad{p*(1/r)}."))
 (|map|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{map(fn,{} x)} returns \\spad{Sum(fn(r_i) w_i)} if \\spad{x} writes \\spad{Sum(r_i w_i)}."))
 (|quasiRegular|
  (($ $) "\\spad{quasiRegular(x)} return \\spad{x} minus its constant term."))
 (|quasiRegular?|
  (((|Boolean|) $)
   "\\spad{quasiRegular?(x)} return \\spad{true} if \\spad{constant(p)} is zero."))
 (|constant|
  ((|#1| $) "\\spad{constant(p)} return the constant term of \\spad{p}."))
 (|constant?|
  (((|Boolean|) $)
   "\\spad{constant?(p)} tests whether the polynomial \\spad{p} belongs to the coefficient ring."))
 (|coef|
  ((|#1| $ |#2|)
   "\\spad{coef(p,{} e)} extracts the coefficient of the monomial \\spad{e}. Returns zero if \\spad{e} is not present."))
 (|reductum|
  (($ $)
   "\\spad{reductum(p)} returns \\spad{p} minus its leading term. An error is produced if \\spad{p} is zero."))
 (|mindeg|
  ((|#2| $)
   "\\spad{mindeg(p)} returns the smallest word occurring in the polynomial \\spad{p} with a non-zero coefficient. An error is produced if \\spad{p} is zero."))
 (|maxdeg|
  ((|#2| $)
   "\\spad{maxdeg(p)} returns the greatest word occurring in the polynomial \\spad{p} with a non-zero coefficient. An error is produced if \\spad{p} is zero."))
 (|coerce| (($ |#2|) "\\spad{coerce(e)} returns \\spad{1*e}"))
 (|#|
  (((|NonNegativeInteger|) $)
   "\\spad{\\# p} returns the number of terms in \\spad{p}."))
 (* (($ $ |#1|) "\\spad{p*r} returns the product of \\spad{p} by \\spad{r}."))
 (|canonicalUnitNormal|
  ((|attribute|)
   "canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element."))) 
((|HasCategory| |#1| '(|CommutativeRing|))
 (|HasCategory| |#1| '(|canonicalUnitNormal|))
 (|HasCategory| |#1| '(|noZeroDivisors|)) (|HasCategory| |#2| '(|Comparable|))
 (AND (|HasCategory| |#1| '(|Comparable|))
      (|HasCategory| |#2| '(|Comparable|)))
 (|HasCategory| |#1| '(|Field|))) 
(|XRecursivePolynomial| |VarSet| R) 
((|constructor|
  (NIL
   "\\indented{2}{This type supports multivariate polynomials} whose variables do not commute. The representation is recursive. The coefficient ring may be non-commutative. Coefficients and variables commute."))
 (|RemainderList|
  (((|List| (|Record| (|:| |k| |#1|) (|:| |c| $))) $)
   "\\spad{RemainderList(p)} returns the regular part of \\spad{p} as a list of terms."))
 (|unexpand|
  (($ (|XDistributedPolynomial| |#1| |#2|))
   "\\spad{unexpand(p)} returns \\spad{p} in recursive form."))
 (|expand|
  (((|XDistributedPolynomial| |#1| |#2|) $)
   "\\spad{expand(p)} returns \\spad{p} in distributed form."))) 
((|HasCategory| |#2| '(|CommutativeRing|))
 (|HasCategory| |#2| '(|noZeroDivisors|))
 (|HasCategory| (|FreeMonoid| |#1|) '(|Comparable|))
 (AND (|HasCategory| |#2| '(|Comparable|))
      (|HasCategory| (|FreeMonoid| |#1|) '(|Comparable|)))) 
(|ParadoxicalCombinatorsForStreams| A) 
((|constructor|
  (NIL "This package implements fixed-point computations on streams."))
 (Y
  (((|List| (|Stream| |#1|))
    (|Mapping| (|List| (|Stream| |#1|)) (|List| (|Stream| |#1|))) (|Integer|))
   "\\spad{Y(g,{} n)} computes a fixed point of the function \\spad{g},{} where \\spad{g} takes a list of \\spad{n} streams and returns a list of \\spad{n} streams.")
  (((|Stream| |#1|) (|Mapping| (|Stream| |#1|) (|Stream| |#1|)))
   "\\spad{Y(f)} computes a fixed point of the function \\spad{f}."))) 
NIL 
(|ZeroDimensionalSolvePackage| R |ls| |ls2|) 
((|constructor|
  (NIL
   "A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the \\spadtype{RealClosure} of the coefficient ring. This constructor takes three arguments. The first one \\spad{R} is the coefficient ring. The second one \\spad{ls} is the list of variables involved in the systems to solve. The third one must be \\spad{concat(ls,{} s)} where \\spad{s} is an additional symbol used for the univariate representations. WARNING: The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the \\spadtype{RegularChain} domain constructor. The lexTriangular algorithm can also be used for computing these decompositions (see the \\spadtype{LexTriangularPackage} package constructor). For that purpose,{} the operations \\spadopFrom{univariateSolve}{ZeroDimensionalSolvePackage},{} \\spadopFrom{realSolve}{ZeroDimensionalSolvePackage} and \\spadopFrom{positiveSolve}{ZeroDimensionalSolvePackage} admit an optional argument. \\newline Author: Marc Moreno Maza."))
 (|convert|
  (((|List|
     (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|)))
    (|SquareFreeRegularTriangularSet| |#1|
                                      (|IndexedExponents|
                                       (|OrderedVariableList| |#3|))
                                      (|OrderedVariableList| |#3|)
                                      (|NewSparseMultivariatePolynomial| |#1|
                                                                         (|OrderedVariableList|
                                                                          |#3|))))
   "\\spad{convert(st)} returns the members of \\spad{st}.")
  (((|SparseUnivariatePolynomial| (|RealClosure| (|Fraction| |#1|)))
    (|SparseUnivariatePolynomial| |#1|))
   "\\spad{convert(u)} converts \\spad{u}.")
  (((|Polynomial| (|RealClosure| (|Fraction| |#1|)))
    (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|)))
   "\\spad{convert(q)} converts \\spad{q}.")
  (((|Polynomial| (|RealClosure| (|Fraction| |#1|))) (|Polynomial| |#1|))
   "\\spad{convert(p)} converts \\spad{p}.")
  (((|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|))
    (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))
   "\\spad{convert(q)} converts \\spad{q}."))
 (|squareFree|
  (((|List|
     (|SquareFreeRegularTriangularSet| |#1|
                                       (|IndexedExponents|
                                        (|OrderedVariableList| |#3|))
                                       (|OrderedVariableList| |#3|)
                                       (|NewSparseMultivariatePolynomial| |#1|
                                                                          (|OrderedVariableList|
                                                                           |#3|))))
    (|RegularChain| |#1| |#2|))
   "\\spad{squareFree(ts)} returns the square-free factorization of \\spad{ts}. Moreover,{} each factor is a Lazard triangular set and the decomposition is a Kalkbrener split of \\spad{ts},{} which is enough here for the matter of solving zero-dimensional algebraic systems. WARNING: \\spad{ts} is not checked to be zero-dimensional."))
 (|positiveSolve|
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{positiveSolve(lp)} returns the same as \\spad{positiveSolve(lp,{} false,{} false)}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)) (|Boolean|))
   "\\spad{positiveSolve(lp)} returns the same as \\spad{positiveSolve(lp,{} info?,{} false)}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|))
   "\\spad{positiveSolve(lp,{} info?,{} lextri?)} returns the set of the points in the variety associated with \\spad{lp} whose coordinates are (real) strictly positive. Moreover,{} if \\spad{info?} is \\spad{true} then some information is displayed during decomposition into regular chains. If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see \\spadopFrom{zeroSetSplit}{LexTriangularPackage}(\\spad{lp},{} \\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \\spadopFrom{zeroSetSplit}{RegularChain} from \\spadtype{RegularChain}. WARNING: For each set of coordinates given by \\spad{positiveSolve(lp,{} info?,{} lextri?)} the ordering of the indeterminates is reversed \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ls}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|RegularChain| |#1| |#2|))
   "\\spad{positiveSolve(ts)} returns the points of the regular set of \\spad{ts} with (real) strictly positive coordinates."))
 (|realSolve|
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{realSolve(lp)} returns the same as \\spad{realSolve(ts,{} false,{} false,{} false)}")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)) (|Boolean|))
   "\\spad{realSolve(ts,{} info?)} returns the same as \\spad{realSolve(ts,{} info?,{} false,{} false)}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|))
   "\\spad{realSolve(ts,{} info?,{} check?)} returns the same as \\spad{realSolve(ts,{} info?,{} check?,{} false)}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{realSolve(ts,{} info?,{} check?,{} lextri?)} returns the set of the points in the variety associated with \\spad{lp} whose coordinates are all real. Moreover,{} if \\spad{info?} is \\spad{true} then some information is displayed during decomposition into regular chains. If \\spad{check?} is \\spad{true} then the result is checked. If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see \\spadopFrom{zeroSetSplit}{LexTriangularPackage}(\\spad{lp},{} \\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \\spadopFrom{zeroSetSplit}{RegularChain} from \\spadtype{RegularChain}. WARNING: For each set of coordinates given by \\spad{realSolve(ts,{} info?,{} check?,{} lextri?)} the ordering of the indeterminates is reversed \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ls}.")
  (((|List| (|List| (|RealClosure| (|Fraction| |#1|))))
    (|RegularChain| |#1| |#2|))
   "\\spad{realSolve(ts)} returns the set of the points in the regular zero set of \\spad{ts} whose coordinates are all real. WARNING: For each set of coordinates given by \\spad{realSolve(ts)} the ordering of the indeterminates is reversed \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ls}."))
 (|univariateSolve|
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)))
   "\\spad{univariateSolve(lp)} returns the same as \\spad{univariateSolve(lp,{} false,{} false,{} false)}.")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|Boolean|))
   "\\spad{univariateSolve(lp,{} info?)} returns the same as \\spad{univariateSolve(lp,{} info?,{} false,{} false)}.")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|))
   "\\spad{univariateSolve(lp,{} info?,{} check?)} returns the same as \\spad{univariateSolve(lp,{} info?,{} check?,{} false)}.")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|) (|Boolean|))
   "\\spad{univariateSolve(lp,{} info?,{} check?,{} lextri?)} returns a univariate representation of the variety associated with \\spad{lp}. Moreover,{} if \\spad{info?} is \\spad{true} then some information is displayed during the decomposition into regular chains. If \\spad{check?} is \\spad{true} then the result is checked. See \\spadopFrom{rur}{RationalUnivariateRepresentationPackage}(\\spad{lp},{} \\spad{true}). If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see \\spadopFrom{zeroSetSplit}{LexTriangularPackage}(\\spad{lp},{} \\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \\spadopFrom{zeroSetSplit}{RegularChain} from \\spadtype{RegularChain}.")
  (((|List|
     (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|))
               (|:| |coordinates| (|List| (|Polynomial| |#1|)))))
    (|RegularChain| |#1| |#2|))
   "\\spad{univariateSolve(ts)} returns a univariate representation of \\spad{ts}. See \\spadopFrom{rur}{RationalUnivariateRepresentationPackage}(\\spad{lp},{} \\spad{true})."))
 (|triangSolve|
  (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|)))
   "\\spad{triangSolve(lp)} returns the same as \\spad{triangSolve(lp,{} false,{} false)}")
  (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|))
    (|Boolean|))
   "\\spad{triangSolve(lp,{} info?)} returns the same as \\spad{triangSolve(lp,{} false)}")
  (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|))
    (|Boolean|) (|Boolean|))
   "\\spad{triangSolve(lp,{} info?,{} lextri?)} decomposes the variety associated with \\spad{lp} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\spad{lp} needs to generate a zero-dimensional ideal. If \\spad{lp} is not zero-dimensional then the result is only a decomposition of its zero-set in the sense of the closure (\\spad{w}.\\spad{r}.\\spad{t}. Zarisky topology). Moreover,{} if \\spad{info?} is \\spad{true} then some information is displayed during the computations. See \\spadopFrom{zeroSetSplit}{RegularTriangularSetCategory}(\\spad{lp},{} \\spad{true},{} \\spad{info?}). If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see \\spadopFrom{zeroSetSplit}{LexTriangularPackage}(\\spad{lp},{} \\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \\spadopFrom{zeroSetSplit}{RegularChain} from \\spadtype{RegularChain}."))) 
NIL 
(|IntegerLinearDependence| R) 
((|constructor| (NIL "Test for linear dependence over the integers."))
 (|solveLinearlyOverQ|
  (((|Record|
     (|:| |particular|
          (|Union| (|Vector| (|Fraction| (|Integer|))) #1="failed"))
     (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
    (|Matrix| |#1|) (|Vector| |#1|))
   "\\spad{solveLinearlyOverQ([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}")
  (((|Record|
     (|:| |particular| (|Union| (|Vector| (|Fraction| (|Integer|))) #1#))
     (|:| |basis| (|List| (|Vector| (|Fraction| (|Integer|))))))
    (|Vector| |#1|) |#1|)
   "\\spad{solveLinearlyOverQ([v1,{} ...,{} vn],{} u)} returns solution of the system \\spad{c1*v1 + ... + cn*vn = u} and and a basis of the associated homogeneous system \\spad{c1*v1 + ... + cn*vn = 0}"))
 (|particularSolutionOverQ|
  (((|Union| (|Vector| (|Fraction| (|Integer|))) #1#) (|Matrix| |#1|)
    (|Vector| |#1|))
   "\\spad{solveLinearlyOverQ([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such rational numbers \\spad{ci}\\spad{'s} exist.")
  (((|Union| (|Vector| (|Fraction| (|Integer|))) #1#) (|Vector| |#1|) |#1|)
   "\\spad{particularSolutionOverQ([v1,{} ...,{} vn],{} u)} returns \\spad{[c1,{} ...,{} cn]} such that \\spad{c1*v1 + ... + cn*vn = u},{} \"failed\" if no such rational numbers \\spad{ci}\\spad{'s} exist."))
 (|linearDependenceOverZ|
  (((|Union| (|Vector| (|Integer|)) "failed") (|Vector| |#1|))
   "\\spad{linearlyDependenceOverZ([v1,{} ...,{} vn])} returns \\spad{[c1,{} ...,{} cn]} if \\spad{c1*v1 + ... + cn*vn = 0} and not all the \\spad{ci}\\spad{'s} are 0,{} \"failed\" if the \\spad{vi}\\spad{'s} are linearly independent over the integers."))
 (|linearlyDependentOverZ?|
  (((|Boolean|) (|Vector| |#1|))
   "\\spad{linearlyDependentOverZ?([v1,{} ...,{} vn])} returns \\spad{true} if the \\spad{vi}\\spad{'s} are linearly dependent over the integers,{} \\spad{false} otherwise."))) 
NIL 
(|IntegerMod| |p|) 
((|constructor|
  (NIL
   "IntegerMod(\\spad{n}) creates the ring of integers reduced modulo the integer \\spad{n}."))) 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
((|Category| NIL 3155497 3155502 3155507) (|Union| NIL 3155482 3155487 3155492)
 (|Record| NIL 3155467 3155472 3155477) (|Mapping| NIL 3155452 3155457 3155462)
 (|Enumeration| NIL 3155437 3155442 3155447)
 (|IntegerMod| "ZMOD.spad" 3155291 3155311 3155432)
 (|IntegerLinearDependence| "ZLINDEP.spad" 3153172 3153203 3155286)
 (|ZeroDimensionalSolvePackage| "ZDSOLVE.spad" 3142061 3142107 3153167)
 (|ParadoxicalCombinatorsForStreams| "YSTREAM.spad" 3141512 3141552 3142056)
 (|XRecursivePolynomial| "XRPOLY.spad" 3140594 3140631 3141270)
 (|XPolynomialRing| "XPR.spad" 3138232 3138257 3140303)
 (|XPolynomialsCat| "XPOLYC.spad" 3137588 3137616 3138227)
 (|XPolynomial| "XPOLY.spad" 3137020 3137039 3137334)
 (|XPolynomialFactor| "XPFACT.spad" 3136267 3136297 3136959)
 (|XPBWPolynomial| "XPBWPOLY.spad" 3134690 3134721 3135912)
 (|XmlElement| "XMLEL.spad" 3133372 3133388 3134685)
 (|XmlAttribute| "XMLAT.spad" 3132447 3132465 3133367)
 (|ExportXml| "XML.spad" 3131727 3131742 3132442)
 (|XHashTable| "XHASHTBL.spad" 3128254 3128284 3128819)
 (|XFreeAlgebra| "XFALG.spad" 3125230 3125255 3128249)
 (|ExtensionField| "XF.spad" 3123652 3123674 3125225)
 (|ExtensionField&| "XF.spad" 3121945 3121970 3123521)
 (|XExponentialPackage| "XEXPPKG.spad" 3121256 3121298 3121940)
 (|XDistributedPolynomialFunctions| "XDPOLYF.spad" 3118016 3118059 3121251)
 (|XDistributedPolynomial| "XDPOLY.spad" 3117508 3117543 3117774)
 (|XAlgebra| "XALG.spad" 3117134 3117150 3117503)
 (|WuWenTsunTriangularSet| "WUTSET.spad" 3113284 3113320 3116555)
 (|WeightedPolynomials| "WP.spad" 3112322 3112382 3113207)
 (|WeightedGraph| "WGRPH.spad" 3106935 3106958 3112317)
 (|WildFunctionFieldIntegralBasis| "WFFINTBS.spad" 3104417 3104462 3106930)
 (|WeierstrassPreparation| "WEIER.spad" 3103396 3103426 3104412)
 (|VectorSpaceBasis| "VSBASIS.spad" 3098456 3098480 3103391)
 (|Void| "VOID.spad" 3098041 3098051 3098451)
 (|ViewDefaultsPackage| "VIEWDEF.spad" 3093076 3093101 3098036)
 (|ThreeDimensionalViewport| "VIEW3D.spad" 3076344 3076374 3093071)
 (|TwoDimensionalViewport| "VIEW2D.spad" 3063714 3063742 3076339)
 (|ViewportPackage| "VIEW.spad" 3061250 3061271 3063709)
 (|VectorHermitePadeSolver| "VHPSOLV.spad" 3060860 3060889 3061245)
 (|VectorFunctions2| "VECTOR2.spad" 3059459 3059485 3060855)
 (|Vector| "VECTOR.spad" 3056374 3056388 3056639)
 (|VectorCategory| "VECTCAT.spad" 3054224 3054246 3056369)
 (|VectorCategory&| "VECTCAT.spad" 3051805 3051830 3053953)
 (|VectorIntegerReconstructor| "VECREC2.spad" 3050612 3050644 3051800)
 (|VectorModularReconstructor| "VECREC1.spad" 3047162 3047194 3050607)
 (|Variable| "VARIABLE.spad" 3046940 3046960 3047157)
 (|VarCat| "VARCAT.spad" 3045593 3045605 3046935)
 (|TaylorSolve| "UTSSOL.spad" 3045551 3045583 3045588)
 (|UTSodetools| "UTSODETL.spad" 3044814 3044842 3045507)
 (|UnivariateTaylorSeriesODESolver| "UTSODE.spad" 3042894 3042942 3044809)
 (|UnivariateTaylorSeriesCategory| "UTSCAT.spad" 3040866 3040909 3042889)
 (|UnivariateTaylorSeriesCategory&| "UTSCAT.spad" 3038805 3038851 3040831)
 (|UnivariateTaylorSeriesFunctions2| "UTS2.spad" 3038362 3038426 3038800)
 (|UnivariateTaylorSeries| "UTS.spad" 3027739 3027786 3031541)
 (|UnaryRecursiveAggregate| "URAGG.spad" 3022123 3022154 3027734)
 (|UnaryRecursiveAggregate&| "URAGG.spad" 3016463 3016497 3022077)
 (|UnivariatePuiseuxSeriesWithExponentialSingularity| "UPXSSING.spad" 3013131
                                                      3013203 3014894)
 (|UnivariatePuiseuxSeriesConstructor| "UPXSCONS.spad" 3005083 3005134 3005495)
 (|UnivariatePuiseuxSeriesConstructorCategory| "UPXSCCA.spad" 3003601 3003660
                                               3005078)
 (|UnivariatePuiseuxSeriesConstructorCategory&| "UPXSCCA.spad" 3002116 3002178
                                                3003596)
 (|UnivariatePuiseuxSeriesCategory| "UPXSCAT.spad" 3001313 3001357 3002111)
 (|UnivariatePuiseuxSeriesFunctions2| "UPXS2.spad" 3000776 3000896 3001308)
 (|UnivariatePuiseuxSeries| "UPXS.spad" 2991989 2992037 2993140)
 (|UnivariatePolynomialSquareFree| "UPSQFREE.spad" 2990282 2990323 2991984)
 (|UnivariatePowerSeriesCategory| "UPSCAT.spad" 2987684 2987734 2990277)
 (|UnivariatePowerSeriesCategory&| "UPSCAT.spad" 2984571 2984624 2987167)
 (|UnivariatePolynomialCategoryFunctions2| "UPOLYC2.spad" 2983999 2984053
                                           2984566)
 (|UnivariatePolynomialCategory| "UPOLYC.spad" 2978730 2978766 2983994)
 (|UnivariatePolynomialCategory&| "UPOLYC.spad" 2973165 2973204 2978432)
 (|UnivariatePolynomialMultiplicationPackage| "UPMP.spad" 2971993 2972044
                                              2973160)
 (|UnivariatePolynomialDivisionPackage| "UPDIVP.spad" 2971513 2971559 2971988)
 (|UnivariatePolynomialDecompositionPackage| "UPDECOMP.spad" 2969124 2969175
                                             2971478)
 (|UnivariatePolynomialCommonDenominator| "UPCDEN.spad" 2969064 2969114
                                          2969119)
 (|UnivariatePolynomialFunctions2| "UP2.spad" 2968387 2968435 2969059)
 (|UnivariatePolynomial| "UP.spad" 2950134 2950166 2950528)
 (|Untyped| "UNTYPED.spad" 2949502 2949515 2950129)
 (|UniversalSegmentFunctions2| "UNISEG2.spad" 2948965 2949001 2949461)
 (|UniversalSegment| "UNISEG.spad" 2948133 2948157 2948741)
 (|UnivariateLaurentSeriesConstructor| "ULSCONS.spad" 2934900 2934951 2935308)
 (|UnivariateLaurentSeriesConstructorCategory| "ULSCCAT.spad" 2932580 2932639
                                               2934895)
 (|UnivariateLaurentSeriesConstructorCategory&| "ULSCCAT.spad" 2930227 2930289
                                                2932545)
 (|UnivariateLaurentSeriesCategory| "ULSCAT.spad" 2928800 2928844 2930222)
 (|UnivariateLaurentSeriesCategory&| "ULSCAT.spad" 2927299 2927346 2928724)
 (|UnivariateLaurentSeriesFunctions2| "ULS2.spad" 2926733 2926853 2927294)
 (|UnivariateLaurentSeries| "ULS.spad" 2908696 2908744 2909835)
 (|UnitGaussianElimination| "UGAUSS.spad" 2907812 2907841 2908691)
 (|UnivariateFormalPowerSeriesFunctions| "UFPS1.spad" 2907753 2907802 2907807)
 (|UnivariateFormalPowerSeries| "UFPS.spad" 2900887 2900927 2900932)
 (|UniqueFactorizationDomain| "UFD.spad" 2899970 2900001 2900882)
 (|UniqueFactorizationDomain&| "UFD.spad" 2899050 2899084 2899965)
 (|UserDefinedVariableOrdering| "UDVO.spad" 2897822 2897855 2899045)
 (|UserDefinedPartialOrdering| "UDPO.spad" 2895160 2895194 2897782)
 (|UndirectedGraph| "UDGRPH.spad" 2891594 2891617 2895155)
 (|U8Vector| "U8VEC.spad" 2888688 2888702 2888922)
 (|U8Matrix| "U8MAT.spad" 2886642 2886656 2886878)
 (|U64Int| "U64INT.spad" 2886471 2886483 2886637)
 (|U32Vector| "U32VEC.spad" 2883563 2883578 2883799)
 (|U32Matrix| "U32MAT.spad" 2881515 2881530 2881753)
 (|U16Vector| "U16VEC.spad" 2878607 2878622 2878843)
 (|U16Matrix| "U16MAT.spad" 2876559 2876574 2876797)
 (|Typed| "TYPED.spad" 2876463 2876474 2876554)
 (|Type| "TYPE.spad" 2876399 2876409 2876458)
 (|TwoFactorize| "TWOFACT.spad" 2874510 2874530 2876394)
 (|Tuple| "TUPLE.spad" 2873878 2873891 2874409)
 (|TubePlotTools| "TUBETOOL.spad" 2870615 2870634 2873873)
 (|TubePlot| "TUBE.spad" 2869212 2869234 2870610)
 (|TriangularSetCategory| "TSETCAT.spad" 2858305 2858340 2869207)
 (|TriangularSetCategory&| "TSETCAT.spad" 2847364 2847402 2858269)
 (|TaylorSeriesExpansionTaylor| "TSEREXPT.spad" 2847310 2847354 2847359)
 (|TaylorSeriesExpansionPuiseux| "TSEREXPP.spad" 2847247 2847300 2847305)
 (|TaylorSeriesExpansionLaurent| "TSEREXPL.spad" 2847188 2847237 2847242)
 (|TaylorSeriesExpansionGeneralized| "TSEREXPG.spad" 2847117 2847178 2847183)
 (|TaylorSeriesExpansion| "TSEREXP.spad" 2846000 2846055 2847112)
 (|TaylorSeriesExpansion&| "TSEREXP.spad" 2844880 2844938 2845995)
 (|TaylorSeries| "TS.spad" 2842962 2842987 2843982)
 (|TranscendentalManipulations| "TRMANIP.spad" 2836933 2836970 2842613)
 (|TriangularMatrixOperations| "TRIMAT.spad" 2835855 2835903 2836928)
 (|TrigonometricManipulationsAux| "TRIGMNPA.spad" 2835219 2835259 2835850)
 (|TrigonometricManipulations| "TRIGMNIP.spad" 2833665 2833701 2835214)
 (|TrigonometricFunctionCategory| "TRIGCAT.spad" 2833150 2833185 2833660)
 (|TrigonometricFunctionCategory&| "TRIGCAT.spad" 2832632 2832670 2833145)
 (|Tree| "TREE.spad" 2831177 2831189 2831690)
 (|TranscendentalFunctionCategory| "TRANFUN.spad" 2830985 2831021 2831172)
 (|TranscendentalFunctionCategory&| "TRANFUN.spad" 2830790 2830829 2830980)
 (|TopLevelThreeSpace| "TOPSP.spad" 2830446 2830470 2830785)
 (|ToolsForSign| "TOOLSIGN.spad" 2830098 2830118 2830441)
 (|TexmacsFormat| "TMFORM.spad" 2829532 2829551 2830093)
 (|TimeoutPackage| "TIMEOUT.spad" 2829155 2829177 2829527)
 (|TextFile| "TEXTFILE.spad" 2827671 2827685 2829150)
 (|TexFormat1| "TEX1.spad" 2827214 2827232 2827666)
 (|TexFormat| "TEX.spad" 2823855 2823870 2827209)
 (|Unittest| "TESTUNIT.spad" 2821658 2821672 2823850)
 (|UnittestCount| "TESTCNT.spad" 2818431 2818450 2821653)
 (|UnittestAux| "TESTAUX.spad" 2815572 2815591 2818385)
 (|TensorProductProperty| "TENSPRP.spad" 2815306 2815347 2815567)
 (|TensorPower| "TENSPOW.spad" 2814274 2814301 2814463)
 (|TensorPowerFunctions2| "TENSPO2.spad" 2813913 2813954 2814269)
 (|TensorPowerCategory| "TENSPC.spad" 2813642 2813675 2813908)
 (|TensorPowerCategory&| "TENSPC.spad" 2813312 2813348 2813581)
 (|TensorProduct| "TENSOR.spad" 2811765 2811798 2812091)
 (|TensorProductCategory| "TENSCAT.spad" 2811506 2811539 2811760)
 (|TemplateUtilities| "TEMUTL.spad" 2811036 2811059 2811501)
 (|TabulatedComputationPackage| "TBCMPPK.spad" 2809167 2809214 2811031)
 (|TableAggregate| "TBAGG.spad" 2808254 2808288 2809162)
 (|TableAggregate&| "TBAGG.spad" 2807338 2807375 2808249)
 (|TangentExpansions| "TANEXP.spad" 2806681 2806706 2807333)
 (|Tableau| "TABLEAU.spad" 2806261 2806276 2806676)
 (|Table| "TABLE.spad" 2803076 2803101 2803353)
 (|TableauxBumpers| "TABLBUMP.spad" 2799597 2799620 2803071)
 (|SystemSolvePackage| "SYSSOLP.spad" 2796087 2796113 2799592)
 (|SymbolTable| "SYMTAB.spad" 2793909 2793926 2796082)
 (|TheSymbolTable| "SYMS.spad" 2789780 2789800 2793904)
 (|SymmetricPolynomial| "SYMPOLY.spad" 2785474 2785501 2785572)
 (|SymmetricFunctions| "SYMFUNC.spad" 2784921 2784947 2785469)
 (|Symbol| "SYMBOL.spad" 2782148 2782160 2784916)
 (|SymmetryAnalysis| "SYMANA.spad" 2778405 2778442 2782143)
 (|Switch| "SWITCH.spad" 2774658 2774670 2778400)
 (|SparseUnivariateTaylorSeries| "SUTS.spad" 2766205 2766258 2767837)
 (|SparseUnivariatePuiseuxSeries| "SUPXS.spad" 2757399 2757453 2758569)
 (|SparseUnivariatePolynomialFunctions2| "SUP2.spad" 2756746 2756792 2757394)
 (|SparseUnivariatePolynomial| "SUP.spad" 2738210 2738244 2738887)
 (|RationalFunctionSum| "SUMRF.spad" 2737128 2737155 2738205)
 (|FunctionSpaceSum| "SUMFS.spad" 2736738 2736764 2737123)
 (|SparseUnivariateLaurentSeries| "SULS.spad" 2718196 2718250 2719354)
 (|SuchThat| "SUCH.spad" 2717858 2717878 2718191)
 (|SubSpace| "SUBSPACE.spad" 2709707 2709727 2717853)
 (|SubResultantPackage| "SUBRESP.spad" 2708830 2708860 2709662)
 (|StreamTranscendentalFunctionsNonCommutative| "STTFNC.spad" 2705098 2705154
                                                2708825)
 (|StreamTranscendentalFunctions| "STTF.spad" 2700991 2701033 2705093)
 (|StreamTaylorSeriesOperations| "STTAYLOR.spad" 2692439 2692475 2700884)
 (|StringTable| "STRTBL.spad" 2689242 2689267 2689404)
 (|String| "STRING.spad" 2687400 2687412 2688041)
 (|StringCategory| "STRICAT.spad" 2687197 2687217 2687395)
 (|StreamFunctions3| "STREAM3.spad" 2686712 2686740 2687192)
 (|StreamFunctions2| "STREAM2.spad" 2685725 2685751 2686707)
 (|StreamFunctions1| "STREAM1.spad" 2685414 2685438 2685720)
 (|Stream| "STREAM.spad" 2680589 2680603 2683399)
 (|STransformPackage| "STRANS.spad" 2679760 2679800 2680584)
 (|STransform| "STR.spad" 2677989 2678008 2679755)
 (|StreamTensor| "STNSR.spad" 2677699 2677719 2677984)
 (|StreamExponentialSeriesTranscendentalFunctions| "STEXPST.spad" 2677403
                                                   2677462 2677694)
 (|StreamExponentialSeriesOperations| "STEXPS.spad" 2675897 2675943 2677398)
 (|StepThrough| "STEP.spad" 2675083 2675100 2675892)
 (|SparseTable| "STBL.spad" 2672283 2672319 2672463)
 (|StreamAggregate| "STAGG.spad" 2671478 2671501 2672278)
 (|StreamAggregate&| "STAGG.spad" 2670670 2670696 2671473)
 (|Stack| "STACK.spad" 2669399 2669412 2669668)
 (|SolvableSkewPolynomialCategory| "SSKPOLC.spad" 2668402 2668448 2669394)
 (|SemiRng| "SRNG.spad" 2668250 2668263 2668397)
 (|SemiRing| "SRING.spad" 2668113 2668127 2668245)
 (|SquareFreeRegularTriangularSet| "SREGSET.spad" 2665874 2665918 2667534)
 (|SquareFreeRegularSetDecompositionPackage| "SRDCMPK.spad" 2664556 2664613
                                             2665869)
 (|StringAggregate| "SRAGG.spad" 2660858 2660879 2664551)
 (|StringAggregate&| "SRAGG.spad" 2657157 2657181 2660853)
 (|SquareMatrix| "SQMATRIX.spad" 2652219 2652246 2652968)
 (|SPointCategory| "SPTCAT.spad" 2644854 2644874 2652214)
 (|SPointCategory&| "SPTCAT.spad" 2637486 2637509 2644849)
 (|SplittingTree| "SPLTREE.spad" 2631573 2631596 2635940)
 (|SplittingNode| "SPLNODE.spad" 2628475 2628498 2631568)
 (|SpecialFunctionUnivariateTaylorSeries| "SPFUTS.spad" 2627449 2627503
                                          2628470)
 (|SpecialFunctionCategory| "SPFCAT.spad" 2619798 2619827 2627444)
 (|SpecialOutputPackage| "SPECOUT.spad" 2618304 2618330 2619793)
 (|ThreeSpaceCategory| "SPACEC.spad" 2601848 2601874 2618299)
 (|ThreeSpace| "SPACE3.spad" 2601617 2601635 2601843)
 (|SortPackage| "SORTPAK.spad" 2601144 2601165 2601577)
 (|SortedExponentVector| "SOREXPV.spad" 2598313 2598339 2598472)
 (|SmallOrdinal| "SORD.spad" 2596959 2596977 2598274)
 (|TransSolvePackage| "SOLVETRA.spad" 2594024 2594049 2596954)
 (|TransSolvePackageService| "SOLVESER.spad" 2592416 2592448 2594019)
 (|RadicalSolvePackage| "SOLVERAD.spad" 2588141 2588168 2592411)
 (|PolynomialSolveByFormulas| "SOLVEFOR.spad" 2586664 2586703 2588136)
 (|SquareFreeNormalizedTriangularSetCategory| "SNTSCAT.spad" 2586418 2586473
                                              2586659)
 (|SparseMultivariateTaylorSeries| "SMTS.spad" 2583837 2583890 2585526)
 (|SparseMultivariatePolynomialExpressions| "SMPEXPR.spad" 2569135 2569182
                                            2569187)
 (|SparsePolynomialCoercionHelpers| "SMPCOER.spad" 2568687 2568746 2569130)
 (|SparseMultivariatePolynomial| "SMP.spad" 2555025 2555070 2555445)
 (|SmithNormalForm| "SMITH.spad" 2553788 2553825 2555020)
 (|SquareMatrixCategory| "SMATCAT.spad" 2551723 2551770 2553783)
 (|SquareMatrixCategory&| "SMATCAT.spad" 2549516 2549566 2551579)
 (|SparseMultivariateSkewPolynomial| "SKSMP.spad" 2544512 2544574 2545158)
 (|SKICombinators| "SKICOMB.spad" 2542446 2542469 2544507)
 (|StackAggregate| "SKAGG.spad" 2541572 2541594 2542441)
 (|SingleInteger| "SINT.spad" 2540154 2540173 2541567)
 (|SimplicialComplexFactory| "SIMPCF.spad" 2538340 2538373 2540149)
 (|FiniteSimplicialComplex| "SIMPC.spad" 2531551 2531583 2538335)
 (|SimplifyAlgebraicNumberConvertPackage| "SIMPAN.spad" 2531239 2531282
                                          2531546)
 (|RationalFunctionSign| "SIGNRF.spad" 2530316 2530344 2531234)
 (|ElementaryFunctionSign| "SIGNEF.spad" 2529399 2529431 2530311)
 (|SturmHabichtPackage| "SHP.spad" 2527846 2527876 2529360)
 (|SplitHomogeneousDirectProduct| "SHDP.spad" 2515142 2515195 2515690)
 (|SemiGroup| "SGROUP.spad" 2514964 2514979 2515137)
 (|SymmetricGroupCombinatoricFunctions| "SGCF.spad" 2507617 2507658 2514959)
 (|SquareFreeRegularTriangularSetCategory| "SFRTCAT.spad" 2507012 2507064
                                           2507612)
 (|SquareFreeRegularTriangularSetGcdPackage| "SFRGCD.spad" 2506664 2506721
                                             2507007)
 (|SquareFreeQuasiComponentPackage| "SFQCMPK.spad" 2502151 2502199 2506659)
 (|SimpleFortranProgram| "SFORT.spad" 2501598 2501629 2502146)
 (|SExpressionOf| "SEXOF.spad" 2501438 2501481 2501593)
 (|SExpressionCategory| "SEXCAT.spad" 2498536 2498585 2501433)
 (|SExpression| "SEX.spad" 2498423 2498440 2498531)
 (|SetOfMIntegersInOneToN| "SETMN.spad" 2496771 2496807 2498418)
 (|SubsetLattice| "SETLAT.spad" 2496289 2496316 2496766)
 (|SetCategory| "SETCAT.spad" 2495512 2495529 2496284)
 (|SetCategory&| "SETCAT.spad" 2494732 2494752 2495507)
 (|SetAggregate| "SETAGG.spad" 2491955 2491975 2494727)
 (|SetAggregate&| "SETAGG.spad" 2489175 2489198 2491950)
 (|Set| "SET.spad" 2487105 2487116 2488263)
 (|SequenceCategory| "SEQUCAT.spad" 2485733 2485757 2487100)
 (|SequenceFunctions2| "SEQU2.spad" 2485476 2485506 2485728)
 (|Sequence| "SEQU.spad" 2484152 2484168 2484303)
 (|SparseEchelonMatrix| "SEM.spad" 2477881 2477910 2484072)
 (|SegmentExpansionCategory| "SEGXCAT.spad" 2476955 2476989 2477876)
 (|SegmentCategory| "SEGCAT.spad" 2475633 2475656 2476950)
 (|SegmentBindingFunctions2| "SEGBIND2.spad" 2475301 2475335 2475628)
 (|SegmentBinding| "SEGBIND.spad" 2474281 2474303 2475199)
 (|SegmentFunctions2| "SEG2.spad" 2473676 2473703 2474240)
 (|Segment| "SEG.spad" 2473340 2473355 2473452)
 (|SequentialDifferentialVariable| "SDVAR.spad" 2472589 2472627 2473335)
 (|SequentialDifferentialPolynomial| "SDPOL.spad" 2457499 2457539 2457824)
 (|SCartesian| "SCRT.spad" 2457337 2457357 2457494)
 (|StructuralConstantsPackage| "SCPKG.spad" 2455356 2455390 2457332)
 (|SConformal| "SCONF.spad" 2455087 2455107 2455351)
 (|SceneNamedPoints| "SCNP.spad" 2453378 2453403 2455082)
 (|SceneIFS| "SCIFS.spad" 2451349 2451366 2453373)
 (|Scene| "SCENE.spad" 2417947 2417961 2451344)
 (|SimpleCell| "SCELL.spad" 2417167 2417204 2417942)
 (|ScanningUtilities| "SCANUTIL.spad" 2417010 2417033 2417162)
 (|SortedCache| "SCACHE.spad" 2415291 2415310 2417005)
 (|SBoundary| "SBOUND.spad" 2410452 2410470 2415286)
 (|SArgand| "SARGND.spad" 2410270 2410283 2410447)
 (|SingletonAsOrderedSet| "SAOS.spad" 2410109 2410136 2410265)
 (|SimpleAlgebraicExtension| "SAE.spad" 2407640 2407677 2408277)
 (|RationalUnivariateRepresentationPackage| "RURPK.spad" 2405148 2405200
                                            2407635)
 (|Ruleset| "RULESET.spad" 2404568 2404592 2405143)
 (|RuleCalled| "RULECOLD.spad" 2404417 2404437 2404563)
 (|RewriteRule| "RULE.spad" 2402593 2402621 2404412)
 (|RegularTriangularSetGcdPackage| "RSETGCD.spad" 2399713 2399760 2402588)
 (|RegularTriangularSetCategory| "RSETCAT.spad" 2389939 2389981 2399708)
 (|RegularTriangularSetCategory&| "RSETCAT.spad" 2380162 2380207 2389934)
 (|RegularSetDecompositionPackage| "RSDCMPK.spad" 2378763 2378810 2380157)
 (|RealRootCharacterizationCategory| "RRCC.spad" 2377085 2377144 2378758)
 (|RealRootCharacterizationCategory&| "RRCC.spad" 2375404 2375466 2377080)
 (|RecursivePolynomialCategory| "RPOLCAT.spad" 2358760 2358799 2375399)
 (|RecursivePolynomialCategory&| "RPOLCAT.spad" 2341796 2341838 2358438)
 (|RomanNumeral| "ROMAN.spad" 2341361 2341379 2341791)
 (|RightOpenIntervalRootCharacterization| "ROIRC.spad" 2340424 2340490 2341356)
 (|RealNumberSystem| "RNS.spad" 2339454 2339476 2340419)
 (|RealNumberSystem&| "RNS.spad" 2338481 2338506 2339449)
 (|Rng| "RNG.spad" 2338081 2338090 2338476)
 (|Rng&| "RNG.spad" 2337678 2337690 2338076)
 (|RightModule| "RMODULE.spad" 2337302 2337321 2337673)
 (|RectangularMatrixCategoryFunctions2| "RMCAT2.spad" 2336621 2336749 2337297)
 (|RectangularMatrix| "RMATRIX.spad" 2334431 2334464 2334950)
 (|RectangularMatrixCategory| "RMATCAT.spad" 2329470 2329523 2334426)
 (|RectangularMatrixCategory&| "RMATCAT.spad" 2324276 2324332 2329235)
 (|RationalInterpolation| "RINTERP.spad" 2324155 2324189 2324271)
 (|Ring| "RING.spad" 2324017 2324027 2324150)
 (|RandomIntegerDistributions| "RIDIST.spad" 2323325 2323357 2324012)
 (|RegularChain| "RGCHAIN.spad" 2321160 2321185 2322100)
 (|RootFSSplit| "RFSSPLIT.spad" 2320729 2320750 2321155)
 (|RationalFunctionFactor| "RFFACT.spad" 2320439 2320470 2320724)
 (|RandomFloatDistributions| "RFDIST.spad" 2319279 2319309 2320434)
 (|RationalFunction| "RF.spad" 2316785 2316809 2319274)
 (|RetractSolvePackage| "RETSOL.spad" 2316175 2316204 2316780)
 (|RetractableTo| "RETRACT.spad" 2315580 2315601 2316170)
 (|RetractableTo&| "RETRACT.spad" 2314982 2315006 2315575)
 (|RetractableFrom| "RETFROM.spad" 2314407 2314430 2314977)
 (|RetractableFrom&| "RETFROM.spad" 2313829 2313855 2314402)
 (|Result| "RESULT.spad" 2310108 2310120 2310715)
 (|ResidueRing| "RESRING.spad" 2309485 2309536 2310103)
 (|ResolveLatticeCompletion| "RESLATC.spad" 2308777 2308809 2309480)
 (|RepeatedSquaring| "REPSQ.spad" 2308492 2308516 2308772)
 (|RepeatedDoubling| "REPDB.spad" 2308182 2308206 2308487)
 (|RepresentationPackage2| "REP2.spad" 2297602 2297632 2308032)
 (|RepresentationPackage1| "REP1.spad" 2291422 2291452 2297557)
 (|RadicalEigenPackage| "REP.spad" 2288852 2288877 2291417)
 (|RegularTriangularSet| "REGSET.spad" 2286690 2286724 2288273)
 (|Reference| "REF.spad" 2285962 2285979 2286649)
 (|ReductionOfOrder| "REDORDER.spad" 2285112 2285138 2285957)
 (|RecurrenceOperator| "RECOP.spad" 2283309 2283337 2285107)
 (|RealClosure| "RECLOS.spad" 2282235 2282263 2283026)
 (|RealSolvePackage| "REALSOLV.spad" 2281353 2281375 2282230)
 (|RealZeroPackageQ| "REAL0Q.spad" 2278349 2278377 2281348)
 (|RealZeroPackage| "REAL0.spad" 2274838 2274865 2278344)
 (|RealConstant| "REAL.spad" 2274701 2274719 2274833)
 (|ReducedDivisor| "RDIV.spad" 2274364 2274400 2274696)
 (|RandomDistributions| "RDIST.spad" 2273895 2273922 2274359)
 (|TranscendentalRischDESystem| "RDETRS.spad" 2272629 2272667 2273890)
 (|ParametricRischDE| "RDEPAR.spad" 2269419 2269446 2272624)
 (|ElementaryRischDEX2| "RDEEFX2.spad" 2267784 2267813 2269414)
 (|ElementaryRischDEX| "RDEEFX.spad" 2267096 2267124 2267779)
 (|ElementaryRischDESystem| "RDEEFS.spad" 2266083 2266116 2267091)
 (|RDEaux| "RDEAUX.spad" 2264439 2264453 2266078)
 (|RealClosedField| "RCFIELD.spad" 2261871 2261892 2264434)
 (|RealClosedField&| "RCFIELD.spad" 2259300 2259324 2261866)
 (|RecursiveAggregate| "RCAGG.spad" 2257173 2257199 2259295)
 (|RecursiveAggregate&| "RCAGG.spad" 2254966 2254995 2257091)
 (|RationalRetractions| "RATRET.spad" 2254324 2254351 2254961)
 (|UnivariateSeriesWithRationalExponents| "RATPSCT.spad" 2253890 2253948
                                          2254319)
 (|RationalFactorize| "RATFACT.spad" 2252954 2252980 2253885)
 (|RandomNumberSource| "RANDSRC.spad" 2252238 2252262 2252949)
 (|RadixUtilities| "RADUTIL.spad" 2251977 2251997 2252233)
 (|RadixExpansion| "RADIX.spad" 2248181 2248206 2249933)
 (|RadicalFunctionField| "RADFF.spad" 2246376 2246426 2246517)
 (|RadicalCategory| "RADCAT.spad" 2245862 2245883 2246371)
 (|RadicalCategory&| "RADCAT.spad" 2245345 2245369 2245857)
 (|Queue| "QUEUE.spad" 2244065 2244078 2244343)
 (|QuaternionCategoryFunctions2| "QUATCT2.spad" 2243651 2243695 2244060)
 (|QuaternionCategory| "QUATCAT.spad" 2241794 2241820 2243646)
 (|QuaternionCategory&| "QUATCAT.spad" 2239582 2239611 2241437)
 (|GeneralQuaternion| "QUAT2.spad" 2238116 2238149 2238501)
 (|Quaternion| "QUAT.spad" 2236890 2236908 2237035)
 (|QueueAggregate| "QUAGG.spad" 2235844 2235866 2236885)
 (|QuadraticForm| "QFORM.spad" 2235184 2235209 2235743)
 (|QuotientFieldCategoryFunctions2| "QFCAT2.spad" 2234847 2234892 2235179)
 (|QuotientFieldCategory| "QFCAT.spad" 2233628 2233657 2234842)
 (|QuotientFieldCategory&| "QFCAT.spad" 2231784 2231816 2233001)
 (|QueryEquation| "QEQUAT.spad" 2231335 2231354 2231779)
 (|QuasiComponentPackage| "QCMPACK.spad" 2226852 2226890 2231330)
 (|QuasiAlgebraicSet2| "QALGSET2.spad" 2224465 2224494 2226847)
 (|QuasiAlgebraicSet| "QALGSET.spad" 2220439 2220486 2224347)
 (|PAdicWildFunctionFieldIntegralBasis| "PWFFINTB.spad" 2217656 2217706
                                        2220434)
 (|PushVariables| "PUSHVAR.spad" 2217077 2217107 2217651)
 (|PartialTranscendentalFunctions| "PTRANFN.spad" 2213012 2213050 2217072)
 (|PointPackage| "PTPACK.spad" 2210041 2210061 2213007)
 (|PointFunctions2| "PTFUNC2.spad" 2209847 2209874 2210036)
 (|PointCategory| "PTCAT.spad" 2208924 2208945 2209842)
 (|PolynomialSquareFree| "PSQFR.spad" 2208206 2208248 2208919)
 (|PseudoLinearNormalForm| "PSEUDLIN.spad" 2206969 2206999 2208201)
 (|PolynomialSetUtilitiesPackage| "PSETPK.spad" 2193965 2194008 2206814)
 (|PolynomialSetCategory| "PSETCAT.spad" 2188988 2189030 2193960)
 (|PolynomialSetCategory&| "PSETCAT.spad" 2183969 2184014 2188944)
 (|PlottableSpaceCurveCategory| "PSCURVE.spad" 2182903 2182936 2183964)
 (|PowerSeriesCategory| "PSCAT.spad" 2182065 2182111 2182898)
 (|PowerSeriesCategory&| "PSCAT.spad" 2181224 2181273 2182060)
 (|Partition| "PRTITION.spad" 2180035 2180050 2181219)
 (|PseudoRemainderSequence| "PRS.spad" 2172368 2172406 2179996)
 (|PolynomialRationalRoots| "PRROOT.spad" 2172001 2172035 2172363)
 (|PriorityQueueAggregate| "PRQAGG.spad" 2171414 2171444 2171996)
 (|Product| "PRODUCT.spad" 2168392 2168409 2168993)
 (|PrintPackage| "PRINT.spad" 2168131 2168149 2168387)
 (|PrimitiveTwoDimensionalArray| "PRIMMAT2.spad" 2165605 2165641 2165899)
 (|IntegerPrimesPackage| "PRIMES.spad" 2163736 2163764 2165600)
 (|PrimitiveElement| "PRIMELT.spad" 2161581 2161605 2163731)
 (|PrimitiveFunctionCategory| "PRIMCAT.spad" 2161175 2161206 2161576)
 (|PrimitiveArrayFunctions2| "PRIMARR2.spad" 2159832 2159866 2161170)
 (|PrimitiveArray| "PRIMARR.spad" 2157177 2157199 2157372)
 (|PrimGCD| "PRIGCD3.spad" 2154124 2154137 2157172)
 (|Preorder| "PREORD.spad" 2153540 2153556 2154119)
 (|PrecomputedAssociatedEquations| "PREASSOC.spad" 2152875 2152915 2153535)
 (|PolynomialRing| "PR.spad" 2148072 2148096 2148676)
 (|PlottablePlaneCurveCategory| "PPCURVE.spad" 2147166 2147199 2148067)
 (|PosetFactory| "POSETF.spad" 2146048 2146068 2147161)
 (|Poset| "POSET.spad" 2139559 2139572 2146043)
 (|Poset&| "POSET.spad" 2133067 2133083 2139554)
 (|PartialOrder| "PORDER.spad" 2132624 2132642 2133062)
 (|PartialOrder&| "PORDER.spad" 2132178 2132199 2132619)
 (|U32VectorPolynomialOperations| "POLYVEC.spad" 2126401 2126436 2132173)
 (|PolynomialRoots| "POLYROOT.spad" 2125067 2125098 2126362)
 (|PolynomialCategoryLifting| "POLYLIFT.spad" 2124300 2124346 2125062)
 (|PolynomialCategoryQuotientFunctions| "POLYCATQ.spad" 2122306 2122357
                                        2124295)
 (|PolynomialCategory| "POLYCAT.spad" 2118173 2118210 2122301)
 (|PolynomialCategory&| "POLYCAT.spad" 2113165 2113205 2117296)
 (|PolynomialToUnivariatePolynomial| "POLY2UP.spad" 2112572 2112616 2113160)
 (|PolynomialFunctions2| "POLY2.spad" 2112143 2112173 2112567)
 (|Polynomial| "POLY.spad" 2097885 2097903 2098422)
 (|RealPolynomialUtilitiesPackage| "POLUTIL.spad" 2096851 2096908 2097844)
 (|PolToPol| "POLTOPOL.spad" 2095541 2095562 2096846)
 (|Point| "POINT.spad" 2092631 2092644 2092721)
 (|PolynomialNumberTheoryFunctions| "PNTHEORY.spad" 2089208 2089245 2092626)
 (|PatternMatchTools| "PMTOOLS.spad" 2087895 2087924 2089203)
 (|PatternMatchSymbol| "PMSYM.spad" 2087417 2087443 2087890)
 (|PatternMatchQuotientFieldCategory| "PMQFCAT.spad" 2086966 2087011 2087412)
 (|FunctionSpaceAttachPredicates| "PMPREDFS.spad" 2086411 2086452 2086961)
 (|AttachPredicates| "PMPRED.spad" 2085886 2085910 2086406)
 (|PatternMatchPolynomialCategory| "PMPLCAT.spad" 2084886 2084932 2085816)
 (|PatternMatchListAggregate| "PMLSAGG.spad" 2084437 2084474 2084881)
 (|PatternMatchKernel| "PMKERNEL.spad" 2083977 2084005 2084432)
 (|PatternMatchIntegerNumberSystem| "PMINS.spad" 2083517 2083556 2083972)
 (|PatternMatchFunctionSpace| "PMFS.spad" 2083064 2083101 2083512)
 (|PatternMatchPushDown| "PMDOWN.spad" 2082316 2082348 2083059)
 (|FunctionSpaceAssertions| "PMASSFS.spad" 2081426 2081459 2082311)
 (|PatternMatchAssertions| "PMASS.spad" 2080568 2080596 2081421)
 (|PlotTools| "PLOTTOOL.spad" 2080336 2080351 2080563)
 (|Plot3D| "PLOT3D.spad" 2076579 2076591 2080331)
 (|PlotFunctions1| "PLOT1.spad" 2075678 2075700 2076574)
 (|Plot| "PLOT.spad" 2070290 2070300 2075673)
 (|ParametricLinearEquations| "PLEQN.spad" 2053677 2053727 2070285)
 (|ParallelIntegrationTools| "PIT.spad" 2053256 2053292 2053672)
 (|PolynomialInterpolationAlgorithms| "PINTERPA.spad" 2053009 2053052 2053251)
 (|PolynomialInterpolation| "PINTERP.spad" 2052595 2052631 2053004)
 (|PrincipalIdealDomain| "PID.spad" 2051578 2051604 2052590)
 (|PiCoercions| "PICOERCE.spad" 2051251 2051270 2051573)
 (|PositiveInteger| "PI.spad" 2050849 2050870 2051246)
 (|PolyGroebner| "PGROEB.spad" 2049418 2049438 2050844)
 (|PermutationGroupExamples| "PGE.spad" 2040460 2040490 2049413)
 (|PolynomialGcdPackage| "PGCD.spad" 2038924 2038959 2040455)
 (|PartialFractionUtilities| "PFUTIL.spad" 2038618 2038653 2038919)
 (|PartialFractionPackage| "PFRPAC.spad" 2037738 2037768 2038613)
 (|PartialFraction| "PFR.spad" 2034586 2034609 2037683)
 (|PointsOfFiniteOrderTools| "PFOTOOLS.spad" 2033829 2033867 2034581)
 (|PointsOfFiniteOrderRational| "PFOQ.spad" 2033138 2033181 2033824)
 (|PointsOfFiniteOrder| "PFO.spad" 2031128 2031168 2033027)
 (|PolynomialFactorizationExplicit| "PFECAT.spad" 2028925 2028962 2031123)
 (|PolynomialFactorizationExplicit&| "PFECAT.spad" 2026673 2026713 2028874)
 (|PolynomialFactorizationByRecursion| "PFBR.spad" 2024526 2024581 2026668)
 (|ProductFacet| "PFACET.spad" 2023325 2023343 2024521)
 (|PrimeField| "PF.spad" 2022832 2022852 2023217)
 (|PolynomialEvaluationUtilities| "PEVALUT.spad" 2019953 2019988 2022827)
 (|PermutationGroup| "PERMGRP.spad" 2013928 2013952 2019948)
 (|PermutationCategory| "PERMCAT.spad" 2012436 2012463 2013923)
 (|Permanent| "PERMAN.spad" 2010953 2010974 2012431)
 (|Permutation| "PERM.spad" 2006487 2006506 2010751)
 (|PendantTree| "PENDTREE.spad" 2005254 2005273 2005625)
 (|PartialDifferentialRing| "PDRING.spad" 2003678 2003709 2005249)
 (|PartialDifferentialRing&| "PDRING.spad" 2002099 2002133 2003673)
 (|PartialDifferentialOperatorHelper| "PDOHLP.spad" 2002042 2002089 2002094)
 (|PartialDifferentialOperator| "PDO.spad" 1997017 1997058 1997576)
 (|PolynomialCommonDenominator| "PCDEN.spad" 1996177 1996227 1997012)
 (|PoincareBirkhoffWittLyndonBasis| "PBWLB.spad" 1994676 1994722 1996172)
 (|PatternFunctions2| "PATTERN2.spad" 1994396 1994423 1994671)
 (|PatternFunctions1| "PATTERN1.spad" 1992633 1992660 1994391)
 (|Pattern| "PATTERN.spad" 1986806 1986821 1992628)
 (|PatternMatchResultFunctions2| "PATRES2.spad" 1986421 1986461 1986801)
 (|PatternMatchResult| "PATRES.spad" 1983886 1983914 1986416)
 (|PatternMatch| "PATMATCH.spad" 1981991 1982032 1983600)
 (|PatternMatchable| "PATMAB.spad" 1981392 1981416 1981986)
 (|PatternMatchListResult| "PATLRES.spad" 1980431 1980465 1981387)
 (|Patternable| "PATAB.spad" 1980186 1980205 1980426)
 (|PartitionsAndPermutations| "PARTPERM.spad" 1976450 1976481 1980181)
 (|ParametricSurface| "PARSURF.spad" 1975848 1975891 1976445)
 (|ParametricSurfaceFunctions2| "PARSU2.spad" 1975612 1975653 1975843)
 (|ParametricSpaceCurve| "PARSCURV.spad" 1975007 1975053 1975607)
 (|ParametricSpaceCurveFunctions2| "PARSC2.spad" 1974762 1974806 1975002)
 (|PathArrayPackage| "PARRPKG.spad" 1973971 1973995 1974757)
 (|ParametricPlaneCurve| "PARPCURV.spad" 1973397 1973443 1973966)
 (|ParametricPlaneCurveFunctions2| "PARPC2.spad" 1973152 1973196 1973392)
 (|PolynomialAN2Expression| "PAN2EXPR.spad" 1972540 1972569 1973147)
 (|Palette| "PALETTE.spad" 1971460 1971473 1972535)
 (|PAdicRationalConstructor| "PADICRC.spad" 1968413 1968453 1969637)
 (|PAdicRational| "PADICRAT.spad" 1965536 1965559 1965776)
 (|PAdicIntegerCategory| "PADICCT.spad" 1964065 1964095 1965531)
 (|PAdicInteger| "PADIC.spad" 1963811 1963833 1964060)
 (|PadeApproximantPackage| "PADEPAC.spad" 1962466 1962505 1963806)
 (|PadeApproximants| "PADE.spad" 1961199 1961229 1962461)
 (|OrdinaryWeightedPolynomials| "OWP.spad" 1960811 1960866 1961122)
 (|OrderedVariableList| "OVAR.spad" 1960574 1960614 1960806)
 (|OutputForm| "OUTFORM.spad" 1950287 1950303 1960569)
 (|OutputBox| "OUTBOX.spad" 1947615 1947630 1950282)
 (|OutputPackage| "OUT.spad" 1946678 1946697 1947610)
 (|OrdSetInts| "OSI.spad" 1946167 1946183 1946673)
 (|OrderedSemiGroup| "OSGROUP.spad" 1946076 1946098 1946162)
 (|OrthogonalPolynomialFunctions| "ORTHPOL.spad" 1944484 1944521 1946002)
 (|UnivariateSkewPolynomial| "OREUP.spad" 1939806 1939858 1940163)
 (|SparseUnivariateSkewPolynomial| "ORESUP.spad" 1935063 1935117 1935485)
 (|UnivariateSkewPolynomialCategoryOps| "OREPCTO.spad" 1932792 1932837 1934987)
 (|UnivariateSkewPolynomialCategory| "OREPCAT.spad" 1927678 1927718 1932787)
 (|UnivariateSkewPolynomialCategory&| "OREPCAT.spad" 1922447 1922490 1927559)
 (|OrePolynomialMatrixOperations| "OREMAT.spad" 1920764 1920804 1922442)
 (|OrderedSet| "ORDSET.spad" 1920156 1920172 1920759)
 (|OrderedSet&| "ORDSET.spad" 1919545 1919564 1920151)
 (|OrderedRing| "ORDRING.spad" 1918917 1918934 1919540)
 (|OrderedRing&| "ORDRING.spad" 1918286 1918306 1918912)
 (|OrderedMonoid| "ORDMON.spad" 1918130 1918149 1918281)
 (|OrderingFunctions| "ORDFUNS.spad" 1917220 1917251 1918125)
 (|OrderedFinite| "ORDFIN.spad" 1917148 1917167 1917215)
 (|OrderedCompletionFunctions2| "ORDCOMP2.spad" 1916422 1916459 1917143)
 (|OrderedCompletion| "ORDCOMP.spad" 1914950 1914975 1916057)
 (|OperationsQuery| "OPQUERY.spad" 1914479 1914500 1914945)
 (|OperatorHandlers| "OPHANDL.spad" 1913113 1913143 1914474)
 (|Operator| "OP.spad" 1912887 1912903 1912973)
 (|OnePointCompletionFunctions2| "ONECOMP2.spad" 1912293 1912331 1912882)
 (|OnePointCompletion| "ONECOMP.spad" 1911231 1911257 1912046)
 (|OpenMathServerPackage| "OMSERVER.spad" 1910235 1910262 1911226)
 (|OrderedMultisetAggregate| "OMSAGG.spad" 1909867 1909899 1910230)
 (|OpenMathPackage| "OMPKG.spad" 1908472 1908493 1909862)
 (|ExpressionToOpenMath| "OMEXPR.spad" 1908288 1908316 1908467)
 (|OpenMathErrorKind| "OMERRK.spad" 1907290 1907313 1908283)
 (|OpenMathError| "OMERR.spad" 1906806 1906825 1907285)
 (|OpenMathEncoding| "OMENC.spad" 1906115 1906137 1906801)
 (|OpenMathDevice| "OMDEV.spad" 1900596 1900616 1906110)
 (|OpenMathConnection| "OMCONN.spad" 1899977 1900001 1900591)
 (|OpenMath| "OM.spad" 1898978 1898992 1899972)
 (|OpenMath&| "OM.spad" 1897976 1897993 1898973)
 (|OrderedIntegralDomain| "OINTDOM.spad" 1897795 1897822 1897971)
 (|OutputFormTools| "OFTOOL.spad" 1895527 1895548 1897790)
 (|OrientedFacet| "OFACET.spad" 1891375 1891394 1895522)
 (|OrderedExpression| "OEXPR.spad" 1891342 1891365 1891370)
 (|OrderlyDifferentialVariable| "ODVAR.spad" 1890578 1890613 1891337)
 (|OrdinaryDifferentialRing| "ODR.spad" 1890141 1890189 1890543)
 (|OrderlyDifferentialPolynomial| "ODPOL.spad" 1875130 1875167 1875502)
 (|OrderedDirectProduct| "ODP.spad" 1862578 1862616 1862974)
 (|ODETools| "ODETOOLS.spad" 1861126 1861147 1862573)
 (|SystemODESolver| "ODESYS.spad" 1856563 1856589 1861121)
 (|RationalRicDE| "ODERTRIC.spad" 1852036 1852060 1856509)
 (|ReduceLODE| "ODERED.spad" 1851024 1851052 1852031)
 (|RationalLODE| "ODERAT.spad" 1848049 1848072 1851019)
 (|PrimitiveRatRicDE| "ODEPRRIC.spad" 1844866 1844899 1848044)
 (|PrimitiveRatDE| "ODEPRIM.spad" 1842057 1842087 1844861)
 (|PureAlgebraicLODE| "ODEPAL.spad" 1841071 1841106 1842052)
 (|ODEIntegration| "ODEINT.spad" 1840476 1840500 1841066)
 (|ElementaryFunctionODESolver| "ODEEF.spad" 1835626 1835663 1840471)
 (|ConstantLODE| "ODECONST.spad" 1835127 1835151 1835621)
 (|OctonionCategoryFunctions2| "OCTCT2.spad" 1834735 1834777 1835122)
 (|Octonion| "OCT.spad" 1832478 1832494 1833212)
 (|OrderedCancellationAbelianMonoid| "OCAMON.spad" 1832296 1832334 1832473)
 (|OctonionCategory| "OC.spad" 1829991 1830015 1832291)
 (|OctonionCategory&| "OC.spad" 1827369 1827396 1829672)
 (|OrderedAbelianSemiGroup| "OASGP.spad" 1827163 1827192 1827364)
 (|OrderedAbelianMonoidSup| "OAMONS.spad" 1826527 1826556 1827158)
 (|OrderedAbelianMonoid| "OAMON.spad" 1826370 1826396 1826522)
 (|OrderedAbelianGroup| "OAGROUP.spad" 1826215 1826240 1826365)
 (|NumericTubePlot| "NUMTUBE.spad" 1825812 1825841 1826210)
 (|NumericalQuadrature| "NUMQUAD.spad" 1813719 1813746 1825807)
 (|NumericalOrdinaryDifferentialEquations| "NUMODE.spad" 1804566 1804610
                                           1813714)
 (|NumberFormats| "NUMFMT.spad" 1803207 1803226 1804561)
 (|Numeric| "NUMERIC.spad" 1795163 1795178 1802998)
 (|NormalizedTriangularSetCategory| "NTSCAT.spad" 1794462 1794507 1795158)
 (|NumberTheoreticPolynomialFunctions| "NTPOLFN.spad" 1793805 1793847 1794388)
 (|NewSparseUnivariatePolynomialFunctions2| "NSUP2.spad" 1793143 1793192
                                            1793800)
 (|NewSparseUnivariatePolynomial| "NSUP.spad" 1771611 1771648 1775284)
 (|NewSparseMultivariatePolynomial| "NSMP.spad" 1757589 1757637 1757920)
 (|NumericRealEigenPackage| "NREP.spad" 1755945 1755980 1757584)
 (|NPCoef| "NPCOEF.spad" 1754643 1754667 1755940)
 (|NormRetractPackage| "NORMRETR.spad" 1754209 1754260 1754638)
 (|NormalizationPackage| "NORMPK.spad" 1752852 1752889 1754204)
 (|NormInMonogenicAlgebra| "NORMMA.spad" 1752514 1752560 1752847)
 (|NoneFunctions1| "NONE1.spad" 1752185 1752207 1752509)
 (|None| "NONE.spad" 1751867 1751877 1752180)
 (|NonLinearFirstOrderODESolver| "NODE1.spad" 1751302 1751340 1751862)
 (|NonNegativeRational| "NNRAT.spad" 1751116 1751141 1751263)
 (|NonNegativeInteger| "NNI.spad" 1749920 1749944 1751077)
 (|NonLinearSolvePackage| "NLINSOL.spad" 1748483 1748512 1749915)
 (|NGroebnerPackage| "NGROEB.spad" 1747418 1747461 1748478)
 (|NumberFieldIntegralBasis| "NFINTBAS.spad" 1744805 1744840 1747413)
 (|NewtonInterpolation| "NEWTON.spad" 1744178 1744205 1744800)
 (|NumericContinuedFraction| "NCNTFRAC.spad" 1743796 1743828 1744173)
 (|NumericComplexEigenPackage| "NCEP.spad" 1741902 1741940 1743791)
 (|NaiveBeckermannLabahnModular| "NBLM.spad" 1737997 1738031 1741897)
 (|NonAssociativeSemiRng| "NASRNG.spad" 1737722 1737749 1737992)
 (|NonAssociativeSemiRng&| "NASRNG.spad" 1737444 1737474 1737717)
 (|NonAssociativeSemiRing| "NASRING.spad" 1737274 1737302 1737439)
 (|NonAssociativeRng| "NARNG.spad" 1736671 1736694 1737269)
 (|NonAssociativeRng&| "NARNG.spad" 1736065 1736091 1736666)
 (|NonAssociativeRing| "NARING.spad" 1735633 1735657 1736060)
 (|NonAssociativeRing&| "NARING.spad" 1735198 1735225 1735628)
 (|NonAssociativeAlgebra| "NAALG.spad" 1734727 1734756 1735193)
 (|NonAssociativeAlgebra&| "NAALG.spad" 1734253 1734285 1734722)
 (|MultivariateSquareFree| "MULTSQFR.spad" 1730938 1730975 1734248)
 (|MultivariateFactorize| "MULTFACT.spad" 1730287 1730323 1730933)
 (|MultiplicativeDependence| "MULDEP.spad" 1729943 1729973 1730282)
 (|MultivariateTaylorSeriesCategory| "MTSCAT.spad" 1727953 1728004 1729938)
 (|MultivariateTaylorSeriesCategory&| "MTSCAT.spad" 1725891 1725945 1727879)
 (|MergeThing| "MTHING.spad" 1725538 1725556 1725886)
 (|MoreSystemCommands| "MSYSCMD.spad" 1724952 1724976 1725533)
 (|MultisetAggregate| "MSETAGG.spad" 1724804 1724829 1724947)
 (|Multiset| "MSET.spad" 1722648 1722664 1724300)
 (|MrvLimitPackage| "MRVLIM.spad" 1717301 1717322 1722643)
 (|MonoidRing| "MRING.spad" 1715774 1715794 1716784)
 (|MonoidRingFunctions2| "MRF2.spad" 1715309 1715341 1715769)
 (|MonoidRingCategory| "MRCAT.spad" 1714685 1714713 1715304)
 (|MRationalFactorize| "MRATFAC.spad" 1714209 1714242 1714680)
 (|MPolyCatRationalFunctionFactorizer| "MPRFF.spad" 1712189 1712240 1714204)
 (|MultivariatePolynomial| "MPOLY.spad" 1696969 1697004 1697353)
 (|MPolyCatPolyFactorizer| "MPCPF.spad" 1696324 1696363 1696964)
 (|MPolyCatFunctions3| "MPC3.spad" 1696124 1696180 1696319)
 (|MPolyCatFunctions2| "MPC2.spad" 1695872 1695921 1696119)
 (|MultivariateSkewPolynomialCategory| "MORECAT.spad" 1695812 1695862 1695867)
 (|MonomialExtensionTools| "MONOTOOL.spad" 1694069 1694102 1695807)
 (|Monoid| "MONOID.spad" 1693899 1693911 1694064)
 (|MonogenicAlgebra| "MONOGEN.spad" 1692723 1692750 1693894)
 (|MonogenicAlgebra&| "MONOGEN.spad" 1691468 1691498 1692642)
 (|MomentPackage| "MOMPKG.spad" 1687866 1687887 1691361)
 (|MoebiusTransform| "MOEBIUS.spad" 1686482 1686506 1687861)
 (|Module| "MODULE.spad" 1686373 1686387 1686477)
 (|Module&| "MODULE.spad" 1686261 1686278 1686368)
 (|ModularRing| "MODRING.spad" 1685576 1685632 1686256)
 (|ModuleOperator| "MODOP.spad" 1684284 1684308 1685436)
 (|ModuleMonomial| "MODMONOM.spad" 1683794 1683824 1684279)
 (|ModMonic| "MODMON.spad" 1663665 1663687 1664512)
 (|ModularHermitePadeSolver| "MODHPS.spad" 1661710 1661744 1663660)
 (|ModularHermitePade| "MODHP.spad" 1657253 1657277 1661705)
 (|ModularField| "MODFIELD.spad" 1656675 1656732 1657248)
 (|ModularFactorization| "MODFACT.spad" 1653719 1653745 1656670)
 (|MathMLFormat| "MMLFORM.spad" 1652993 1653011 1653714)
 (|MultipleMap| "MMAP.spad" 1652723 1652766 1652988)
 (|MultivariateLifting| "MLIFT.spad" 1649947 1649981 1652678)
 (|MakeUnaryCompiledFunction| "MKUCFUNC.spad" 1649454 1649491 1649942)
 (|MakeRecord| "MKRECORD.spad" 1648989 1649010 1649449)
 (|MakeFunction| "MKFUNC.spad" 1648338 1648358 1648984)
 (|MakeFloatCompiledFunction| "MKFLCFN.spad" 1647256 1647289 1648333)
 (|MakeCachableSet| "MKCHSET.spad" 1647013 1647036 1647251)
 (|MakeBinaryCompiledFunction| "MKBCFUNC.spad" 1646465 1646507 1647008)
 (|MachineInteger| "MINT.spad" 1645963 1645983 1646460)
 (|ModularHermitianRowReduction| "MHROWRED.spad" 1644442 1644478 1645958)
 (|MachineFloat| "MFLOAT.spad" 1642761 1642779 1644285)
 (|MultFiniteFactorize| "MFINFACT.spad" 1642133 1642168 1642756)
 (|MultifunctionGraph| "MFGRPH.spad" 1637718 1637744 1642128)
 (|ModularEvaluationCategory| "MEVCAT.spad" 1635939 1635976 1637713)
 (|ModularEvaluation2| "MEVAL2.spad" 1635905 1635929 1635934)
 (|ModularEvaluation1| "MEVAL1.spad" 1635871 1635895 1635900)
 (|MeshCreationRoutinesForThreeDimensions| "MESH.spad" 1633456 1633500 1635866)
 (|MeetSemilattice| "MEETLAT.spad" 1633102 1633123 1633451)
 (|ModularDistinctDegreeFactorizer| "MDDFACT.spad" 1631898 1631937 1633097)
 (|MultiDictionary| "MDAGG.spad" 1631158 1631181 1631893)
 (|MachineComplex| "MCMPLX.spad" 1626553 1626573 1627210)
 (|MatrixCommonDenominator| "MCDEN.spad" 1625722 1625755 1626548)
 (|MultiVariableCalculusFunctions| "MCALCFN.spad" 1622780 1622830 1625717)
 (|StorageEfficientMatrixOperations| "MATSTOR.spad" 1619964 1620004 1622775)
 (|Matrix| "MATRIX.spad" 1617671 1617685 1618184)
 (|MatrixLinearAlgebraFunctions| "MATLIN.spad" 1614868 1614918 1617552)
 (|MatrixCategoryFunctions2| "MATCAT2.spad" 1613869 1613939 1614863)
 (|MatrixCategory| "MATCAT.spad" 1606348 1606382 1613864)
 (|MatrixCategory&| "MATCAT.spad" 1598560 1598597 1606079)
 (|MappingPackage3| "MAPPKG3.spad" 1597407 1597434 1598555)
 (|MappingPackage2| "MAPPKG2.spad" 1596698 1596723 1597402)
 (|MappingPackage1| "MAPPKG1.spad" 1595899 1595922 1596693)
 (|MappingPackageInternalHacks3| "MAPHACK3.spad" 1595678 1595718 1595894)
 (|MappingPackageInternalHacks2| "MAPHACK2.spad" 1595416 1595454 1595673)
 (|MappingPackageInternalHacks1| "MAPHACK1.spad" 1594994 1595030 1595411)
 (|MatrixManipulation| "MAMA.spad" 1591855 1591895 1594951)
 (|MagmaWithUnit| "MAGMAWU.spad" 1589750 1589769 1591850)
 (|MagmaWithUnit&| "MAGMAWU.spad" 1587642 1587664 1589745)
 (|Magma| "MAGMA.spad" 1586753 1586764 1587637)
 (|Magma&| "MAGMA.spad" 1585861 1585875 1586748)
 (|ModularAlgebraicGcdTools4| "MAGCDT4.spad" 1585820 1585851 1585856)
 (|ModularAlgebraicGcdTools3| "MAGCDT3.spad" 1585316 1585347 1585815)
 (|ModularAlgebraicGcdTools2| "MAGCDT2.spad" 1585275 1585306 1585311)
 (|ModularAlgebraicGcdOperations| "MAGCDOC.spad" 1582928 1582973 1585270)
 (|ModularAlgebraicGcd2| "MAGCD2.spad" 1582090 1582135 1582923)
 (|ModularAlgebraicGcd| "MAGCD.spad" 1581886 1581921 1582085)
 (|ThreeDimensionalMatrix| "M3D.spad" 1578958 1578988 1580770)
 (|LazyStreamAggregate| "LZSTAGG.spad" 1575761 1575788 1578953)
 (|LazyStreamAggregate&| "LZSTAGG.spad" 1572561 1572591 1575756)
 (|LyndonWord| "LWORD.spad" 1569599 1569624 1572556)
 (|LUDecomposition| "LUD.spad" 1568513 1568536 1569594)
 (|LieSquareMatrix| "LSQM.spad" 1567885 1567912 1568403)
 (|LinearSystemPolynomialPackage| "LSPP.spad" 1567095 1567139 1567880)
 (|LinearSystemMatrixPackage1| "LSMP1.spad" 1564765 1564799 1567090)
 (|LinearSystemMatrixPackage| "LSMP.spad" 1563520 1563567 1564760)
 (|ListAggregate| "LSAGG.spad" 1563197 1563218 1563515)
 (|ListAggregate&| "LSAGG.spad" 1562871 1562895 1563192)
 (|LiePolynomial| "LPOLY.spad" 1561493 1561523 1562309)
 (|LinearPolynomialEquationByFractions| "LPEFRAC.spad" 1560703 1560746 1561488)
 (|LeftOreRing| "LORER.spad" 1560208 1560225 1560698)
 (|Loop| "LOOP.spad" 1559606 1559616 1560203)
 (|Logic| "LOGIC.spad" 1559294 1559305 1559601)
 (|Logic&| "LOGIC.spad" 1558979 1558993 1559289)
 (|LinearOrdinaryDifferentialOperatorsOps| "LODOOPS.spad" 1557837 1557885
                                           1558974)
 (|LinearOrdinaryDifferentialOperatorFactorizer2| "LODOF2.spad" 1529538 1529601
                                                  1557832)
 (|LinearOrdinaryDifferentialOperatorFactorizer| "LODOF.spad" 1528495 1528550
                                                 1529484)
 (|LODOConvertions| "LODOCONV.spad" 1527419 1527455 1528490)
 (|LinearOrdinaryDifferentialOperatorCategory| "LODOCAT.spad" 1526036 1526086
                                               1527414)
 (|LinearOrdinaryDifferentialOperatorCategory&| "LODOCAT.spad" 1524620 1524673
                                                1526001)
 (|LinearOrdinaryDifferentialOperator3Aux| "LODO3AUX.spad" 1524255 1524311
                                           1524615)
 (|LinearOrdinaryDifferentialOperator3| "LODO3.spad" 1519591 1519644 1519933)
 (|LinearOrdinaryDifferentialOperator2| "LODO2.spad" 1514821 1514866 1515269)
 (|LinearOrdinaryDifferentialOperator1| "LODO1.spad" 1510181 1510224 1510499)
 (|LinearOrdinaryDifferentialOperator| "LODO.spad" 1505525 1505574 1505859)
 (|ElementaryFunctionLODESolver| "LODEEF.spad" 1504241 1504281 1505520)
 (|Localize| "LO.spad" 1503335 1503353 1503858)
 (|LinearAggregate| "LNAGG.spad" 1496438 1496461 1503330)
 (|LinearAggregate&| "LNAGG.spad" 1489343 1489369 1496238)
 (|ListMonoidOps| "LMOPS.spad" 1486428 1486456 1489338)
 (|LeftModule| "LMODULE.spad" 1486054 1486072 1486423)
 (|ListMultiDictionary| "LMDICT.spad" 1484342 1484369 1485052)
 (|LLLReduction| "LLLRED.spad" 1482786 1482804 1484337)
 (|LiftLinearDependence| "LLINDEP.spad" 1482013 1482046 1482781)
 (|ListPackage| "LISTPKG.spad" 1480202 1480222 1481973)
 (|ListFunctions3| "LIST3.spad" 1479469 1479495 1480197)
 (|ListToMap| "LIST2MAP.spad" 1476286 1476305 1479464)
 (|ListFunctions2| "LIST2.spad" 1474866 1474890 1476281)
 (|List| "LIST.spad" 1470885 1470897 1472369)
 (|LinearMultivariateMatrixPencil| "LINPEN.spad" 1451323 1451361 1470850)
 (|LinearlyExplicitOver| "LINEXP.spad" 1450735 1450763 1451318)
 (|LinearDependence| "LINDEP.spad" 1447434 1447460 1450660)
 (|LinearCombinationUtilities| "LINCOMB.spad" 1444158 1444195 1447429)
 (|RationalFunctionLimitPackage| "LIMITRF.spad" 1441642 1441678 1444153)
 (|PowerSeriesLimitPackage| "LIMITPS.spad" 1440422 1440456 1441637)
 (|LieAlgebra| "LIECAT.spad" 1439964 1439982 1440417)
 (|LieAlgebra&| "LIECAT.spad" 1439473 1439494 1439929)
 (|AssociatedLieAlgebra| "LIE.spad" 1437113 1437143 1438422)
 (|Library| "LIB.spad" 1433572 1433585 1434316)
 (|LinGroebnerPackage| "LGROBP.spad" 1430474 1430505 1433567)
 (|LiouvillianFunctionCategory| "LFCAT.spad" 1428786 1428819 1430469)
 (|LiouvillianFunction| "LF.spad" 1427250 1427279 1428781)
 (|LexTriangularPackage| "LEXTRIPK.spad" 1422156 1422189 1427245)
 (|LieExponentials| "LEXP.spad" 1420264 1420304 1422151)
 (|LeadingCoefDetermination| "LEADCDET.spad" 1418400 1418439 1420259)
 (|LazardSetSolvingPackage| "LAZM3PK.spad" 1417436 1417479 1418395)
 (|LaurentPolynomial| "LAUPOL.spad" 1416140 1416168 1417057)
 (|LatticeMeetOfJoins| "LATMOFJ.spad" 1413357 1413381 1416135)
 (|LatticeJoinOfMeets| "LATJOFM.spad" 1410386 1410410 1413352)
 (|Lattice| "LAT.spad" 1410184 1410197 1410381)
 (|LaplaceTransform| "LAPLACE.spad" 1409746 1409772 1410179)
 (|Lambda| "LAMBDA.spad" 1405959 1405974 1409741)
 (|LeftAlgebra| "LALG.spad" 1405733 1405752 1405954)
 (|LeftAlgebra&| "LALG.spad" 1405504 1405526 1405728)
 (|LocalAlgebra| "LA.spad" 1404961 1404983 1405463)
 (|Kovacic| "KOVACIC.spad" 1403651 1403669 1404956)
 (|ConvertibleTo| "KONVERT.spad" 1403359 1403380 1403646)
 (|ConvertibleFrom| "KONVERF.spad" 1403076 1403099 1403354)
 (|CoercibleFrom| "KOERCEF.spad" 1402807 1402828 1403071)
 (|CoercibleTo| "KOERCE.spad" 1402532 1402551 1402802)
 (|KernelFunctions2| "KERNEL2.spad" 1402215 1402241 1402527)
 (|Kernel| "KERNEL.spad" 1401856 1401870 1402000)
 (|KernelCategory| "KERCAT.spad" 1400523 1400545 1401851)
 (|KeyedDictionary| "KDAGG.spad" 1399631 1399666 1400518)
 (|KeyedDictionary&| "KDAGG.spad" 1398736 1398774 1399626)
 (|KeyedAccessFile| "KAFILE.spad" 1396988 1397017 1397247)
 (|JetVectorField| "JVF.spad" 1394913 1394938 1396816)
 (|AssociatedJordanAlgebra| "JORDAN.spad" 1392363 1392396 1393862)
 (|JoinSemilattice| "JOINLAT.spad" 1391894 1391915 1392358)
 (|JetLazyFunction| "JLF.spad" 1389266 1389292 1391889)
 (|JetGroebner| "JGB.spad" 1388653 1388683 1389261)
 (|JFriCASSupport| "JFRICAS.spad" 1387835 1387855 1388648)
 (|JetDifferential| "JDIFF.spad" 1385967 1385993 1387663)
 (|JetDifferentialEquation| "JDE.spad" 1380514 1380548 1385962)
 (|JetCoordinateTransformation| "JCT.spad" 1379757 1379802 1380509)
 (|JetBundleXExpression| "JBX.spad" 1376317 1376346 1377234)
 (|JetBundle| "JBUNDLE.spad" 1375721 1375750 1376312)
 (|JetBundleSymAna| "JBSA.spad" 1375226 1375262 1375716)
 (|JetBundlePolynomial| "JBP.spad" 1365719 1365749 1366103)
 (|JetBundleLinearFunction| "JBLF.spad" 1364513 1364547 1365393)
 (|JetBundleFunctionCategory| "JBFC.spad" 1357752 1357786 1364508)
 (|JetBundleFunctionCategory&| "JBFC.spad" 1350988 1351025 1357747)
 (|JetBundleExpression| "JBE.spad" 1347604 1347632 1348465)
 (|JetBundleCategory| "JBC.spad" 1341190 1341213 1347599)
 (|JetBundleCategory&| "JBC.spad" 1334773 1334799 1341185)
 (|JetBundleBaseFunctionCategory| "JBBFC.spad" 1334412 1334450 1334768)
 (|JetBundleBaseFunctionCategory&| "JBBFC.spad" 1334048 1334089 1334407)
 (|IndexedAggregate| "IXAGG.spad" 1332244 1332282 1334043)
 (|IndexedAggregate&| "IXAGG.spad" 1330279 1330320 1332081)
 (|IndexedVector| "IVECTOR.spad" 1327288 1327314 1327459)
 (|InfiniteTuple| "ITUPLE.spad" 1326382 1326403 1327283)
 (|InnerTrigonometricManipulations| "ITRIGMNP.spad" 1325088 1325132 1326377)
 (|InfiniteTupleFunctions3| "ITFUN3.spad" 1324528 1324563 1325083)
 (|InfiniteTupleFunctions2| "ITFUN2.spad" 1324229 1324262 1324523)
 (|InnerTaylorSeries| "ITAYLOR.spad" 1322075 1322105 1324185)
 (|InnerSparseUnivariatePowerSeries| "ISUPS.spad" 1309039 1309084 1315894)
 (|InnerPolySum| "ISUMP.spad" 1308516 1308542 1309034)
 (|IndexedString| "ISTRING.spad" 1305633 1305657 1305725)
 (|IntegerSmithNormalForm| "ISMITH.spad" 1304576 1304604 1305628)
 (|InternalRationalUnivariateRepresentationPackage| "IRURPK.spad" 1303231
                                                    1303295 1304571)
 (|IrrRepSymNatPackage| "IRSN.spad" 1301134 1301159 1303226)
 (|IntegrationResultRFToFunction| "IRRF2F.spad" 1299532 1299569 1301086)
 (|IrredPolyOverFiniteField| "IRREDFFX.spad" 1299105 1299138 1299527)
 (|IntegerRoots| "IROOT.spad" 1297457 1297477 1299100)
 (|IntegrationResultToFunction| "IR2F.spad" 1296584 1296621 1297452)
 (|IntegrationResultFunctions2| "IR2.spad" 1295440 1295477 1296579)
 (|IntegrationResult| "IR.spad" 1292849 1292874 1295061)
 (|InternalPrintPackage| "IPRNTPK.spad" 1292606 1292632 1292844)
 (|InnerPrimeField| "IPF.spad" 1291421 1291446 1292498)
 (|IndexedProductCategory| "IPC.spad" 1288758 1288790 1291416)
 (|InnerPAdicInteger| "IPADIC.spad" 1288568 1288609 1288753)
 (|InverseLaplaceTransform| "INVLAPLA.spad" 1288159 1288192 1288563)
 (|TranscendentalIntegration| "INTTR.spad" 1285087 1285123 1288154)
 (|IntegrationTools| "INTTOOLS.spad" 1283505 1283531 1284941)
 (|IntegerSolveLinearPolynomialEquation| "INTSLPE.spad" 1282763 1282805
                                         1283500)
 (|Interval| "INTRVL.spad" 1282420 1282436 1282758)
 (|RationalFunctionIntegration| "INTRF.spad" 1281787 1281822 1282415)
 (|IntegerRetractions| "INTRET.spad" 1281217 1281243 1281782)
 (|RationalIntegration| "INTRAT.spad" 1280709 1280739 1281212)
 (|PatternMatchIntegration| "INTPM.spad" 1279754 1279787 1280507)
 (|ParametricIntegration| "INTPAR2.spad" 1277479 1277510 1279749)
 (|ParametricTranscendentalIntegration| "INTPAR1.spad" 1274096 1274142 1277474)
 (|PureAlgebraicIntegration| "INTPAF.spad" 1272065 1272101 1273962)
 (|IntegerLocalizedAtPrime| "INTLOCP.spad" 1271370 1271403 1272060)
 (|TranscendentalHermiteIntegration| "INTHERTR.spad" 1269907 1269950 1271365)
 (|AlgebraicHermiteIntegration| "INTHERAL.spad" 1269259 1269304 1269902)
 (|IntegerNumberTheoryFunctions| "INTHEORY.spad" 1265254 1265288 1269254)
 (|GenerateEllipticIntegrals| "INTGEL.spad" 1264487 1264530 1265249)
 (|GenusZeroIntegration| "INTG0.spad" 1259758 1259790 1264353)
 (|IntegerFactorizationPackage| "INTFACT.spad" 1258767 1258802 1259753)
 (|ElementaryIntegration| "INTEF.spad" 1258113 1258144 1258762)
 (|IntegrateSolutions| "INTDSOL.spad" 1257161 1257189 1258108)
 (|IntegralDomain| "INTDOM.spad" 1256984 1257004 1257156)
 (|DenominatorIntegration| "INTDEN.spad" 1255597 1255629 1256979)
 (|IntervalCategory| "INTCAT.spad" 1254043 1254067 1255592)
 (|IntegerBits| "INTBIT.spad" 1253567 1253584 1254038)
 (|AlgebraicIntegrate2| "INTALG2.spad" 1252189 1252229 1253562)
 (|AlgebraicIntegrate| "INTALG.spad" 1251508 1251547 1252184)
 (|AlgebraicIntegration| "INTAF.spad" 1249375 1249405 1251503)
 (|InnerTable| "INTABL.spad" 1246291 1246330 1246467)
 (|Integer| "INT.spad" 1245750 1245763 1246243)
 (|IntegerNumberSystem| "INS.spad" 1243349 1243374 1245745)
 (|IntegerNumberSystem&| "INS.spad" 1240945 1240973 1243344)
 (|InnerPolySign| "INPSIGN.spad" 1240358 1240382 1240940)
 (|InnerMultFact| "INNMFACT.spad" 1239279 1239307 1240353)
 (|InnerModularGcd| "INMODGCD.spad" 1238552 1238595 1239274)
 (|InnerNumericFloatSolvePackage| "INFSP.spad" 1236809 1236854 1238547)
 (|InfiniteLambertProduct| "INFPROD0.spad" 1235852 1235891 1236804)
 (|InputFormFunctions1| "INFORM1.spad" 1234772 1234799 1235847)
 (|InputForm| "INFORM.spad" 1231831 1231846 1234767)
 (|Infinity| "INFINITY.spad" 1231390 1231404 1231826)
 (|InfiniteCyclicGroup| "INFCG.spad" 1231126 1231155 1231385)
 (|InnerNumericEigenPackage| "INEP.spad" 1229738 1229778 1231121)
 (|IndexedExponents| "INDE.spad" 1229360 1229391 1229640)
 (|IncrementingMaps| "INCRMAPS.spad" 1228758 1228782 1229355)
 (|IncidenceAlgebra| "INCALG.spad" 1226977 1227003 1228753)
 (|InnerNormalBasisFieldFunctions| "INBFF.spad" 1222604 1222643 1226972)
 (|InnerModularHermitePade| "IMODHP.spad" 1222151 1222180 1222599)
 (|IndexedMatrix| "IMATRIX.spad" 1220020 1220057 1220548)
 (|InnerMatrixQuotientFieldFunctions| "IMATQF.spad" 1219058 1219133 1219974)
 (|InnerMatrixLinearAlgebraFunctions| "IMATLIN.spad" 1217201 1217256 1218980)
 (|ILogic| "ILOGIC.spad" 1213266 1213278 1217196)
 (|IndexedList| "ILIST.spad" 1210500 1210524 1210805)
 (|IndexedJetBundle| "IJB.spad" 1210285 1210327 1210495)
 (|InnerIndexedTwoDimensionalArray| "IIARRAY2.spad" 1208737 1208804 1208990)
 (|InnerFiniteField| "IFF.spad" 1208029 1208059 1208319)
 (|IndexedFlexibleArray| "IFARRAY.spad" 1203652 1203685 1205569)
 (|InnerEvalable| "IEVALAB.spad" 1203015 1203038 1203647)
 (|InnerEvalable&| "IEVALAB.spad" 1202375 1202401 1203010)
 (|InnerEigenPackage| "IEP.spad" 1197648 1197673 1202314)
 (|IndexedDirectProductObject| "IDPO.spad" 1194314 1194350 1194861)
 (|IndexedDirectProductCategory| "IDPC.spad" 1193566 1193604 1194309)
 (|IdealDecompositionPackage| "IDECOMP.spad" 1188956 1188992 1193561)
 (|PolynomialIdeal| "IDEAL.spad" 1183644 1183692 1188896)
 (|InnerCommonDenominator| "ICDEN.spad" 1182745 1182781 1183639)
 (|IndexCard| "ICARD.spad" 1181948 1181963 1182740)
 (|IntegralBasisPolynomialTools| "IBPTOOLS.spad" 1180467 1180510 1181943)
 (|IndexedBits| "IBITS.spad" 1179169 1179191 1179640)
 (|IntegralBasisTools| "IBATOOL.spad" 1175911 1175942 1179164)
 (|ChineseRemainderToolsForIntegralBases| "IBACHIN.spad" 1174275 1174325
                                          1175906)
 (|IndexedTwoDimensionalArray| "IARRAY2.spad" 1172332 1172382 1172980)
 (|IndexedOneDimensionalArray| "IARRAY1.spad" 1169697 1169736 1169872)
 (|InnerAlgFactor| "IALGFACT.spad" 1169284 1169325 1169692)
 (|I8Vector| "I8VEC.spad" 1166380 1166394 1166612)
 (|I8Matrix| "I8MAT.spad" 1164336 1164350 1164570)
 (|I32Vector| "I32VEC.spad" 1161430 1161445 1161664)
 (|I32Matrix| "I32MAT.spad" 1159384 1159399 1159620)
 (|I16Vector| "I16VEC.spad" 1156478 1156493 1156712)
 (|I16Matrix| "I16MAT.spad" 1154432 1154447 1154668)
 (|HyperbolicFunctionCategory| "HYPCAT.spad" 1153825 1153857 1154427)
 (|HyperbolicFunctionCategory&| "HYPCAT.spad" 1153215 1153250 1153820)
 (|HTMLFormat| "HTMLFORM.spad" 1152395 1152411 1153210)
 (|HopfAlgebra| "HOPFALG.spad" 1152200 1152225 1152390)
 (|Homology| "HOMOL.spad" 1150933 1150947 1152195)
 (|HomogeneousAggregate| "HOAGG.spad" 1147686 1147714 1150928)
 (|HomogeneousAggregate&| "HOAGG.spad" 1144119 1144150 1147364)
 (|HexadecimalExpansion| "HEXADEC.spad" 1141431 1141457 1142075)
 (|HeuGcd| "HEUGCD.spad" 1140395 1140410 1141426)
 (|HyperellipticFiniteDivisor| "HELLFDIV.spad" 1139965 1140009 1140390)
 (|Heap| "HEAP.spad" 1138738 1138750 1138963)
 (|HomogeneousDirectProduct| "HDP.spad" 1126178 1126216 1126582)
 (|HomogeneousDistributedMultivariatePolynomial| "HDMP.spad" 1110660 1110717
                                                 1111331)
 (|HallBasis| "HB.spad" 1108901 1108916 1110655)
 (|HashTable| "HASHTBL.spad" 1105770 1105808 1105993)
 (|HashState| "HASHSTAT.spad" 1105299 1105314 1105765)
 (|HankelPackage| "HANKP.spad" 1104960 1104981 1105294)
 (|Pi| "HACKPI.spad" 1104561 1104569 1104955)
 (|GuessPolynomialInteger| "GUESSPI.spad" 1104200 1104228 1104343)
 (|GuessPolynomialFunctions| "GUESSP1.spad" 1103858 1103890 1104195)
 (|GuessPolynomial| "GUESSP.spad" 1103554 1103577 1103671)
 (|GuessInteger| "GUESSINT.spad" 1103290 1103308 1103400)
 (|GuessFiniteFunctions| "GUESSF1.spad" 1103149 1103177 1103285)
 (|GuessFinite| "GUESSF.spad" 1102966 1102985 1103089)
 (|GuessExpBin| "GUESSEB.spad" 1101422 1101468 1102837)
 (|GuessAlgebraicNumber| "GUESSAN.spad" 1101227 1101253 1101347)
 (|Guess| "GUESS.spad" 1077772 1077812 1101098)
 (|GeneralTriangularSet| "GTSET.spad" 1076652 1076686 1077193)
 (|GeneralSparseTable| "GSTBL.spad" 1073837 1073888 1074032)
 (|GeneralUnivariatePowerSeries| "GSERIES.spad" 1065180 1065233 1066201)
 (|GroupPresentationFunctions1| "GROUPPF1.spad" 1064929 1064964 1065175)
 (|GroupPresentation| "GROUPP.spad" 1061615 1061638 1064924)
 (|Group| "GROUP.spad" 1060968 1060979 1061610)
 (|Group&| "GROUP.spad" 1060318 1060332 1060963)
 (|GroebnerSolve| "GROEBSOL.spad" 1058734 1058762 1060313)
 (|GradedModule| "GRMOD.spad" 1057265 1057287 1058729)
 (|GradedModule&| "GRMOD.spad" 1055793 1055818 1057260)
 (|GraphImage| "GRIMAGE.spad" 1048770 1048786 1055788)
 (|GraphicsDefaults| "GRDEF.spad" 1047069 1047091 1048765)
 (|GrayCode| "GRAY.spad" 1045501 1045515 1047064)
 (|GradedAlgebra| "GRALG.spad" 1044514 1044537 1045496)
 (|GradedAlgebra&| "GRALG.spad" 1043524 1043550 1044509)
 (|GeneralPolynomialSet| "GPOLSET.spad" 1042744 1042785 1042978)
 (|MaybeSkewPolynomialCategory| "GPOLCAT.spad" 1039593 1039639 1042739)
 (|MaybeSkewPolynomialCategory&| "GPOLCAT.spad" 1036290 1036339 1039439)
 (|GosperSummationMethod| "GOSPER.spad" 1035535 1035572 1036285)
 (|GuessOptionFunctions0| "GOPT0.spad" 1031552 1031579 1035530)
 (|GuessOption| "GOPT.spad" 1025802 1025819 1031547)
 (|GeneralModulePolynomial| "GMODPOL.spad" 1024561 1024609 1025441)
 (|GeneralHenselPackage| "GHENSEL.spad" 1023601 1023633 1024556)
 (|GeneralizedUnivariatePowerSeries| "GENUSER.spad" 1014301 1014366 1015026)
 (|GenerateUnivariatePowerSeries2| "GENUPS2.spad" 1009909 1009948 1013999)
 (|GenerateUnivariatePowerSeries1| "GENUPS1.spad" 1008512 1008550 1009904)
 (|GenerateUnivariatePowerSeries| "GENUPS.spad" 1008026 1008066 1008210)
 (|GeneralPolynomialGcdPackage| "GENPGCD.spad" 1007573 1007615 1008021)
 (|GeneralizedFiniteMoebiusFunction| "GENMOEBF.spad" 1006796 1006838 1007568)
 (|GeneralizedMultivariateFactorize| "GENMFACT.spad" 1006329 1006378 1006791)
 (|GenExEuclid| "GENEEZ.spad" 1004249 1004271 1006324)
 (|GnuDraw| "GDRAW.spad" 1002905 1002918 1004244)
 (|GeneralDistributedMultivariatePolynomial| "GDMP.spad" 987306 987361 988131)
 (|GenericNonAssociativeAlgebra| "GCNAALG.spad" 980965 981018 987069)
 (|GcdDomain| "GCDDOM.spad" 979915 979930 980960)
 (|GcdDomain&| "GCDDOM.spad" 978862 978880 979910)
 (|GcdBasis| "GCDBAS.spad" 977920 977936 978857)
 (|GroebnerInternalPackage| "GBINTERN.spad" 972918 972968 977915)
 (|GroebnerFactorizationPackage| "GBF.spad" 968616 968680 972913)
 (|EuclideanGroebnerBasisPackage| "GBEUCLID.spad" 966440 966505 968611)
 (|GroebnerPackage| "GB.spad" 963935 963977 966405)
 (|GaussianFactorizationPackage| "GAUSSFAC.spad" 963193 963227 963930)
 (|GaloisGroupUtilities| "GALUTIL.spad" 961439 961467 963144)
 (|GaloisGroupPolynomialUtilities| "GALPOLYU.spad" 959977 960018 961434)
 (|GaloisGroupFactorizationUtilities| "GALFACTU.spad" 958052 958098 959972)
 (|GaloisGroupFactorizer| "GALFACT.spad" 947575 947605 958047)
 (|FortranVectorFunctionCategory| "FVFUN.spad" 944476 944511 947570)
 (|FortranVectorCategory| "FVC.spad" 943473 943500 944471)
 (|FunctionCalled| "FUNCTION.spad" 943314 943338 943468)
 (|FortranTemplate| "FTEM.spad" 942439 942460 943309)
 (|FortranType| "FT.spad" 940556 940573 942434)
 (|FortranScalarType| "FST.spad" 938465 938488 940551)
 (|FunctionSpaceRationalRoots| "FSRROOT.spad" 938217 938253 938460)
 (|FunctionSpaceReduce| "FSRED.spad" 937355 937384 938212)
 (|FunctionSpacePrimitiveElement| "FSPRMELT.spad" 936029 936068 937301)
 (|FunctionalSpecialFunction| "FSPECF.spad" 925472 925507 935968)
 (|FunctionSpaceIntegration| "FSINT.spad" 925106 925140 925467)
 (|FloatSpecialFunctions| "FSFUN.spad" 922182 922209 925101)
 (|FourierSeries| "FSERIES.spad" 921449 921472 922101)
 (|FunctionSpaceComplexIntegrationAux| "FSCINTA.spad" 921042 921087 921444)
 (|FunctionSpaceComplexIntegration| "FSCINT.spad" 920312 920353 921037)
 (|FiniteSetAggregateFunctions2| "FSAGG2.spad" 918937 918979 920307)
 (|FiniteSetAggregate| "FSAGG.spad" 918240 918266 918932)
 (|FiniteSetAggregate&| "FSAGG.spad" 917472 917501 918167)
 (|FunctionSpaceToUnivariatePowerSeries2| "FS2UPS2.spad" 909690 909821 917467)
 (|FunctionSpaceToUnivariatePowerSeries| "FS2UPS.spad" 903211 903288 909685)
 (|FunctionSpaceToExponentialExpansion| "FS2EXPXP.spad" 902254 902310 903206)
 (|FunctionSpaceFunctions2| "FS2.spad" 901872 901909 902249)
 (|FunctionSpace| "FS.spad" 895706 895727 901867)
 (|FunctionSpace&| "FS.spad" 889056 889080 895220)
 (|FactoredFunctionUtilities| "FRUTIL.spad" 888362 888395 889051)
 (|FramedNonAssociativeAlgebra| "FRNAALG.spad" 884374 884409 888357)
 (|FramedNonAssociativeAlgebra&| "FRNAALG.spad" 880353 880391 884339)
 (|FramedNonAssociativeAlgebraFunctions2| "FRNAAF2.spad" 879757 879810 880348)
 (|FramedModule| "FRMOD.spad" 878494 878514 879752)
 (|FramedModule&| "FRMOD.spad" 877197 877220 878458)
 (|FractionalIdealAsModule| "FRIMOD.spad" 876548 876595 877130)
 (|FractionalIdealFunctions2| "FRIDEAL2.spad" 876147 876202 876543)
 (|FractionalIdeal| "FRIDEAL.spad" 875299 875329 876142)
 (|FullyRetractableTo| "FRETRCT.spad" 874826 874852 875294)
 (|FullyRetractableTo&| "FRETRCT.spad" 874216 874245 874687)
 (|FramedAlgebra| "FRAMALG.spad" 873457 873481 874211)
 (|FramedAlgebra&| "FRAMALG.spad" 872695 872722 873452)
 (|FractionFunctions2| "FRAC2.spad" 872283 872311 872690)
 (|Fraction| "FRAC.spad" 869025 869041 869499)
 (|FactoredFunctions2| "FR2.spad" 868060 868088 869020)
 (|Factored| "FR.spad" 862229 862245 867106)
 (|FloatingPointSystem| "FPS.spad" 858774 858799 862224)
 (|FloatingPointSystem&| "FPS.spad" 855228 855256 858681)
 (|FinitePoset| "FPOSET.spad" 854710 854729 855223)
 (|FieldOfPrimeCharacteristic| "FPC.spad" 853795 853827 854705)
 (|FieldOfPrimeCharacteristic&| "FPC.spad" 852877 852912 853790)
 (|FullyPatternMatchable| "FPATMAB.spad" 852620 852649 852872)
 (|FullPartialFractionExpansion| "FPARFRAC.spad" 851009 851048 852615)
 (|FortranProgram| "FORTRAN.spad" 849424 849486 851004)
 (|FortranFormat| "FORTFORM.spad" 849395 849414 849419)
 (|FortranFunctionCategory| "FORTFN.spad" 846449 846478 849390)
 (|FortranProgramCategory| "FORTCAT.spad" 846126 846154 846444)
 (|OutputFormatterCategory| "FORMCAT.spad" 845837 845866 846121)
 (|Formatter| "FORMAT.spad" 843689 843706 845832)
 (|FindOrderFinite| "FORDER.spad" 843396 843429 843684)
 (|FortranOutputStackPackage| "FOP.spad" 842547 842578 843391)
 (|FreeNilpotentLie| "FNLA.spad" 841848 841884 842542)
 (|FunctionGraph| "FNGRPH.spad" 838893 838914 841843)
 (|FileNameCategory| "FNCAT.spad" 837150 837172 838888)
 (|FileName| "FNAME.spad" 837039 837053 837145)
 (|FormattedOutput| "FMTOUT.spad" 836581 836602 837034)
 (|FormatMathJax| "FMTMJAX.spad" 835868 835887 836576)
 (|FormatLaTeX| "FMTLATEX.spad" 834932 834949 835863)
 (|FormatterCategory| "FMTCAT.spad" 820523 820546 834927)
 (|FormatterCategory&| "FMTCAT.spad" 806111 806137 820518)
 (|FortranMachineTypeCategory| "FMTC.spad" 805949 805981 806106)
 (|Format2D| "FMT2D.spad" 805787 805801 805944)
 (|Format1D| "FMT1D.spad" 805572 805586 805782)
 (|FreeMonoid| "FMONOID.spad" 801135 801153 805378)
 (|FiniteMoebiusFunction| "FMOEBF.spad" 800381 800410 801130)
 (|FortranMatrixFunctionCategory| "FMFUN.spad" 797289 797324 800376)
 (|FreeModuleCoefficientFunctions2| "FMCF2.spad" 796980 797031 797284)
 (|FreeModuleCategory| "FMCAT.spad" 795423 795451 796975)
 (|FreeModuleCategory&| "FMCAT.spad" 793823 793854 795378)
 (|FortranMatrixCategory| "FMC.spad" 792820 792847 793818)
 (|FreeMagma| "FMAGMA.spad" 790851 790875 792815)
 (|FreeModuleFunctions2| "FM2.spad" 790547 790583 790846)
 (|FreeModule| "FM.spad" 787627 787647 788683)
 (|FloatingRealPackage| "FLOATRP.spad" 785313 785344 787622)
 (|FloatingComplexPackage| "FLOATCP.spad" 782678 782712 785308)
 (|Float| "FLOAT.spad" 775907 775918 782521)
 (|FloatLiouvilianFunctions| "FLIOUFUN.spad" 773800 773830 775902)
 (|FullyLinearlyExplicitOver| "FLINEXP.spad" 773511 773544 773795)
 (|FullyLinearlyExplicitOver&| "FLINEXP.spad" 773156 773192 773443)
 (|FiniteLinearAggregateSort| "FLASORT.spad" 772435 772470 773151)
 (|FreeLieAlgebra| "FLALG.spad" 770424 770455 772430)
 (|FiniteLinearAggregateFunctions2| "FLAGG2.spad" 769028 769073 770419)
 (|FiniteLinearAggregate| "FLAGG.spad" 768899 768928 769023)
 (|FiniteRankAlgebra| "FINRALG.spad" 766779 766807 768894)
 (|FiniteRankAlgebra&| "FINRALG.spad" 764532 764563 766650)
 (|FiniteLattice| "FINLAT.spad" 764062 764087 764527)
 (|Finite| "FINITE.spad" 763099 763111 764057)
 (|Finite&| "FINITE.spad" 762133 762148 763094)
 (|FiniteGroup| "FINGRP.spad" 761949 761966 762128)
 (|FiniteGroup&| "FINGRP.spad" 761762 761782 761944)
 (|FiniteGroupPackage| "FINGPKG.spad" 761280 761306 761757)
 (|FinitelyGenerated| "FINGEN.spad" 761056 761079 761275)
 (|FiniteRankNonAssociativeAlgebra| "FINAALG.spad" 749502 749541 761051)
 (|FiniteRankNonAssociativeAlgebra&| "FINAALG.spad" 737906 737948 749458)
 (|FileCategory| "FILECAT.spad" 736248 736275 737901)
 (|File| "FILE.spad" 735823 735835 736243)
 (|Field| "FIELD.spad" 735441 735452 735818)
 (|Field&| "FIELD.spad" 735056 735070 735436)
 (|FiniteGraph| "FGRPH.spad" 717652 717671 735051)
 (|FiniteGraph&| "FGRPH.spad" 700245 700267 717647)
 (|FreeGroup| "FGROUP.spad" 698767 698784 700205)
 (|FGLMIfCanPackage| "FGLMICPK.spad" 697599 697628 698762)
 (|FiniteFieldExtension| "FFX.spad" 696938 696971 697302)
 (|FiniteFieldSolveLinearPolynomialEquation| "FFSLPE.spad" 696387 696442
                                             696933)
 (|FiniteFieldPolynomialPackage2| "FFPOLY2.spad" 695418 695458 696382)
 (|FiniteFieldPolynomialPackage| "FFPOLY.spad" 686198 686235 695413)
 (|FiniteFieldExtensionByPolynomial| "FFP.spad" 685547 685597 685901)
 (|FiniteFieldNormalBasisExtension| "FFNBX.spad" 683988 684037 685250)
 (|FiniteFieldNormalBasisExtensionByPolynomial| "FFNBP.spad" 682418 682476
                                                683691)
 (|FiniteFieldNormalBasis| "FFNB.spad" 680743 680784 682030)
 (|FunctionFieldIntegralBasis| "FFINTBAS.spad" 678073 678112 680738)
 (|FiniteFieldCategory| "FFIELDC.spad" 675916 675941 678068)
 (|FiniteFieldCategory&| "FFIELDC.spad" 673756 673784 675911)
 (|FiniteFieldHomomorphisms| "FFHOM.spad" 672469 672508 673751)
 (|FractionFreeFastGaussianFractions| "FFFGF.spad" 671609 671655 672464)
 (|FractionFreeFastGaussian| "FFFG.spad" 664303 664337 671604)
 (|FiniteFieldFunctions| "FFF.spad" 661594 661623 664298)
 (|FiniteFieldCyclicGroupExtension| "FFCGX.spad" 660387 660436 661297)
 (|FiniteFieldCyclicGroupExtensionByPolynomial| "FFCGP.spad" 659210 659271
                                                660090)
 (|FiniteFieldCyclicGroup| "FFCG.spad" 657901 657942 658822)
 (|FunctionFieldCategoryFunctions2| "FFCAT2.spad" 657616 657685 657896)
 (|FunctionFieldCategory| "FFCAT.spad" 650214 650251 657611)
 (|FunctionFieldCategory&| "FFCAT.spad" 642746 642786 650146)
 (|FiniteField| "FF.spad" 642103 642128 642358)
 (|FortranExpression| "FEXPR.spad" 633686 633747 641900)
 (|FullyEvalableOver| "FEVALAB.spad" 633371 633396 633681)
 (|FullyEvalableOver&| "FEVALAB.spad" 632841 632869 633154)
 (|FloatEllipticFunctions| "FELFUN.spad" 627836 627864 632836)
 (|FiniteDivisorCategory| "FDIVCAT.spad" 625121 625160 627831)
 (|FiniteDivisorCategory&| "FDIVCAT.spad" 622403 622445 625116)
 (|FiniteDivisorFunctions2| "FDIV2.spad" 622056 622117 622398)
 (|FiniteDivisor| "FDIV.spad" 621479 621510 622051)
 (|FiniteDcpo| "FDCPO.spad" 620962 620980 621474)
 (|FreeDivisionAlgebra| "FDALG.spad" 598294 598325 620957)
 (|FortranCodeTools| "FCTOOL.spad" 596044 596066 598289)
 (|FortranCodePackage1| "FCPAK1.spad" 594504 594529 596039)
 (|FourierComponent| "FCOMP.spad" 593883 593907 594499)
 (|FiniteCoDcpo| "FCDCPO.spad" 593364 593384 593878)
 (|FortranCode| "FC.spad" 582020 582037 593359)
 (|FiniteBiCPO| "FBICPO.spad" 581532 581551 582015)
 (|FiniteAlgebraicExtensionField| "FAXF.spad" 575578 575615 581527)
 (|FiniteAlgebraicExtensionField&| "FAXF.spad" 569590 569630 575542)
 (|FlexibleArray| "FARRAY.spad" 566073 566094 567130)
 (|FiniteAbelianMonoidRingFunctions2| "FAMR2.spad" 565729 565782 566068)
 (|FiniteAbelianMonoidRing| "FAMR.spad" 564018 564051 565724)
 (|FiniteAbelianMonoidRing&| "FAMR.spad" 562159 562195 563868)
 (|FakePolynomial| "FAKEPOL.spad" 561771 561791 562154)
 (|FactoringUtilities| "FACUTIL.spad" 559896 559929 561766)
 (|FactoredFunctions| "FACTFUNC.spad" 559020 559045 559891)
 (|FacetCategory| "FACTCAT.spad" 558582 558601 559015)
 (|FacetCategory&| "FACTCAT.spad" 558141 558163 558577)
 (|ExtendedPolynomialReduction| "EXTRED.spad" 557379 557418 558136)
 (|ExponentialOfUnivariatePuiseuxSeries| "EXPUPXS.spad" 549484 549541 550839)
 (|ExpressionTubePlot| "EXPRTUBE.spad" 546623 546647 549479)
 (|ExpressionSolve| "EXPRSOL.spad" 546575 546613 546618)
 (|ExpressionSpaceODESolver| "EXPRODE.spad" 543291 543325 546570)
 (|ExpressionToUnivariatePowerSeries| "EXPR2UPS.spad" 539233 539277 543286)
 (|ExpressionFunctions2| "EXPR2.spad" 538946 538976 539228)
 (|Expression| "EXPR.spad" 534799 534817 535544)
 (|ExponentialExpansion| "EXPEXPAN.spad" 529285 529328 529955)
 (|Export3D| "EXP3D.spad" 529013 529027 529280)
 (|Exit| "EXIT.spad" 528682 528692 529008)
 (|EvaluateCycleIndicators| "EVALCYC.spad" 528112 528143 528677)
 (|Evalable| "EVALAB.spad" 527656 527672 528107)
 (|Evalable&| "EVALAB.spad" 527197 527216 527651)
 (|EuclideanDomain| "EUCDOM.spad" 524732 524753 527192)
 (|EuclideanDomain&| "EUCDOM.spad" 522264 522288 524727)
 (|ExpressionSpaceFunctions2| "ES2.spad" 521730 521765 522259)
 (|ExpressionSpaceFunctions1| "ES1.spad" 521271 521306 521725)
 (|ExpressionSpace| "ES.spad" 512596 512617 521266)
 (|ExpressionSpace&| "ES.spad" 503830 503854 512503)
 (|ErrorFunctions| "ERROR.spad" 501124 501144 503825)
 (|EqTable| "EQTBL.spad" 497997 498024 498216)
 (|EquationFunctions2| "EQ2.spad" 497701 497729 497992)
 (|Equation| "EQ.spad" 492460 492476 495396)
 (|EigenPackage| "EP.spad" 488668 488688 492399)
 (|EntireRing| "ENTIRER.spad" 487491 487507 488663)
 (|EntireRing&| "ENTIRER.spad" 486311 486330 487486)
 (|EuclideanModularRing| "EMR.spad" 485538 485605 486306)
 (|EltableAggregate| "ELTAGG.spad" 484095 484128 485533)
 (|EltableAggregate&| "ELTAGG.spad" 482608 482644 484049)
 (|Eltable| "ELTAB.spad" 482051 482068 482603)
 (|DoubleFloatEllipticIntegrals| "ELIPIDF.spad" 478187 478221 482046)
 (|ExpressionLinearSolve| "ELINSOL.spad" 477689 477720 478182)
 (|EllipticFunctionsUnivariateTaylorSeries| "ELFUTS.spad" 476426 476482 477615)
 (|ElementaryFunctionCategory| "ELEMFUN.spad" 475911 475943 476421)
 (|ElementaryFunctionCategory&| "ELEMFUN.spad" 475393 475428 475906)
 (|ExtensibleLinearAggregate| "ELAGG.spad" 473297 473330 475388)
 (|ExtensibleLinearAggregate&| "ELAGG.spad" 471127 471163 473221)
 (|ElementaryFunctionsUnivariatePuiseuxSeries| "EFUPXS.spad" 467707 467777
                                               471092)
 (|ElementaryFunctionsUnivariateLaurentSeries| "EFULS.spad" 464350 464413
                                               467672)
 (|ElementaryFunctionStructurePackage| "EFSTRUC.spad" 460035 460079 464345)
 (|ElementaryFunctionsGeneralizedUnivariatePowerSeries| "EFGUSER.spad" 459905
                                                        459980 460030)
 (|ExpressionFactorPolynomial| "EFACTOR.spad" 459054 459090 459900)
 (|ElementaryFunction| "EF.spad" 453628 453656 459049)
 (|ExtAlgBasis| "EAB.spad" 451869 451886 453623)
 (|DifferentialVariableCategory| "DVARCAT.spad" 448482 448518 451864)
 (|DifferentialVariableCategory&| "DVARCAT.spad" 445092 445131 448477)
 (|DistributionContinuedFractionPackage| "DSTCFPG.spad" 444301 444349 444963)
 (|DifferentialSparseMultivariatePolynomial| "DSMP.spad" 431904 431956 432252)
 (|DrawOptionFunctions1| "DROPT1.spad" 431547 431575 431899)
 (|DrawOptionFunctions0| "DROPT0.spad" 426150 426176 431542)
 (|DrawOption| "DROPT.spad" 419859 419875 426145)
 (|TopLevelDrawFunctionsForPoints| "DRAWPT.spad" 417967 418003 419854)
 (|DrawNumericHack| "DRAWHACK.spad" 417256 417279 417962)
 (|DrawComplex| "DRAWCX.spad" 414554 414571 417251)
 (|TopLevelDrawFunctionsForAlgebraicCurves| "DRAWCURV.spad" 413723 413775
                                            414549)
 (|TopLevelDrawFunctionsForCompiledFunctions| "DRAWCFUN.spad" 401557 401604
                                              413718)
 (|TopLevelDrawFunctions| "DRAW.spad" 393129 393161 401552)
 (|DequeueAggregate| "DQAGG.spad" 391819 391843 393124)
 (|DifferentialPolynomialCategory| "DPOLCAT.spad" 387164 387208 391814)
 (|DifferentialPolynomialCategory&| "DPOLCAT.spad" 382465 382512 387118)
 (|DirectProductModule| "DPMO.spad" 372195 372228 372355)
 (|DirectProductMatrixModule| "DPMM.spad" 361541 361582 361694)
 (|DistributedMultivariatePolynomial| "DMP.spad" 346079 346125 346693)
 (|DiscreteLogarithmPackage| "DLP.spad" 345400 345432 346074)
 (|DataList| "DLIST.spad" 342223 342239 342939)
 (|DoublyLinkedAggregate| "DLAGG.spad" 340619 340648 342218)
 (|DistributedJetBundlePolynomial| "DJBP.spad" 326381 326428 327399)
 (|DivisionRing| "DIVRING.spad" 325949 325967 326376)
 (|DivisionRing&| "DIVRING.spad" 325514 325535 325944)
 (|DistributionFunctions2| "DISTRO2.spad" 324963 324997 325509)
 (|Distribution| "DISTRO.spad" 321016 321036 324762)
 (|DistributionPolynomialPackage| "DISTPOL.spad" 320230 320273 321011)
 (|DistributiveLattice| "DISTLAT.spad" 319941 319966 320225)
 (|DistributionPackage| "DISTEX.spad" 318867 318894 319867)
 (|DistributionCategory| "DISTCAT.spad" 315287 315315 318862)
 (|DisplayPackage| "DISPLAY.spad" 313400 313420 315282)
 (|DirichletRing| "DIRRING.spad" 312782 312808 313355)
 (|DirectProductFunctions2| "DIRPROD2.spad" 311555 311594 312777)
 (|DirectProduct| "DIRPROD.spad" 298743 298770 299399)
 (|DirectProductCategory| "DIRPCAT.spad" 297857 297892 298738)
 (|DirectProductCategory&| "DIRPCAT.spad" 296506 296544 297390)
 (|DiophantineSolutionPackage| "DIOSP.spad" 295222 295254 296501)
 (|DictionaryOperations| "DIOPS.spad" 294238 294266 295217)
 (|DictionaryOperations&| "DIOPS.spad" 293175 293206 294157)
 (|DihedralGroup| "DIHGRP.spad" 292414 292445 293170)
 (|DifferentialRing| "DIFRING.spad" 291680 291702 292409)
 (|DifferentialRing&| "DIFRING.spad" 290943 290968 291675)
 (|DifferentialExtension| "DIFEXT.spad" 290071 290100 290938)
 (|DifferentialExtension&| "DIFEXT.spad" 289087 289119 289957)
 (|Dictionary| "DIAGG.spad" 288719 288737 289082)
 (|Dictionary&| "DIAGG.spad" 288348 288369 288714)
 (|DenavitHartenbergMatrix| "DHMATRIX.spad" 285525 285556 286745)
 (|DirectedGraph| "DGRPH.spad" 281364 281385 285520)
 (|DoubleFloatVector| "DFVEC.spad" 277666 277689 278033)
 (|DoubleFloatSpecialFunctions2| "DFSFUN2.spad" 277622 277656 277661)
 (|DoubleFloatSpecialFunctions| "DFSFUN.spad" 273939 273972 277617)
 (|DoubleFloatMatrix| "DFMAT.spad" 271727 271750 271988)
 (|DoubleFloat| "DFLOAT.spad" 268383 268400 271514)
 (|DefiniteIntegrationTools| "DFINTTLS.spad" 266539 266573 268378)
 (|DoubleFloatElementaryFunctions| "DFELEM.spad" 266493 266529 266534)
 (|DeRhamComplex| "DERHAM.spad" 264322 264365 266488)
 (|Dequeue| "DEQUEUE.spad" 263015 263030 263320)
 (|DeltaComplexFactory| "DELTCF.spad" 262355 262383 263010)
 (|DeltaComplex| "DELTAC.spad" 259791 259812 262350)
 (|DegreeReductionPackage| "DEGRED.spad" 259014 259048 259786)
 (|RationalFunctionDefiniteIntegration| "DEFINTRF.spad" 256390 256433 259009)
 (|ElementaryFunctionDefiniteIntegration| "DEFINTEF.spad" 254772 254819 256385)
 (|DecimalExpansion| "DECIMAL.spad" 252100 252122 252728)
 (|DistinctDegreeFactorize| "DDFACT.spad" 249727 249761 252095)
 (|Dcpo| "DCPO.spad" 249202 249214 249722)
 (|DoubleResultantPackage| "DBLRESP.spad" 248778 248818 249197)
 (|Database| "DBASE.spad" 247359 247375 248773)
 (|CyclotomicPolynomialPackage| "CYCLOTOM.spad" 246641 246674 247354)
 (|CyclotomicUtilities| "CYCLOT2.spad" 244981 245006 246636)
 (|CycleIndicators| "CYCLES.spad" 241699 241720 244976)
 (|CyclicGroup| "CYCGRP.spad" 241428 241453 241694)
 (|CoerceVectorMatrixPackage| "CVMP.spad" 240806 240839 241423)
 (|CubicalComplexFactory| "CUBECF.spad" 239128 239155 240801)
 (|FiniteCubicalComplex| "CUBEC.spad" 235845 235874 239123)
 (|ComplexTrigonometricManipulations| "CTRIGMNP.spad" 234256 234299 235840)
 (|CyclicStreamTools| "CSTTOOLS.spad" 233476 233504 234251)
 (|ComplexRootFindingPackage| "CRFP.spad" 227055 227091 233471)
 (|CRApackage| "CRAPACK.spad" 226131 226149 227050)
 (|ComplexPatternMatch| "CPMATCH.spad" 225573 225605 226030)
 (|CharacteristicPolynomialInMonogenicalAlgebra| "CPIMA.spad" 225230 225291
                                                 225568)
 (|CoordinateSystems| "COORDSYS.spad" 220010 220035 225225)
 (|ContinuedFraction| "CONTFRAC.spad" 215552 215577 220005)
 (|CommutativeRing| "COMRING.spad" 215334 215355 215547)
 (|compUtil| "COMPUTIL.spad" 213558 213575 215329)
 (|SubSpaceComponentProperty| "COMPPROP.spad" 213044 213075 213553)
 (|ComplexPattern| "COMPLPAT.spad" 212796 212823 213039)
 (|ComplexFunctions2| "COMPLEX2.spad" 212487 212514 212791)
 (|Complex| "COMPLEX.spad" 208215 208230 208468)
 (|compCode| "COMPCODE.spad" 207067 207081 208210)
 (|ComplexCategory| "COMPCAT.spad" 205385 205408 207062)
 (|ComplexCategory&| "COMPCAT.spad" 203056 203082 204736)
 (|Comparable| "COMPAR.spad" 202786 202802 203051)
 (|CommuteUnivariatePolynomialCategory| "COMMUPC.spad" 202491 202542 202781)
 (|CommonOperators| "COMMONOP.spad" 202005 202026 202486)
 (|Commutator| "COMM.spad" 201807 201823 202000)
 (|CombinatorialOpsCategory| "COMBOPC.spad" 200657 200687 201802)
 (|IntegerCombinatoricFunctions| "COMBINAT.spad" 198734 198770 200652)
 (|CombinatorialFunction| "COMBF.spad" 196000 196031 198729)
 (|Color| "COLOR.spad" 194781 194792 195995)
 (|CoDcpo| "CODCPO.spad" 194260 194274 194776)
 (|CoChainComplex| "COCHNC.spad" 193257 193280 194255)
 (|Coalgebra| "COALG.spad" 192843 192866 193252)
 (|ComplexRootPackage| "CMPLXRT.spad" 192138 192171 192838)
 (|TwoDimensionalPlotClipping| "CLIP.spad" 187952 187984 192133)
 (|ConstantLinearDependence| "CLINDEP.spad" 183821 183855 187947)
 (|CliffordAlgebra| "CLIF.spad" 180631 180665 183816)
 (|Collection| "CLAGG.spad" 177569 177587 180626)
 (|Collection&| "CLAGG.spad" 174367 174388 177427)
 (|CartanKuranishi| "CKP.spad" 169793 169819 174362)
 (|ComplexIntegerSolveLinearPolynomialEquation| "CINTSLPE.spad" 169063 169117
                                                169788)
 (|ChangeOfVariable| "CHVAR.spad" 166658 166690 169058)
 (|CharacteristicZero| "CHARZ.spad" 166572 166596 166653)
 (|CharacteristicPolynomial3| "CHARPOL3.spad" 165522 165555 166533)
 (|CharacteristicPolynomial2| "CHARPOL2.spad" 164943 164976 165517)
 (|CharacteristicPolynomialPackage| "CHARPOL.spad" 164415 164454 164938)
 (|CharacteristicNonZero| "CHARNZ.spad" 164158 164185 164410)
 (|Character| "CHAR.spad" 161900 161915 164153)
 (|ChainComplex| "CHAINC.spad" 160989 161007 161895)
 (|CombinatorialFunctionCategory| "CFCAT.spad" 160260 160295 160984)
 (|CubicalFacet| "CFACET.spad" 158443 158461 160255)
 (|Cell| "CELL.spad" 157089 157110 158438)
 (|ComplexDoubleFloatVector| "CDFVEC.spad" 152623 152653 153126)
 (|ComplexDoubleFloatMatrix| "CDFMAT.spad" 149857 149887 150133)
 (|CommonDenominator| "CDEN.spad" 148970 148999 149852)
 (|CharacterClass| "CCLASS.spad" 146612 146632 147938)
 (|CartesianTensorFunctions2| "CARTEN2.spad" 145953 146003 146607)
 (|CartesianTensor| "CARTEN.spad" 140833 140870 145948)
 (|CardinalNumber| "CARD.spad" 138251 138271 140828)
 (|CylindricalAlgebraicDecompositionUtilities| "CADU.spad" 137915 137967
                                               138246)
 (|CylindricalAlgebraicDecompositionPackage| "CAD.spad" 136995 137052 137910)
 (|CachableSet| "CACHSET.spad" 136596 136613 136990)
 (|CancellationAbelianMonoid| "CABMON.spad" 136120 136151 136591)
 (|BinaryTree| "BTREE.spad" 134606 134624 135178)
 (|BinaryTournament| "BTOURN.spad" 133028 133052 133664)
 (|BinaryTreeCategory| "BTCAT.spad" 132591 132617 133023)
 (|BinaryTreeCategory&| "BTCAT.spad" 132151 132180 132586)
 (|BitAggregate| "BTAGG.spad" 131305 131323 132146)
 (|BitAggregate&| "BTAGG.spad" 130456 130477 131300)
 (|BinarySearchTree| "BSTREE.spad" 128553 128577 129514)
 (|BrillhartTests| "BRILL.spad" 126747 126770 128548)
 (|BinaryRecursiveAggregate| "BRAGG.spad" 125673 125705 126742)
 (|BinaryRecursiveAggregate&| "BRAGG.spad" 124555 124590 125627)
 (|BalancedPAdicRational| "BPADICRT.spad" 121217 121248 121498)
 (|BalancedPAdicInteger| "BPADIC.spad" 120925 120955 121212)
 (|BoundIntegerRoots| "BOUNDZRO.spad" 120564 120592 120920)
 (|BasicOperatorFunctions1| "BOP1.spad" 117880 117911 120559)
 (|BasicOperator| "BOP.spad" 113152 113171 117875)
 (|Boolean| "BOOLEAN.spad" 112127 112140 113147)
 (|BiModule| "BMODULE.spad" 111960 111978 112122)
 (|BoundedMeetSemilattice| "BMEET.spad" 111624 111652 111955)
 (|BoundedLattice| "BLAT.spad" 111395 111415 111619)
 (|BoundedJoinSemilattice| "BJOIN.spad" 110932 110960 111390)
 (|BitStreamFrame| "BITST.spad" 110648 110668 110927)
 (|Bits| "BITS.spad" 109593 109603 109821)
 (|BinaryExpansion| "BINARY.spad" 106931 106952 107549)
 (|BiCPO| "BICPO.spad" 106641 106654 106926)
 (|Bialgebra| "BIALG.spad" 106333 106356 106636)
 (|BagAggregate| "BGAGG.spad" 105758 105778 106328)
 (|BagAggregate&| "BGAGG.spad" 105180 105203 105753)
 (|BezoutMatrixWrapper| "BEZOUT2.spad" 104982 105012 105135)
 (|BezoutMatrix| "BEZOUT.spad" 103495 103532 104937)
 (|BoundedDistributiveLattice| "BDISTL.spad" 103199 103231 103490)
 (|BalancedBinaryTree| "BBTREE.spad" 99398 99424 102257)
 (|BasicType| "BASTYPE.spad" 99049 99064 99393)
 (|BasicType&| "BASTYPE.spad" 98697 98715 99044)
 (|BalancedFactorisation| "BALFACT.spad" 98105 98137 98692)
 (|Automorphism| "AUTOMOR.spad" 97534 97554 98100)
 (|VariablesCommuteWithCoefficients| "ATVCWC.spad" 97376 97414 97529)
 (|unitsKnown| "ATUNIKN.spad" 97162 97178 97371)
 (|TwoSidedRecip| "ATTWSR.spad" 97004 97023 97157)
 (|shallowlyMutable| "ATSHMUT.spad" 96852 96874 96999)
 (|ArcTrigonometricFunctionCategory| "ATRIG.spad" 95293 95331 96847)
 (|ArcTrigonometricFunctionCategory&| "ATRIG.spad" 93731 93772 95288)
 (|noZeroDivisors| "ATNZDIV.spad" 93565 93585 93726)
 (|multiplicativeValuation| "ATMULVA.spad" 93392 93421 93560)
 (|lazyRepresentation| "ATLR.spad" 93272 93296 93387)
 (|finiteAggregate| "ATFINAG.spad" 93155 93176 93267)
 (|canonicalUnitNormal| "ATCUNOR.spad" 92851 92876 93150)
 (|CommutativeStar| "ATCS.spad" 92608 92629 92846)
 (|Canonical| "ATCANON.spad" 92420 92435 92603)
 (|canonicalsClosed| "ATCANCL.spad" 92253 92275 92415)
 (|arbitraryPrecision| "ATARBPR.spad" 92102 92126 92248)
 (|arbitraryExponent| "ATARBEX.spad" 91994 92017 92097)
 (|Approximate| "ATAPPRO.spad" 91907 91924 91989)
 (|additiveValuation| "ATADDVA.spad" 91740 91763 91902)
 (|ArrayStack| "ASTACK.spad" 90444 90462 90738)
 (|AssociatedEquations| "ASSOCEQ.spad" 89154 89183 90409)
 (|TwoDimensionalArrayFunctions| "ARRAY22.spad" 88903 88959 89149)
 (|TwoDimensionalArray| "ARRAY2.spad" 87436 87463 87608)
 (|OneDimensionalArrayFunctions2| "ARRAY12.spad" 86029 86068 87431)
 (|OneDimensionalArray| "ARRAY1.spad" 83191 83218 83569)
 (|TwoDimensionalArrayCategory| "ARR2CAT.spad" 68333 68380 83186)
 (|TwoDimensionalArrayCategory&| "ARR2CAT.spad" 53437 53487 68293)
 (|AbelianProductCategory| "APRODC.spad" 53295 53325 53432)
 (|ApplyRules| "APPRULE.spad" 52616 52643 53290)
 (|ApplyUnivariateSkewPolynomial| "APPLYORE.spad" 52197 52238 52611)
 (|AnyFunctions1| "ANY1.spad" 51232 51253 52192)
 (|Any| "ANY.spad" 49543 49552 51227)
 (|AntiSymm| "ANTISYM.spad" 47927 47950 49538)
 (|AnonymousFunction| "ANON.spad" 47829 47852 47922)
 (|AlgebraicNumber| "AN.spad" 46016 46037 47696)
 (|AbelianMonoidRing| "AMR.spad" 44966 44993 46011)
 (|AbelianMonoidRing&| "AMR.spad" 43504 43534 44552)
 (|AssociationList| "ALIST.spad" 37376 37411 37745)
 (|AlgebraGivenByStructuralConstants| "ALGSC.spad" 36472 36530 37266)
 (|AlgebraPackage| "ALGPKG.spad" 32006 32030 36427)
 (|AlgebraicMultFact| "ALGMFACT.spad" 31178 31208 32001)
 (|AlgebraicManipulations| "ALGMANIP.spad" 27953 27985 30690)
 (|AlgebraicFunctionField| "ALGFF.spad" 26043 26091 26289)
 (|AlgFactor| "ALGFACT.spad" 25121 25139 26038)
 (|Algebra| "ALGEBRA.spad" 24874 24889 25116)
 (|Algebra&| "ALGEBRA.spad" 24624 24642 24869)
 (|AssociationListAggregate| "ALAGG.spad" 24126 24170 24619)
 (|AssociationListAggregate&| "ALAGG.spad" 23625 23672 24121)
 (|ArcHyperbolicFunctionCategory| "AHYP.spad" 22960 22995 23620)
 (|Aggregate| "AGG.spad" 21266 21281 22955)
 (|Aggregate&| "AGG.spad" 19529 19547 21221)
 (|AlgebraicFunction| "AF.spad" 17779 17806 19468)
 (|PlaneAlgebraicCurvePlot| "ACPLOT.spad" 16338 16367 17774)
 (|AlgebraicallyClosedFunctionSpace| "ACFS.spad" 14045 14085 16333)
 (|AlgebraicallyClosedFunctionSpace&| "ACFS.spad" 11693 11736 13984)
 (|AlgebraicallyClosedField| "ACF.spad" 8274 8304 11688)
 (|AlgebraicallyClosedField&| "ACF.spad" 4852 4885 8269)
 (|AbelianSemiGroup| "ABELSG.spad" 4371 4393 4847)
 (|AbelianSemiGroup&| "ABELSG.spad" 3887 3912 4366)
 (|AbelianMonoid| "ABELMON.spad" 3282 3301 3882)
 (|AbelianMonoid&| "ABELMON.spad" 2674 2696 3277)
 (|AbelianGroup| "ABELGRP.spad" 2221 2239 2669)
 (|AbelianGroup&| "ABELGRP.spad" 1765 1786 2216)
 (|OneDimensionalArrayAggregate| "A1AGG.spad" 899 935 1760)
 (|OneDimensionalArrayAggregate&| "A1AGG.spad" 30 69 894)) 